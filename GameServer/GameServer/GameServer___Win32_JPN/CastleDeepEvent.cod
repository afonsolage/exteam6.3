; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	D:\Projects\ExTeam6.3\Source\GameServer\GameServer\CastleDeepEvent.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
_DATA	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Odtp /ZI
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@vector:
  00009	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000c	83 e8 01	 sub	 eax, 1
  0000f	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00012	78 11		 js	 SHORT $LN3@vector
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00017	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  0001d	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00020	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00023	eb e4		 jmp	 SHORT $LN2@vector
$LN3@vector:
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
PUBLIC	??1?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE@XZ ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::~vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >
PUBLIC	??1?$map@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@@std@@QAE@XZ ; std::map<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > > >::~map<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > > >
PUBLIC	??1?$map@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@@std@@QAE@XZ ; std::map<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > > >::~map<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > > >
PUBLIC	??0?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
PUBLIC	??0?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE@XZ ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >
PUBLIC	??0?$map@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@@std@@QAE@XZ ; std::map<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > > >::map<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > > >
PUBLIC	??0?$map@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@@std@@QAE@XZ ; std::map<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > > >::map<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > > >
PUBLIC	??_7CCastleDeepEvent@@6B@			; CCastleDeepEvent::`vftable'
PUBLIC	??0CCastleDeepEvent@@QAE@XZ			; CCastleDeepEvent::CCastleDeepEvent
PUBLIC	??_R4CCastleDeepEvent@@6B@			; CCastleDeepEvent::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCCastleDeepEvent@@@8			; CCastleDeepEvent `RTTI Type Descriptor'
PUBLIC	??_R3CCastleDeepEvent@@8			; CCastleDeepEvent::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CCastleDeepEvent@@8			; CCastleDeepEvent::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CCastleDeepEvent@@8		; CCastleDeepEvent::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	__imp__InitializeCriticalSection@4:PROC
EXTRN	_srand:PROC
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ECCastleDeepEvent@@UAEPAXI@Z:PROC		; CCastleDeepEvent::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CCastleDeepEvent@@8
; File d:\projects\exteam6.3\source\gameserver\gameserver\castledeepevent.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@CCastleDeepEvent@@8 DD FLAT:??_R0?AVCCastleDeepEvent@@@8 ; CCastleDeepEvent::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CCastleDeepEvent@@8
rdata$r	ENDS
;	COMDAT ??_R2CCastleDeepEvent@@8
rdata$r	SEGMENT
??_R2CCastleDeepEvent@@8 DD FLAT:??_R1A@?0A@EA@CCastleDeepEvent@@8 ; CCastleDeepEvent::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CCastleDeepEvent@@8
rdata$r	SEGMENT
??_R3CCastleDeepEvent@@8 DD 00H				; CCastleDeepEvent::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CCastleDeepEvent@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCCastleDeepEvent@@@8
_DATA	SEGMENT
??_R0?AVCCastleDeepEvent@@@8 DD FLAT:??_7type_info@@6B@	; CCastleDeepEvent `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCCastleDeepEvent@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CCastleDeepEvent@@6B@
rdata$r	SEGMENT
??_R4CCastleDeepEvent@@6B@ DD 00H			; CCastleDeepEvent::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCCastleDeepEvent@@@8
	DD	FLAT:??_R3CCastleDeepEvent@@8
rdata$r	ENDS
;	COMDAT ??_7CCastleDeepEvent@@6B@
CONST	SEGMENT
??_7CCastleDeepEvent@@6B@ DD FLAT:??_R4CCastleDeepEvent@@6B@ ; CCastleDeepEvent::`vftable'
	DD	FLAT:??_ECCastleDeepEvent@@UAEPAXI@Z
CONST	ENDS
xdata$x	SEGMENT
__ehfuncinfo$??0CCastleDeepEvent@@QAE@XZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??0CCastleDeepEvent@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CCastleDeepEvent@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CCastleDeepEvent@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CCastleDeepEvent@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CCastleDeepEvent@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CCastleDeepEvent@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0CCastleDeepEvent@@QAE@XZ$4
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CCastleDeepEvent@@QAE@XZ PROC			; CCastleDeepEvent::CCastleDeepEvent
; _this$ = ecx

; 21   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CCastleDeepEvent@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CCastleDeepEvent@@6B@
  00034	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	83 c1 30	 add	 ecx, 48			; 00000030H
  0003a	e8 00 00 00 00	 call	 ??0?$map@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@@std@@QAE@XZ ; std::map<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > > >::map<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > > >
  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00046	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	83 c1 40	 add	 ecx, 64			; 00000040H
  0004c	e8 00 00 00 00	 call	 ??0?$map@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@@std@@QAE@XZ ; std::map<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > > >::map<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > > >
  00051	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00055	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	83 c1 50	 add	 ecx, 80			; 00000050H
  0005b	e8 00 00 00 00	 call	 ??0?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE@XZ ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >
  00060	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00064	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	83 c1 60	 add	 ecx, 96			; 00000060H
  0006a	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  0006f	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00073	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	83 c1 70	 add	 ecx, 112		; 00000070H
  00079	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  0007e	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00082	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00085	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0008b	e8 00 00 00 00	 call	 ??0?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >

; 22   : 	this->m_bDoEvent = FALSE;

  00090	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00093	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 23   : 	this->m_bHasData = FALSE;

  0009a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009d	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 24   : 
; 25   : 	srand(time(NULL));

  000a4	6a 00		 push	 0
  000a6	e8 00 00 00 00	 call	 _time
  000ab	83 c4 04	 add	 esp, 4
  000ae	50		 push	 eax
  000af	e8 00 00 00 00	 call	 _srand
  000b4	83 c4 04	 add	 esp, 4

; 26   : 
; 27   : 	InitializeCriticalSection(&this->m_critEventData);

  000b7	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000ba	05 90 00 00 00	 add	 eax, 144		; 00000090H
  000bf	50		 push	 eax
  000c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4

; 28   : }

  000c6	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000cd	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000d0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000da	59		 pop	 ecx
  000db	5f		 pop	 edi
  000dc	5e		 pop	 esi
  000dd	5b		 pop	 ebx
  000de	8b e5		 mov	 esp, ebp
  000e0	5d		 pop	 ebp
  000e1	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0CCastleDeepEvent@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 30	 add	 ecx, 48			; 00000030H
  00006	e9 00 00 00 00	 jmp	 ??1?$map@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@@std@@QAE@XZ
__unwindfunclet$??0CCastleDeepEvent@@QAE@XZ$1:
  0000b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 40	 add	 ecx, 64			; 00000040H
  00011	e9 00 00 00 00	 jmp	 ??1?$map@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@@std@@QAE@XZ
__unwindfunclet$??0CCastleDeepEvent@@QAE@XZ$2:
  00016	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	83 c1 50	 add	 ecx, 80			; 00000050H
  0001c	e9 00 00 00 00	 jmp	 ??1?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE@XZ ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::~vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >
__unwindfunclet$??0CCastleDeepEvent@@QAE@XZ$3:
  00021	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	83 c1 60	 add	 ecx, 96			; 00000060H
  00027	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??0CCastleDeepEvent@@QAE@XZ$4:
  0002c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	83 c1 70	 add	 ecx, 112		; 00000070H
  00032	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__ehhandler$??0CCastleDeepEvent@@QAE@XZ:
  00037	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0003b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0003e	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00041	33 c8		 xor	 ecx, eax
  00043	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00048	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CCastleDeepEvent@@QAE@XZ
  0004d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CCastleDeepEvent@@QAE@XZ ENDP			; CCastleDeepEvent::CCastleDeepEvent
EXTRN	__time64:PROC
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\time.inl
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_time	PROC

; 132  : {

  000f0	55		 push	 ebp
  000f1	8b ec		 mov	 ebp, esp
  000f3	83 ec 40	 sub	 esp, 64			; 00000040H
  000f6	53		 push	 ebx
  000f7	56		 push	 esi
  000f8	57		 push	 edi

; 133  :     return _time64(_Time);

  000f9	8b 45 08	 mov	 eax, DWORD PTR __Time$[ebp]
  000fc	50		 push	 eax
  000fd	e8 00 00 00 00	 call	 __time64
  00102	83 c4 04	 add	 esp, 4

; 134  : }

  00105	5f		 pop	 edi
  00106	5e		 pop	 esi
  00107	5b		 pop	 ebx
  00108	8b e5		 mov	 esp, ebp
  0010a	5d		 pop	 ebp
  0010b	c3		 ret	 0
_time	ENDP
_TEXT	ENDS
PUBLIC	??1CCastleDeepEvent@@UAE@XZ			; CCastleDeepEvent::~CCastleDeepEvent
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp /ZI
;	COMDAT ??_GCCastleDeepEvent@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCCastleDeepEvent@@UAEPAXI@Z PROC			; CCastleDeepEvent::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1CCastleDeepEvent@@UAE@XZ ; CCastleDeepEvent::~CCastleDeepEvent
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_GCCastleDeepEvent@@UAEPAXI@Z ENDP			; CCastleDeepEvent::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::~_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >
; Function compile flags: /Odtp /ZI
;	COMDAT ??1?$map@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$map@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@@std@@QAE@XZ PROC ; std::map<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > > >::~map<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::~_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >
  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1?$map@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@@std@@QAE@XZ ENDP ; std::map<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > > >::~map<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > > >
_TEXT	ENDS
PUBLIC	??1?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::~_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >
; Function compile flags: /Odtp /ZI
;	COMDAT ??1?$map@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$map@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@@std@@QAE@XZ PROC ; std::map<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > > >::~map<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::~_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >
  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1?$map@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@@std@@QAE@XZ ENDP ; std::map<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > > >::~map<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > > >
_TEXT	ENDS
PUBLIC	??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::~map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
EXTRN	__imp__DeleteCriticalSection@4:PROC
xdata$x	SEGMENT
__ehfuncinfo$??1CCastleDeepEvent@@UAE@XZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??1CCastleDeepEvent@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CCastleDeepEvent@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CCastleDeepEvent@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CCastleDeepEvent@@UAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CCastleDeepEvent@@UAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CCastleDeepEvent@@UAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CCastleDeepEvent@@UAE@XZ$4
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\castledeepevent.cpp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CCastleDeepEvent@@UAE@XZ PROC			; CCastleDeepEvent::~CCastleDeepEvent
; _this$ = ecx

; 31   : {

  00110	55		 push	 ebp
  00111	8b ec		 mov	 ebp, esp
  00113	6a ff		 push	 -1
  00115	68 00 00 00 00	 push	 __ehhandler$??1CCastleDeepEvent@@UAE@XZ
  0011a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00120	50		 push	 eax
  00121	83 ec 44	 sub	 esp, 68			; 00000044H
  00124	53		 push	 ebx
  00125	56		 push	 esi
  00126	57		 push	 edi
  00127	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0012c	33 c5		 xor	 eax, ebp
  0012e	50		 push	 eax
  0012f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00132	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00138	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0013b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0013e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CCastleDeepEvent@@6B@
  00144	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 4

; 32   : 	DeleteCriticalSection(&this->m_critEventData);

  0014b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0014e	05 90 00 00 00	 add	 eax, 144		; 00000090H
  00153	50		 push	 eax
  00154	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4

; 33   : }

  0015a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0015d	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00163	e8 00 00 00 00	 call	 ??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
  00168	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0016c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0016f	83 c1 70	 add	 ecx, 112		; 00000070H
  00172	e8 00 00 00 00	 call	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
  00177	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0017b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0017e	83 c1 60	 add	 ecx, 96			; 00000060H
  00181	e8 00 00 00 00	 call	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
  00186	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0018a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0018d	83 c1 50	 add	 ecx, 80			; 00000050H
  00190	e8 00 00 00 00	 call	 ??1?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE@XZ ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::~vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >
  00195	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00199	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0019c	83 c1 40	 add	 ecx, 64			; 00000040H
  0019f	e8 00 00 00 00	 call	 ??1?$map@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@@std@@QAE@XZ
  001a4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  001ab	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001ae	83 c1 30	 add	 ecx, 48			; 00000030H
  001b1	e8 00 00 00 00	 call	 ??1?$map@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@@std@@QAE@XZ
  001b6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001b9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001c0	59		 pop	 ecx
  001c1	5f		 pop	 edi
  001c2	5e		 pop	 esi
  001c3	5b		 pop	 ebx
  001c4	8b e5		 mov	 esp, ebp
  001c6	5d		 pop	 ebp
  001c7	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??1CCastleDeepEvent@@UAE@XZ$0:
  00052	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	83 c1 30	 add	 ecx, 48			; 00000030H
  00058	e9 00 00 00 00	 jmp	 ??1?$map@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@@std@@QAE@XZ
__unwindfunclet$??1CCastleDeepEvent@@UAE@XZ$1:
  0005d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00060	83 c1 40	 add	 ecx, 64			; 00000040H
  00063	e9 00 00 00 00	 jmp	 ??1?$map@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@@std@@QAE@XZ
__unwindfunclet$??1CCastleDeepEvent@@UAE@XZ$2:
  00068	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	83 c1 50	 add	 ecx, 80			; 00000050H
  0006e	e9 00 00 00 00	 jmp	 ??1?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE@XZ ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::~vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >
__unwindfunclet$??1CCastleDeepEvent@@UAE@XZ$3:
  00073	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	83 c1 60	 add	 ecx, 96			; 00000060H
  00079	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??1CCastleDeepEvent@@UAE@XZ$4:
  0007e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00081	83 c1 70	 add	 ecx, 112		; 00000070H
  00084	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__ehhandler$??1CCastleDeepEvent@@UAE@XZ:
  00089	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0008d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00090	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00093	33 c8		 xor	 ecx, eax
  00095	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CCastleDeepEvent@@UAE@XZ
  0009f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CCastleDeepEvent@@UAE@XZ ENDP			; CCastleDeepEvent::~CCastleDeepEvent
PUBLIC	??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
; Function compile flags: /Odtp /ZI
;	COMDAT ??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ PROC ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::~map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ ENDP ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::~map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
_TEXT	ENDS
PUBLIC	??$insert@U?$pair@HH@std@@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HH@1@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::insert<std::pair<int,int> >
PUBLIC	??$?0AAHAAH@?$pair@HH@std@@QAE@AAH0@Z		; std::pair<int,int>::pair<int,int><int &,int &>
PUBLIC	??C?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QBEPAUCASTLEDEEP_SPAWNTIME@@XZ ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::operator->
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::operator!=
PUBLIC	?end@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@XZ ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::end
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::operator++
PUBLIC	?begin@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@XZ ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::begin
PUBLIC	??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::operator->
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::clear
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::operator==
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::end
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::find
PUBLIC	??_C@_0DC@JMKIKJEC@?$FLCastleDeep?5Event?$FN?5Start?5Fail?5?9?5@ ; `string'
PUBLIC	??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int> >::operator[]
PUBLIC	?SetState@CCastleDeepEvent@@QAEXH@Z		; CCastleDeepEvent::SetState
PUBLIC	??_C@_0CP@EPJCMAAN@?$FLCastleDeep?5Event?$FN?5Start?5Fail?5?9?5@ ; `string'
PUBLIC	?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
PUBLIC	?StartEvent@CCastleDeepEvent@@QAEXXZ		; CCastleDeepEvent::StartEvent
EXTRN	_rand:PROC
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
;	COMDAT ??_C@_0DC@JMKIKJEC@?$FLCastleDeep?5Event?$FN?5Start?5Fail?5?9?5@
CONST	SEGMENT
??_C@_0DC@JMKIKJEC@?$FLCastleDeep?5Event?$FN?5Start?5Fail?5?9?5@ DB '[Cas'
	DB	'tleDeep Event] Start Fail - bDoStart == FALSE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@EPJCMAAN@?$FLCastleDeep?5Event?$FN?5Start?5Fail?5?9?5@
CONST	SEGMENT
??_C@_0CP@EPJCMAAN@?$FLCastleDeep?5Event?$FN?5Start?5Fail?5?9?5@ DB '[Cas'
	DB	'tleDeep Event] Start Fail - No Assult Data', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
$T238878 = -124						; size = 4
$T238879 = -120						; size = 4
$T238880 = -116						; size = 4
$T238881 = -112						; size = 8
$T238882 = -104						; size = 8
_stSpawnTime$231019 = -32				; size = 4
_it2$230834 = -28					; size = 4
_it$ = -24						; size = 4
_iRndIndex$230190 = -20					; size = 4
_bDoStart$ = -16					; size = 4
_iASSULT_RATE$ = -12					; size = 4
_iCheckCount$ = -8					; size = 4
_this$ = -4						; size = 4
?StartEvent@CCastleDeepEvent@@QAEXXZ PROC		; CCastleDeepEvent::StartEvent
; _this$ = ecx

; 40   : {

  001d0	55		 push	 ebp
  001d1	8b ec		 mov	 ebp, esp
  001d3	83 ec 7c	 sub	 esp, 124		; 0000007cH
  001d6	53		 push	 ebx
  001d7	56		 push	 esi
  001d8	57		 push	 edi
  001d9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 41   : 	if (m_vtAssultType.size() <= 0)

  001dc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001df	83 c1 60	 add	 ecx, 96			; 00000060H
  001e2	e8 00 00 00 00	 call	 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
  001e7	85 c0		 test	 eax, eax
  001e9	77 1d		 ja	 SHORT $LN9@StartEvent

; 42   : 	{
; 43   : 		LogAddTD("[CastleDeep Event] Start Fail - No Assult Data");

  001eb	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@EPJCMAAN@?$FLCastleDeep?5Event?$FN?5Start?5Fail?5?9?5@
  001f0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001f6	83 c4 04	 add	 esp, 4

; 44   : 		SetState(CD_STATE_NONE);

  001f9	6a 00		 push	 0
  001fb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001fe	e8 00 00 00 00	 call	 ?SetState@CCastleDeepEvent@@QAEXH@Z ; CCastleDeepEvent::SetState

; 45   : 		return;

  00203	e9 8d 01 00 00	 jmp	 $LN10@StartEvent
$LN9@StartEvent:

; 46   : 	}
; 47   : 
; 48   : 	int iCheckCount = 100;

  00208	c7 45 f8 64 00
	00 00		 mov	 DWORD PTR _iCheckCount$[ebp], 100 ; 00000064H

; 49   : 	int iASSULT_RATE = 0;

  0020f	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iASSULT_RATE$[ebp], 0

; 50   : 	int bDoStart = FALSE;

  00216	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _bDoStart$[ebp], 0
$LN8@StartEvent:

; 51   : 
; 52   : 	while(iCheckCount-- > 0)

  0021d	8b 45 f8	 mov	 eax, DWORD PTR _iCheckCount$[ebp]
  00220	8b 4d f8	 mov	 ecx, DWORD PTR _iCheckCount$[ebp]
  00223	83 e9 01	 sub	 ecx, 1
  00226	89 4d f8	 mov	 DWORD PTR _iCheckCount$[ebp], ecx
  00229	85 c0		 test	 eax, eax
  0022b	7e 65		 jle	 SHORT $LN7@StartEvent

; 53   : 	{
; 54   : 		int iRndIndex = rand()%m_vtAssultType.size();

  0022d	e8 00 00 00 00	 call	 _rand
  00232	8b f0		 mov	 esi, eax
  00234	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00237	83 c1 60	 add	 ecx, 96			; 00000060H
  0023a	e8 00 00 00 00	 call	 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
  0023f	8b c8		 mov	 ecx, eax
  00241	8b c6		 mov	 eax, esi
  00243	33 d2		 xor	 edx, edx
  00245	f7 f1		 div	 ecx
  00247	89 55 ec	 mov	 DWORD PTR _iRndIndex$230190[ebp], edx

; 55   : 
; 56   : 		this->m_iCUR_ASSULT_TYPE = m_vtAssultType[iRndIndex];

  0024a	8b 45 ec	 mov	 eax, DWORD PTR _iRndIndex$230190[ebp]
  0024d	50		 push	 eax
  0024e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00251	83 c1 60	 add	 ecx, 96			; 00000060H
  00254	e8 00 00 00 00	 call	 ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int> >::operator[]
  00259	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0025c	8b 10		 mov	 edx, DWORD PTR [eax]
  0025e	89 51 28	 mov	 DWORD PTR [ecx+40], edx

; 57   : 		iASSULT_RATE = m_vtAssultTypeRate[iRndIndex];

  00261	8b 45 ec	 mov	 eax, DWORD PTR _iRndIndex$230190[ebp]
  00264	50		 push	 eax
  00265	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00268	83 c1 70	 add	 ecx, 112		; 00000070H
  0026b	e8 00 00 00 00	 call	 ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int> >::operator[]
  00270	8b 08		 mov	 ecx, DWORD PTR [eax]
  00272	89 4d f4	 mov	 DWORD PTR _iASSULT_RATE$[ebp], ecx

; 58   : 
; 59   : 		if (rand()%100 < iASSULT_RATE)

  00275	e8 00 00 00 00	 call	 _rand
  0027a	99		 cdq
  0027b	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00280	f7 f9		 idiv	 ecx
  00282	3b 55 f4	 cmp	 edx, DWORD PTR _iASSULT_RATE$[ebp]
  00285	7d 09		 jge	 SHORT $LN6@StartEvent

; 60   : 		{
; 61   : 			bDoStart = TRUE;

  00287	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _bDoStart$[ebp], 1

; 62   : 			break;

  0028e	eb 02		 jmp	 SHORT $LN7@StartEvent
$LN6@StartEvent:

; 63   : 		}
; 64   : 	}

  00290	eb 8b		 jmp	 SHORT $LN8@StartEvent
$LN7@StartEvent:

; 65   : 
; 66   : 	if (bDoStart == FALSE)

  00292	83 7d f0 00	 cmp	 DWORD PTR _bDoStart$[ebp], 0
  00296	75 1d		 jne	 SHORT $LN5@StartEvent

; 67   : 	{
; 68   : 		LogAddTD("[CastleDeep Event] Start Fail - bDoStart == FALSE");

  00298	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@JMKIKJEC@?$FLCastleDeep?5Event?$FN?5Start?5Fail?5?9?5@
  0029d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  002a3	83 c4 04	 add	 esp, 4

; 69   : 		SetState(CD_STATE_NONE);

  002a6	6a 00		 push	 0
  002a8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002ab	e8 00 00 00 00	 call	 ?SetState@CCastleDeepEvent@@QAEXH@Z ; CCastleDeepEvent::SetState

; 70   : 		return;

  002b0	e9 e0 00 00 00	 jmp	 $LN10@StartEvent
$LN5@StartEvent:

; 71   : 	}
; 72   : 
; 73   : 	this->m_iCUR_SPAWN_STEP = 0;

  002b5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002b8	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0

; 74   : 
; 75   : 	std::map<int,vector<CASTLEDEEP_SPAWNTIME > >::iterator it = this->m_mapSpawnTime.find(m_iCUR_ASSULT_TYPE); //HermeX Fix

  002bf	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002c2	83 c0 28	 add	 eax, 40			; 00000028H
  002c5	50		 push	 eax
  002c6	8d 4d e8	 lea	 ecx, DWORD PTR _it$[ebp]
  002c9	51		 push	 ecx
  002ca	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002cd	83 c1 40	 add	 ecx, 64			; 00000040H
  002d0	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::find

; 76   : 
; 77   : 	if (it == m_mapSpawnTime.end())

  002d5	8d 45 84	 lea	 eax, DWORD PTR $T238878[ebp]
  002d8	50		 push	 eax
  002d9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002dc	83 c1 40	 add	 ecx, 64			; 00000040H
  002df	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::end
  002e4	50		 push	 eax
  002e5	8d 4d e8	 lea	 ecx, DWORD PTR _it$[ebp]
  002e8	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::operator==
  002ed	0f b6 c8	 movzx	 ecx, al
  002f0	85 c9		 test	 ecx, ecx
  002f2	74 0f		 je	 SHORT $LN4@StartEvent

; 78   : 	{
; 79   : 		SetState(CD_STATE_NONE);

  002f4	6a 00		 push	 0
  002f6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002f9	e8 00 00 00 00	 call	 ?SetState@CCastleDeepEvent@@QAEXH@Z ; CCastleDeepEvent::SetState

; 80   : 		return;

  002fe	e9 92 00 00 00	 jmp	 $LN10@StartEvent
$LN4@StartEvent:

; 81   : 	}
; 82   : 
; 83   : 	m_mapRunCheck.clear();

  00303	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00306	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0030c	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::clear

; 84   : 
; 85   : 	for(std::vector<CASTLEDEEP_SPAWNTIME>::iterator it2 = it->second.begin(); it2 != it->second.end(); it2++)

  00311	8d 45 e4	 lea	 eax, DWORD PTR _it2$230834[ebp]
  00314	50		 push	 eax
  00315	8d 4d e8	 lea	 ecx, DWORD PTR _it$[ebp]
  00318	e8 00 00 00 00	 call	 ??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::operator->
  0031d	83 c0 04	 add	 eax, 4
  00320	8b c8		 mov	 ecx, eax
  00322	e8 00 00 00 00	 call	 ?begin@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@XZ ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::begin
  00327	eb 0e		 jmp	 SHORT $LN3@StartEvent
$LN2@StartEvent:
  00329	6a 00		 push	 0
  0032b	8d 45 88	 lea	 eax, DWORD PTR $T238879[ebp]
  0032e	50		 push	 eax
  0032f	8d 4d e4	 lea	 ecx, DWORD PTR _it2$230834[ebp]
  00332	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::operator++
$LN3@StartEvent:
  00337	8d 45 8c	 lea	 eax, DWORD PTR $T238880[ebp]
  0033a	50		 push	 eax
  0033b	8d 4d e8	 lea	 ecx, DWORD PTR _it$[ebp]
  0033e	e8 00 00 00 00	 call	 ??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::operator->
  00343	83 c0 04	 add	 eax, 4
  00346	8b c8		 mov	 ecx, eax
  00348	e8 00 00 00 00	 call	 ?end@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@XZ ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::end
  0034d	50		 push	 eax
  0034e	8d 4d e4	 lea	 ecx, DWORD PTR _it2$230834[ebp]
  00351	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::operator!=
  00356	0f b6 c8	 movzx	 ecx, al
  00359	85 c9		 test	 ecx, ecx
  0035b	74 38		 je	 SHORT $LN10@StartEvent

; 86   : 	{
; 87   : 		std::vector<CASTLEDEEP_SPAWNTIME>::iterator stSpawnTime= it2;

  0035d	8b 45 e4	 mov	 eax, DWORD PTR _it2$230834[ebp]
  00360	89 45 e0	 mov	 DWORD PTR _stSpawnTime$231019[ebp], eax

; 88   : 
; 89   : 		m_mapRunCheck.insert(std::pair<int,int>(stSpawnTime->m_iMonsterGroup,stSpawnTime->m_iMonsterSpawnMinute)); //HermeX Fix

  00363	8d 4d e0	 lea	 ecx, DWORD PTR _stSpawnTime$231019[ebp]
  00366	e8 00 00 00 00	 call	 ??C?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QBEPAUCASTLEDEEP_SPAWNTIME@@XZ ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::operator->
  0036b	83 c0 04	 add	 eax, 4
  0036e	50		 push	 eax
  0036f	8d 4d e0	 lea	 ecx, DWORD PTR _stSpawnTime$231019[ebp]
  00372	e8 00 00 00 00	 call	 ??C?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QBEPAUCASTLEDEEP_SPAWNTIME@@XZ ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::operator->
  00377	50		 push	 eax
  00378	8d 4d 90	 lea	 ecx, DWORD PTR $T238881[ebp]
  0037b	e8 00 00 00 00	 call	 ??$?0AAHAAH@?$pair@HH@std@@QAE@AAH0@Z ; std::pair<int,int>::pair<int,int><int &,int &>
  00380	50		 push	 eax
  00381	8d 45 98	 lea	 eax, DWORD PTR $T238882[ebp]
  00384	50		 push	 eax
  00385	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00388	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0038e	e8 00 00 00 00	 call	 ??$insert@U?$pair@HH@std@@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HH@1@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::insert<std::pair<int,int> >

; 90   : 	}

  00393	eb 94		 jmp	 SHORT $LN2@StartEvent
$LN10@StartEvent:

; 91   : }

  00395	5f		 pop	 edi
  00396	5e		 pop	 esi
  00397	5b		 pop	 ebx
  00398	8b e5		 mov	 esp, ebp
  0039a	5d		 pop	 ebp
  0039b	c3		 ret	 0
?StartEvent@CCastleDeepEvent@@QAEXXZ ENDP		; CCastleDeepEvent::StartEvent
_TEXT	ENDS
PUBLIC	?StopEvent@CCastleDeepEvent@@QAEXXZ		; CCastleDeepEvent::StopEvent
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
?StopEvent@CCastleDeepEvent@@QAEXXZ PROC		; CCastleDeepEvent::StopEvent
; _this$ = ecx

; 94   : {

  003a0	55		 push	 ebp
  003a1	8b ec		 mov	 ebp, esp
  003a3	83 ec 44	 sub	 esp, 68			; 00000044H
  003a6	53		 push	 ebx
  003a7	56		 push	 esi
  003a8	57		 push	 edi
  003a9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 95   : ;
; 96   : }

  003ac	5f		 pop	 edi
  003ad	5e		 pop	 esi
  003ae	5b		 pop	 ebx
  003af	8b e5		 mov	 esp, ebp
  003b1	5d		 pop	 ebp
  003b2	c3		 ret	 0
?StopEvent@CCastleDeepEvent@@QAEXXZ ENDP		; CCastleDeepEvent::StopEvent
_TEXT	ENDS
PUBLIC	?EnableEvent@CCastleDeepEvent@@QAEXH@Z		; CCastleDeepEvent::EnableEvent
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bDoEvent$ = 8						; size = 4
?EnableEvent@CCastleDeepEvent@@QAEXH@Z PROC		; CCastleDeepEvent::EnableEvent
; _this$ = ecx

; 99   : {

  003c0	55		 push	 ebp
  003c1	8b ec		 mov	 ebp, esp
  003c3	83 ec 44	 sub	 esp, 68			; 00000044H
  003c6	53		 push	 ebx
  003c7	56		 push	 esi
  003c8	57		 push	 edi
  003c9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 100  : 	this->m_bDoEvent = bDoEvent;

  003cc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  003cf	8b 4d 08	 mov	 ecx, DWORD PTR _bDoEvent$[ebp]
  003d2	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 101  : 
; 102  : 	if (this->m_bDoEvent != 0)

  003d5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  003d8	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  003dc	74 0c		 je	 SHORT $LN2@EnableEven

; 103  : 	{
; 104  : 		this->SetState(CD_STATE_CLOSED);

  003de	6a 01		 push	 1
  003e0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003e3	e8 00 00 00 00	 call	 ?SetState@CCastleDeepEvent@@QAEXH@Z ; CCastleDeepEvent::SetState

; 105  : 	}
; 106  : 	else

  003e8	eb 0a		 jmp	 SHORT $LN3@EnableEven
$LN2@EnableEven:

; 107  : 	{
; 108  : 		this->SetState(CD_STATE_NONE);

  003ea	6a 00		 push	 0
  003ec	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003ef	e8 00 00 00 00	 call	 ?SetState@CCastleDeepEvent@@QAEXH@Z ; CCastleDeepEvent::SetState
$LN3@EnableEven:

; 109  : 	}
; 110  : }

  003f4	5f		 pop	 edi
  003f5	5e		 pop	 esi
  003f6	5b		 pop	 ebx
  003f7	8b e5		 mov	 esp, ebp
  003f9	5d		 pop	 ebp
  003fa	c2 04 00	 ret	 4
?EnableEvent@CCastleDeepEvent@@QAEXH@Z ENDP		; CCastleDeepEvent::EnableEvent
_TEXT	ENDS
PUBLIC	??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@	; `string'
PUBLIC	?push_back@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAEXABUCASTLEDEEP_MONSTERINFO@@@Z ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::push_back
PUBLIC	??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::operator->
PUBLIC	??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::operator!=
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::end
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::find
PUBLIC	?push_back@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAEXABUCASTLEDEEP_SPAWNTIME@@@Z ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::push_back
PUBLIC	??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::operator!=
PUBLIC	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
PUBLIC	??1?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@XZ ; std::pair<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::~pair<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >
PUBLIC	??$insert@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::insert<std::pair<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >
PUBLIC	??$?0AAHAAV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@AAHAAV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@1@@Z ; std::pair<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::pair<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > ><int &,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > &>
PUBLIC	??1?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@XZ ; std::pair<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::~pair<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >
PUBLIC	??$insert@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::insert<std::pair<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >
PUBLIC	??$?0AAHAAV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@AAHAAV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@1@@Z ; std::pair<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::pair<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > ><int &,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > &>
PUBLIC	??1?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@XZ ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::~vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >
PUBLIC	??1?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@XZ ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::~vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >
PUBLIC	??0?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@XZ ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >
PUBLIC	??0?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@XZ ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >
PUBLIC	?push_back@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAEXABUCASTLEDEEP_EVENTTIME@@@Z ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::push_back
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	?clear@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAEXXZ ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::clear
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::clear
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::clear
PUBLIC	?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ; std::vector<int,std::allocator<int> >::clear
PUBLIC	??_C@_0CM@NBAEFDEO@?$FLCastleDeep?5Event?$FN?5Info?5file?5Loa@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?Load@CCastleDeepEvent@@QAEHPAD@Z		; CCastleDeepEvent::Load
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	_fclose:PROC
EXTRN	_strcmp:PROC
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	_fopen:PROC
EXTRN	__ftol2_sse:PROC
_BSS	SEGMENT
_TokenString DB	064H DUP (?)
_TokenNumber DD	01H DUP (?)
_SMDFile DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@
CONST	SEGMENT
??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@ DB '%s file load!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@NBAEFDEO@?$FLCastleDeep?5Event?$FN?5Info?5file?5Loa@
CONST	SEGMENT
??_C@_0CM@NBAEFDEO@?$FLCastleDeep?5Event?$FN?5Info?5file?5Loa@ DB '[Castl'
	DB	'eDeep Event] Info file Load Fail [%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
xdata$x	SEGMENT
__unwindtable$?Load@CCastleDeepEvent@@QAEHPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Load@CCastleDeepEvent@@QAEHPAD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@CCastleDeepEvent@@QAEHPAD@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?Load@CCastleDeepEvent@@QAEHPAD@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?Load@CCastleDeepEvent@@QAEHPAD@Z$3
__ehfuncinfo$?Load@CCastleDeepEvent@@QAEHPAD@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?Load@CCastleDeepEvent@@QAEHPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
_TEXT	SEGMENT
tv357 = -264						; size = 4
tv355 = -264						; size = 4
tv154 = -260						; size = 4
tv151 = -260						; size = 4
$T238887 = -256						; size = 20
$T238888 = -236						; size = 8
$T238889 = -228						; size = 20
$T238890 = -208						; size = 8
$T238891 = -200						; size = 4
$T238892 = -196						; size = 4
_it$232774 = -128					; size = 4
_iAssultType$232747 = -124				; size = 4
_stMonsterInfo$232746 = -120				; size = 28
_it$232740 = -92					; size = 4
_iAssultType$232718 = -88				; size = 4
_stSpawnTime$232717 = -84				; size = 8
_iAssultRate$231853 = -76				; size = 4
_iAssultType$231852 = -72				; size = 4
_vtTempSpawnTime$231851 = -68				; size = 16
_vtTempMonsterInfo$231846 = -52				; size = 16
_pRET$231498 = -36					; size = 8
_type$ = -28						; size = 4
_Token$ = -24						; size = 4
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_lpszFileName$ = 8					; size = 4
?Load@CCastleDeepEvent@@QAEHPAD@Z PROC			; CCastleDeepEvent::Load
; _this$ = ecx

; 113  : {

  00400	55		 push	 ebp
  00401	8b ec		 mov	 ebp, esp
  00403	6a ff		 push	 -1
  00405	68 00 00 00 00	 push	 __ehhandler$?Load@CCastleDeepEvent@@QAEHPAD@Z
  0040a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00410	50		 push	 eax
  00411	81 ec fc 00 00
	00		 sub	 esp, 252		; 000000fcH
  00417	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0041c	33 c5		 xor	 eax, ebp
  0041e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00421	53		 push	 ebx
  00422	56		 push	 esi
  00423	57		 push	 edi
  00424	50		 push	 eax
  00425	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00428	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0042e	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 114  : using namespace std;
; 115  : 
; 116  : 	if (lpszFileName == NULL)

  00431	83 7d 08 00	 cmp	 DWORD PTR _lpszFileName$[ebp], 0
  00435	75 07		 jne	 SHORT $LN20@Load

; 117  : 	{
; 118  : 		return false;

  00437	33 c0		 xor	 eax, eax
  00439	e9 fa 04 00 00	 jmp	 $LN21@Load
$LN20@Load:

; 119  : 	}
; 120  : 
; 121  : 	SMDFile = fopen(lpszFileName,"r");

  0043e	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  00443	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  00446	50		 push	 eax
  00447	e8 00 00 00 00	 call	 _fopen
  0044c	83 c4 08	 add	 esp, 8
  0044f	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax

; 122  : 
; 123  : 	if (SMDFile == NULL)

  00454	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SMDFile, 0
  0045b	75 18		 jne	 SHORT $LN19@Load

; 124  : 	{
; 125  : 		MsgBox("[CastleDeep Event] Info file Load Fail [%s]",lpszFileName);

  0045d	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  00460	50		 push	 eax
  00461	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@NBAEFDEO@?$FLCastleDeep?5Event?$FN?5Info?5file?5Loa@
  00466	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  0046b	83 c4 08	 add	 esp, 8

; 126  : 		return false;

  0046e	33 c0		 xor	 eax, eax
  00470	e9 c3 04 00 00	 jmp	 $LN21@Load
$LN19@Load:

; 127  : 	}
; 128  : 
; 129  : 	EnterCriticalSection(&this->m_critEventData);

  00475	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00478	05 90 00 00 00	 add	 eax, 144		; 00000090H
  0047d	50		 push	 eax
  0047e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 130  : 	this->m_vtAssultType.clear();

  00484	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00487	83 c1 60	 add	 ecx, 96			; 00000060H
  0048a	e8 00 00 00 00	 call	 ?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ; std::vector<int,std::allocator<int> >::clear

; 131  : 	this->m_vtAssultTypeRate.clear();

  0048f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00492	83 c1 70	 add	 ecx, 112		; 00000070H
  00495	e8 00 00 00 00	 call	 ?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ; std::vector<int,std::allocator<int> >::clear

; 132  : 	this->m_mapSpawnTime.clear();

  0049a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0049d	83 c1 40	 add	 ecx, 64			; 00000040H
  004a0	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::clear

; 133  : 	this->m_mapMonsterInfo.clear();

  004a5	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  004a8	83 c1 30	 add	 ecx, 48			; 00000030H
  004ab	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::clear

; 134  : 	this->m_vtEventTime.clear();

  004b0	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  004b3	83 c1 50	 add	 ecx, 80			; 00000050H
  004b6	e8 00 00 00 00	 call	 ?clear@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAEXXZ ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::clear

; 135  : 	this->m_mapRunCheck.clear();

  004bb	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  004be	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  004c4	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::clear

; 136  : 	LeaveCriticalSection(&this->m_critEventData);

  004c9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  004cc	05 90 00 00 00	 add	 eax, 144		; 00000090H
  004d1	50		 push	 eax
  004d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 137  : 
; 138  : 	this->m_bHasData = FALSE;

  004d8	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  004db	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 139  : 
; 140  : 	SMDToken Token;
; 141  : 	int type = -1;

  004e2	c7 45 e4 ff ff
	ff ff		 mov	 DWORD PTR _type$[ebp], -1
$LN18@Load:

; 142  : 
; 143  : 	while( true )

  004e9	b8 01 00 00 00	 mov	 eax, 1
  004ee	85 c0		 test	 eax, eax
  004f0	0f 84 13 04 00
	00		 je	 $LN17@Load

; 144  : 	{
; 145  : 		Token = GetToken();

  004f6	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  004fb	89 45 e8	 mov	 DWORD PTR _Token$[ebp], eax

; 146  : 
; 147  : 		if (Token == END)

  004fe	83 7d e8 02	 cmp	 DWORD PTR _Token$[ebp], 2
  00502	75 05		 jne	 SHORT $LN16@Load

; 148  : 		{
; 149  : 			break;

  00504	e9 00 04 00 00	 jmp	 $LN17@Load
$LN16@Load:

; 150  : 		}
; 151  : 
; 152  : 		type = (int)TokenNumber;

  00509	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0050f	e8 00 00 00 00	 call	 __ftol2_sse
  00514	89 45 e4	 mov	 DWORD PTR _type$[ebp], eax
$LN15@Load:

; 153  : 
; 154  : 		while( true )

  00517	b8 01 00 00 00	 mov	 eax, 1
  0051c	85 c0		 test	 eax, eax
  0051e	0f 84 e0 03 00
	00		 je	 $LN14@Load

; 155  : 		{
; 156  : 			if (type == 0)

  00524	83 7d e4 00	 cmp	 DWORD PTR _type$[ebp], 0
  00528	75 5b		 jne	 SHORT $LN13@Load

; 157  : 			{
; 158  : 				CASTLEDEEP_EVENTTIME pRET;
; 159  : 
; 160  : 				Token = GetToken();

  0052a	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0052f	89 45 e8	 mov	 DWORD PTR _Token$[ebp], eax

; 161  : 				if (!strcmp("end",TokenString))

  00532	68 00 00 00 00	 push	 OFFSET _TokenString
  00537	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  0053c	e8 00 00 00 00	 call	 _strcmp
  00541	83 c4 08	 add	 esp, 8
  00544	85 c0		 test	 eax, eax
  00546	75 05		 jne	 SHORT $LN12@Load

; 162  : 					break;

  00548	e9 b7 03 00 00	 jmp	 $LN14@Load
$LN12@Load:

; 163  : 				
; 164  : 				pRET.m_iHour = (int)TokenNumber;

  0054d	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00553	e8 00 00 00 00	 call	 __ftol2_sse
  00558	89 45 dc	 mov	 DWORD PTR _pRET$231498[ebp], eax

; 165  : 				Token = GetToken();

  0055b	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00560	89 45 e8	 mov	 DWORD PTR _Token$[ebp], eax

; 166  : 				pRET.m_iMinute = (int)TokenNumber;

  00563	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00569	e8 00 00 00 00	 call	 __ftol2_sse
  0056e	89 45 e0	 mov	 DWORD PTR _pRET$231498[ebp+4], eax

; 167  : 				this->m_vtEventTime.push_back(pRET);

  00571	8d 45 dc	 lea	 eax, DWORD PTR _pRET$231498[ebp]
  00574	50		 push	 eax
  00575	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00578	83 c1 50	 add	 ecx, 80			; 00000050H
  0057b	e8 00 00 00 00	 call	 ?push_back@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAEXABUCASTLEDEEP_EVENTTIME@@@Z ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::push_back
  00580	e9 7a 03 00 00	 jmp	 $LN3@Load
$LN13@Load:

; 168  : 			}
; 169  : 			else if (type == 1)

  00585	83 7d e4 01	 cmp	 DWORD PTR _type$[ebp], 1
  00589	0f 85 5d 01 00
	00		 jne	 $LN10@Load

; 170  : 			{
; 171  : 				std::vector<CASTLEDEEP_MONSTERINFO> vtTempMonsterInfo; //HermeX Fix

  0058f	8d 4d cc	 lea	 ecx, DWORD PTR _vtTempMonsterInfo$231846[ebp]
  00592	e8 00 00 00 00	 call	 ??0?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@XZ ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >
  00597	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 172  : 				std::vector<CASTLEDEEP_SPAWNTIME> vtTempSpawnTime; //HermeX Fix

  0059e	8d 4d bc	 lea	 ecx, DWORD PTR _vtTempSpawnTime$231851[ebp]
  005a1	e8 00 00 00 00	 call	 ??0?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@XZ ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >
  005a6	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 173  : 
; 174  : 				int iAssultType;
; 175  : 				int iAssultRate;
; 176  : 
; 177  : 				Token = GetToken();

  005aa	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  005af	89 45 e8	 mov	 DWORD PTR _Token$[ebp], eax

; 178  : 				if (!strcmp("end",TokenString))

  005b2	68 00 00 00 00	 push	 OFFSET _TokenString
  005b7	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  005bc	e8 00 00 00 00	 call	 _strcmp
  005c1	83 c4 08	 add	 esp, 8
  005c4	85 c0		 test	 eax, eax
  005c6	75 20		 jne	 SHORT $LN9@Load

; 179  : 					break;

  005c8	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  005cc	8d 4d bc	 lea	 ecx, DWORD PTR _vtTempSpawnTime$231851[ebp]
  005cf	e8 00 00 00 00	 call	 ??1?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@XZ ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::~vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >
  005d4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  005db	8d 4d cc	 lea	 ecx, DWORD PTR _vtTempMonsterInfo$231846[ebp]
  005de	e8 00 00 00 00	 call	 ??1?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@XZ ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::~vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >
  005e3	e9 1c 03 00 00	 jmp	 $LN14@Load
$LN9@Load:

; 180  : 
; 181  : 				iAssultType = (int)TokenNumber;

  005e8	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  005ee	e8 00 00 00 00	 call	 __ftol2_sse
  005f3	89 45 b8	 mov	 DWORD PTR _iAssultType$231852[ebp], eax

; 182  : 
; 183  : 				Token = GetToken();

  005f6	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  005fb	89 45 e8	 mov	 DWORD PTR _Token$[ebp], eax

; 184  : 				iAssultRate = (int)TokenNumber;

  005fe	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00604	e8 00 00 00 00	 call	 __ftol2_sse
  00609	89 45 b4	 mov	 DWORD PTR _iAssultRate$231853[ebp], eax

; 185  : 
; 186  : 				this->m_mapMonsterInfo.insert(std::pair<int,vector<CASTLEDEEP_MONSTERINFO> >(iAssultType,vtTempMonsterInfo)); //HermeX Fix

  0060c	8d 45 cc	 lea	 eax, DWORD PTR _vtTempMonsterInfo$231846[ebp]
  0060f	50		 push	 eax
  00610	8d 4d b8	 lea	 ecx, DWORD PTR _iAssultType$231852[ebp]
  00613	51		 push	 ecx
  00614	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR $T238887[ebp]
  0061a	e8 00 00 00 00	 call	 ??$?0AAHAAV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@AAHAAV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@1@@Z ; std::pair<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::pair<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > ><int &,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > &>
  0061f	89 85 fc fe ff
	ff		 mov	 DWORD PTR tv154[ebp], eax
  00625	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR tv154[ebp]
  0062b	89 95 f8 fe ff
	ff		 mov	 DWORD PTR tv355[ebp], edx
  00631	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00635	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR tv355[ebp]
  0063b	50		 push	 eax
  0063c	8d 8d 14 ff ff
	ff		 lea	 ecx, DWORD PTR $T238888[ebp]
  00642	51		 push	 ecx
  00643	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00646	83 c1 30	 add	 ecx, 48			; 00000030H
  00649	e8 00 00 00 00	 call	 ??$insert@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::insert<std::pair<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >
  0064e	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00652	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR $T238887[ebp]
  00658	e8 00 00 00 00	 call	 ??1?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@XZ

; 187  : 				this->m_mapSpawnTime.insert(std::pair<int,vector<CASTLEDEEP_SPAWNTIME> >(iAssultType,vtTempSpawnTime)); //HermeX Fix

  0065d	8d 45 bc	 lea	 eax, DWORD PTR _vtTempSpawnTime$231851[ebp]
  00660	50		 push	 eax
  00661	8d 4d b8	 lea	 ecx, DWORD PTR _iAssultType$231852[ebp]
  00664	51		 push	 ecx
  00665	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR $T238889[ebp]
  0066b	e8 00 00 00 00	 call	 ??$?0AAHAAV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@AAHAAV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@1@@Z ; std::pair<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::pair<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > ><int &,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > &>
  00670	89 85 fc fe ff
	ff		 mov	 DWORD PTR tv151[ebp], eax
  00676	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR tv151[ebp]
  0067c	89 95 f8 fe ff
	ff		 mov	 DWORD PTR tv357[ebp], edx
  00682	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00686	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR tv357[ebp]
  0068c	50		 push	 eax
  0068d	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR $T238890[ebp]
  00693	51		 push	 ecx
  00694	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00697	83 c1 40	 add	 ecx, 64			; 00000040H
  0069a	e8 00 00 00 00	 call	 ??$insert@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::insert<std::pair<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >
  0069f	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  006a3	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR $T238889[ebp]
  006a9	e8 00 00 00 00	 call	 ??1?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@XZ

; 188  : 
; 189  : 				this->m_vtAssultType.push_back(iAssultType);

  006ae	8d 45 b8	 lea	 eax, DWORD PTR _iAssultType$231852[ebp]
  006b1	50		 push	 eax
  006b2	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  006b5	83 c1 60	 add	 ecx, 96			; 00000060H
  006b8	e8 00 00 00 00	 call	 ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 190  : 				this->m_vtAssultTypeRate.push_back(iAssultRate);

  006bd	8d 45 b4	 lea	 eax, DWORD PTR _iAssultRate$231853[ebp]
  006c0	50		 push	 eax
  006c1	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  006c4	83 c1 70	 add	 ecx, 112		; 00000070H
  006c7	e8 00 00 00 00	 call	 ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 191  : 			}

  006cc	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  006d0	8d 4d bc	 lea	 ecx, DWORD PTR _vtTempSpawnTime$231851[ebp]
  006d3	e8 00 00 00 00	 call	 ??1?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@XZ ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::~vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >
  006d8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  006df	8d 4d cc	 lea	 ecx, DWORD PTR _vtTempMonsterInfo$231846[ebp]
  006e2	e8 00 00 00 00	 call	 ??1?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@XZ ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::~vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >
  006e7	e9 13 02 00 00	 jmp	 $LN3@Load
$LN10@Load:

; 192  : 			else if (type == 2)

  006ec	83 7d e4 02	 cmp	 DWORD PTR _type$[ebp], 2
  006f0	0f 85 cb 00 00
	00		 jne	 $LN7@Load

; 193  : 			{
; 194  : 				CASTLEDEEP_SPAWNTIME stSpawnTime;
; 195  : 				int iAssultType;
; 196  : 
; 197  : 				Token = GetToken();

  006f6	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  006fb	89 45 e8	 mov	 DWORD PTR _Token$[ebp], eax

; 198  : 				if (!strcmp("end",TokenString))

  006fe	68 00 00 00 00	 push	 OFFSET _TokenString
  00703	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  00708	e8 00 00 00 00	 call	 _strcmp
  0070d	83 c4 08	 add	 esp, 8
  00710	85 c0		 test	 eax, eax
  00712	75 05		 jne	 SHORT $LN6@Load

; 199  : 					break;

  00714	e9 eb 01 00 00	 jmp	 $LN14@Load
$LN6@Load:

; 200  : 
; 201  : 				iAssultType = (int)TokenNumber;

  00719	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0071f	e8 00 00 00 00	 call	 __ftol2_sse
  00724	89 45 a8	 mov	 DWORD PTR _iAssultType$232718[ebp], eax

; 202  : 
; 203  : 				Token = GetToken();

  00727	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0072c	89 45 e8	 mov	 DWORD PTR _Token$[ebp], eax

; 204  : 				stSpawnTime.m_iMonsterGroup = (int)TokenNumber;

  0072f	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00735	e8 00 00 00 00	 call	 __ftol2_sse
  0073a	89 45 ac	 mov	 DWORD PTR _stSpawnTime$232717[ebp], eax

; 205  : 
; 206  : 				Token = GetToken();

  0073d	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00742	89 45 e8	 mov	 DWORD PTR _Token$[ebp], eax

; 207  : 				stSpawnTime.m_iMonsterSpawnMinute = (int)TokenNumber;

  00745	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0074b	e8 00 00 00 00	 call	 __ftol2_sse
  00750	89 45 b0	 mov	 DWORD PTR _stSpawnTime$232717[ebp+4], eax

; 208  : 
; 209  : 				EnterCriticalSection(&this->m_critEventData);

  00753	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00756	05 90 00 00 00	 add	 eax, 144		; 00000090H
  0075b	50		 push	 eax
  0075c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 210  : 
; 211  : 				std::map<int,vector<CASTLEDEEP_SPAWNTIME > >::iterator it = this->m_mapSpawnTime.find(iAssultType); //HermeX Fix

  00762	8d 45 a8	 lea	 eax, DWORD PTR _iAssultType$232718[ebp]
  00765	50		 push	 eax
  00766	8d 4d a4	 lea	 ecx, DWORD PTR _it$232740[ebp]
  00769	51		 push	 ecx
  0076a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0076d	83 c1 40	 add	 ecx, 64			; 00000040H
  00770	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::find

; 212  : 
; 213  : 				if (it != this->m_mapSpawnTime.end())

  00775	8d 85 38 ff ff
	ff		 lea	 eax, DWORD PTR $T238891[ebp]
  0077b	50		 push	 eax
  0077c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0077f	83 c1 40	 add	 ecx, 64			; 00000040H
  00782	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::end
  00787	50		 push	 eax
  00788	8d 4d a4	 lea	 ecx, DWORD PTR _it$232740[ebp]
  0078b	e8 00 00 00 00	 call	 ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::operator!=
  00790	0f b6 c8	 movzx	 ecx, al
  00793	85 c9		 test	 ecx, ecx
  00795	74 16		 je	 SHORT $LN5@Load

; 214  : 				{
; 215  : 					it->second.push_back(stSpawnTime);

  00797	8d 45 ac	 lea	 eax, DWORD PTR _stSpawnTime$232717[ebp]
  0079a	50		 push	 eax
  0079b	8d 4d a4	 lea	 ecx, DWORD PTR _it$232740[ebp]
  0079e	e8 00 00 00 00	 call	 ??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::operator->
  007a3	83 c0 04	 add	 eax, 4
  007a6	8b c8		 mov	 ecx, eax
  007a8	e8 00 00 00 00	 call	 ?push_back@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAEXABUCASTLEDEEP_SPAWNTIME@@@Z ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::push_back
$LN5@Load:

; 216  : 				}
; 217  : 
; 218  : 				LeaveCriticalSection(&this->m_critEventData);

  007ad	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  007b0	05 90 00 00 00	 add	 eax, 144		; 00000090H
  007b5	50		 push	 eax
  007b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  007bc	e9 3e 01 00 00	 jmp	 $LN3@Load
$LN7@Load:

; 219  : 			}
; 220  : 			else if (type == 3)

  007c1	83 7d e4 03	 cmp	 DWORD PTR _type$[ebp], 3
  007c5	0f 85 34 01 00
	00		 jne	 $LN3@Load

; 221  : 			{
; 222  : 				CASTLEDEEP_MONSTERINFO stMonsterInfo;
; 223  : 				int iAssultType;
; 224  : 
; 225  : 				Token = GetToken();

  007cb	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  007d0	89 45 e8	 mov	 DWORD PTR _Token$[ebp], eax

; 226  : 				if (!strcmp("end",TokenString))

  007d3	68 00 00 00 00	 push	 OFFSET _TokenString
  007d8	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  007dd	e8 00 00 00 00	 call	 _strcmp
  007e2	83 c4 08	 add	 esp, 8
  007e5	85 c0		 test	 eax, eax
  007e7	75 05		 jne	 SHORT $LN2@Load

; 227  : 					break;

  007e9	e9 16 01 00 00	 jmp	 $LN14@Load
$LN2@Load:

; 228  : 
; 229  : 				iAssultType = (int)TokenNumber;

  007ee	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  007f4	e8 00 00 00 00	 call	 __ftol2_sse
  007f9	89 45 84	 mov	 DWORD PTR _iAssultType$232747[ebp], eax

; 230  : 
; 231  : 				Token = GetToken();

  007fc	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00801	89 45 e8	 mov	 DWORD PTR _Token$[ebp], eax

; 232  : 				stMonsterInfo.m_iMonsterGroup = (int)TokenNumber;

  00804	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0080a	e8 00 00 00 00	 call	 __ftol2_sse
  0080f	89 45 88	 mov	 DWORD PTR _stMonsterInfo$232746[ebp], eax

; 233  : 
; 234  : 				Token = GetToken();

  00812	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00817	89 45 e8	 mov	 DWORD PTR _Token$[ebp], eax

; 235  : 				stMonsterInfo.m_iMonsterType = (int)TokenNumber;

  0081a	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00820	e8 00 00 00 00	 call	 __ftol2_sse
  00825	89 45 8c	 mov	 DWORD PTR _stMonsterInfo$232746[ebp+4], eax

; 236  : 
; 237  : 				Token = GetToken();

  00828	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0082d	89 45 e8	 mov	 DWORD PTR _Token$[ebp], eax

; 238  : 				stMonsterInfo.m_iMonsterNumber = (int)TokenNumber;

  00830	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00836	e8 00 00 00 00	 call	 __ftol2_sse
  0083b	89 45 90	 mov	 DWORD PTR _stMonsterInfo$232746[ebp+8], eax

; 239  : 
; 240  : 				Token = GetToken();

  0083e	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00843	89 45 e8	 mov	 DWORD PTR _Token$[ebp], eax

; 241  : 				stMonsterInfo.m_iSX = (int)TokenNumber;

  00846	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0084c	e8 00 00 00 00	 call	 __ftol2_sse
  00851	89 45 94	 mov	 DWORD PTR _stMonsterInfo$232746[ebp+12], eax

; 242  : 
; 243  : 				Token = GetToken();

  00854	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00859	89 45 e8	 mov	 DWORD PTR _Token$[ebp], eax

; 244  : 				stMonsterInfo.m_iSY = (int)TokenNumber;

  0085c	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00862	e8 00 00 00 00	 call	 __ftol2_sse
  00867	89 45 98	 mov	 DWORD PTR _stMonsterInfo$232746[ebp+16], eax

; 245  : 
; 246  : 				Token = GetToken();

  0086a	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0086f	89 45 e8	 mov	 DWORD PTR _Token$[ebp], eax

; 247  : 				stMonsterInfo.m_iDX = (int)TokenNumber;

  00872	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00878	e8 00 00 00 00	 call	 __ftol2_sse
  0087d	89 45 9c	 mov	 DWORD PTR _stMonsterInfo$232746[ebp+20], eax

; 248  : 
; 249  : 				Token = GetToken();

  00880	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00885	89 45 e8	 mov	 DWORD PTR _Token$[ebp], eax

; 250  : 				stMonsterInfo.m_iDY = (int)TokenNumber;

  00888	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0088e	e8 00 00 00 00	 call	 __ftol2_sse
  00893	89 45 a0	 mov	 DWORD PTR _stMonsterInfo$232746[ebp+24], eax

; 251  : 
; 252  : 				EnterCriticalSection(&this->m_critEventData);

  00896	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00899	05 90 00 00 00	 add	 eax, 144		; 00000090H
  0089e	50		 push	 eax
  0089f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 253  : 
; 254  : 				std::map<int,vector<CASTLEDEEP_MONSTERINFO > >::iterator it = this->m_mapMonsterInfo.find(iAssultType); //HermeX Fix

  008a5	8d 45 84	 lea	 eax, DWORD PTR _iAssultType$232747[ebp]
  008a8	50		 push	 eax
  008a9	8d 4d 80	 lea	 ecx, DWORD PTR _it$232774[ebp]
  008ac	51		 push	 ecx
  008ad	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  008b0	83 c1 30	 add	 ecx, 48			; 00000030H
  008b3	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::find

; 255  : 
; 256  : 				if (it != this->m_mapMonsterInfo.end())

  008b8	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR $T238892[ebp]
  008be	50		 push	 eax
  008bf	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  008c2	83 c1 30	 add	 ecx, 48			; 00000030H
  008c5	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::end
  008ca	50		 push	 eax
  008cb	8d 4d 80	 lea	 ecx, DWORD PTR _it$232774[ebp]
  008ce	e8 00 00 00 00	 call	 ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::operator!=
  008d3	0f b6 c8	 movzx	 ecx, al
  008d6	85 c9		 test	 ecx, ecx
  008d8	74 16		 je	 SHORT $LN1@Load

; 257  : 				{
; 258  : 					it->second.push_back(stMonsterInfo);

  008da	8d 45 88	 lea	 eax, DWORD PTR _stMonsterInfo$232746[ebp]
  008dd	50		 push	 eax
  008de	8d 4d 80	 lea	 ecx, DWORD PTR _it$232774[ebp]
  008e1	e8 00 00 00 00	 call	 ??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::operator->
  008e6	83 c0 04	 add	 eax, 4
  008e9	8b c8		 mov	 ecx, eax
  008eb	e8 00 00 00 00	 call	 ?push_back@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAEXABUCASTLEDEEP_MONSTERINFO@@@Z ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::push_back
$LN1@Load:

; 259  : 				}
; 260  : 
; 261  : 				LeaveCriticalSection(&this->m_critEventData);

  008f0	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  008f3	05 90 00 00 00	 add	 eax, 144		; 00000090H
  008f8	50		 push	 eax
  008f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
$LN3@Load:

; 262  : 			}
; 263  : 		}

  008ff	e9 13 fc ff ff	 jmp	 $LN15@Load
$LN14@Load:

; 264  : 	}

  00904	e9 e0 fb ff ff	 jmp	 $LN18@Load
$LN17@Load:

; 265  : 
; 266  : 	fclose(SMDFile);

  00909	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0090e	50		 push	 eax
  0090f	e8 00 00 00 00	 call	 _fclose
  00914	83 c4 04	 add	 esp, 4

; 267  : 	LogAdd("%s file load!",lpszFileName);

  00917	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  0091a	50		 push	 eax
  0091b	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@
  00920	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00926	83 c4 08	 add	 esp, 8

; 268  : 	this->m_bHasData = TRUE;

  00929	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0092c	c7 40 08 01 00
	00 00		 mov	 DWORD PTR [eax+8], 1

; 269  : 	return true;

  00933	b8 01 00 00 00	 mov	 eax, 1
$LN21@Load:

; 270  : }

  00938	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0093b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00942	59		 pop	 ecx
  00943	5f		 pop	 edi
  00944	5e		 pop	 esi
  00945	5b		 pop	 ebx
  00946	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00949	33 cd		 xor	 ecx, ebp
  0094b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00950	8b e5		 mov	 esp, ebp
  00952	5d		 pop	 ebp
  00953	c2 04 00	 ret	 4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?Load@CCastleDeepEvent@@QAEHPAD@Z$0:
  000a4	8d 4d cc	 lea	 ecx, DWORD PTR _vtTempMonsterInfo$231846[ebp]
  000a7	e9 00 00 00 00	 jmp	 ??1?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@XZ ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::~vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >
__unwindfunclet$?Load@CCastleDeepEvent@@QAEHPAD@Z$1:
  000ac	8d 4d bc	 lea	 ecx, DWORD PTR _vtTempSpawnTime$231851[ebp]
  000af	e9 00 00 00 00	 jmp	 ??1?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@XZ ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::~vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >
__unwindfunclet$?Load@CCastleDeepEvent@@QAEHPAD@Z$2:
  000b4	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR $T238887[ebp]
  000ba	e9 00 00 00 00	 jmp	 ??1?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?Load@CCastleDeepEvent@@QAEHPAD@Z$3:
  000bf	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR $T238889[ebp]
  000c5	e9 00 00 00 00	 jmp	 ??1?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@XZ
__ehhandler$?Load@CCastleDeepEvent@@QAEHPAD@Z:
  000ca	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  000ce	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  000d1	8b 8a f4 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-268]
  000d7	33 c8		 xor	 ecx, eax
  000d9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000de	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  000e1	33 c8		 xor	 ecx, eax
  000e3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e8	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Load@CCastleDeepEvent@@QAEHPAD@Z
  000ed	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Load@CCastleDeepEvent@@QAEHPAD@Z ENDP			; CCastleDeepEvent::Load
PUBLIC	__$ArrayPad$
EXTRN	_isalnum:PROC
EXTRN	_isalpha:PROC
EXTRN	_atof:PROC
EXTRN	_isdigit:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_isspace:PROC
EXTRN	_fgetc:PROC
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_CurrentToken DD 01H DUP (?)
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\include\readscript.h
_BSS	ENDS
_TEXT	SEGMENT
tv90 = -180						; size = 4
_TempString$ = -112					; size = 100
_p$ = -12						; size = 4
_ch$ = -5						; size = 1
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken

; 24   : {

  00960	55		 push	 ebp
  00961	8b ec		 mov	 ebp, esp
  00963	81 ec b4 00 00
	00		 sub	 esp, 180		; 000000b4H
  00969	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0096e	33 c5		 xor	 eax, ebp
  00970	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00973	53		 push	 ebx
  00974	56		 push	 esi
  00975	57		 push	 edi

; 25   : 	char ch;
; 26   : 	char* p;
; 27   : 	char TempString[100];
; 28   : 
; 29   : 	TokenString[0]=0;

  00976	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _TokenString, 0
$LN31@GetToken:

; 30   : 
; 31   : 	do
; 32   : 	{
; 33   : 		if ((ch=fgetc(SMDFile)) == -1)

  0097d	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00982	50		 push	 eax
  00983	e8 00 00 00 00	 call	 _fgetc
  00988	83 c4 04	 add	 esp, 4
  0098b	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0098e	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00992	83 f9 ff	 cmp	 ecx, -1
  00995	75 0c		 jne	 SHORT $LN28@GetToken

; 34   : 		{
; 35   : 			return END;	// End of FILE (EOF)

  00997	b8 02 00 00 00	 mov	 eax, 2
  0099c	e9 f7 02 00 00	 jmp	 $LN32@GetToken

; 36   : 		}
; 37   : 		else

  009a1	eb 5b		 jmp	 SHORT $LN22@GetToken
$LN28@GetToken:

; 38   : 		{	
; 39   : 			if (ch=='/')		// this is /

  009a3	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  009a7	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  009aa	75 52		 jne	 SHORT $LN22@GetToken

; 40   : 			{
; 41   : 				if((ch=fgetc(SMDFile)) == '/')

  009ac	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  009b1	50		 push	 eax
  009b2	e8 00 00 00 00	 call	 _fgetc
  009b7	83 c4 04	 add	 esp, 4
  009ba	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  009bd	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  009c1	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  009c4	75 38		 jne	 SHORT $LN22@GetToken
$LN24@GetToken:

; 42   : 				{
; 43   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  009c6	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  009ca	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  009cd	74 1c		 je	 SHORT $LN23@GetToken
  009cf	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  009d3	83 f8 ff	 cmp	 eax, -1
  009d6	74 13		 je	 SHORT $LN23@GetToken

; 44   : 					{
; 45   : 						ch=fgetc(SMDFile);

  009d8	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  009dd	50		 push	 eax
  009de	e8 00 00 00 00	 call	 _fgetc
  009e3	83 c4 04	 add	 esp, 4
  009e6	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al

; 46   : 					}

  009e9	eb db		 jmp	 SHORT $LN24@GetToken
$LN23@GetToken:

; 47   : 	
; 48   : 					if (ch == -1)

  009eb	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  009ef	83 f8 ff	 cmp	 eax, -1
  009f2	75 0a		 jne	 SHORT $LN22@GetToken

; 49   : 					{
; 50   : 						return END;	// End of FILE

  009f4	b8 02 00 00 00	 mov	 eax, 2
  009f9	e9 9a 02 00 00	 jmp	 $LN32@GetToken
$LN22@GetToken:

; 51   : 					}
; 52   : 				}
; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : 	while (isspace(ch) != 0);

  009fe	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00a02	50		 push	 eax
  00a03	e8 00 00 00 00	 call	 _isspace
  00a08	83 c4 04	 add	 esp, 4
  00a0b	85 c0		 test	 eax, eax
  00a0d	0f 85 6a ff ff
	ff		 jne	 $LN31@GetToken

; 57   : 
; 58   : 	
; 59   : 	switch(ch)

  00a13	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00a17	89 85 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], eax
  00a1d	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR tv90[ebp]
  00a23	83 e9 22	 sub	 ecx, 34			; 00000022H
  00a26	89 8d 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], ecx
  00a2c	83 bd 4c ff ff
	ff 5b		 cmp	 DWORD PTR tv90[ebp], 91	; 0000005bH
  00a33	0f 87 a3 01 00
	00		 ja	 $LN6@GetToken
  00a39	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR tv90[ebp]
  00a3f	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN34@GetToken[edx]
  00a46	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN35@GetToken[eax*4]
$LN19@GetToken:

; 60   : 	{
; 61   : 
; 62   : 	case 0x23:	// #
; 63   : 		return CurrentToken=COMMAND;

  00a4d	c7 05 00 00 00
	00 23 00 00 00	 mov	 DWORD PTR _CurrentToken, 35 ; 00000023H
  00a57	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00a5c	e9 37 02 00 00	 jmp	 $LN32@GetToken

; 64   : 		break;

  00a61	e9 30 02 00 00	 jmp	 $LN20@GetToken
$LN18@GetToken:

; 65   : 	
; 66   : 	case 0x3B:	// ;
; 67   : 		return CurrentToken=SEMICOLON;

  00a66	c7 05 00 00 00
	00 3b 00 00 00	 mov	 DWORD PTR _CurrentToken, 59 ; 0000003bH
  00a70	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00a75	e9 1e 02 00 00	 jmp	 $LN32@GetToken

; 68   : 		break;

  00a7a	e9 17 02 00 00	 jmp	 $LN20@GetToken
$LN17@GetToken:

; 69   : 	
; 70   : 	case 0x2C:	// ,
; 71   : 
; 72   : 		return CurrentToken=COMMA;

  00a7f	c7 05 00 00 00
	00 2c 00 00 00	 mov	 DWORD PTR _CurrentToken, 44 ; 0000002cH
  00a89	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00a8e	e9 05 02 00 00	 jmp	 $LN32@GetToken

; 73   : 		break;

  00a93	e9 fe 01 00 00	 jmp	 $LN20@GetToken
$LN16@GetToken:

; 74   : 	
; 75   : 	case 0x7B:	// {
; 76   : 		return CurrentToken = LP;

  00a98	c7 05 00 00 00
	00 7b 00 00 00	 mov	 DWORD PTR _CurrentToken, 123 ; 0000007bH
  00aa2	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00aa7	e9 ec 01 00 00	 jmp	 $LN32@GetToken

; 77   : 		break;

  00aac	e9 e5 01 00 00	 jmp	 $LN20@GetToken
$LN15@GetToken:

; 78   : 
; 79   : 	case 0x7D:	// }
; 80   : 		return CurrentToken = RP;

  00ab1	c7 05 00 00 00
	00 7d 00 00 00	 mov	 DWORD PTR _CurrentToken, 125 ; 0000007dH
  00abb	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00ac0	e9 d3 01 00 00	 jmp	 $LN32@GetToken

; 81   : 		break;

  00ac5	e9 cc 01 00 00	 jmp	 $LN20@GetToken
$LN14@GetToken:

; 82   : 	// Nice Index Table :)	by Deathway
; 83   : 	// Numbers Case
; 84   : 	case 0x2D:	//-
; 85   : 	case 0x2E:	//.
; 86   : 	case '0':	//0
; 87   : 	case '1':	//1
; 88   : 	case '2':	//2
; 89   : 	case '3':	//3
; 90   : 	case '4':	//4		
; 91   : 	case '5':	//5
; 92   : 	case '6':	//6
; 93   : 	case '7':	//7
; 94   : 	case '8':	//8
; 95   : 	case '9':	//9
; 96   : 		ungetc(ch, SMDFile);

  00aca	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00acf	50		 push	 eax
  00ad0	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00ad4	51		 push	 ecx
  00ad5	e8 00 00 00 00	 call	 _ungetc
  00ada	83 c4 08	 add	 esp, 8

; 97   : 		p = TempString;

  00add	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  00ae0	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN13@GetToken:

; 98   : 		
; 99   : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  00ae3	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00ae8	50		 push	 eax
  00ae9	e8 00 00 00 00	 call	 _getc
  00aee	83 c4 04	 add	 esp, 4
  00af1	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00af4	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00af8	83 f9 ff	 cmp	 ecx, -1
  00afb	74 36		 je	 SHORT $LN12@GetToken
  00afd	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00b01	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  00b04	74 1a		 je	 SHORT $LN11@GetToken
  00b06	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00b0a	50		 push	 eax
  00b0b	e8 00 00 00 00	 call	 _isdigit
  00b10	83 c4 04	 add	 esp, 4
  00b13	85 c0		 test	 eax, eax
  00b15	75 09		 jne	 SHORT $LN11@GetToken
  00b17	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00b1b	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00b1e	75 13		 jne	 SHORT $LN12@GetToken
$LN11@GetToken:

; 100  : 		{
; 101  : 			*p = ch;	// Construct a String

  00b20	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00b23	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00b26	88 08		 mov	 BYTE PTR [eax], cl

; 102  : 			p++;

  00b28	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00b2b	83 c0 01	 add	 eax, 1
  00b2e	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 103  : 		}		

  00b31	eb b0		 jmp	 SHORT $LN13@GetToken
$LN12@GetToken:

; 104  : 		*p = 0;

  00b33	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00b36	c6 00 00	 mov	 BYTE PTR [eax], 0

; 105  : 		TokenNumber = atof( TempString);	// Select the first Byte as Main ID

  00b39	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  00b3c	50		 push	 eax
  00b3d	e8 00 00 00 00	 call	 _atof
  00b42	83 c4 04	 add	 esp, 4
  00b45	d9 1d 00 00 00
	00		 fstp	 DWORD PTR _TokenNumber

; 106  : 		return CurrentToken  = NUMBER ;

  00b4b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CurrentToken, 1
  00b55	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00b5a	e9 39 01 00 00	 jmp	 $LN32@GetToken

; 107  : 		break;

  00b5f	e9 32 01 00 00	 jmp	 $LN20@GetToken
$LN10@GetToken:

; 108  : 
; 109  : 	case '\"':	// "	String Case
; 110  : 		p=&TokenString[0];

  00b64	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString
$LN9@GetToken:

; 111  : 		
; 112  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  00b6b	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00b70	50		 push	 eax
  00b71	e8 00 00 00 00	 call	 _getc
  00b76	83 c4 04	 add	 esp, 4
  00b79	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00b7c	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00b80	83 f9 ff	 cmp	 ecx, -1
  00b83	74 1c		 je	 SHORT $LN8@GetToken
  00b85	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00b89	83 f8 22	 cmp	 eax, 34			; 00000022H
  00b8c	74 13		 je	 SHORT $LN8@GetToken

; 113  : 		{
; 114  : 			*p = ch;

  00b8e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00b91	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00b94	88 08		 mov	 BYTE PTR [eax], cl

; 115  : 			p++;

  00b96	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00b99	83 c0 01	 add	 eax, 1
  00b9c	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 116  : 		}

  00b9f	eb ca		 jmp	 SHORT $LN9@GetToken
$LN8@GetToken:

; 117  : 		if (ch != 0x22 )

  00ba1	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00ba5	83 f8 22	 cmp	 eax, 34			; 00000022H
  00ba8	74 13		 je	 SHORT $LN7@GetToken

; 118  : 		{
; 119  : 			ungetc(ch, SMDFile);

  00baa	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00baf	50		 push	 eax
  00bb0	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00bb4	51		 push	 ecx
  00bb5	e8 00 00 00 00	 call	 _ungetc
  00bba	83 c4 08	 add	 esp, 8
$LN7@GetToken:

; 120  : 		}
; 121  : 		*p = 0;

  00bbd	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00bc0	c6 00 00	 mov	 BYTE PTR [eax], 0

; 122  : 		return CurrentToken = NAME;

  00bc3	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0
  00bcd	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00bd2	e9 c1 00 00 00	 jmp	 $LN32@GetToken

; 123  : 		break;

  00bd7	e9 ba 00 00 00	 jmp	 $LN20@GetToken
$LN6@GetToken:

; 124  : 
; 125  : 	default:	// Others
; 126  : 		if (isalpha(ch))

  00bdc	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00be0	50		 push	 eax
  00be1	e8 00 00 00 00	 call	 _isalpha
  00be6	83 c4 04	 add	 esp, 4
  00be9	85 c0		 test	 eax, eax
  00beb	0f 84 94 00 00
	00		 je	 $LN5@GetToken

; 127  : 		{
; 128  : 			p=&TokenString[0];

  00bf1	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString

; 129  : 			*p=ch;

  00bf8	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00bfb	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00bfe	88 08		 mov	 BYTE PTR [eax], cl

; 130  : 			p++;

  00c00	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00c03	83 c0 01	 add	 eax, 1
  00c06	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN4@GetToken:

; 131  : 
; 132  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  00c09	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00c0e	50		 push	 eax
  00c0f	e8 00 00 00 00	 call	 _getc
  00c14	83 c4 04	 add	 esp, 4
  00c17	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00c1a	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00c1e	83 f9 ff	 cmp	 ecx, -1
  00c21	74 36		 je	 SHORT $LN3@GetToken
  00c23	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00c27	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  00c2a	74 1a		 je	 SHORT $LN2@GetToken
  00c2c	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00c30	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  00c33	74 11		 je	 SHORT $LN2@GetToken
  00c35	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00c39	50		 push	 eax
  00c3a	e8 00 00 00 00	 call	 _isalnum
  00c3f	83 c4 04	 add	 esp, 4
  00c42	85 c0		 test	 eax, eax
  00c44	74 13		 je	 SHORT $LN3@GetToken
$LN2@GetToken:

; 133  : 			{
; 134  : 				*p=ch;

  00c46	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00c49	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00c4c	88 08		 mov	 BYTE PTR [eax], cl

; 135  : 				p++;

  00c4e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00c51	83 c0 01	 add	 eax, 1
  00c54	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 136  : 				
; 137  : 			}

  00c57	eb b0		 jmp	 SHORT $LN4@GetToken
$LN3@GetToken:

; 138  : 
; 139  : 			ungetc(ch, SMDFile);

  00c59	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00c5e	50		 push	 eax
  00c5f	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00c63	51		 push	 ecx
  00c64	e8 00 00 00 00	 call	 _ungetc
  00c69	83 c4 08	 add	 esp, 8

; 140  : 			*p=0;

  00c6c	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00c6f	c6 00 00	 mov	 BYTE PTR [eax], 0

; 141  : 			CurrentToken=NAME;

  00c72	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0

; 142  : 			return CurrentToken;

  00c7c	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00c81	eb 15		 jmp	 SHORT $LN32@GetToken

; 143  : 		}
; 144  : 		else

  00c83	eb 11		 jmp	 SHORT $LN1@GetToken
$LN5@GetToken:

; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'

  00c85	c7 05 00 00 00
	00 3c 00 00 00	 mov	 DWORD PTR _CurrentToken, 60 ; 0000003cH
  00c8f	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00c94	eb 02		 jmp	 SHORT $LN32@GetToken
$LN1@GetToken:
$LN20@GetToken:

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;

  00c96	33 c0		 xor	 eax, eax
$LN32@GetToken:

; 153  : }

  00c98	5f		 pop	 edi
  00c99	5e		 pop	 esi
  00c9a	5b		 pop	 ebx
  00c9b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00c9e	33 cd		 xor	 ecx, ebp
  00ca0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00ca5	8b e5		 mov	 esp, ebp
  00ca7	5d		 pop	 ebp
  00ca8	c3		 ret	 0
  00ca9	8d 49 00	 npad	 3
$LN35@GetToken:
  00cac	00 00 00 00	 DD	 $LN10@GetToken
  00cb0	00 00 00 00	 DD	 $LN19@GetToken
  00cb4	00 00 00 00	 DD	 $LN17@GetToken
  00cb8	00 00 00 00	 DD	 $LN14@GetToken
  00cbc	00 00 00 00	 DD	 $LN18@GetToken
  00cc0	00 00 00 00	 DD	 $LN16@GetToken
  00cc4	00 00 00 00	 DD	 $LN15@GetToken
  00cc8	00 00 00 00	 DD	 $LN6@GetToken
$LN34@GetToken:
  00ccc	00		 DB	 0
  00ccd	01		 DB	 1
  00cce	07		 DB	 7
  00ccf	07		 DB	 7
  00cd0	07		 DB	 7
  00cd1	07		 DB	 7
  00cd2	07		 DB	 7
  00cd3	07		 DB	 7
  00cd4	07		 DB	 7
  00cd5	07		 DB	 7
  00cd6	02		 DB	 2
  00cd7	03		 DB	 3
  00cd8	03		 DB	 3
  00cd9	07		 DB	 7
  00cda	03		 DB	 3
  00cdb	03		 DB	 3
  00cdc	03		 DB	 3
  00cdd	03		 DB	 3
  00cde	03		 DB	 3
  00cdf	03		 DB	 3
  00ce0	03		 DB	 3
  00ce1	03		 DB	 3
  00ce2	03		 DB	 3
  00ce3	03		 DB	 3
  00ce4	07		 DB	 7
  00ce5	04		 DB	 4
  00ce6	07		 DB	 7
  00ce7	07		 DB	 7
  00ce8	07		 DB	 7
  00ce9	07		 DB	 7
  00cea	07		 DB	 7
  00ceb	07		 DB	 7
  00cec	07		 DB	 7
  00ced	07		 DB	 7
  00cee	07		 DB	 7
  00cef	07		 DB	 7
  00cf0	07		 DB	 7
  00cf1	07		 DB	 7
  00cf2	07		 DB	 7
  00cf3	07		 DB	 7
  00cf4	07		 DB	 7
  00cf5	07		 DB	 7
  00cf6	07		 DB	 7
  00cf7	07		 DB	 7
  00cf8	07		 DB	 7
  00cf9	07		 DB	 7
  00cfa	07		 DB	 7
  00cfb	07		 DB	 7
  00cfc	07		 DB	 7
  00cfd	07		 DB	 7
  00cfe	07		 DB	 7
  00cff	07		 DB	 7
  00d00	07		 DB	 7
  00d01	07		 DB	 7
  00d02	07		 DB	 7
  00d03	07		 DB	 7
  00d04	07		 DB	 7
  00d05	07		 DB	 7
  00d06	07		 DB	 7
  00d07	07		 DB	 7
  00d08	07		 DB	 7
  00d09	07		 DB	 7
  00d0a	07		 DB	 7
  00d0b	07		 DB	 7
  00d0c	07		 DB	 7
  00d0d	07		 DB	 7
  00d0e	07		 DB	 7
  00d0f	07		 DB	 7
  00d10	07		 DB	 7
  00d11	07		 DB	 7
  00d12	07		 DB	 7
  00d13	07		 DB	 7
  00d14	07		 DB	 7
  00d15	07		 DB	 7
  00d16	07		 DB	 7
  00d17	07		 DB	 7
  00d18	07		 DB	 7
  00d19	07		 DB	 7
  00d1a	07		 DB	 7
  00d1b	07		 DB	 7
  00d1c	07		 DB	 7
  00d1d	07		 DB	 7
  00d1e	07		 DB	 7
  00d1f	07		 DB	 7
  00d20	07		 DB	 7
  00d21	07		 DB	 7
  00d22	07		 DB	 7
  00d23	07		 DB	 7
  00d24	07		 DB	 7
  00d25	05		 DB	 5
  00d26	07		 DB	 7
  00d27	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
PUBLIC	??1?$_Pair_base@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@XZ ; std::_Pair_base<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::~_Pair_base<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ??1?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@XZ PROC ; std::pair<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::~pair<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1?$_Pair_base@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@XZ
  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@XZ ENDP ; std::pair<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::~pair<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >
_TEXT	ENDS
PUBLIC	??1?$_Pair_base@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@XZ ; std::_Pair_base<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::~_Pair_base<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ??1?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@XZ PROC ; std::pair<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::~pair<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1?$_Pair_base@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@XZ
  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@XZ ENDP ; std::pair<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::~pair<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??1?$_Pair_base@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Pair_base@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Pair_base<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::~_Pair_base<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 04	 add	 ecx, 4
  00012	e8 00 00 00 00	 call	 ??1?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@XZ ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::~vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >
  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??1?$_Pair_base@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Pair_base<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::~_Pair_base<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??1?$_Pair_base@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Pair_base@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Pair_base<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::~_Pair_base<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 04	 add	 ecx, 4
  00012	e8 00 00 00 00	 call	 ??1?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@XZ ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::~vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >
  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??1?$_Pair_base@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Pair_base<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::~_Pair_base<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >
_TEXT	ENDS
PUBLIC	??_C@_0EM@HOLJDKOB@?$FLCastleDeep?5Event?$FN?5Sync?5Start?5Ti@ ; `string'
PUBLIC	??C?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QBEPAUCASTLEDEEP_EVENTTIME@@XZ ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::operator->
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::operator!=
PUBLIC	?end@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@2@XZ ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::end
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::operator++
PUBLIC	?begin@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@2@XZ ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::begin
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::_Vector_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >
PUBLIC	??_C@_0CJ@IPPMNGNJ@?$FLCastleDeep?5Event?$FN?5No?5Schedule?5T@ ; `string'
PUBLIC	?empty@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QBE_NXZ ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::empty
PUBLIC	__$ArrayPad$
PUBLIC	?CheckSync@CCastleDeepEvent@@QAEXXZ		; CCastleDeepEvent::CheckSync
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	__imp__GetLocalTime@4:PROC
EXTRN	?LogAddC@@3P6AXEPADZZA:DWORD			; LogAddC
;	COMDAT ??_C@_0EM@HOLJDKOB@?$FLCastleDeep?5Event?$FN?5Sync?5Start?5Ti@
; File d:\projects\exteam6.3\source\gameserver\gameserver\castledeepevent.cpp
CONST	SEGMENT
??_C@_0EM@HOLJDKOB@?$FLCastleDeep?5Event?$FN?5Sync?5Start?5Ti@ DB '[Castl'
	DB	'eDeep Event] Sync Start Time. [%d] min remain (START HOUR:%d,'
	DB	' MIN:%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@IPPMNGNJ@?$FLCastleDeep?5Event?$FN?5No?5Schedule?5T@
CONST	SEGMENT
??_C@_0CJ@IPPMNGNJ@?$FLCastleDeep?5Event?$FN?5No?5Schedule?5T@ DB '[Castl'
	DB	'eDeep Event] No Schedule Time Data', 00H	; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv200 = -140						; size = 4
$T238921 = -136						; size = 4
$T238922 = -132						; size = 4
$T238923 = -128						; size = 4
$T238924 = -124						; size = 4
$T238925 = -120						; size = 4
$T238926 = -116						; size = 4
_pRET$232983 = -48					; size = 4
_pRET$232969 = -44					; size = 4
_it$ = -40						; size = 4
_bTIME_CHANGED$ = -36					; size = 4
_iMIN_MINUTE$ = -32					; size = 4
_iMIN_HOUR$ = -28					; size = 4
_sysTime$ = -24						; size = 16
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?CheckSync@CCastleDeepEvent@@QAEXXZ PROC		; CCastleDeepEvent::CheckSync
; _this$ = ecx

; 273  : {

  00d30	55		 push	 ebp
  00d31	8b ec		 mov	 ebp, esp
  00d33	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  00d39	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00d3e	33 c5		 xor	 eax, ebp
  00d40	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00d43	53		 push	 ebx
  00d44	56		 push	 esi
  00d45	57		 push	 edi
  00d46	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 274  : 	if (this->m_vtEventTime.empty())

  00d49	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00d4c	83 c1 50	 add	 ecx, 80			; 00000050H
  00d4f	e8 00 00 00 00	 call	 ?empty@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QBE_NXZ ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::empty
  00d54	0f b6 c0	 movzx	 eax, al
  00d57	85 c0		 test	 eax, eax
  00d59	74 1f		 je	 SHORT $LN16@CheckSync

; 275  : 	{
; 276  : 		LogAddC(2,"[CastleDeep Event] No Schedule Time Data");

  00d5b	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@IPPMNGNJ@?$FLCastleDeep?5Event?$FN?5No?5Schedule?5T@
  00d60	6a 02		 push	 2
  00d62	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00d68	83 c4 08	 add	 esp, 8

; 277  : 		this->SetState(CD_STATE_NONE);

  00d6b	6a 00		 push	 0
  00d6d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00d70	e8 00 00 00 00	 call	 ?SetState@CCastleDeepEvent@@QAEXH@Z ; CCastleDeepEvent::SetState

; 278  : 		return;

  00d75	e9 80 02 00 00	 jmp	 $LN17@CheckSync
$LN16@CheckSync:

; 279  : 	}
; 280  : 
; 281  : 	_SYSTEMTIME sysTime;
; 282  : 	GetLocalTime(&sysTime);

  00d7a	8d 45 e8	 lea	 eax, DWORD PTR _sysTime$[ebp]
  00d7d	50		 push	 eax
  00d7e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocalTime@4

; 283  : 
; 284  : 	int iMIN_HOUR = 24;

  00d84	c7 45 e4 18 00
	00 00		 mov	 DWORD PTR _iMIN_HOUR$[ebp], 24 ; 00000018H

; 285  : 	int iMIN_MINUTE = 60;

  00d8b	c7 45 e0 3c 00
	00 00		 mov	 DWORD PTR _iMIN_MINUTE$[ebp], 60 ; 0000003cH

; 286  : 	int bTIME_CHANGED = 0;

  00d92	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _bTIME_CHANGED$[ebp], 0

; 287  : 
; 288  : 	std::vector<CASTLEDEEP_EVENTTIME>::iterator it;

  00d99	8d 4d d8	 lea	 ecx, DWORD PTR _it$[ebp]
  00d9c	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::_Vector_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >

; 289  : 
; 290  : 	for (it = this->m_vtEventTime.begin(); it != this->m_vtEventTime.end();it++)

  00da1	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR $T238921[ebp]
  00da7	50		 push	 eax
  00da8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00dab	83 c1 50	 add	 ecx, 80			; 00000050H
  00dae	e8 00 00 00 00	 call	 ?begin@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@2@XZ ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::begin
  00db3	8b 08		 mov	 ecx, DWORD PTR [eax]
  00db5	89 4d d8	 mov	 DWORD PTR _it$[ebp], ecx
  00db8	eb 11		 jmp	 SHORT $LN15@CheckSync
$LN14@CheckSync:
  00dba	6a 00		 push	 0
  00dbc	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR $T238922[ebp]
  00dc2	50		 push	 eax
  00dc3	8d 4d d8	 lea	 ecx, DWORD PTR _it$[ebp]
  00dc6	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::operator++
$LN15@CheckSync:
  00dcb	8d 45 80	 lea	 eax, DWORD PTR $T238923[ebp]
  00dce	50		 push	 eax
  00dcf	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00dd2	83 c1 50	 add	 ecx, 80			; 00000050H
  00dd5	e8 00 00 00 00	 call	 ?end@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@2@XZ ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::end
  00dda	50		 push	 eax
  00ddb	8d 4d d8	 lea	 ecx, DWORD PTR _it$[ebp]
  00dde	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::operator!=
  00de3	0f b6 c8	 movzx	 ecx, al
  00de6	85 c9		 test	 ecx, ecx
  00de8	74 7b		 je	 SHORT $LN13@CheckSync

; 291  : 	{
; 292  : 		std::vector<CASTLEDEEP_EVENTTIME>::iterator pRET = it;

  00dea	8b 45 d8	 mov	 eax, DWORD PTR _it$[ebp]
  00ded	89 45 d4	 mov	 DWORD PTR _pRET$232969[ebp], eax

; 293  : 
; 294  : 		if ((sysTime.wHour * 60 + sysTime.wMinute) < (pRET->m_iHour * 60 + pRET->m_iMinute))

  00df0	0f b7 75 f0	 movzx	 esi, WORD PTR _sysTime$[ebp+8]
  00df4	6b f6 3c	 imul	 esi, 60			; 0000003cH
  00df7	0f b7 45 f2	 movzx	 eax, WORD PTR _sysTime$[ebp+10]
  00dfb	03 f0		 add	 esi, eax
  00dfd	8d 4d d4	 lea	 ecx, DWORD PTR _pRET$232969[ebp]
  00e00	e8 00 00 00 00	 call	 ??C?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QBEPAUCASTLEDEEP_EVENTTIME@@XZ ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::operator->
  00e05	8b 38		 mov	 edi, DWORD PTR [eax]
  00e07	6b ff 3c	 imul	 edi, 60			; 0000003cH
  00e0a	8d 4d d4	 lea	 ecx, DWORD PTR _pRET$232969[ebp]
  00e0d	e8 00 00 00 00	 call	 ??C?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QBEPAUCASTLEDEEP_EVENTTIME@@XZ ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::operator->
  00e12	03 78 04	 add	 edi, DWORD PTR [eax+4]
  00e15	3b f7		 cmp	 esi, edi
  00e17	7d 47		 jge	 SHORT $LN12@CheckSync

; 295  : 		{
; 296  : 			if ((iMIN_HOUR * 60 + iMIN_MINUTE) > (pRET->m_iHour * 60 + pRET->m_iMinute))

  00e19	8b 75 e4	 mov	 esi, DWORD PTR _iMIN_HOUR$[ebp]
  00e1c	6b f6 3c	 imul	 esi, 60			; 0000003cH
  00e1f	03 75 e0	 add	 esi, DWORD PTR _iMIN_MINUTE$[ebp]
  00e22	8d 4d d4	 lea	 ecx, DWORD PTR _pRET$232969[ebp]
  00e25	e8 00 00 00 00	 call	 ??C?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QBEPAUCASTLEDEEP_EVENTTIME@@XZ ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::operator->
  00e2a	8b 38		 mov	 edi, DWORD PTR [eax]
  00e2c	6b ff 3c	 imul	 edi, 60			; 0000003cH
  00e2f	8d 4d d4	 lea	 ecx, DWORD PTR _pRET$232969[ebp]
  00e32	e8 00 00 00 00	 call	 ??C?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QBEPAUCASTLEDEEP_EVENTTIME@@XZ ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::operator->
  00e37	03 78 04	 add	 edi, DWORD PTR [eax+4]
  00e3a	3b f7		 cmp	 esi, edi
  00e3c	7e 22		 jle	 SHORT $LN12@CheckSync

; 297  : 			{
; 298  : 				bTIME_CHANGED = 1;

  00e3e	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _bTIME_CHANGED$[ebp], 1

; 299  : 				iMIN_HOUR = pRET->m_iHour;

  00e45	8d 4d d4	 lea	 ecx, DWORD PTR _pRET$232969[ebp]
  00e48	e8 00 00 00 00	 call	 ??C?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QBEPAUCASTLEDEEP_EVENTTIME@@XZ ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::operator->
  00e4d	8b 00		 mov	 eax, DWORD PTR [eax]
  00e4f	89 45 e4	 mov	 DWORD PTR _iMIN_HOUR$[ebp], eax

; 300  : 				iMIN_MINUTE = pRET->m_iMinute;

  00e52	8d 4d d4	 lea	 ecx, DWORD PTR _pRET$232969[ebp]
  00e55	e8 00 00 00 00	 call	 ??C?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QBEPAUCASTLEDEEP_EVENTTIME@@XZ ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::operator->
  00e5a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00e5d	89 45 e0	 mov	 DWORD PTR _iMIN_MINUTE$[ebp], eax
$LN12@CheckSync:

; 301  : 			}
; 302  : 		}
; 303  : 	}

  00e60	e9 55 ff ff ff	 jmp	 $LN14@CheckSync
$LN13@CheckSync:

; 304  : 
; 305  : 	if (bTIME_CHANGED == 0)

  00e65	83 7d dc 00	 cmp	 DWORD PTR _bTIME_CHANGED$[ebp], 0
  00e69	0f 85 a0 00 00
	00		 jne	 $LN10@CheckSync

; 306  : 	{
; 307  : 		for (it = this->m_vtEventTime.begin(),iMIN_HOUR = 24,iMIN_MINUTE = 60; it != this->m_vtEventTime.end();it++)

  00e6f	8d 45 84	 lea	 eax, DWORD PTR $T238924[ebp]
  00e72	50		 push	 eax
  00e73	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00e76	83 c1 50	 add	 ecx, 80			; 00000050H
  00e79	e8 00 00 00 00	 call	 ?begin@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@2@XZ ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::begin
  00e7e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00e80	89 4d d8	 mov	 DWORD PTR _it$[ebp], ecx
  00e83	c7 45 e4 18 00
	00 00		 mov	 DWORD PTR _iMIN_HOUR$[ebp], 24 ; 00000018H
  00e8a	c7 45 e0 3c 00
	00 00		 mov	 DWORD PTR _iMIN_MINUTE$[ebp], 60 ; 0000003cH
  00e91	eb 0e		 jmp	 SHORT $LN9@CheckSync
$LN8@CheckSync:
  00e93	6a 00		 push	 0
  00e95	8d 45 88	 lea	 eax, DWORD PTR $T238925[ebp]
  00e98	50		 push	 eax
  00e99	8d 4d d8	 lea	 ecx, DWORD PTR _it$[ebp]
  00e9c	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::operator++
$LN9@CheckSync:
  00ea1	8d 45 8c	 lea	 eax, DWORD PTR $T238926[ebp]
  00ea4	50		 push	 eax
  00ea5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00ea8	83 c1 50	 add	 ecx, 80			; 00000050H
  00eab	e8 00 00 00 00	 call	 ?end@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@2@XZ ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::end
  00eb0	50		 push	 eax
  00eb1	8d 4d d8	 lea	 ecx, DWORD PTR _it$[ebp]
  00eb4	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::operator!=
  00eb9	0f b6 c8	 movzx	 ecx, al
  00ebc	85 c9		 test	 ecx, ecx
  00ebe	74 4f		 je	 SHORT $LN10@CheckSync

; 308  : 		{
; 309  : 			std::vector<CASTLEDEEP_EVENTTIME>::iterator pRET = it;

  00ec0	8b 45 d8	 mov	 eax, DWORD PTR _it$[ebp]
  00ec3	89 45 d0	 mov	 DWORD PTR _pRET$232983[ebp], eax

; 310  : 
; 311  : 			if ( (iMIN_HOUR * 60 + iMIN_MINUTE) > (pRET->m_iHour * 60 + pRET->m_iMinute) )

  00ec6	8b 75 e4	 mov	 esi, DWORD PTR _iMIN_HOUR$[ebp]
  00ec9	6b f6 3c	 imul	 esi, 60			; 0000003cH
  00ecc	03 75 e0	 add	 esi, DWORD PTR _iMIN_MINUTE$[ebp]
  00ecf	8d 4d d0	 lea	 ecx, DWORD PTR _pRET$232983[ebp]
  00ed2	e8 00 00 00 00	 call	 ??C?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QBEPAUCASTLEDEEP_EVENTTIME@@XZ ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::operator->
  00ed7	8b 38		 mov	 edi, DWORD PTR [eax]
  00ed9	6b ff 3c	 imul	 edi, 60			; 0000003cH
  00edc	8d 4d d0	 lea	 ecx, DWORD PTR _pRET$232983[ebp]
  00edf	e8 00 00 00 00	 call	 ??C?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QBEPAUCASTLEDEEP_EVENTTIME@@XZ ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::operator->
  00ee4	03 78 04	 add	 edi, DWORD PTR [eax+4]
  00ee7	3b f7		 cmp	 esi, edi
  00ee9	7e 22		 jle	 SHORT $LN6@CheckSync

; 312  : 			{
; 313  : 				bTIME_CHANGED = 2;

  00eeb	c7 45 dc 02 00
	00 00		 mov	 DWORD PTR _bTIME_CHANGED$[ebp], 2

; 314  : 				iMIN_HOUR = pRET->m_iHour;

  00ef2	8d 4d d0	 lea	 ecx, DWORD PTR _pRET$232983[ebp]
  00ef5	e8 00 00 00 00	 call	 ??C?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QBEPAUCASTLEDEEP_EVENTTIME@@XZ ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::operator->
  00efa	8b 00		 mov	 eax, DWORD PTR [eax]
  00efc	89 45 e4	 mov	 DWORD PTR _iMIN_HOUR$[ebp], eax

; 315  : 				iMIN_MINUTE = pRET->m_iMinute;

  00eff	8d 4d d0	 lea	 ecx, DWORD PTR _pRET$232983[ebp]
  00f02	e8 00 00 00 00	 call	 ??C?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QBEPAUCASTLEDEEP_EVENTTIME@@XZ ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::operator->
  00f07	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00f0a	89 45 e0	 mov	 DWORD PTR _iMIN_MINUTE$[ebp], eax
$LN6@CheckSync:

; 316  : 			}
; 317  : 		}

  00f0d	eb 84		 jmp	 SHORT $LN8@CheckSync
$LN10@CheckSync:

; 318  : 	}
; 319  : 
; 320  : 	switch(bTIME_CHANGED)

  00f0f	8b 45 dc	 mov	 eax, DWORD PTR _bTIME_CHANGED$[ebp]
  00f12	89 85 74 ff ff
	ff		 mov	 DWORD PTR tv200[ebp], eax
  00f18	83 bd 74 ff ff
	ff 01		 cmp	 DWORD PTR tv200[ebp], 1
  00f1f	74 0b		 je	 SHORT $LN3@CheckSync
  00f21	83 bd 74 ff ff
	ff 02		 cmp	 DWORD PTR tv200[ebp], 2
  00f28	74 3c		 je	 SHORT $LN2@CheckSync
  00f2a	eb 77		 jmp	 SHORT $LN1@CheckSync
$LN3@CheckSync:

; 321  : 	{
; 322  : 	case 1:
; 323  : 		this->m_iTIME_MSEC_REMAIN = ( ( (iMIN_HOUR * 60) * 60 + iMIN_MINUTE * 60 ) - ( (sysTime.wHour * 60) * 60 + sysTime.wMinute * 60 + sysTime.wSecond) ) * 1000;

  00f2c	8b 45 e4	 mov	 eax, DWORD PTR _iMIN_HOUR$[ebp]
  00f2f	6b c0 3c	 imul	 eax, 60			; 0000003cH
  00f32	6b c0 3c	 imul	 eax, 60			; 0000003cH
  00f35	8b 4d e0	 mov	 ecx, DWORD PTR _iMIN_MINUTE$[ebp]
  00f38	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  00f3b	03 c1		 add	 eax, ecx
  00f3d	0f b7 55 f0	 movzx	 edx, WORD PTR _sysTime$[ebp+8]
  00f41	6b d2 3c	 imul	 edx, 60			; 0000003cH
  00f44	6b d2 3c	 imul	 edx, 60			; 0000003cH
  00f47	0f b7 4d f2	 movzx	 ecx, WORD PTR _sysTime$[ebp+10]
  00f4b	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  00f4e	03 d1		 add	 edx, ecx
  00f50	0f b7 4d f4	 movzx	 ecx, WORD PTR _sysTime$[ebp+12]
  00f54	03 d1		 add	 edx, ecx
  00f56	2b c2		 sub	 eax, edx
  00f58	69 c0 e8 03 00
	00		 imul	 eax, 1000		; 000003e8H
  00f5e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00f61	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 324  : 		break;

  00f64	eb 59		 jmp	 SHORT $LN4@CheckSync
$LN2@CheckSync:

; 325  : 	case 2:
; 326  : 		this->m_iTIME_MSEC_REMAIN = ( ( ((iMIN_HOUR + 24) * 60) * 60 + iMIN_MINUTE * 60 ) - ( (sysTime.wHour * 60) * 60 + sysTime.wMinute * 60 + sysTime.wSecond ) ) * 1000;

  00f66	8b 45 e4	 mov	 eax, DWORD PTR _iMIN_HOUR$[ebp]
  00f69	83 c0 18	 add	 eax, 24			; 00000018H
  00f6c	6b c0 3c	 imul	 eax, 60			; 0000003cH
  00f6f	6b c0 3c	 imul	 eax, 60			; 0000003cH
  00f72	8b 4d e0	 mov	 ecx, DWORD PTR _iMIN_MINUTE$[ebp]
  00f75	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  00f78	03 c1		 add	 eax, ecx
  00f7a	0f b7 55 f0	 movzx	 edx, WORD PTR _sysTime$[ebp+8]
  00f7e	6b d2 3c	 imul	 edx, 60			; 0000003cH
  00f81	6b d2 3c	 imul	 edx, 60			; 0000003cH
  00f84	0f b7 4d f2	 movzx	 ecx, WORD PTR _sysTime$[ebp+10]
  00f88	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  00f8b	03 d1		 add	 edx, ecx
  00f8d	0f b7 4d f4	 movzx	 ecx, WORD PTR _sysTime$[ebp+12]
  00f91	03 d1		 add	 edx, ecx
  00f93	2b c2		 sub	 eax, edx
  00f95	69 c0 e8 03 00
	00		 imul	 eax, 1000		; 000003e8H
  00f9b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00f9e	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 327  : 		break;

  00fa1	eb 1c		 jmp	 SHORT $LN4@CheckSync
$LN1@CheckSync:

; 328  : 	default:
; 329  : 		LogAddC(2,"[CastleDeep Event] No Schedule Time Data");

  00fa3	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@IPPMNGNJ@?$FLCastleDeep?5Event?$FN?5No?5Schedule?5T@
  00fa8	6a 02		 push	 2
  00faa	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00fb0	83 c4 08	 add	 esp, 8

; 330  : 		this->SetState(CD_STATE_NONE);

  00fb3	6a 00		 push	 0
  00fb5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00fb8	e8 00 00 00 00	 call	 ?SetState@CCastleDeepEvent@@QAEXH@Z ; CCastleDeepEvent::SetState

; 331  : 		return;

  00fbd	eb 3b		 jmp	 SHORT $LN17@CheckSync
$LN4@CheckSync:

; 332  : 	}
; 333  : 
; 334  : 	this->m_iTIME_TICK_COUNT = GetTickCount();

  00fbf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00fc5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00fc8	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 335  : 	LogAddTD("[CastleDeep Event] Sync Start Time. [%d] min remain (START HOUR:%d, MIN:%d)",
; 336  : 		this->m_iTIME_MSEC_REMAIN / 60000,iMIN_HOUR,iMIN_MINUTE);

  00fcb	8b 45 e0	 mov	 eax, DWORD PTR _iMIN_MINUTE$[ebp]
  00fce	50		 push	 eax
  00fcf	8b 4d e4	 mov	 ecx, DWORD PTR _iMIN_HOUR$[ebp]
  00fd2	51		 push	 ecx
  00fd3	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00fd6	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00fd9	99		 cdq
  00fda	b9 60 ea 00 00	 mov	 ecx, 60000		; 0000ea60H
  00fdf	f7 f9		 idiv	 ecx
  00fe1	50		 push	 eax
  00fe2	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@HOLJDKOB@?$FLCastleDeep?5Event?$FN?5Sync?5Start?5Ti@
  00fe7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00fed	83 c4 10	 add	 esp, 16			; 00000010H

; 337  : 	this->m_iTIME_NOTIFY_COUNT = 5;

  00ff0	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00ff3	c7 40 20 05 00
	00 00		 mov	 DWORD PTR [eax+32], 5
$LN17@CheckSync:

; 338  : }

  00ffa	5f		 pop	 edi
  00ffb	5e		 pop	 esi
  00ffc	5b		 pop	 ebx
  00ffd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01000	33 cd		 xor	 ecx, ebp
  01002	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01007	8b e5		 mov	 esp, ebp
  01009	5d		 pop	 ebp
  0100a	c3		 ret	 0
?CheckSync@CCastleDeepEvent@@QAEXXZ ENDP		; CCastleDeepEvent::CheckSync
_TEXT	ENDS
PUBLIC	?SetState_Playing@CCastleDeepEvent@@QAEXXZ	; CCastleDeepEvent::SetState_Playing
PUBLIC	?SetState_Closed@CCastleDeepEvent@@QAEXXZ	; CCastleDeepEvent::SetState_Closed
PUBLIC	?SetState_None@CCastleDeepEvent@@QAEXXZ		; CCastleDeepEvent::SetState_None
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv70 = -72						; size = 4
_this$ = -4						; size = 4
_iSTATE$ = 8						; size = 4
?SetState@CCastleDeepEvent@@QAEXH@Z PROC		; CCastleDeepEvent::SetState
; _this$ = ecx

; 341  : {

  01010	55		 push	 ebp
  01011	8b ec		 mov	 ebp, esp
  01013	83 ec 48	 sub	 esp, 72			; 00000048H
  01016	53		 push	 ebx
  01017	56		 push	 esi
  01018	57		 push	 edi
  01019	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 342  : 	if (m_iEVENT_STATE < 0 || m_iEVENT_STATE > 2)

  0101c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0101f	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  01023	7c 09		 jl	 SHORT $LN6@SetState
  01025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01028	83 78 24 02	 cmp	 DWORD PTR [eax+36], 2
  0102c	7e 02		 jle	 SHORT $LN7@SetState
$LN6@SetState:

; 343  : 		return;

  0102e	eb 42		 jmp	 SHORT $LN8@SetState
$LN7@SetState:

; 344  : 
; 345  : 	m_iEVENT_STATE = iSTATE;

  01030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01033	8b 4d 08	 mov	 ecx, DWORD PTR _iSTATE$[ebp]
  01036	89 48 24	 mov	 DWORD PTR [eax+36], ecx

; 346  : 
; 347  : 	switch(m_iEVENT_STATE)

  01039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0103c	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0103f	89 4d b8	 mov	 DWORD PTR tv70[ebp], ecx
  01042	83 7d b8 00	 cmp	 DWORD PTR tv70[ebp], 0
  01046	74 0e		 je	 SHORT $LN3@SetState
  01048	83 7d b8 01	 cmp	 DWORD PTR tv70[ebp], 1
  0104c	74 12		 je	 SHORT $LN2@SetState
  0104e	83 7d b8 02	 cmp	 DWORD PTR tv70[ebp], 2
  01052	74 16		 je	 SHORT $LN1@SetState
  01054	eb 1c		 jmp	 SHORT $LN8@SetState
$LN3@SetState:

; 348  : 	{
; 349  : 		case 0: SetState_None(); break;

  01056	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01059	e8 00 00 00 00	 call	 ?SetState_None@CCastleDeepEvent@@QAEXXZ ; CCastleDeepEvent::SetState_None
  0105e	eb 12		 jmp	 SHORT $LN8@SetState
$LN2@SetState:

; 350  : 		case 1: SetState_Closed(); break;

  01060	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01063	e8 00 00 00 00	 call	 ?SetState_Closed@CCastleDeepEvent@@QAEXXZ ; CCastleDeepEvent::SetState_Closed
  01068	eb 08		 jmp	 SHORT $LN8@SetState
$LN1@SetState:

; 351  : 		case 2: SetState_Playing(); break;

  0106a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0106d	e8 00 00 00 00	 call	 ?SetState_Playing@CCastleDeepEvent@@QAEXXZ ; CCastleDeepEvent::SetState_Playing
$LN8@SetState:

; 352  : 	}
; 353  : }

  01072	5f		 pop	 edi
  01073	5e		 pop	 esi
  01074	5b		 pop	 ebx
  01075	8b e5		 mov	 esp, ebp
  01077	5d		 pop	 ebp
  01078	c2 04 00	 ret	 4
?SetState@CCastleDeepEvent@@QAEXH@Z ENDP		; CCastleDeepEvent::SetState
; Function compile flags: /Odtp /ZI
_this$ = -4						; size = 4
?SetState_None@CCastleDeepEvent@@QAEXXZ PROC		; CCastleDeepEvent::SetState_None
; _this$ = ecx

; 356  : {

  01080	55		 push	 ebp
  01081	8b ec		 mov	 ebp, esp
  01083	83 ec 44	 sub	 esp, 68			; 00000044H
  01086	53		 push	 ebx
  01087	56		 push	 esi
  01088	57		 push	 edi
  01089	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 357  : 	this->StopEvent();

  0108c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0108f	e8 00 00 00 00	 call	 ?StopEvent@CCastleDeepEvent@@QAEXXZ ; CCastleDeepEvent::StopEvent

; 358  : }

  01094	5f		 pop	 edi
  01095	5e		 pop	 esi
  01096	5b		 pop	 ebx
  01097	8b e5		 mov	 esp, ebp
  01099	5d		 pop	 ebp
  0109a	c3		 ret	 0
?SetState_None@CCastleDeepEvent@@QAEXXZ ENDP		; CCastleDeepEvent::SetState_None
; Function compile flags: /Odtp /ZI
_this$ = -4						; size = 4
?SetState_Closed@CCastleDeepEvent@@QAEXXZ PROC		; CCastleDeepEvent::SetState_Closed
; _this$ = ecx

; 361  : {

  010a0	55		 push	 ebp
  010a1	8b ec		 mov	 ebp, esp
  010a3	83 ec 44	 sub	 esp, 68			; 00000044H
  010a6	53		 push	 ebx
  010a7	56		 push	 esi
  010a8	57		 push	 edi
  010a9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 362  : 	StopEvent();

  010ac	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  010af	e8 00 00 00 00	 call	 ?StopEvent@CCastleDeepEvent@@QAEXXZ ; CCastleDeepEvent::StopEvent

; 363  : 
; 364  : 	if (m_bDoEvent != 0)

  010b4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  010b7	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  010bb	74 0a		 je	 SHORT $LN2@SetState_C

; 365  : 	{
; 366  : 		CheckSync();

  010bd	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  010c0	e8 00 00 00 00	 call	 ?CheckSync@CCastleDeepEvent@@QAEXXZ ; CCastleDeepEvent::CheckSync

; 367  : 	}
; 368  : 	else

  010c5	eb 0a		 jmp	 SHORT $LN3@SetState_C
$LN2@SetState_C:

; 369  : 	{
; 370  : 		SetState(CD_STATE_NONE);

  010c7	6a 00		 push	 0
  010c9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  010cc	e8 00 00 00 00	 call	 ?SetState@CCastleDeepEvent@@QAEXH@Z ; CCastleDeepEvent::SetState
$LN3@SetState_C:

; 371  : 	}
; 372  : }

  010d1	5f		 pop	 edi
  010d2	5e		 pop	 esi
  010d3	5b		 pop	 ebx
  010d4	8b e5		 mov	 esp, ebp
  010d6	5d		 pop	 ebp
  010d7	c3		 ret	 0
?SetState_Closed@CCastleDeepEvent@@QAEXXZ ENDP		; CCastleDeepEvent::SetState_Closed
_TEXT	ENDS
PUBLIC	?ClearMonster@CCastleDeepEvent@@QAEXXZ		; CCastleDeepEvent::ClearMonster
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetState_Playing@CCastleDeepEvent@@QAEXXZ PROC		; CCastleDeepEvent::SetState_Playing
; _this$ = ecx

; 375  : {

  010e0	55		 push	 ebp
  010e1	8b ec		 mov	 ebp, esp
  010e3	83 ec 44	 sub	 esp, 68			; 00000044H
  010e6	53		 push	 ebx
  010e7	56		 push	 esi
  010e8	57		 push	 edi
  010e9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 376  : 	m_iTIME_MSEC_REMAIN = 0;

  010ec	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  010ef	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 377  : 	m_bCheckEnd = 0;

  010f6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  010f9	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 378  : 	m_uCheckEndTick = 0;

  01100	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01103	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 379  : 
; 380  : 	ClearMonster(); //Fixed

  0110a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0110d	e8 00 00 00 00	 call	 ?ClearMonster@CCastleDeepEvent@@QAEXXZ ; CCastleDeepEvent::ClearMonster

; 381  : 	StartEvent(); //Fixed 

  01112	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01115	e8 00 00 00 00	 call	 ?StartEvent@CCastleDeepEvent@@QAEXXZ ; CCastleDeepEvent::StartEvent

; 382  : }

  0111a	5f		 pop	 edi
  0111b	5e		 pop	 esi
  0111c	5b		 pop	 ebx
  0111d	8b e5		 mov	 esp, ebp
  0111f	5d		 pop	 ebp
  01120	c3		 ret	 0
?SetState_Playing@CCastleDeepEvent@@QAEXXZ ENDP		; CCastleDeepEvent::SetState_Playing
_TEXT	ENDS
PUBLIC	?ProcState_Playing@CCastleDeepEvent@@QAEXXZ	; CCastleDeepEvent::ProcState_Playing
PUBLIC	?ProcState_Closed@CCastleDeepEvent@@QAEXXZ	; CCastleDeepEvent::ProcState_Closed
PUBLIC	?ProcState_None@CCastleDeepEvent@@QAEXXZ	; CCastleDeepEvent::ProcState_None
PUBLIC	?Run@CCastleDeepEvent@@QAEXXZ			; CCastleDeepEvent::Run
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv67 = -72						; size = 4
_this$ = -4						; size = 4
?Run@CCastleDeepEvent@@QAEXXZ PROC			; CCastleDeepEvent::Run
; _this$ = ecx

; 385  : {

  01130	55		 push	 ebp
  01131	8b ec		 mov	 ebp, esp
  01133	83 ec 48	 sub	 esp, 72			; 00000048H
  01136	53		 push	 ebx
  01137	56		 push	 esi
  01138	57		 push	 edi
  01139	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 386  : 	if (m_bDoEvent)

  0113c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0113f	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  01143	74 39		 je	 SHORT $LN7@Run

; 387  : 	{
; 388  : 		switch(m_iEVENT_STATE)

  01145	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01148	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0114b	89 4d b8	 mov	 DWORD PTR tv67[ebp], ecx
  0114e	83 7d b8 00	 cmp	 DWORD PTR tv67[ebp], 0
  01152	74 0e		 je	 SHORT $LN3@Run
  01154	83 7d b8 01	 cmp	 DWORD PTR tv67[ebp], 1
  01158	74 12		 je	 SHORT $LN2@Run
  0115a	83 7d b8 02	 cmp	 DWORD PTR tv67[ebp], 2
  0115e	74 16		 je	 SHORT $LN1@Run
  01160	eb 1c		 jmp	 SHORT $LN7@Run
$LN3@Run:

; 389  : 		{
; 390  : 			case 0: ProcState_None(); break;

  01162	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01165	e8 00 00 00 00	 call	 ?ProcState_None@CCastleDeepEvent@@QAEXXZ ; CCastleDeepEvent::ProcState_None
  0116a	eb 12		 jmp	 SHORT $LN7@Run
$LN2@Run:

; 391  : 			case 1: ProcState_Closed(); break;

  0116c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0116f	e8 00 00 00 00	 call	 ?ProcState_Closed@CCastleDeepEvent@@QAEXXZ ; CCastleDeepEvent::ProcState_Closed
  01174	eb 08		 jmp	 SHORT $LN7@Run
$LN1@Run:

; 392  : 			case 2: ProcState_Playing(); break;

  01176	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01179	e8 00 00 00 00	 call	 ?ProcState_Playing@CCastleDeepEvent@@QAEXXZ ; CCastleDeepEvent::ProcState_Playing
$LN7@Run:

; 393  : 		}
; 394  : 	}
; 395  : }

  0117e	5f		 pop	 edi
  0117f	5e		 pop	 esi
  01180	5b		 pop	 ebx
  01181	8b e5		 mov	 esp, ebp
  01183	5d		 pop	 ebp
  01184	c3		 ret	 0
?Run@CCastleDeepEvent@@QAEXXZ ENDP			; CCastleDeepEvent::Run
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\castledeepevent.h
_TEXT	ENDS
;	COMDAT ?ProcState_None@CCastleDeepEvent@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ProcState_None@CCastleDeepEvent@@QAEXXZ PROC		; CCastleDeepEvent::ProcState_None, COMDAT
; _this$ = ecx

; 76   : 	void ProcState_None() {};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?ProcState_None@CCastleDeepEvent@@QAEXXZ ENDP		; CCastleDeepEvent::ProcState_None
_TEXT	ENDS
PUBLIC	??_C@_0CD@HCDGCBIA@?$FLCastleDeep?5Event?$FN?5?9?5Event?5Start@ ; `string'
PUBLIC	??_C@_0DD@OCBAHGCE@?$FLCastleDeep?5Event?$FN?5ProcState_Clo@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?SendMapServerGroupMsg@CCastleSiege@@QAEXPAD@Z:PROC ; CCastleSiege::SendMapServerGroupMsg
EXTRN	?g_CastleSiege@@3VCCastleSiege@@A:BYTE		; g_CastleSiege
EXTRN	__imp__wsprintfA:PROC
EXTRN	?Get@CMsg@@QAEPADH@Z:PROC			; CMsg::Get
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
;	COMDAT ??_C@_0CD@HCDGCBIA@?$FLCastleDeep?5Event?$FN?5?9?5Event?5Start@
; File d:\projects\exteam6.3\source\gameserver\gameserver\castledeepevent.cpp
CONST	SEGMENT
??_C@_0CD@HCDGCBIA@?$FLCastleDeep?5Event?$FN?5?9?5Event?5Start@ DB '[Cast'
	DB	'leDeep Event] - Event Started', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@OCBAHGCE@?$FLCastleDeep?5Event?$FN?5ProcState_Clo@
CONST	SEGMENT
??_C@_0DD@OCBAHGCE@?$FLCastleDeep?5Event?$FN?5ProcState_Clo@ DB '[CastleD'
	DB	'eep Event] ProcState_Closed()', 09H, 'LEFT-MSEC:%d', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_szTemp$233039 = -524					; size = 256
_szTemp$233036 = -268					; size = 256
_iTICK_MSEC$ = -12					; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?ProcState_Closed@CCastleDeepEvent@@QAEXXZ PROC		; CCastleDeepEvent::ProcState_Closed
; _this$ = ecx

; 398  : {

  01190	55		 push	 ebp
  01191	8b ec		 mov	 ebp, esp
  01193	81 ec 4c 02 00
	00		 sub	 esp, 588		; 0000024cH
  01199	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0119e	33 c5		 xor	 eax, ebp
  011a0	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  011a3	53		 push	 ebx
  011a4	56		 push	 esi
  011a5	57		 push	 edi
  011a6	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 399  : 	int iTICK_MSEC = GetTickCount() - m_iTIME_TICK_COUNT;

  011a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  011af	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  011b2	2b 41 1c	 sub	 eax, DWORD PTR [ecx+28]
  011b5	89 45 f4	 mov	 DWORD PTR _iTICK_MSEC$[ebp], eax

; 400  : 
; 401  : 	if (iTICK_MSEC >= 1000)

  011b8	81 7d f4 e8 03
	00 00		 cmp	 DWORD PTR _iTICK_MSEC$[ebp], 1000 ; 000003e8H
  011bf	0f 8c b9 00 00
	00		 jl	 $LN7@ProcState_

; 402  : 	{
; 403  : 		m_iTIME_MSEC_REMAIN -= iTICK_MSEC;

  011c5	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  011c8	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  011cb	2b 4d f4	 sub	 ecx, DWORD PTR _iTICK_MSEC$[ebp]
  011ce	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  011d1	89 4a 14	 mov	 DWORD PTR [edx+20], ecx

; 404  : 		m_iTIME_TICK_COUNT = GetTickCount();

  011d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  011da	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  011dd	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 405  : 
; 406  : 		if (m_bDoEvent != 0)

  011e0	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  011e3	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  011e7	74 7e		 je	 SHORT $LN6@ProcState_

; 407  : 		{
; 408  : 			if (m_iTIME_MSEC_REMAIN <= 300000
; 409  : 				&& m_iTIME_MSEC_REMAIN > 0
; 410  : 				&& m_iTIME_MSEC_REMAIN / 60000 != m_iTIME_NOTIFY_COUNT)

  011e9	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  011ec	81 78 14 e0 93
	04 00		 cmp	 DWORD PTR [eax+20], 300000 ; 000493e0H
  011f3	7f 72		 jg	 SHORT $LN6@ProcState_
  011f5	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  011f8	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  011fc	7e 69		 jle	 SHORT $LN6@ProcState_
  011fe	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  01201	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  01204	99		 cdq
  01205	b9 60 ea 00 00	 mov	 ecx, 60000		; 0000ea60H
  0120a	f7 f9		 idiv	 ecx
  0120c	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0120f	3b 42 20	 cmp	 eax, DWORD PTR [edx+32]
  01212	74 53		 je	 SHORT $LN6@ProcState_

; 411  : 			{
; 412  : 				m_iTIME_NOTIFY_COUNT = m_iTIME_MSEC_REMAIN / 60000;

  01214	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  01217	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0121a	99		 cdq
  0121b	b9 60 ea 00 00	 mov	 ecx, 60000		; 0000ea60H
  01220	f7 f9		 idiv	 ecx
  01222	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  01225	89 42 20	 mov	 DWORD PTR [edx+32], eax

; 413  : 
; 414  : 				if (m_iTIME_NOTIFY_COUNT + 1 == 5)

  01228	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0122b	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0122e	83 c1 01	 add	 ecx, 1
  01231	83 f9 05	 cmp	 ecx, 5
  01234	75 31		 jne	 SHORT $LN6@ProcState_

; 415  : 				{
; 416  : 					char szTemp[256];
; 417  : 					wsprintf(szTemp,lMsg.Get(3224)); // # translation here

  01236	68 98 0c 00 00	 push	 3224			; 00000c98H
  0123b	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  01240	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  01245	50		 push	 eax
  01246	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$233036[ebp]
  0124c	50		 push	 eax
  0124d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  01253	83 c4 08	 add	 esp, 8

; 418  : 					g_CastleSiege.SendMapServerGroupMsg(szTemp);

  01256	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$233036[ebp]
  0125c	50		 push	 eax
  0125d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  01262	e8 00 00 00 00	 call	 ?SendMapServerGroupMsg@CCastleSiege@@QAEXPAD@Z ; CCastleSiege::SendMapServerGroupMsg
$LN6@ProcState_:

; 419  : 				}
; 420  : 			}
; 421  : 		}
; 422  : 
; 423  : 		LogAddC(3,"[CastleDeep Event] ProcState_Closed()	LEFT-MSEC:%d",m_iTIME_MSEC_REMAIN);

  01267	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0126a	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0126d	51		 push	 ecx
  0126e	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@OCBAHGCE@?$FLCastleDeep?5Event?$FN?5ProcState_Clo@
  01273	6a 03		 push	 3
  01275	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0127b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@ProcState_:

; 424  : 	}
; 425  : 
; 426  : 	if (m_iTIME_MSEC_REMAIN <= 0)

  0127e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  01281	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  01285	7f 5e		 jg	 SHORT $LN8@ProcState_

; 427  : 	{
; 428  : 		char szTemp[256];
; 429  : 		wsprintf(szTemp,lMsg.Get(3225)); // # translation here

  01287	68 99 0c 00 00	 push	 3225			; 00000c99H
  0128c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  01291	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  01296	50		 push	 eax
  01297	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szTemp$233039[ebp]
  0129d	50		 push	 eax
  0129e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  012a4	83 c4 08	 add	 esp, 8

; 430  : 		g_CastleSiege.SendMapServerGroupMsg(szTemp);

  012a7	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szTemp$233039[ebp]
  012ad	50		 push	 eax
  012ae	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  012b3	e8 00 00 00 00	 call	 ?SendMapServerGroupMsg@CCastleSiege@@QAEXPAD@Z ; CCastleSiege::SendMapServerGroupMsg

; 431  : 
; 432  : 		if (m_bDoEvent != 0)

  012b8	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  012bb	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  012bf	74 0c		 je	 SHORT $LN2@ProcState_

; 433  : 		{
; 434  : 			SetState(CD_STATE_PLAYING);

  012c1	6a 02		 push	 2
  012c3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  012c6	e8 00 00 00 00	 call	 ?SetState@CCastleDeepEvent@@QAEXH@Z ; CCastleDeepEvent::SetState

; 435  : 		}
; 436  : 		else

  012cb	eb 0a		 jmp	 SHORT $LN1@ProcState_
$LN2@ProcState_:

; 437  : 		{
; 438  : 			SetState(CD_STATE_NONE);

  012cd	6a 00		 push	 0
  012cf	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  012d2	e8 00 00 00 00	 call	 ?SetState@CCastleDeepEvent@@QAEXH@Z ; CCastleDeepEvent::SetState
$LN1@ProcState_:

; 439  : 		}
; 440  : 
; 441  : 		LogAddTD("[CastleDeep Event] - Event Started");

  012d7	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@HCDGCBIA@?$FLCastleDeep?5Event?$FN?5?9?5Event?5Start@
  012dc	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  012e2	83 c4 04	 add	 esp, 4
$LN8@ProcState_:

; 442  : 	}
; 443  : }

  012e5	5f		 pop	 edi
  012e6	5e		 pop	 esi
  012e7	5b		 pop	 ebx
  012e8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  012eb	33 cd		 xor	 ecx, ebp
  012ed	e8 00 00 00 00	 call	 @__security_check_cookie@4
  012f2	8b e5		 mov	 esp, ebp
  012f4	5d		 pop	 ebp
  012f5	c3		 ret	 0
?ProcState_Closed@CCastleDeepEvent@@QAEXXZ ENDP		; CCastleDeepEvent::ProcState_Closed
_TEXT	ENDS
PUBLIC	??_C@_0CB@IOPJIFCO@?$FLCastleDeep?5Event?$FN?5?9?5Event?5Ended@ ; `string'
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::size
PUBLIC	??_C@_0DE@CCCKDNDF@?$FLCastleDeep?5Event?$FN?5ProcState_Pla@ ; `string'
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
PUBLIC	?AddMonster@CCastleDeepEvent@@QAEXHH@Z		; CCastleDeepEvent::AddMonster
PUBLIC	??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHH@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator->
PUBLIC	??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator!=
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::end
PUBLIC	??E?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator++
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::begin
PUBLIC	__$ArrayPad$
EXTRN	?AllSendServerMsg@@YAXPAD@Z:PROC		; AllSendServerMsg
;	COMDAT ??_C@_0CB@IOPJIFCO@?$FLCastleDeep?5Event?$FN?5?9?5Event?5Ended@
CONST	SEGMENT
??_C@_0CB@IOPJIFCO@?$FLCastleDeep?5Event?$FN?5?9?5Event?5Ended@ DB '[Cast'
	DB	'leDeep Event] - Event Ended', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@CCCKDNDF@?$FLCastleDeep?5Event?$FN?5ProcState_Pla@
CONST	SEGMENT
??_C@_0DE@CCCKDNDF@?$FLCastleDeep?5Event?$FN?5ProcState_Pla@ DB '[CastleD'
	DB	'eep Event] ProcState_Playing()', 09H, 'LEFT-MSEC:%d', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
$T238938 = -356						; size = 4
$T238939 = -352						; size = 4
$T238940 = -348						; size = 4
$T238941 = -344						; size = 4
_szTemp$233093 = -276					; size = 256
_iSpawnMin$233084 = -20					; size = 4
_it$233061 = -16					; size = 4
_iTICK_MSEC$ = -12					; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?ProcState_Playing@CCastleDeepEvent@@QAEXXZ PROC	; CCastleDeepEvent::ProcState_Playing
; _this$ = ecx

; 446  : {

  01300	55		 push	 ebp
  01301	8b ec		 mov	 ebp, esp
  01303	81 ec 64 01 00
	00		 sub	 esp, 356		; 00000164H
  01309	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0130e	33 c5		 xor	 eax, ebp
  01310	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  01313	53		 push	 ebx
  01314	56		 push	 esi
  01315	57		 push	 edi
  01316	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 447  : using namespace std;
; 448  : 	int iTICK_MSEC = GetTickCount() - m_iTIME_TICK_COUNT;

  01319	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0131f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01322	2b 41 1c	 sub	 eax, DWORD PTR [ecx+28]
  01325	89 45 f4	 mov	 DWORD PTR _iTICK_MSEC$[ebp], eax

; 449  : 
; 450  : 	if (iTICK_MSEC >= 1000)

  01328	81 7d f4 e8 03
	00 00		 cmp	 DWORD PTR _iTICK_MSEC$[ebp], 1000 ; 000003e8H
  0132f	0f 8c e3 00 00
	00		 jl	 $LN11@ProcState_@2

; 451  : 	{
; 452  : 		m_iTIME_MSEC_REMAIN +=  iTICK_MSEC;

  01335	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  01338	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0133b	03 4d f4	 add	 ecx, DWORD PTR _iTICK_MSEC$[ebp]
  0133e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  01341	89 4a 14	 mov	 DWORD PTR [edx+20], ecx

; 453  : 		m_iTIME_TICK_COUNT = GetTickCount();

  01344	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0134a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0134d	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 454  : 
; 455  : 		for ( std::map<int, int>::iterator it = this->m_mapRunCheck.begin() ; it != this->m_mapRunCheck.end() ; it++) //HermeX Fix

  01350	8d 45 f0	 lea	 eax, DWORD PTR _it$233061[ebp]
  01353	50		 push	 eax
  01354	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01357	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0135d	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::begin
  01362	eb 11		 jmp	 SHORT $LN10@ProcState_@2
$LN9@ProcState_@2:
  01364	6a 00		 push	 0
  01366	8d 85 9c fe ff
	ff		 lea	 eax, DWORD PTR $T238938[ebp]
  0136c	50		 push	 eax
  0136d	8d 4d f0	 lea	 ecx, DWORD PTR _it$233061[ebp]
  01370	e8 00 00 00 00	 call	 ??E?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator++
$LN10@ProcState_@2:
  01375	8d 85 a0 fe ff
	ff		 lea	 eax, DWORD PTR $T238939[ebp]
  0137b	50		 push	 eax
  0137c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0137f	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01385	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::end
  0138a	50		 push	 eax
  0138b	8d 4d f0	 lea	 ecx, DWORD PTR _it$233061[ebp]
  0138e	e8 00 00 00 00	 call	 ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator!=
  01393	0f b6 c8	 movzx	 ecx, al
  01396	85 c9		 test	 ecx, ecx
  01398	74 67		 je	 SHORT $LN8@ProcState_@2

; 456  : 		{
; 457  : 			int iSpawnMin = it->second;

  0139a	8d 4d f0	 lea	 ecx, DWORD PTR _it$233061[ebp]
  0139d	e8 00 00 00 00	 call	 ??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHH@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator->
  013a2	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  013a5	89 45 ec	 mov	 DWORD PTR _iSpawnMin$233084[ebp], eax

; 458  : 
; 459  : 			if (iSpawnMin == m_iTIME_MSEC_REMAIN / 60000)

  013a8	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  013ab	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  013ae	99		 cdq
  013af	b9 60 ea 00 00	 mov	 ecx, 60000		; 0000ea60H
  013b4	f7 f9		 idiv	 ecx
  013b6	39 45 ec	 cmp	 DWORD PTR _iSpawnMin$233084[ebp], eax
  013b9	75 41		 jne	 SHORT $LN7@ProcState_@2

; 460  : 			{
; 461  : 				AddMonster(m_iCUR_ASSULT_TYPE,it->first);

  013bb	8d 4d f0	 lea	 ecx, DWORD PTR _it$233061[ebp]
  013be	e8 00 00 00 00	 call	 ??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHH@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator->
  013c3	8b 00		 mov	 eax, DWORD PTR [eax]
  013c5	50		 push	 eax
  013c6	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  013c9	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  013cc	52		 push	 edx
  013cd	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  013d0	e8 00 00 00 00	 call	 ?AddMonster@CCastleDeepEvent@@QAEXHH@Z ; CCastleDeepEvent::AddMonster

; 462  : 				m_mapRunCheck.erase(it);

  013d5	8b 45 f0	 mov	 eax, DWORD PTR _it$233061[ebp]
  013d8	89 85 a4 fe ff
	ff		 mov	 DWORD PTR $T238940[ebp], eax
  013de	8b 8d a4 fe ff
	ff		 mov	 ecx, DWORD PTR $T238940[ebp]
  013e4	51		 push	 ecx
  013e5	8d 95 a8 fe ff
	ff		 lea	 edx, DWORD PTR $T238941[ebp]
  013eb	52		 push	 edx
  013ec	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  013ef	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  013f5	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase

; 463  : 				break;

  013fa	eb 05		 jmp	 SHORT $LN8@ProcState_@2
$LN7@ProcState_@2:

; 464  : 			}
; 465  : 		}

  013fc	e9 63 ff ff ff	 jmp	 $LN9@ProcState_@2
$LN8@ProcState_@2:

; 466  : 
; 467  : 		LogAddC(3,"[CastleDeep Event] ProcState_Playing()	LEFT-MSEC:%d",m_iTIME_MSEC_REMAIN);

  01401	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  01404	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  01407	51		 push	 ecx
  01408	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@CCCKDNDF@?$FLCastleDeep?5Event?$FN?5ProcState_Pla@
  0140d	6a 03		 push	 3
  0140f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  01415	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN11@ProcState_@2:

; 468  : 	}
; 469  : 
; 470  : 	if (m_mapRunCheck.size() <= 0)

  01418	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0141b	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01421	e8 00 00 00 00	 call	 ?size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::size
  01426	85 c0		 test	 eax, eax
  01428	0f 87 93 00 00
	00		 ja	 $LN12@ProcState_@2

; 471  : 	{
; 472  : 		if (m_bCheckEnd == 0)

  0142e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  01431	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  01435	75 18		 jne	 SHORT $LN5@ProcState_@2

; 473  : 		{
; 474  : 			m_bCheckEnd = 1;

  01437	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0143a	c7 40 0c 01 00
	00 00		 mov	 DWORD PTR [eax+12], 1

; 475  : 			m_uCheckEndTick = GetTickCount();

  01441	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  01447	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0144a	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 476  : 		}
; 477  : 		else

  0144d	eb 64		 jmp	 SHORT $LN4@ProcState_@2
$LN5@ProcState_@2:

; 478  : 		{
; 479  : 			if (m_uCheckEndTick + 600000 < GetTickCount()) //HermeX Fix

  0144f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  01452	8b 70 10	 mov	 esi, DWORD PTR [eax+16]
  01455	81 c6 c0 27 09
	00		 add	 esi, 600000		; 000927c0H
  0145b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  01461	3b f0		 cmp	 esi, eax
  01463	73 4e		 jae	 SHORT $LN4@ProcState_@2

; 480  : 			{
; 481  : 				char szTemp[256];
; 482  : 				wsprintf(szTemp,lMsg.Get(3226)); // # translation here (HermeX Fix)

  01465	68 9a 0c 00 00	 push	 3226			; 00000c9aH
  0146a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0146f	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  01474	50		 push	 eax
  01475	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$233093[ebp]
  0147b	50		 push	 eax
  0147c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  01482	83 c4 08	 add	 esp, 8

; 483  : 				AllSendServerMsg(szTemp);

  01485	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$233093[ebp]
  0148b	50		 push	 eax
  0148c	e8 00 00 00 00	 call	 ?AllSendServerMsg@@YAXPAD@Z ; AllSendServerMsg
  01491	83 c4 04	 add	 esp, 4

; 484  : 
; 485  : 				if (m_bDoEvent != 0)

  01494	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  01497	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0149b	74 0c		 je	 SHORT $LN2@ProcState_@2

; 486  : 				{
; 487  : 					SetState(CD_STATE_CLOSED);

  0149d	6a 01		 push	 1
  0149f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  014a2	e8 00 00 00 00	 call	 ?SetState@CCastleDeepEvent@@QAEXH@Z ; CCastleDeepEvent::SetState

; 488  : 				}
; 489  : 				else

  014a7	eb 0a		 jmp	 SHORT $LN4@ProcState_@2
$LN2@ProcState_@2:

; 490  : 				{
; 491  : 					SetState(CD_STATE_NONE);

  014a9	6a 00		 push	 0
  014ab	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  014ae	e8 00 00 00 00	 call	 ?SetState@CCastleDeepEvent@@QAEXH@Z ; CCastleDeepEvent::SetState
$LN4@ProcState_@2:

; 492  : 				}
; 493  : 			}
; 494  : 		}
; 495  : 
; 496  : 		LogAddTD("[CastleDeep Event] - Event Ended");

  014b3	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@IOPJIFCO@?$FLCastleDeep?5Event?$FN?5?9?5Event?5Ended@
  014b8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  014be	83 c4 04	 add	 esp, 4
$LN12@ProcState_@2:

; 497  : 	}
; 498  : }

  014c1	5f		 pop	 edi
  014c2	5e		 pop	 esi
  014c3	5b		 pop	 ebx
  014c4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  014c7	33 cd		 xor	 ecx, ebp
  014c9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  014ce	8b e5		 mov	 esp, ebp
  014d0	5d		 pop	 ebp
  014d1	c3		 ret	 0
?ProcState_Playing@CCastleDeepEvent@@QAEXXZ ENDP	; CCastleDeepEvent::ProcState_Playing
_TEXT	ENDS
EXTRN	?gObjDel@@YAFH@Z:PROC				; gObjDel
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?gObjIsConnected@@YAHH@Z:PROC			; gObjIsConnected
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_iIndex$233100 = -8					; size = 4
_this$ = -4						; size = 4
?ClearMonster@CCastleDeepEvent@@QAEXXZ PROC		; CCastleDeepEvent::ClearMonster
; _this$ = ecx

; 501  : {

  014e0	55		 push	 ebp
  014e1	8b ec		 mov	 ebp, esp
  014e3	83 ec 48	 sub	 esp, 72			; 00000048H
  014e6	53		 push	 ebx
  014e7	56		 push	 esi
  014e8	57		 push	 edi
  014e9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 502  : 	for(int iIndex = 0; iIndex < OBJ_MAXMONSTER; iIndex++)

  014ec	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iIndex$233100[ebp], 0
  014f3	eb 09		 jmp	 SHORT $LN4@ClearMonst
$LN3@ClearMonst:
  014f5	8b 45 f8	 mov	 eax, DWORD PTR _iIndex$233100[ebp]
  014f8	83 c0 01	 add	 eax, 1
  014fb	89 45 f8	 mov	 DWORD PTR _iIndex$233100[ebp], eax
$LN4@ClearMonst:
  014fe	81 7d f8 c8 32
	00 00		 cmp	 DWORD PTR _iIndex$233100[ebp], 13000 ; 000032c8H
  01505	7d 3a		 jge	 SHORT $LN5@ClearMonst

; 503  : 	{
; 504  : 		if (gObjIsConnected(iIndex) && gObj[iIndex].m_Attribute == 62)

  01507	8b 45 f8	 mov	 eax, DWORD PTR _iIndex$233100[ebp]
  0150a	50		 push	 eax
  0150b	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  01510	83 c4 04	 add	 esp, 4
  01513	85 c0		 test	 eax, eax
  01515	74 28		 je	 SHORT $LN1@ClearMonst
  01517	8b 45 f8	 mov	 eax, DWORD PTR _iIndex$233100[ebp]
  0151a	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01520	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01526	0f bf 94 01 b6
	04 00 00	 movsx	 edx, WORD PTR [ecx+eax+1206]
  0152e	83 fa 3e	 cmp	 edx, 62			; 0000003eH
  01531	75 0c		 jne	 SHORT $LN1@ClearMonst

; 505  : 		{
; 506  : 			gObjDel(iIndex);

  01533	8b 45 f8	 mov	 eax, DWORD PTR _iIndex$233100[ebp]
  01536	50		 push	 eax
  01537	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  0153c	83 c4 04	 add	 esp, 4
$LN1@ClearMonst:

; 507  : 		}
; 508  : 	}

  0153f	eb b4		 jmp	 SHORT $LN3@ClearMonst
$LN5@ClearMonst:

; 509  : }

  01541	5f		 pop	 edi
  01542	5e		 pop	 esi
  01543	5b		 pop	 ebx
  01544	8b e5		 mov	 esp, ebp
  01546	5d		 pop	 ebp
  01547	c3		 ret	 0
?ClearMonster@CCastleDeepEvent@@QAEXXZ ENDP		; CCastleDeepEvent::ClearMonster
_TEXT	ENDS
PUBLIC	??C?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QBEPAUCASTLEDEEP_MONSTERINFO@@XZ ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::operator->
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::operator!=
PUBLIC	?end@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@XZ ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::end
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::operator++
PUBLIC	?begin@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@XZ ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::begin
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::_Vector_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::operator==
EXTRN	?gObjSetMonster@@YAHHH@Z:PROC			; gObjSetMonster
EXTRN	?gObjAddMonster@@YAFH@Z:PROC			; gObjAddMonster
EXTRN	?gObjGetRandomFreeArea@@YAHHAAE0HHHHH@Z:PROC	; gObjGetRandomFreeArea
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
$T238944 = -108						; size = 4
$T238945 = -104						; size = 4
$T238946 = -100						; size = 4
$T238947 = -96						; size = 4
_result$233299 = -28					; size = 4
_iMonCount$233292 = -24					; size = 4
_cSY$233291 = -18					; size = 1
_cSX$233290 = -17					; size = 1
_stMonsterInfo$233288 = -16				; size = 4
_it2$ = -12						; size = 4
_it$ = -8						; size = 4
_this$ = -4						; size = 4
_iAssultType$ = 8					; size = 4
_iGroup$ = 12						; size = 4
?AddMonster@CCastleDeepEvent@@QAEXHH@Z PROC		; CCastleDeepEvent::AddMonster
; _this$ = ecx

; 512  : {

  01550	55		 push	 ebp
  01551	8b ec		 mov	 ebp, esp
  01553	83 ec 6c	 sub	 esp, 108		; 0000006cH
  01556	53		 push	 ebx
  01557	56		 push	 esi
  01558	57		 push	 edi
  01559	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 513  : 	std::map<int,vector<CASTLEDEEP_MONSTERINFO > >::iterator it = this->m_mapMonsterInfo.find(iAssultType); //HermeX Fix

  0155c	8d 45 08	 lea	 eax, DWORD PTR _iAssultType$[ebp]
  0155f	50		 push	 eax
  01560	8d 4d f8	 lea	 ecx, DWORD PTR _it$[ebp]
  01563	51		 push	 ecx
  01564	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01567	83 c1 30	 add	 ecx, 48			; 00000030H
  0156a	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::find

; 514  : 
; 515  : 	if (it == this->m_mapMonsterInfo.end())

  0156f	8d 45 94	 lea	 eax, DWORD PTR $T238944[ebp]
  01572	50		 push	 eax
  01573	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01576	83 c1 30	 add	 ecx, 48			; 00000030H
  01579	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::end
  0157e	50		 push	 eax
  0157f	8d 4d f8	 lea	 ecx, DWORD PTR _it$[ebp]
  01582	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::operator==
  01587	0f b6 c8	 movzx	 ecx, al
  0158a	85 c9		 test	 ecx, ecx
  0158c	74 05		 je	 SHORT $LN10@AddMonster

; 516  : 	{
; 517  : 		return;

  0158e	e9 75 03 00 00	 jmp	 $LN11@AddMonster
$LN10@AddMonster:

; 518  : 	}
; 519  : 
; 520  : 	std::vector<CASTLEDEEP_MONSTERINFO>::iterator it2;

  01593	8d 4d f4	 lea	 ecx, DWORD PTR _it2$[ebp]
  01596	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::_Vector_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >

; 521  : 
; 522  : 	for(it2 = it->second.begin(); it2 != it->second.end(); it2++)

  0159b	8d 45 98	 lea	 eax, DWORD PTR $T238945[ebp]
  0159e	50		 push	 eax
  0159f	8d 4d f8	 lea	 ecx, DWORD PTR _it$[ebp]
  015a2	e8 00 00 00 00	 call	 ??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::operator->
  015a7	83 c0 04	 add	 eax, 4
  015aa	8b c8		 mov	 ecx, eax
  015ac	e8 00 00 00 00	 call	 ?begin@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@XZ ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::begin
  015b1	8b 08		 mov	 ecx, DWORD PTR [eax]
  015b3	89 4d f4	 mov	 DWORD PTR _it2$[ebp], ecx
  015b6	eb 0e		 jmp	 SHORT $LN9@AddMonster
$LN8@AddMonster:
  015b8	6a 00		 push	 0
  015ba	8d 45 9c	 lea	 eax, DWORD PTR $T238946[ebp]
  015bd	50		 push	 eax
  015be	8d 4d f4	 lea	 ecx, DWORD PTR _it2$[ebp]
  015c1	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::operator++
$LN9@AddMonster:
  015c6	8d 45 a0	 lea	 eax, DWORD PTR $T238947[ebp]
  015c9	50		 push	 eax
  015ca	8d 4d f8	 lea	 ecx, DWORD PTR _it$[ebp]
  015cd	e8 00 00 00 00	 call	 ??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::operator->
  015d2	83 c0 04	 add	 eax, 4
  015d5	8b c8		 mov	 ecx, eax
  015d7	e8 00 00 00 00	 call	 ?end@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@XZ ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::end
  015dc	50		 push	 eax
  015dd	8d 4d f4	 lea	 ecx, DWORD PTR _it2$[ebp]
  015e0	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::operator!=
  015e5	0f b6 c8	 movzx	 ecx, al
  015e8	85 c9		 test	 ecx, ecx
  015ea	0f 84 18 03 00
	00		 je	 $LN11@AddMonster

; 523  : 	{
; 524  : 		std::vector<CASTLEDEEP_MONSTERINFO>::iterator stMonsterInfo= it2;

  015f0	8b 45 f4	 mov	 eax, DWORD PTR _it2$[ebp]
  015f3	89 45 f0	 mov	 DWORD PTR _stMonsterInfo$233288[ebp], eax

; 525  : 
; 526  : 		if (stMonsterInfo->m_iMonsterGroup != iGroup)

  015f6	8d 4d f0	 lea	 ecx, DWORD PTR _stMonsterInfo$233288[ebp]
  015f9	e8 00 00 00 00	 call	 ??C?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QBEPAUCASTLEDEEP_MONSTERINFO@@XZ ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::operator->
  015fe	8b 00		 mov	 eax, DWORD PTR [eax]
  01600	3b 45 0c	 cmp	 eax, DWORD PTR _iGroup$[ebp]
  01603	74 02		 je	 SHORT $LN6@AddMonster

; 527  : 			continue;

  01605	eb b1		 jmp	 SHORT $LN8@AddMonster
$LN6@AddMonster:

; 528  : 
; 529  : 		BYTE cSX;
; 530  : 		BYTE cSY;
; 531  : 
; 532  : 		for(int iMonCount = 0; iMonCount < stMonsterInfo->m_iMonsterNumber; iMonCount++)

  01607	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _iMonCount$233292[ebp], 0
  0160e	eb 09		 jmp	 SHORT $LN5@AddMonster
$LN4@AddMonster:
  01610	8b 45 e8	 mov	 eax, DWORD PTR _iMonCount$233292[ebp]
  01613	83 c0 01	 add	 eax, 1
  01616	89 45 e8	 mov	 DWORD PTR _iMonCount$233292[ebp], eax
$LN5@AddMonster:
  01619	8d 4d f0	 lea	 ecx, DWORD PTR _stMonsterInfo$233288[ebp]
  0161c	e8 00 00 00 00	 call	 ??C?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QBEPAUCASTLEDEEP_MONSTERINFO@@XZ ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::operator->
  01621	8b 4d e8	 mov	 ecx, DWORD PTR _iMonCount$233292[ebp]
  01624	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  01627	0f 8d d6 02 00
	00		 jge	 $LN3@AddMonster

; 533  : 		{
; 534  : 			if (gObjGetRandomFreeArea(MAP_INDEX_CASTLESIEGE,(BYTE &)cSX,(BYTE &)cSY,
; 535  : 				stMonsterInfo->m_iSX,stMonsterInfo->m_iSY,stMonsterInfo->m_iDX,stMonsterInfo->m_iDY,MAP_INDEX_CASTLESIEGE) == TRUE)

  0162d	6a 1e		 push	 30			; 0000001eH
  0162f	8d 4d f0	 lea	 ecx, DWORD PTR _stMonsterInfo$233288[ebp]
  01632	e8 00 00 00 00	 call	 ??C?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QBEPAUCASTLEDEEP_MONSTERINFO@@XZ ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::operator->
  01637	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0163a	50		 push	 eax
  0163b	8d 4d f0	 lea	 ecx, DWORD PTR _stMonsterInfo$233288[ebp]
  0163e	e8 00 00 00 00	 call	 ??C?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QBEPAUCASTLEDEEP_MONSTERINFO@@XZ ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::operator->
  01643	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  01646	51		 push	 ecx
  01647	8d 4d f0	 lea	 ecx, DWORD PTR _stMonsterInfo$233288[ebp]
  0164a	e8 00 00 00 00	 call	 ??C?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QBEPAUCASTLEDEEP_MONSTERINFO@@XZ ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::operator->
  0164f	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  01652	52		 push	 edx
  01653	8d 4d f0	 lea	 ecx, DWORD PTR _stMonsterInfo$233288[ebp]
  01656	e8 00 00 00 00	 call	 ??C?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QBEPAUCASTLEDEEP_MONSTERINFO@@XZ ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::operator->
  0165b	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0165e	50		 push	 eax
  0165f	8d 4d ee	 lea	 ecx, DWORD PTR _cSY$233291[ebp]
  01662	51		 push	 ecx
  01663	8d 55 ef	 lea	 edx, DWORD PTR _cSX$233290[ebp]
  01666	52		 push	 edx
  01667	6a 1e		 push	 30			; 0000001eH
  01669	e8 00 00 00 00	 call	 ?gObjGetRandomFreeArea@@YAHHAAE0HHHHH@Z ; gObjGetRandomFreeArea
  0166e	83 c4 20	 add	 esp, 32			; 00000020H
  01671	83 f8 01	 cmp	 eax, 1
  01674	0f 85 84 02 00
	00		 jne	 $LN2@AddMonster

; 536  : 			{
; 537  : 				int result = gObjAddMonster(MAP_INDEX_CASTLESIEGE);

  0167a	6a 1e		 push	 30			; 0000001eH
  0167c	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  01681	83 c4 04	 add	 esp, 4
  01684	98		 cwde
  01685	89 45 e4	 mov	 DWORD PTR _result$233299[ebp], eax

; 538  : 
; 539  : 				if (result >= 0)

  01688	83 7d e4 00	 cmp	 DWORD PTR _result$233299[ebp], 0
  0168c	0f 8c 6c 02 00
	00		 jl	 $LN2@AddMonster

; 540  : 				{
; 541  : 					gObj[result].m_PosNum = -1;

  01692	8b 45 e4	 mov	 eax, DWORD PTR _result$233299[ebp]
  01695	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0169b	83 c9 ff	 or	 ecx, -1
  0169e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  016a4	66 89 8c 02 b0
	03 00 00	 mov	 WORD PTR [edx+eax+944], cx

; 542  : 					gObj[result].X = cSX;

  016ac	66 0f b6 45 ef	 movzx	 ax, BYTE PTR _cSX$233290[ebp]
  016b1	8b 4d e4	 mov	 ecx, DWORD PTR _result$233299[ebp]
  016b4	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  016ba	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  016c0	66 89 84 0a 44
	01 00 00	 mov	 WORD PTR [edx+ecx+324], ax

; 543  : 					gObj[result].Y = cSY;

  016c8	66 0f b6 45 ee	 movzx	 ax, BYTE PTR _cSY$233291[ebp]
  016cd	8b 4d e4	 mov	 ecx, DWORD PTR _result$233299[ebp]
  016d0	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  016d6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  016dc	66 89 84 0a 46
	01 00 00	 mov	 WORD PTR [edx+ecx+326], ax

; 544  : 					gObj[result].MapNumber = MAP_INDEX_CASTLESIEGE;

  016e4	8b 45 e4	 mov	 eax, DWORD PTR _result$233299[ebp]
  016e7	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  016ed	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  016f3	c6 84 01 49 01
	00 00 1e	 mov	 BYTE PTR [ecx+eax+329], 30 ; 0000001eH

; 545  : 					gObj[result].TX = gObj[result].X;

  016fb	8b 45 e4	 mov	 eax, DWORD PTR _result$233299[ebp]
  016fe	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01704	8b 4d e4	 mov	 ecx, DWORD PTR _result$233299[ebp]
  01707	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0170d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01713	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01719	66 8b 84 06 44
	01 00 00	 mov	 ax, WORD PTR [esi+eax+324]
  01721	66 89 84 0a 7c
	01 00 00	 mov	 WORD PTR [edx+ecx+380], ax

; 546  : 					gObj[result].TY = gObj[result].Y;

  01729	8b 45 e4	 mov	 eax, DWORD PTR _result$233299[ebp]
  0172c	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01732	8b 4d e4	 mov	 ecx, DWORD PTR _result$233299[ebp]
  01735	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0173b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01741	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01747	66 8b 84 06 46
	01 00 00	 mov	 ax, WORD PTR [esi+eax+326]
  0174f	66 89 84 0a 7e
	01 00 00	 mov	 WORD PTR [edx+ecx+382], ax

; 547  : 					gObj[result].m_OldX = gObj[result].X;

  01757	8b 45 e4	 mov	 eax, DWORD PTR _result$233299[ebp]
  0175a	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01760	8b 4d e4	 mov	 ecx, DWORD PTR _result$233299[ebp]
  01763	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  01769	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0176f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01775	66 8b 84 06 44
	01 00 00	 mov	 ax, WORD PTR [esi+eax+324]
  0177d	66 89 84 0a 78
	01 00 00	 mov	 WORD PTR [edx+ecx+376], ax

; 548  : 					gObj[result].m_OldY = gObj[result].Y;

  01785	8b 45 e4	 mov	 eax, DWORD PTR _result$233299[ebp]
  01788	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0178e	8b 4d e4	 mov	 ecx, DWORD PTR _result$233299[ebp]
  01791	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  01797	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0179d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  017a3	66 8b 84 06 46
	01 00 00	 mov	 ax, WORD PTR [esi+eax+326]
  017ab	66 89 84 0a 7a
	01 00 00	 mov	 WORD PTR [edx+ecx+378], ax

; 549  : 					gObj[result].Dir = 1;

  017b3	8b 45 e4	 mov	 eax, DWORD PTR _result$233299[ebp]
  017b6	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  017bc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  017c2	c6 84 01 48 01
	00 00 01	 mov	 BYTE PTR [ecx+eax+328], 1

; 550  : 					gObj[result].StartX = gObj[result].X;

  017ca	8b 45 e4	 mov	 eax, DWORD PTR _result$233299[ebp]
  017cd	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  017d3	8b 4d e4	 mov	 ecx, DWORD PTR _result$233299[ebp]
  017d6	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  017dc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  017e2	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  017e8	8a 84 06 44 01
	00 00		 mov	 al, BYTE PTR [esi+eax+324]
  017ef	88 84 0a 76 01
	00 00		 mov	 BYTE PTR [edx+ecx+374], al

; 551  : 					gObj[result].StartY = gObj[result].Y;

  017f6	8b 45 e4	 mov	 eax, DWORD PTR _result$233299[ebp]
  017f9	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  017ff	8b 4d e4	 mov	 ecx, DWORD PTR _result$233299[ebp]
  01802	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  01808	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0180e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01814	8a 84 06 46 01
	00 00		 mov	 al, BYTE PTR [esi+eax+326]
  0181b	88 84 0a 77 01
	00 00		 mov	 BYTE PTR [edx+ecx+375], al

; 552  : 
; 553  : 					gObjSetMonster(result,stMonsterInfo->m_iMonsterType);

  01822	8d 4d f0	 lea	 ecx, DWORD PTR _stMonsterInfo$233288[ebp]
  01825	e8 00 00 00 00	 call	 ??C?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QBEPAUCASTLEDEEP_MONSTERINFO@@XZ ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::operator->
  0182a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0182d	50		 push	 eax
  0182e	8b 4d e4	 mov	 ecx, DWORD PTR _result$233299[ebp]
  01831	51		 push	 ecx
  01832	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster
  01837	83 c4 08	 add	 esp, 8

; 554  : 
; 555  : 					gObj[result].m_Attribute = 62;

  0183a	8b 45 e4	 mov	 eax, DWORD PTR _result$233299[ebp]
  0183d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01843	b9 3e 00 00 00	 mov	 ecx, 62			; 0000003eH
  01848	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0184e	66 89 8c 02 b6
	04 00 00	 mov	 WORD PTR [edx+eax+1206], cx

; 556  : 					gObj[result].MaxRegenTime = 0;

  01856	8b 45 e4	 mov	 eax, DWORD PTR _result$233299[ebp]
  01859	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0185f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01865	c7 84 01 ac 03
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+940], 0

; 557  : 					gObj[result].Dir = rand()%8;

  01870	e8 00 00 00 00	 call	 _rand
  01875	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  0187a	79 05		 jns	 SHORT $LN13@AddMonster
  0187c	48		 dec	 eax
  0187d	83 c8 f8	 or	 eax, -8			; fffffff8H
  01880	40		 inc	 eax
$LN13@AddMonster:
  01881	8b 4d e4	 mov	 ecx, DWORD PTR _result$233299[ebp]
  01884	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0188a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01890	88 84 0a 48 01
	00 00		 mov	 BYTE PTR [edx+ecx+328], al

; 558  : 					gObj[result].DieRegen = 0;

  01897	8b 45 e4	 mov	 eax, DWORD PTR _result$233299[ebp]
  0189a	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  018a0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  018a6	c6 84 01 a2 03
	00 00 00	 mov	 BYTE PTR [ecx+eax+930], 0

; 559  : 					gObj[result].RegenTime = 1;

  018ae	8b 45 e4	 mov	 eax, DWORD PTR _result$233299[ebp]
  018b1	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  018b7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  018bd	c7 84 01 a8 03
	00 00 01 00 00
	00		 mov	 DWORD PTR [ecx+eax+936], 1

; 560  : 					gObj[result].MaxRegenTime = 1000;

  018c8	8b 45 e4	 mov	 eax, DWORD PTR _result$233299[ebp]
  018cb	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  018d1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  018d7	c7 84 01 ac 03
	00 00 e8 03 00
	00		 mov	 DWORD PTR [ecx+eax+940], 1000 ; 000003e8H

; 561  : 					gObj[result].m_dwLastCheckTick = GetTickCount();

  018e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  018e8	8b 4d e4	 mov	 ecx, DWORD PTR _result$233299[ebp]
  018eb	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  018f1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  018f7	89 84 0a c8 1f
	00 00		 mov	 DWORD PTR [edx+ecx+8136], eax
$LN2@AddMonster:

; 562  : 				}
; 563  : 			}
; 564  : 		}

  018fe	e9 0d fd ff ff	 jmp	 $LN4@AddMonster
$LN3@AddMonster:

; 565  : 	}

  01903	e9 b0 fc ff ff	 jmp	 $LN8@AddMonster
$LN11@AddMonster:

; 566  : }

  01908	5f		 pop	 edi
  01909	5e		 pop	 esi
  0190a	5b		 pop	 ebx
  0190b	8b e5		 mov	 esp, ebp
  0190d	5d		 pop	 ebp
  0190e	c2 08 00	 ret	 8
?AddMonster@CCastleDeepEvent@@QAEXHH@Z ENDP		; CCastleDeepEvent::AddMonster
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
PUBLIC	??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@XZ	; std::allocator<std::pair<int const ,int> >::allocator<std::pair<int const ,int> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\map
;	COMDAT ??0?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T238950 = -70						; size = 1
$T238951 = -69						; size = 1
_this$ = -4						; size = 4
??0?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ PROC ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >, COMDAT
; _this$ = ecx

; 106  : 		{	// construct empty map from defaults

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 4d ba	 lea	 ecx, DWORD PTR $T238950[ebp]
  0000f	e8 00 00 00 00	 call	 ??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@XZ ; std::allocator<std::pair<int const ,int> >::allocator<std::pair<int const ,int> >
  00014	50		 push	 eax
  00015	8d 45 bb	 lea	 eax, DWORD PTR $T238951[ebp]
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >

; 107  : 		}

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??0?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ ENDP ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
_TEXT	ENDS
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tidy
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xtree
xdata$x	SEGMENT
__unwindtable$??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 790  : 		{	// destroy tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 791  : 		_Tidy();

  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tidy

; 792  : 		}

  0003a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
  00049	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
__ehhandler$??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lmost
; Function compile flags: /Odtp /ZI
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::begin, COMDAT
; _this$ = ecx

; 806  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 807  : 		return (iterator(_Lmost(), this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lmost
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	51		 push	 ecx
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001e	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >
  00023	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 808  : 		}

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::begin
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::end, COMDAT
; _this$ = ecx

; 816  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 817  : 		return (iterator(this->_Myhead, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	52		 push	 edx
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >
  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 818  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::end
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::size, COMDAT
; _this$ = ecx

; 868  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 869  : 		return (this->_Mysize);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 870  : 		}

  00012	5f		 pop	 edi
  00013	5e		 pop	 esi
  00014	5b		 pop	 ebx
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::size
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::deallocate
PUBLIC	??$_Dest_val@V?$allocator@U?$pair@$$CBHH@std@@@std@@U?$pair@$$CBHH@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHH@std@@@0@PAU?$pair@$$CBHH@0@@Z ; std::_Dest_val<std::allocator<std::pair<int const ,int> >,std::pair<int const ,int> >
PUBLIC	??$addressof@U?$pair@$$CBHH@std@@@std@@YAPAU?$pair@$$CBHH@0@AAU10@@Z ; std::addressof<std::pair<int const ,int> >
PUBLIC	?_Myval@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Myval
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate
PUBLIC	??$swap@D@std@@YAXAAD0@Z			; std::swap<char>
PUBLIC	?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
PUBLIC	?_Max@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Max
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rmost
PUBLIC	?_Min@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Min
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root
PUBLIC	?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
PUBLIC	?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
PUBLIC	?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator++
PUBLIC	??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ ; `string'
PUBLIC	?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
PUBLIC	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Mynode
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
;	COMDAT ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
CONST	SEGMENT
??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ DB 'invalid '
	DB	'map/set<T> iterator', 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@@Z
_TEXT	SEGMENT
tv182 = -88						; size = 4
tv170 = -88						; size = 4
__Pnode$ = -20						; size = 4
__Fixnodeparent$ = -16					; size = 4
__Fixnode$ = -12					; size = 4
__Erasednode$ = -8					; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase, COMDAT
; _this$ = ecx

; 1195 : 		{	// erase element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1198 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1199 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1200 : 		++_Where;	// save successor iterator for return
; 1201 : 		_Orphan_ptr(*this, _Erasednode);
; 1202 : 
; 1203 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1204 : 		if (this->_Isnil(_Where._Mynode()))

  0000c	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Mynode
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  0001a	83 c4 04	 add	 esp, 4
  0001d	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00020	85 c0		 test	 eax, eax
  00022	74 0a		 je	 SHORT $LN40@erase

; 1205 : 			_Xout_of_range("invalid map/set<T> iterator");

  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
  00029	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN40@erase:

; 1206 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

  0002e	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  00031	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Mynode
  00036	89 45 f8	 mov	 DWORD PTR __Erasednode$[ebp], eax

; 1207 : 		++_Where;	// save successor iterator for return

  00039	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  0003c	e8 00 00 00 00	 call	 ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator++

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1211 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1212 : 		_Nodeptr _Pnode = _Erasednode;

  00041	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00044	89 45 ec	 mov	 DWORD PTR __Pnode$[ebp], eax

; 1213 : 
; 1214 : 		if (this->_Isnil(this->_Left(_Pnode)))

  00047	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  00050	83 c4 04	 add	 esp, 4
  00053	8b 08		 mov	 ecx, DWORD PTR [eax]
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  0005b	83 c4 04	 add	 esp, 4
  0005e	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00061	85 d2		 test	 edx, edx
  00063	74 13		 je	 SHORT $LN39@erase

; 1215 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree

  00065	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  0006e	83 c4 04	 add	 esp, 4
  00071	8b 08		 mov	 ecx, DWORD PTR [eax]
  00073	89 4d f4	 mov	 DWORD PTR __Fixnode$[ebp], ecx
  00076	eb 4d		 jmp	 SHORT $LN38@erase
$LN39@erase:

; 1216 : 		else if (this->_Isnil(this->_Right(_Pnode)))

  00078	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  00081	83 c4 04	 add	 esp, 4
  00084	8b 08		 mov	 ecx, DWORD PTR [eax]
  00086	51		 push	 ecx
  00087	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  0008c	83 c4 04	 add	 esp, 4
  0008f	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00092	85 d2		 test	 edx, edx
  00094	74 13		 je	 SHORT $LN37@erase

; 1217 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree

  00096	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  0009f	83 c4 04	 add	 esp, 4
  000a2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a4	89 4d f4	 mov	 DWORD PTR __Fixnode$[ebp], ecx

; 1218 : 		else

  000a7	eb 1c		 jmp	 SHORT $LN38@erase
$LN37@erase:

; 1219 : 			{	// two subtrees, must lift successor node to replace erased
; 1220 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

  000a9	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  000ac	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Mynode
  000b1	89 45 ec	 mov	 DWORD PTR __Pnode$[ebp], eax

; 1221 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree

  000b4	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  000bd	83 c4 04	 add	 esp, 4
  000c0	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c2	89 4d f4	 mov	 DWORD PTR __Fixnode$[ebp], ecx
$LN38@erase:

; 1222 : 			}
; 1223 : 
; 1224 : 		if (_Pnode == _Erasednode)

  000c5	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  000c8	3b 45 f8	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  000cb	0f 85 1b 01 00
	00		 jne	 $LN35@erase

; 1225 : 			{	// at most one subtree, relink it
; 1226 : 			_Fixnodeparent = this->_Parent(_Erasednode);

  000d1	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  000d4	50		 push	 eax
  000d5	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  000da	83 c4 04	 add	 esp, 4
  000dd	8b 08		 mov	 ecx, DWORD PTR [eax]
  000df	89 4d f0	 mov	 DWORD PTR __Fixnodeparent$[ebp], ecx

; 1227 : 			if (!this->_Isnil(_Fixnode))

  000e2	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  000eb	83 c4 04	 add	 esp, 4
  000ee	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000f1	85 c9		 test	 ecx, ecx
  000f3	75 11		 jne	 SHORT $LN34@erase

; 1228 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up

  000f5	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  000f8	50		 push	 eax
  000f9	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  000fe	83 c4 04	 add	 esp, 4
  00101	8b 4d f0	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  00104	89 08		 mov	 DWORD PTR [eax], ecx
$LN34@erase:

; 1229 : 
; 1230 : 			if (_Root() == _Erasednode)

  00106	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root
  0010e	8b 00		 mov	 eax, DWORD PTR [eax]
  00110	3b 45 f8	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  00113	75 0f		 jne	 SHORT $LN33@erase

; 1231 : 				_Root() = _Fixnode;	// link down from root

  00115	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00118	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root
  0011d	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  00120	89 08		 mov	 DWORD PTR [eax], ecx
  00122	eb 37		 jmp	 SHORT $LN32@erase
$LN33@erase:

; 1232 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)

  00124	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00127	50		 push	 eax
  00128	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  0012d	83 c4 04	 add	 esp, 4
  00130	8b 08		 mov	 ecx, DWORD PTR [eax]
  00132	3b 4d f8	 cmp	 ecx, DWORD PTR __Erasednode$[ebp]
  00135	75 13		 jne	 SHORT $LN31@erase

; 1233 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left

  00137	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0013a	50		 push	 eax
  0013b	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  00140	83 c4 04	 add	 esp, 4
  00143	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  00146	89 08		 mov	 DWORD PTR [eax], ecx

; 1234 : 			else

  00148	eb 11		 jmp	 SHORT $LN32@erase
$LN31@erase:

; 1235 : 				this->_Right(_Fixnodeparent) =
; 1236 : 					_Fixnode;	// link down to right

  0014a	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0014d	50		 push	 eax
  0014e	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  00153	83 c4 04	 add	 esp, 4
  00156	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  00159	89 08		 mov	 DWORD PTR [eax], ecx
$LN32@erase:

; 1237 : 
; 1238 : 			if (_Lmost() == _Erasednode)

  0015b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0015e	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lmost
  00163	8b 00		 mov	 eax, DWORD PTR [eax]
  00165	3b 45 f8	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  00168	75 37		 jne	 SHORT $LN29@erase

; 1239 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1240 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1241 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree

  0016a	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  0016d	50		 push	 eax
  0016e	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  00173	83 c4 04	 add	 esp, 4
  00176	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00179	85 c9		 test	 ecx, ecx
  0017b	74 08		 je	 SHORT $LN43@erase
  0017d	8b 55 f0	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  00180	89 55 a8	 mov	 DWORD PTR tv170[ebp], edx
  00183	eb 0f		 jmp	 SHORT $LN44@erase
$LN43@erase:
  00185	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00188	50		 push	 eax
  00189	e8 00 00 00 00	 call	 ?_Min@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Min
  0018e	83 c4 04	 add	 esp, 4
  00191	89 45 a8	 mov	 DWORD PTR tv170[ebp], eax
$LN44@erase:
  00194	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00197	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lmost
  0019c	8b 4d a8	 mov	 ecx, DWORD PTR tv170[ebp]
  0019f	89 08		 mov	 DWORD PTR [eax], ecx
$LN29@erase:

; 1242 : 
; 1243 : 			if (_Rmost() == _Erasednode)

  001a1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001a4	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rmost
  001a9	8b 00		 mov	 eax, DWORD PTR [eax]
  001ab	3b 45 f8	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  001ae	75 37		 jne	 SHORT $LN28@erase

; 1244 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1245 : 					? _Fixnodeparent	// largest is parent of erased node
; 1246 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  001b0	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  001b3	50		 push	 eax
  001b4	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  001b9	83 c4 04	 add	 esp, 4
  001bc	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  001bf	85 c9		 test	 ecx, ecx
  001c1	74 08		 je	 SHORT $LN45@erase
  001c3	8b 55 f0	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  001c6	89 55 a8	 mov	 DWORD PTR tv182[ebp], edx
  001c9	eb 0f		 jmp	 SHORT $LN46@erase
$LN45@erase:
  001cb	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  001ce	50		 push	 eax
  001cf	e8 00 00 00 00	 call	 ?_Max@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Max
  001d4	83 c4 04	 add	 esp, 4
  001d7	89 45 a8	 mov	 DWORD PTR tv182[ebp], eax
$LN46@erase:
  001da	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001dd	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rmost
  001e2	8b 4d a8	 mov	 ecx, DWORD PTR tv182[ebp]
  001e5	89 08		 mov	 DWORD PTR [eax], ecx
$LN28@erase:

; 1247 : 			}
; 1248 : 		else

  001e7	e9 8e 01 00 00	 jmp	 $LN27@erase
$LN35@erase:

; 1249 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1250 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1251 : 				_Pnode;	// link left up

  001ec	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  001ef	50		 push	 eax
  001f0	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  001f5	83 c4 04	 add	 esp, 4
  001f8	8b 08		 mov	 ecx, DWORD PTR [eax]
  001fa	51		 push	 ecx
  001fb	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  00200	83 c4 04	 add	 esp, 4
  00203	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00206	89 10		 mov	 DWORD PTR [eax], edx

; 1252 : 			this->_Left(_Pnode) =
; 1253 : 				this->_Left(_Erasednode);	// link successor down

  00208	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0020b	50		 push	 eax
  0020c	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  00211	83 c4 04	 add	 esp, 4
  00214	8b f0		 mov	 esi, eax
  00216	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00219	51		 push	 ecx
  0021a	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  0021f	83 c4 04	 add	 esp, 4
  00222	8b 16		 mov	 edx, DWORD PTR [esi]
  00224	89 10		 mov	 DWORD PTR [eax], edx

; 1254 : 
; 1255 : 			if (_Pnode == this->_Right(_Erasednode))

  00226	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00229	50		 push	 eax
  0022a	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  0022f	83 c4 04	 add	 esp, 4
  00232	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00235	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00237	75 0b		 jne	 SHORT $LN26@erase

; 1256 : 				_Fixnodeparent = _Pnode;	// successor is next to erased

  00239	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0023c	89 45 f0	 mov	 DWORD PTR __Fixnodeparent$[ebp], eax

; 1257 : 			else

  0023f	e9 80 00 00 00	 jmp	 $LN25@erase
$LN26@erase:

; 1258 : 				{	// successor further down, link in place of erased
; 1259 : 				_Fixnodeparent =
; 1260 : 					this->_Parent(_Pnode);	// parent is successor's

  00244	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00247	50		 push	 eax
  00248	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  0024d	83 c4 04	 add	 esp, 4
  00250	8b 08		 mov	 ecx, DWORD PTR [eax]
  00252	89 4d f0	 mov	 DWORD PTR __Fixnodeparent$[ebp], ecx

; 1261 : 				if (!this->_Isnil(_Fixnode))

  00255	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00258	50		 push	 eax
  00259	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  0025e	83 c4 04	 add	 esp, 4
  00261	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00264	85 c9		 test	 ecx, ecx
  00266	75 11		 jne	 SHORT $LN24@erase

; 1262 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

  00268	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  0026b	50		 push	 eax
  0026c	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  00271	83 c4 04	 add	 esp, 4
  00274	8b 4d f0	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  00277	89 08		 mov	 DWORD PTR [eax], ecx
$LN24@erase:

; 1263 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down

  00279	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0027c	50		 push	 eax
  0027d	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  00282	83 c4 04	 add	 esp, 4
  00285	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  00288	89 08		 mov	 DWORD PTR [eax], ecx

; 1264 : 				this->_Right(_Pnode) =
; 1265 : 					this->_Right(_Erasednode);	// link next down

  0028a	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0028d	50		 push	 eax
  0028e	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  00293	83 c4 04	 add	 esp, 4
  00296	8b f0		 mov	 esi, eax
  00298	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0029b	51		 push	 ecx
  0029c	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  002a1	83 c4 04	 add	 esp, 4
  002a4	8b 16		 mov	 edx, DWORD PTR [esi]
  002a6	89 10		 mov	 DWORD PTR [eax], edx

; 1266 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1267 : 					_Pnode;	// right up

  002a8	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  002ab	50		 push	 eax
  002ac	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  002b1	83 c4 04	 add	 esp, 4
  002b4	8b 08		 mov	 ecx, DWORD PTR [eax]
  002b6	51		 push	 ecx
  002b7	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  002bc	83 c4 04	 add	 esp, 4
  002bf	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$[ebp]
  002c2	89 10		 mov	 DWORD PTR [eax], edx
$LN25@erase:

; 1268 : 				}
; 1269 : 
; 1270 : 			if (_Root() == _Erasednode)

  002c4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002c7	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root
  002cc	8b 00		 mov	 eax, DWORD PTR [eax]
  002ce	3b 45 f8	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  002d1	75 0f		 jne	 SHORT $LN23@erase

; 1271 : 				_Root() = _Pnode;	// link down from root

  002d3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002d6	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root
  002db	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  002de	89 08		 mov	 DWORD PTR [eax], ecx
  002e0	eb 58		 jmp	 SHORT $LN22@erase
$LN23@erase:

; 1272 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

  002e2	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  002e5	50		 push	 eax
  002e6	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  002eb	83 c4 04	 add	 esp, 4
  002ee	8b 08		 mov	 ecx, DWORD PTR [eax]
  002f0	51		 push	 ecx
  002f1	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  002f6	83 c4 04	 add	 esp, 4
  002f9	8b 10		 mov	 edx, DWORD PTR [eax]
  002fb	3b 55 f8	 cmp	 edx, DWORD PTR __Erasednode$[ebp]
  002fe	75 1e		 jne	 SHORT $LN21@erase

; 1273 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1274 : 					_Pnode;	// link down to left

  00300	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00303	50		 push	 eax
  00304	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  00309	83 c4 04	 add	 esp, 4
  0030c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0030e	51		 push	 ecx
  0030f	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  00314	83 c4 04	 add	 esp, 4
  00317	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$[ebp]
  0031a	89 10		 mov	 DWORD PTR [eax], edx

; 1275 : 			else

  0031c	eb 1c		 jmp	 SHORT $LN22@erase
$LN21@erase:

; 1276 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1277 : 					_Pnode;	// link down to right

  0031e	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00321	50		 push	 eax
  00322	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  00327	83 c4 04	 add	 esp, 4
  0032a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0032c	51		 push	 ecx
  0032d	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  00332	83 c4 04	 add	 esp, 4
  00335	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00338	89 10		 mov	 DWORD PTR [eax], edx
$LN22@erase:

; 1278 : 
; 1279 : 			this->_Parent(_Pnode) =
; 1280 : 				this->_Parent(_Erasednode);	// link successor up

  0033a	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0033d	50		 push	 eax
  0033e	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  00343	83 c4 04	 add	 esp, 4
  00346	8b f0		 mov	 esi, eax
  00348	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0034b	51		 push	 ecx
  0034c	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  00351	83 c4 04	 add	 esp, 4
  00354	8b 16		 mov	 edx, DWORD PTR [esi]
  00356	89 10		 mov	 DWORD PTR [eax], edx

; 1281 : 			_STD swap(this->_Color(_Pnode),
; 1282 : 				this->_Color(_Erasednode));	// recolor it

  00358	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0035b	50		 push	 eax
  0035c	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  00361	83 c4 04	 add	 esp, 4
  00364	50		 push	 eax
  00365	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00368	51		 push	 ecx
  00369	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  0036e	83 c4 04	 add	 esp, 4
  00371	50		 push	 eax
  00372	e8 00 00 00 00	 call	 ??$swap@D@std@@YAXAAD0@Z ; std::swap<char>
  00377	83 c4 08	 add	 esp, 8
$LN27@erase:

; 1283 : 			}
; 1284 : 
; 1285 : 		if (this->_Color(_Erasednode) == this->_Black)

  0037a	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0037d	50		 push	 eax
  0037e	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  00383	83 c4 04	 add	 esp, 4
  00386	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00389	83 f9 01	 cmp	 ecx, 1
  0038c	0f 85 8f 03 00
	00		 jne	 $LN19@erase
  00392	eb 11		 jmp	 SHORT $LN18@erase
$LN17@erase:

; 1286 : 			{	// erasing black link, must recolor/rebalance tree
; 1287 : 			for (; _Fixnode != _Root()
; 1288 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1289 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  00394	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00397	50		 push	 eax
  00398	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  0039d	83 c4 04	 add	 esp, 4
  003a0	8b 08		 mov	 ecx, DWORD PTR [eax]
  003a2	89 4d f0	 mov	 DWORD PTR __Fixnodeparent$[ebp], ecx
$LN18@erase:
  003a5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003a8	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root
  003ad	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  003b0	3b 08		 cmp	 ecx, DWORD PTR [eax]
  003b2	0f 84 5a 03 00
	00		 je	 $LN16@erase
  003b8	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  003bb	50		 push	 eax
  003bc	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  003c1	83 c4 04	 add	 esp, 4
  003c4	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  003c7	83 f9 01	 cmp	 ecx, 1
  003ca	0f 85 42 03 00
	00		 jne	 $LN16@erase

; 1290 : 				if (_Fixnode == this->_Left(_Fixnodeparent))

  003d0	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  003d3	50		 push	 eax
  003d4	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  003d9	83 c4 04	 add	 esp, 4
  003dc	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  003df	3b 08		 cmp	 ecx, DWORD PTR [eax]
  003e1	0f 85 97 01 00
	00		 jne	 $LN15@erase

; 1291 : 					{	// fixup left subtree
; 1292 : 					_Pnode = this->_Right(_Fixnodeparent);

  003e7	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  003ea	50		 push	 eax
  003eb	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  003f0	83 c4 04	 add	 esp, 4
  003f3	8b 08		 mov	 ecx, DWORD PTR [eax]
  003f5	89 4d ec	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 1293 : 					if (this->_Color(_Pnode) == this->_Red)

  003f8	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  003fb	50		 push	 eax
  003fc	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  00401	83 c4 04	 add	 esp, 4
  00404	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00407	85 c9		 test	 ecx, ecx
  00409	75 3b		 jne	 SHORT $LN14@erase

; 1294 : 						{	// rotate red up from right subtree
; 1295 : 						this->_Color(_Pnode) = this->_Black;

  0040b	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0040e	50		 push	 eax
  0040f	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  00414	83 c4 04	 add	 esp, 4
  00417	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1296 : 						this->_Color(_Fixnodeparent) = this->_Red;

  0041a	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0041d	50		 push	 eax
  0041e	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  00423	83 c4 04	 add	 esp, 4
  00426	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1297 : 						_Lrotate(_Fixnodeparent);

  00429	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0042c	50		 push	 eax
  0042d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00430	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate

; 1298 : 						_Pnode = this->_Right(_Fixnodeparent);

  00435	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00438	50		 push	 eax
  00439	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  0043e	83 c4 04	 add	 esp, 4
  00441	8b 08		 mov	 ecx, DWORD PTR [eax]
  00443	89 4d ec	 mov	 DWORD PTR __Pnode$[ebp], ecx
$LN14@erase:

; 1299 : 						}
; 1300 : 
; 1301 : 					if (this->_Isnil(_Pnode))

  00446	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00449	50		 push	 eax
  0044a	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  0044f	83 c4 04	 add	 esp, 4
  00452	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00455	85 c9		 test	 ecx, ecx
  00457	74 0b		 je	 SHORT $LN13@erase

; 1302 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

  00459	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0045c	89 45 f4	 mov	 DWORD PTR __Fixnode$[ebp], eax

; 1303 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black

  0045f	e9 15 01 00 00	 jmp	 $LN12@erase
$LN13@erase:

; 1304 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)

  00464	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00467	50		 push	 eax
  00468	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  0046d	83 c4 04	 add	 esp, 4
  00470	8b 08		 mov	 ecx, DWORD PTR [eax]
  00472	51		 push	 ecx
  00473	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  00478	83 c4 04	 add	 esp, 4
  0047b	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0047e	83 fa 01	 cmp	 edx, 1
  00481	75 39		 jne	 SHORT $LN11@erase
  00483	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00486	50		 push	 eax
  00487	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  0048c	83 c4 04	 add	 esp, 4
  0048f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00491	51		 push	 ecx
  00492	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  00497	83 c4 04	 add	 esp, 4
  0049a	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0049d	83 fa 01	 cmp	 edx, 1
  004a0	75 1a		 jne	 SHORT $LN11@erase

; 1305 : 						{	// redden right subtree with black children
; 1306 : 						this->_Color(_Pnode) = this->_Red;

  004a2	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  004a5	50		 push	 eax
  004a6	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  004ab	83 c4 04	 add	 esp, 4
  004ae	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1307 : 						_Fixnode = _Fixnodeparent;

  004b1	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  004b4	89 45 f4	 mov	 DWORD PTR __Fixnode$[ebp], eax

; 1308 : 						}
; 1309 : 					else

  004b7	e9 bd 00 00 00	 jmp	 $LN12@erase
$LN11@erase:

; 1310 : 						{	// must rearrange right subtree
; 1311 : 						if (this->_Color(this->_Right(_Pnode))
; 1312 : 							== this->_Black)

  004bc	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  004bf	50		 push	 eax
  004c0	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  004c5	83 c4 04	 add	 esp, 4
  004c8	8b 08		 mov	 ecx, DWORD PTR [eax]
  004ca	51		 push	 ecx
  004cb	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  004d0	83 c4 04	 add	 esp, 4
  004d3	0f be 10	 movsx	 edx, BYTE PTR [eax]
  004d6	83 fa 01	 cmp	 edx, 1
  004d9	75 46		 jne	 SHORT $LN9@erase

; 1313 : 							{	// rotate red up from left sub-subtree
; 1314 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;

  004db	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  004de	50		 push	 eax
  004df	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  004e4	83 c4 04	 add	 esp, 4
  004e7	8b 08		 mov	 ecx, DWORD PTR [eax]
  004e9	51		 push	 ecx
  004ea	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  004ef	83 c4 04	 add	 esp, 4
  004f2	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1315 : 							this->_Color(_Pnode) = this->_Red;

  004f5	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  004f8	50		 push	 eax
  004f9	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  004fe	83 c4 04	 add	 esp, 4
  00501	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1316 : 							_Rrotate(_Pnode);

  00504	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00507	50		 push	 eax
  00508	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0050b	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate

; 1317 : 							_Pnode = this->_Right(_Fixnodeparent);

  00510	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00513	50		 push	 eax
  00514	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  00519	83 c4 04	 add	 esp, 4
  0051c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0051e	89 4d ec	 mov	 DWORD PTR __Pnode$[ebp], ecx
$LN9@erase:

; 1318 : 							}
; 1319 : 
; 1320 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  00521	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00524	50		 push	 eax
  00525	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  0052a	83 c4 04	 add	 esp, 4
  0052d	8b f0		 mov	 esi, eax
  0052f	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00532	51		 push	 ecx
  00533	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  00538	83 c4 04	 add	 esp, 4
  0053b	8a 16		 mov	 dl, BYTE PTR [esi]
  0053d	88 10		 mov	 BYTE PTR [eax], dl

; 1321 : 						this->_Color(_Fixnodeparent) = this->_Black;

  0053f	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00542	50		 push	 eax
  00543	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  00548	83 c4 04	 add	 esp, 4
  0054b	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1322 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;

  0054e	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00551	50		 push	 eax
  00552	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  00557	83 c4 04	 add	 esp, 4
  0055a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0055c	51		 push	 ecx
  0055d	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  00562	83 c4 04	 add	 esp, 4
  00565	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1323 : 						_Lrotate(_Fixnodeparent);

  00568	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0056b	50		 push	 eax
  0056c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0056f	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate

; 1324 : 						break;	// tree now recolored/rebalanced

  00574	e9 99 01 00 00	 jmp	 $LN16@erase
$LN12@erase:

; 1325 : 						}
; 1326 : 					}
; 1327 : 				else

  00579	e9 8f 01 00 00	 jmp	 $LN8@erase
$LN15@erase:

; 1328 : 					{	// fixup right subtree
; 1329 : 					_Pnode = this->_Left(_Fixnodeparent);

  0057e	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00581	50		 push	 eax
  00582	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  00587	83 c4 04	 add	 esp, 4
  0058a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0058c	89 4d ec	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 1330 : 					if (this->_Color(_Pnode) == this->_Red)

  0058f	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00592	50		 push	 eax
  00593	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  00598	83 c4 04	 add	 esp, 4
  0059b	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0059e	85 c9		 test	 ecx, ecx
  005a0	75 3b		 jne	 SHORT $LN7@erase

; 1331 : 						{	// rotate red up from left subtree
; 1332 : 						this->_Color(_Pnode) = this->_Black;

  005a2	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  005a5	50		 push	 eax
  005a6	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  005ab	83 c4 04	 add	 esp, 4
  005ae	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1333 : 						this->_Color(_Fixnodeparent) = this->_Red;

  005b1	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  005b4	50		 push	 eax
  005b5	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  005ba	83 c4 04	 add	 esp, 4
  005bd	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1334 : 						_Rrotate(_Fixnodeparent);

  005c0	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  005c3	50		 push	 eax
  005c4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  005c7	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate

; 1335 : 						_Pnode = this->_Left(_Fixnodeparent);

  005cc	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  005cf	50		 push	 eax
  005d0	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  005d5	83 c4 04	 add	 esp, 4
  005d8	8b 08		 mov	 ecx, DWORD PTR [eax]
  005da	89 4d ec	 mov	 DWORD PTR __Pnode$[ebp], ecx
$LN7@erase:

; 1336 : 						}
; 1337 : 					if (this->_Isnil(_Pnode))

  005dd	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  005e0	50		 push	 eax
  005e1	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  005e6	83 c4 04	 add	 esp, 4
  005e9	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  005ec	85 c9		 test	 ecx, ecx
  005ee	74 0b		 je	 SHORT $LN6@erase

; 1338 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

  005f0	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  005f3	89 45 f4	 mov	 DWORD PTR __Fixnode$[ebp], eax

; 1339 : 					else if (this->_Color(this->_Right(_Pnode)) ==

  005f6	e9 12 01 00 00	 jmp	 $LN8@erase
$LN6@erase:

; 1340 : 						this->_Black
; 1341 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)

  005fb	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  005fe	50		 push	 eax
  005ff	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  00604	83 c4 04	 add	 esp, 4
  00607	8b 08		 mov	 ecx, DWORD PTR [eax]
  00609	51		 push	 ecx
  0060a	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  0060f	83 c4 04	 add	 esp, 4
  00612	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00615	83 fa 01	 cmp	 edx, 1
  00618	75 39		 jne	 SHORT $LN4@erase
  0061a	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0061d	50		 push	 eax
  0061e	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  00623	83 c4 04	 add	 esp, 4
  00626	8b 08		 mov	 ecx, DWORD PTR [eax]
  00628	51		 push	 ecx
  00629	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  0062e	83 c4 04	 add	 esp, 4
  00631	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00634	83 fa 01	 cmp	 edx, 1
  00637	75 1a		 jne	 SHORT $LN4@erase

; 1342 : 						{	// redden left subtree with black children
; 1343 : 						this->_Color(_Pnode) = this->_Red;

  00639	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0063c	50		 push	 eax
  0063d	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  00642	83 c4 04	 add	 esp, 4
  00645	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1344 : 						_Fixnode = _Fixnodeparent;

  00648	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0064b	89 45 f4	 mov	 DWORD PTR __Fixnode$[ebp], eax

; 1345 : 						}
; 1346 : 					else

  0064e	e9 ba 00 00 00	 jmp	 $LN8@erase
$LN4@erase:

; 1347 : 						{	// must rearrange left subtree
; 1348 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)

  00653	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00656	50		 push	 eax
  00657	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  0065c	83 c4 04	 add	 esp, 4
  0065f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00661	51		 push	 ecx
  00662	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  00667	83 c4 04	 add	 esp, 4
  0066a	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0066d	83 fa 01	 cmp	 edx, 1
  00670	75 46		 jne	 SHORT $LN2@erase

; 1349 : 							{	// rotate red up from right sub-subtree
; 1350 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;

  00672	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00675	50		 push	 eax
  00676	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  0067b	83 c4 04	 add	 esp, 4
  0067e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00680	51		 push	 ecx
  00681	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  00686	83 c4 04	 add	 esp, 4
  00689	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1351 : 							this->_Color(_Pnode) = this->_Red;

  0068c	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0068f	50		 push	 eax
  00690	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  00695	83 c4 04	 add	 esp, 4
  00698	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1352 : 							_Lrotate(_Pnode);

  0069b	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0069e	50		 push	 eax
  0069f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  006a2	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate

; 1353 : 							_Pnode = this->_Left(_Fixnodeparent);

  006a7	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  006aa	50		 push	 eax
  006ab	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  006b0	83 c4 04	 add	 esp, 4
  006b3	8b 08		 mov	 ecx, DWORD PTR [eax]
  006b5	89 4d ec	 mov	 DWORD PTR __Pnode$[ebp], ecx
$LN2@erase:

; 1354 : 							}
; 1355 : 
; 1356 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  006b8	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  006bb	50		 push	 eax
  006bc	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  006c1	83 c4 04	 add	 esp, 4
  006c4	8b f0		 mov	 esi, eax
  006c6	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  006c9	51		 push	 ecx
  006ca	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  006cf	83 c4 04	 add	 esp, 4
  006d2	8a 16		 mov	 dl, BYTE PTR [esi]
  006d4	88 10		 mov	 BYTE PTR [eax], dl

; 1357 : 						this->_Color(_Fixnodeparent) = this->_Black;

  006d6	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  006d9	50		 push	 eax
  006da	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  006df	83 c4 04	 add	 esp, 4
  006e2	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1358 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;

  006e5	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  006e8	50		 push	 eax
  006e9	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  006ee	83 c4 04	 add	 esp, 4
  006f1	8b 08		 mov	 ecx, DWORD PTR [eax]
  006f3	51		 push	 ecx
  006f4	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  006f9	83 c4 04	 add	 esp, 4
  006fc	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1359 : 						_Rrotate(_Fixnodeparent);

  006ff	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00702	50		 push	 eax
  00703	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00706	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate

; 1360 : 						break;	// tree now recolored/rebalanced

  0070b	eb 05		 jmp	 SHORT $LN16@erase
$LN8@erase:

; 1361 : 						}
; 1362 : 					}

  0070d	e9 82 fc ff ff	 jmp	 $LN17@erase
$LN16@erase:

; 1363 : 
; 1364 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black

  00712	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00715	50		 push	 eax
  00716	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  0071b	83 c4 04	 add	 esp, 4
  0071e	c6 00 01	 mov	 BYTE PTR [eax], 1
$LN19@erase:

; 1365 : 			}
; 1366 : 
; 1367 : 		_Dest_val(this->_Alval,
; 1368 : 			_STD addressof(this->_Myval(_Erasednode)));	// delete erased node

  00721	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00724	50		 push	 eax
  00725	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Myval
  0072a	83 c4 04	 add	 esp, 4
  0072d	50		 push	 eax
  0072e	e8 00 00 00 00	 call	 ??$addressof@U?$pair@$$CBHH@std@@@std@@YAPAU?$pair@$$CBHH@0@AAU10@@Z ; std::addressof<std::pair<int const ,int> >
  00733	83 c4 04	 add	 esp, 4
  00736	50		 push	 eax
  00737	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0073a	83 c1 0d	 add	 ecx, 13			; 0000000dH
  0073d	51		 push	 ecx
  0073e	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBHH@std@@@std@@U?$pair@$$CBHH@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHH@std@@@0@PAU?$pair@$$CBHH@0@@Z ; std::_Dest_val<std::allocator<std::pair<int const ,int> >,std::pair<int const ,int> >
  00743	83 c4 08	 add	 esp, 8

; 1369 : 
; 1370 : 		this->_Alnod.deallocate(_Erasednode, 1);

  00746	6a 01		 push	 1
  00748	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0074b	50		 push	 eax
  0074c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0074f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00752	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::deallocate

; 1371 : 
; 1372 : 		if (0 < this->_Mysize)

  00757	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0075a	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0075e	76 0f		 jbe	 SHORT $LN1@erase

; 1373 : 			--this->_Mysize;

  00760	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00763	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00766	83 e9 01	 sub	 ecx, 1
  00769	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0076c	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
$LN1@erase:

; 1374 : 
; 1375 : 		return (iterator(_Where._Ptr, this));	// return successor iterator

  0076f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00772	50		 push	 eax
  00773	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00776	51		 push	 ecx
  00777	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0077a	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >
  0077f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN42@erase:

; 1376 : 		}

  00782	5f		 pop	 edi
  00783	5e		 pop	 esi
  00784	5b		 pop	 ebx
  00785	8b e5		 mov	 esp, ebp
  00787	5d		 pop	 ebp
  00788	c2 08 00	 ret	 8
?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
_TEXT	ENDS
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Erase
; Function compile flags: /Odtp /ZI
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::clear, COMDAT
; _this$ = ecx

; 1410 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		this->_Orphan_ptr(*this, 0);
; 1413 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1414 : 
; 1415 : 		_Erase(_Root());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root
  00014	8b 00		 mov	 eax, DWORD PTR [eax]
  00016	50		 push	 eax
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Erase

; 1416 : 		_Root() = this->_Myhead;

  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002d	89 10		 mov	 DWORD PTR [eax], edx

; 1417 : 		_Lmost() = this->_Myhead;

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lmost
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0003d	89 10		 mov	 DWORD PTR [eax], edx

; 1418 : 		_Rmost() = this->_Myhead;

  0003f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rmost
  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0004d	89 10		 mov	 DWORD PTR [eax], edx

; 1419 : 		this->_Mysize = 0;

  0004f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00052	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 1420 : 		}

  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::clear
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@V?$allocator@H@1@@Z ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
PUBLIC	??0?$allocator@H@std@@QAE@XZ			; std::allocator<int>::allocator<int>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T238978 = -72						; size = 4
_this$ = -4						; size = 4
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	51		 push	 ecx
  0000d	8b cc		 mov	 ecx, esp
  0000f	89 65 b8	 mov	 DWORD PTR $T238978[ebp], esp
  00012	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@V?$allocator@H@1@@Z ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >

; 508  : 		}

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 704  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 705  : 		_Tidy();

  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy

; 706  : 		}

  0003a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
  00049	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
__ehhandler$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
; Function compile flags: /Odtp /ZI
;	COMDAT ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC	; std::vector<int,std::allocator<int> >::size, COMDAT
; _this$ = ecx

; 878  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	c1 f8 02	 sar	 eax, 2

; 880  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP	; std::vector<int,std::allocator<int> >::size
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z PROC	; std::vector<int,std::allocator<int> >::operator[], COMDAT
; _this$ = ecx

; 928  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 929  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 930  : 		if (size() <= _Pos)
; 931  : 			{	// report error
; 932  : 			_DEBUG_ERROR("vector subscript out of range");
; 933  : 			_SCL_SECURE_OUT_OF_RANGE;
; 934  : 			}
; 935  : 
; 936  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 937  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 938  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 939  : 
; 940  : 		return (*(this->_Myfirst + _Pos));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	8b 55 08	 mov	 edx, DWORD PTR __Pos$[ebp]
  00014	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]

; 941  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ENDP	; std::vector<int,std::allocator<int> >::operator[]
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@H@std@@HABH@std@@YAXAAV?$allocator@H@0@PAHABH@Z ; std::_Cons_val<std::allocator<int>,int,int const &>
PUBLIC	??$_Cons_val@V?$allocator@H@std@@HAAH@std@@YAXAAV?$allocator@H@0@PAHAAH@Z ; std::_Cons_val<std::allocator<int>,int,int &>
PUBLIC	?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Orphan_range
PUBLIC	?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z ; std::vector<int,std::allocator<int> >::_Reserve
PUBLIC	?_Inside@?$vector@HV?$allocator@H@std@@@std@@IBE_NPBH@Z ; std::vector<int,std::allocator<int> >::_Inside
PUBLIC	??$addressof@$$CBH@std@@YAPBHABH@Z		; std::addressof<int const >
; Function compile flags: /Odtp /ZI
;	COMDAT ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
__Idx$233422 = -8					; size = 4
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z PROC ; std::vector<int,std::allocator<int> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$addressof@$$CBH@std@@YAPBHABH@Z ; std::addressof<int const >
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Inside@?$vector@HV?$allocator@H@std@@@std@@IBE_NPBH@Z ; std::vector<int,std::allocator<int> >::_Inside
  00021	0f b6 c8	 movzx	 ecx, al
  00024	85 c9		 test	 ecx, ecx
  00026	74 78		 je	 SHORT $LN4@push_back

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$addressof@$$CBH@std@@YAPBHABH@Z ; std::addressof<int const >
  00031	83 c4 04	 add	 esp, 4
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	2b 01		 sub	 eax, DWORD PTR [ecx]
  00039	c1 f8 02	 sar	 eax, 2
  0003c	89 45 f8	 mov	 DWORD PTR __Idx$233422[ebp], eax

; 980  : 			if (this->_Mylast == this->_Myend)

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00048	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0004b	75 0a		 jne	 SHORT $LN3@push_back

; 981  : 				_Reserve(1);

  0004d	6a 01		 push	 1
  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	e8 00 00 00 00	 call	 ?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z ; std::vector<int,std::allocator<int> >::_Reserve
$LN3@push_back:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  00057	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005d	51		 push	 ecx
  0005e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00061	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00064	50		 push	 eax
  00065	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Orphan_range

; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  0006d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00070	8b 08		 mov	 ecx, DWORD PTR [eax]
  00072	8b 55 f8	 mov	 edx, DWORD PTR __Idx$233422[ebp]
  00075	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  00078	50		 push	 eax
  00079	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007f	52		 push	 edx
  00080	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00083	83 c0 0c	 add	 eax, 12			; 0000000cH
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@H@std@@HAAH@std@@YAXAAV?$allocator@H@0@PAHAAH@Z ; std::_Cons_val<std::allocator<int>,int,int &>
  0008c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 986  : 			++this->_Mylast;

  0008f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00092	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00095	83 c1 04	 add	 ecx, 4
  00098	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0009b	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 987  : 			}
; 988  : 		else

  0009e	eb 57		 jmp	 SHORT $LN5@push_back
$LN4@push_back:

; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  000a0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a9	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  000ac	75 0a		 jne	 SHORT $LN1@push_back

; 991  : 				_Reserve(1);

  000ae	6a 01		 push	 1
  000b0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b3	e8 00 00 00 00	 call	 ?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z ; std::vector<int,std::allocator<int> >::_Reserve
$LN1@push_back:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  000b8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000bb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000be	51		 push	 ecx
  000bf	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c2	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000c5	50		 push	 eax
  000c6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c9	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Orphan_range

; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  000ce	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  000d1	50		 push	 eax
  000d2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d5	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000d8	52		 push	 edx
  000d9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000dc	83 c0 0c	 add	 eax, 12			; 0000000cH
  000df	50		 push	 eax
  000e0	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@H@std@@HABH@std@@YAXAAV?$allocator@H@0@PAHABH@Z ; std::_Cons_val<std::allocator<int>,int,int const &>
  000e5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  000e8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000eb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ee	83 c1 04	 add	 ecx, 4
  000f1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000f4	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN5@push_back:

; 997  : 			}
; 998  : 		}

  000f7	5f		 pop	 edi
  000f8	5e		 pop	 esi
  000f9	5b		 pop	 ebx
  000fa	8b e5		 mov	 esp, ebp
  000fc	5d		 pop	 ebp
  000fd	c2 04 00	 ret	 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::vector<int,std::allocator<int> >::push_back
_TEXT	ENDS
PUBLIC	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase
PUBLIC	?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
PUBLIC	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
; Function compile flags: /Odtp /ZI
;	COMDAT ?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T238997 = -88						; size = 4
$T238998 = -84						; size = 4
$T238999 = -80						; size = 4
$T239000 = -76						; size = 4
$T239001 = -72						; size = 4
_this$ = -4						; size = 4
?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ PROC	; std::vector<int,std::allocator<int> >::clear, COMDAT
; _this$ = ecx

; 1217 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1218 : 		erase(begin(), end());

  0000c	8d 45 ac	 lea	 eax, DWORD PTR $T238998[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d a8	 mov	 DWORD PTR $T238997[ebp], ecx
  0001d	8d 55 b4	 lea	 edx, DWORD PTR $T239000[ebp]
  00020	52		 push	 edx
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 b0	 mov	 DWORD PTR $T238999[ebp], eax
  0002e	8b 4d a8	 mov	 ecx, DWORD PTR $T238997[ebp]
  00031	51		 push	 ecx
  00032	8b 55 b0	 mov	 edx, DWORD PTR $T238999[ebp]
  00035	52		 push	 edx
  00036	8d 45 b8	 lea	 eax, DWORD PTR $T239001[ebp]
  00039	50		 push	 eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase

; 1219 : 		}

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ENDP	; std::vector<int,std::allocator<int> >::clear
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >
PUBLIC	??0?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\map
;	COMDAT ??0?$map@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T239004 = -70						; size = 1
$T239005 = -69						; size = 1
_this$ = -4						; size = 4
??0?$map@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@@std@@QAE@XZ PROC ; std::map<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > > >::map<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > > >, COMDAT
; _this$ = ecx

; 106  : 		{	// construct empty map from defaults

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 4d ba	 lea	 ecx, DWORD PTR $T239004[ebp]
  0000f	e8 00 00 00 00	 call	 ??0?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >
  00014	50		 push	 eax
  00015	8d 45 bb	 lea	 eax, DWORD PTR $T239005[ebp]
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >

; 107  : 		}

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??0?$map@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@@std@@QAE@XZ ENDP ; std::map<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > > >::map<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > > >
_TEXT	ENDS
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::~_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Tidy
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xtree
xdata$x	SEGMENT
__unwindtable$??1?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::~_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >, COMDAT
; _this$ = ecx

; 790  : 		{	// destroy tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 791  : 		_Tidy();

  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?_Tidy@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Tidy

; 792  : 		}

  0003a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??1?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::~_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >
  00049	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::~_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >
__ehhandler$??1?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::~_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::end, COMDAT
; _this$ = ecx

; 816  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 817  : 		return (iterator(this->_Myhead, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	52		 push	 edx
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >
  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 818  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::end
_TEXT	ENDS
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Rmost
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Lmost
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Erase
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Root
; Function compile flags: /Odtp /ZI
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?clear@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::clear, COMDAT
; _this$ = ecx

; 1410 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		this->_Orphan_ptr(*this, 0);
; 1413 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1414 : 
; 1415 : 		_Erase(_Root());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Root
  00014	8b 00		 mov	 eax, DWORD PTR [eax]
  00016	50		 push	 eax
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Erase

; 1416 : 		_Root() = this->_Myhead;

  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Root
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002d	89 10		 mov	 DWORD PTR [eax], edx

; 1417 : 		_Lmost() = this->_Myhead;

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Lmost
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0003d	89 10		 mov	 DWORD PTR [eax], edx

; 1418 : 		_Rmost() = this->_Myhead;

  0003f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Rmost
  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0004d	89 10		 mov	 DWORD PTR [eax], edx

; 1419 : 		this->_Mysize = 0;

  0004f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00052	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 1420 : 		}

  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::clear
_TEXT	ENDS
PUBLIC	??R?$less@H@std@@QBE_NABH0@Z			; std::less<int>::operator()
PUBLIC	?_Key@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Key
PUBLIC	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >,std::_Iterator_base0>::_Mynode
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::lower_bound
; Function compile flags: /Odtp /ZI
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@ABH@Z
_TEXT	SEGMENT
tv137 = -88						; size = 4
$T239022 = -84						; size = 4
$T239023 = -80						; size = 4
$T239025 = -76						; size = 4
__Where$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::find, COMDAT
; _this$ = ecx

; 1423 : 		{	// find an element in mutable sequence that matches _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1424 : 		iterator _Where = lower_bound(_Keyval);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Keyval$[ebp]
  0000f	50		 push	 eax
  00010	8d 4d f8	 lea	 ecx, DWORD PTR __Where$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?lower_bound@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::lower_bound

; 1425 : 		return (_Where == end()
; 1426 : 			|| _DEBUG_LT_PRED(this->comp,
; 1427 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1428 : 					? end() : _Where);

  0001c	8d 45 b0	 lea	 eax, DWORD PTR $T239023[ebp]
  0001f	50		 push	 eax
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::end
  00028	50		 push	 eax
  00029	8d 4d f8	 lea	 ecx, DWORD PTR __Where$[ebp]
  0002c	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::operator==
  00031	0f b6 c8	 movzx	 ecx, al
  00034	85 c9		 test	 ecx, ecx
  00036	75 2d		 jne	 SHORT $LN3@find
  00038	8d 4d f8	 lea	 ecx, DWORD PTR __Where$[ebp]
  0003b	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >,std::_Iterator_base0>::_Mynode
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ?_Key@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Key
  00046	83 c4 04	 add	 esp, 4
  00049	50		 push	 eax
  0004a	8b 55 0c	 mov	 edx, DWORD PTR __Keyval$[ebp]
  0004d	52		 push	 edx
  0004e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  00056	0f b6 c0	 movzx	 eax, al
  00059	85 c0		 test	 eax, eax
  0005b	75 08		 jne	 SHORT $LN3@find
  0005d	8d 4d f8	 lea	 ecx, DWORD PTR __Where$[ebp]
  00060	89 4d a8	 mov	 DWORD PTR tv137[ebp], ecx
  00063	eb 0f		 jmp	 SHORT $LN4@find
$LN3@find:
  00065	8d 55 b4	 lea	 edx, DWORD PTR $T239025[ebp]
  00068	52		 push	 edx
  00069	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::end
  00071	89 45 a8	 mov	 DWORD PTR tv137[ebp], eax
$LN4@find:
  00074	8b 45 a8	 mov	 eax, DWORD PTR tv137[ebp]
  00077	89 45 ac	 mov	 DWORD PTR $T239022[ebp], eax
  0007a	8b 4d ac	 mov	 ecx, DWORD PTR $T239022[ebp]
  0007d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00082	89 10		 mov	 DWORD PTR [eax], edx
  00084	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1429 : 		}

  00087	5f		 pop	 edi
  00088	5e		 pop	 esi
  00089	5b		 pop	 ebx
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c2 08 00	 ret	 8
?find@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::find
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >
PUBLIC	??0?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\map
;	COMDAT ??0?$map@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T239029 = -70						; size = 1
$T239030 = -69						; size = 1
_this$ = -4						; size = 4
??0?$map@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@@std@@QAE@XZ PROC ; std::map<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > > >::map<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > > >, COMDAT
; _this$ = ecx

; 106  : 		{	// construct empty map from defaults

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 4d ba	 lea	 ecx, DWORD PTR $T239029[ebp]
  0000f	e8 00 00 00 00	 call	 ??0?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >
  00014	50		 push	 eax
  00015	8d 45 bb	 lea	 eax, DWORD PTR $T239030[ebp]
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >

; 107  : 		}

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??0?$map@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@@std@@QAE@XZ ENDP ; std::map<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > > >::map<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > > >
_TEXT	ENDS
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::~_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Tidy
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xtree
xdata$x	SEGMENT
__unwindtable$??1?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::~_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >, COMDAT
; _this$ = ecx

; 790  : 		{	// destroy tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 791  : 		_Tidy();

  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?_Tidy@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Tidy

; 792  : 		}

  0003a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??1?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::~_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >
  00049	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::~_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >
__ehhandler$??1?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::~_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::end, COMDAT
; _this$ = ecx

; 816  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 817  : 		return (iterator(this->_Myhead, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	52		 push	 edx
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >
  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 818  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::end
_TEXT	ENDS
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Rmost
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Lmost
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Erase
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Root
; Function compile flags: /Odtp /ZI
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?clear@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::clear, COMDAT
; _this$ = ecx

; 1410 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		this->_Orphan_ptr(*this, 0);
; 1413 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1414 : 
; 1415 : 		_Erase(_Root());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Root
  00014	8b 00		 mov	 eax, DWORD PTR [eax]
  00016	50		 push	 eax
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Erase

; 1416 : 		_Root() = this->_Myhead;

  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Root
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002d	89 10		 mov	 DWORD PTR [eax], edx

; 1417 : 		_Lmost() = this->_Myhead;

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Lmost
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0003d	89 10		 mov	 DWORD PTR [eax], edx

; 1418 : 		_Rmost() = this->_Myhead;

  0003f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Rmost
  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0004d	89 10		 mov	 DWORD PTR [eax], edx

; 1419 : 		this->_Mysize = 0;

  0004f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00052	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 1420 : 		}

  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::clear
_TEXT	ENDS
PUBLIC	?_Key@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Key
PUBLIC	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >,std::_Iterator_base0>::_Mynode
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::lower_bound
; Function compile flags: /Odtp /ZI
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@ABH@Z
_TEXT	SEGMENT
tv137 = -88						; size = 4
$T239047 = -84						; size = 4
$T239048 = -80						; size = 4
$T239050 = -76						; size = 4
__Where$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::find, COMDAT
; _this$ = ecx

; 1423 : 		{	// find an element in mutable sequence that matches _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1424 : 		iterator _Where = lower_bound(_Keyval);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Keyval$[ebp]
  0000f	50		 push	 eax
  00010	8d 4d f8	 lea	 ecx, DWORD PTR __Where$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?lower_bound@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::lower_bound

; 1425 : 		return (_Where == end()
; 1426 : 			|| _DEBUG_LT_PRED(this->comp,
; 1427 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1428 : 					? end() : _Where);

  0001c	8d 45 b0	 lea	 eax, DWORD PTR $T239048[ebp]
  0001f	50		 push	 eax
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::end
  00028	50		 push	 eax
  00029	8d 4d f8	 lea	 ecx, DWORD PTR __Where$[ebp]
  0002c	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::operator==
  00031	0f b6 c8	 movzx	 ecx, al
  00034	85 c9		 test	 ecx, ecx
  00036	75 2d		 jne	 SHORT $LN3@find@2
  00038	8d 4d f8	 lea	 ecx, DWORD PTR __Where$[ebp]
  0003b	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >,std::_Iterator_base0>::_Mynode
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ?_Key@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Key
  00046	83 c4 04	 add	 esp, 4
  00049	50		 push	 eax
  0004a	8b 55 0c	 mov	 edx, DWORD PTR __Keyval$[ebp]
  0004d	52		 push	 edx
  0004e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  00056	0f b6 c0	 movzx	 eax, al
  00059	85 c0		 test	 eax, eax
  0005b	75 08		 jne	 SHORT $LN3@find@2
  0005d	8d 4d f8	 lea	 ecx, DWORD PTR __Where$[ebp]
  00060	89 4d a8	 mov	 DWORD PTR tv137[ebp], ecx
  00063	eb 0f		 jmp	 SHORT $LN4@find@2
$LN3@find@2:
  00065	8d 55 b4	 lea	 edx, DWORD PTR $T239050[ebp]
  00068	52		 push	 edx
  00069	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::end
  00071	89 45 a8	 mov	 DWORD PTR tv137[ebp], eax
$LN4@find@2:
  00074	8b 45 a8	 mov	 eax, DWORD PTR tv137[ebp]
  00077	89 45 ac	 mov	 DWORD PTR $T239047[ebp], eax
  0007a	8b 4d ac	 mov	 ecx, DWORD PTR $T239047[ebp]
  0007d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00082	89 10		 mov	 DWORD PTR [eax], edx
  00084	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1429 : 		}

  00087	5f		 pop	 edi
  00088	5e		 pop	 esi
  00089	5b		 pop	 ebx
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c2 08 00	 ret	 8
?find@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::find
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE@V?$allocator@UCASTLEDEEP_EVENTTIME@@@1@@Z ; std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >
PUBLIC	??0?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAE@XZ ; std::allocator<CASTLEDEEP_EVENTTIME>::allocator<CASTLEDEEP_EVENTTIME>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T239054 = -72						; size = 4
_this$ = -4						; size = 4
??0?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE@XZ PROC ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	51		 push	 ecx
  0000d	8b cc		 mov	 ecx, esp
  0000f	89 65 b8	 mov	 DWORD PTR $T239054[ebp], esp
  00012	e8 00 00 00 00	 call	 ??0?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAE@XZ ; std::allocator<CASTLEDEEP_EVENTTIME>::allocator<CASTLEDEEP_EVENTTIME>
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE@V?$allocator@UCASTLEDEEP_EVENTTIME@@@1@@Z ; std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >

; 508  : 		}

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE@XZ ENDP ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE@XZ ; std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::~_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >
PUBLIC	?_Tidy@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@IAEXXZ ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??1?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE@XZ PROC ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::~vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >, COMDAT
; _this$ = ecx

; 704  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 705  : 		_Tidy();

  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@IAEXXZ ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::_Tidy

; 706  : 		}

  0003a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??1?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE@XZ ; std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::~_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >
  00049	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE@XZ ; std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::~_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >
__ehhandler$??1?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE@XZ ENDP ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::~vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QAE@PAUCASTLEDEEP_EVENTTIME@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::_Vector_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ?begin@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@2@XZ PROC ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 782  : 		return (iterator(this->_Myfirst, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	52		 push	 edx
  00016	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00019	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QAE@PAUCASTLEDEEP_EVENTTIME@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::_Vector_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >
  0001e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 783  : 		}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?begin@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@2@XZ ENDP ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::begin
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?end@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@2@XZ PROC ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 792  : 		return (iterator(this->_Mylast, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	52		 push	 edx
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QAE@PAUCASTLEDEEP_EVENTTIME@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::_Vector_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >
  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 793  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?end@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@2@XZ ENDP ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::end
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?empty@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?empty@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QBE_NXZ PROC ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::empty, COMDAT
; _this$ = ecx

; 888  : 		{	// test if sequence is empty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 889  : 		return (this->_Myfirst == this->_Mylast);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 10		 mov	 edx, DWORD PTR [eax]
  00014	33 c0		 xor	 eax, eax
  00016	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00019	0f 94 c0	 sete	 al

; 890  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
?empty@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QBE_NXZ ENDP ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::empty
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@UCASTLEDEEP_EVENTTIME@@ABU3@@std@@YAXAAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@PAUCASTLEDEEP_EVENTTIME@@ABU2@@Z ; std::_Cons_val<std::allocator<CASTLEDEEP_EVENTTIME>,CASTLEDEEP_EVENTTIME,CASTLEDEEP_EVENTTIME const &>
PUBLIC	??$_Cons_val@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@UCASTLEDEEP_EVENTTIME@@AAU3@@std@@YAXAAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@PAUCASTLEDEEP_EVENTTIME@@AAU2@@Z ; std::_Cons_val<std::allocator<CASTLEDEEP_EVENTTIME>,CASTLEDEEP_EVENTTIME,CASTLEDEEP_EVENTTIME &>
PUBLIC	?_Orphan_range@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@IBEXPAUCASTLEDEEP_EVENTTIME@@0@Z ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::_Orphan_range
PUBLIC	?_Reserve@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@IAEXI@Z ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::_Reserve
PUBLIC	?_Inside@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@IBE_NPBUCASTLEDEEP_EVENTTIME@@@Z ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::_Inside
PUBLIC	??$addressof@$$CBUCASTLEDEEP_EVENTTIME@@@std@@YAPBUCASTLEDEEP_EVENTTIME@@ABU1@@Z ; std::addressof<CASTLEDEEP_EVENTTIME const >
; Function compile flags: /Odtp /ZI
;	COMDAT ?push_back@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAEXABUCASTLEDEEP_EVENTTIME@@@Z
_TEXT	SEGMENT
__Idx$233644 = -8					; size = 4
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAEXABUCASTLEDEEP_EVENTTIME@@@Z PROC ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$addressof@$$CBUCASTLEDEEP_EVENTTIME@@@std@@YAPBUCASTLEDEEP_EVENTTIME@@ABU1@@Z ; std::addressof<CASTLEDEEP_EVENTTIME const >
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Inside@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@IBE_NPBUCASTLEDEEP_EVENTTIME@@@Z ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::_Inside
  00021	0f b6 c8	 movzx	 ecx, al
  00024	85 c9		 test	 ecx, ecx
  00026	74 78		 je	 SHORT $LN4@push_back@2

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$addressof@$$CBUCASTLEDEEP_EVENTTIME@@@std@@YAPBUCASTLEDEEP_EVENTTIME@@ABU1@@Z ; std::addressof<CASTLEDEEP_EVENTTIME const >
  00031	83 c4 04	 add	 esp, 4
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	2b 01		 sub	 eax, DWORD PTR [ecx]
  00039	c1 f8 03	 sar	 eax, 3
  0003c	89 45 f8	 mov	 DWORD PTR __Idx$233644[ebp], eax

; 980  : 			if (this->_Mylast == this->_Myend)

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00048	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0004b	75 0a		 jne	 SHORT $LN3@push_back@2

; 981  : 				_Reserve(1);

  0004d	6a 01		 push	 1
  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@IAEXI@Z ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::_Reserve
$LN3@push_back@2:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  00057	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005d	51		 push	 ecx
  0005e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00061	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00064	50		 push	 eax
  00065	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@IBEXPAUCASTLEDEEP_EVENTTIME@@0@Z ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::_Orphan_range

; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  0006d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00070	8b 08		 mov	 ecx, DWORD PTR [eax]
  00072	8b 55 f8	 mov	 edx, DWORD PTR __Idx$233644[ebp]
  00075	8d 04 d1	 lea	 eax, DWORD PTR [ecx+edx*8]
  00078	50		 push	 eax
  00079	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007f	52		 push	 edx
  00080	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00083	83 c0 0c	 add	 eax, 12			; 0000000cH
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@UCASTLEDEEP_EVENTTIME@@AAU3@@std@@YAXAAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@PAUCASTLEDEEP_EVENTTIME@@AAU2@@Z ; std::_Cons_val<std::allocator<CASTLEDEEP_EVENTTIME>,CASTLEDEEP_EVENTTIME,CASTLEDEEP_EVENTTIME &>
  0008c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 986  : 			++this->_Mylast;

  0008f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00092	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00095	83 c1 08	 add	 ecx, 8
  00098	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0009b	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 987  : 			}
; 988  : 		else

  0009e	eb 57		 jmp	 SHORT $LN5@push_back@2
$LN4@push_back@2:

; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  000a0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a9	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  000ac	75 0a		 jne	 SHORT $LN1@push_back@2

; 991  : 				_Reserve(1);

  000ae	6a 01		 push	 1
  000b0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b3	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@IAEXI@Z ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::_Reserve
$LN1@push_back@2:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  000b8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000bb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000be	51		 push	 ecx
  000bf	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c2	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000c5	50		 push	 eax
  000c6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c9	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@IBEXPAUCASTLEDEEP_EVENTTIME@@0@Z ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::_Orphan_range

; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  000ce	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  000d1	50		 push	 eax
  000d2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d5	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000d8	52		 push	 edx
  000d9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000dc	83 c0 0c	 add	 eax, 12			; 0000000cH
  000df	50		 push	 eax
  000e0	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@UCASTLEDEEP_EVENTTIME@@ABU3@@std@@YAXAAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@PAUCASTLEDEEP_EVENTTIME@@ABU2@@Z ; std::_Cons_val<std::allocator<CASTLEDEEP_EVENTTIME>,CASTLEDEEP_EVENTTIME,CASTLEDEEP_EVENTTIME const &>
  000e5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  000e8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000eb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ee	83 c1 08	 add	 ecx, 8
  000f1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000f4	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN5@push_back@2:

; 997  : 			}
; 998  : 		}

  000f7	5f		 pop	 edi
  000f8	5e		 pop	 esi
  000f9	5b		 pop	 ebx
  000fa	8b e5		 mov	 esp, ebp
  000fc	5d		 pop	 ebp
  000fd	c2 04 00	 ret	 4
?push_back@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAEXABUCASTLEDEEP_EVENTTIME@@@Z ENDP ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::push_back
_TEXT	ENDS
PUBLIC	?erase@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@2@0@Z ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::erase
; Function compile flags: /Odtp /ZI
;	COMDAT ?clear@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T239075 = -88						; size = 4
$T239076 = -84						; size = 4
$T239077 = -80						; size = 4
$T239078 = -76						; size = 4
$T239079 = -72						; size = 4
_this$ = -4						; size = 4
?clear@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAEXXZ PROC ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::clear, COMDAT
; _this$ = ecx

; 1217 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1218 : 		erase(begin(), end());

  0000c	8d 45 ac	 lea	 eax, DWORD PTR $T239076[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?end@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@2@XZ ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::end
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d a8	 mov	 DWORD PTR $T239075[ebp], ecx
  0001d	8d 55 b4	 lea	 edx, DWORD PTR $T239078[ebp]
  00020	52		 push	 edx
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?begin@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@2@XZ ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::begin
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 b0	 mov	 DWORD PTR $T239077[ebp], eax
  0002e	8b 4d a8	 mov	 ecx, DWORD PTR $T239075[ebp]
  00031	51		 push	 ecx
  00032	8b 55 b0	 mov	 edx, DWORD PTR $T239077[ebp]
  00035	52		 push	 edx
  00036	8d 45 b8	 lea	 eax, DWORD PTR $T239079[ebp]
  00039	50		 push	 eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?erase@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@2@0@Z ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::erase

; 1219 : 		}

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?clear@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAEXXZ ENDP ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::clear
_TEXT	ENDS
PUBLIC	??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::operator*
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::operator->, COMDAT
; _this$ = ecx

; 400  : 		{	// return pointer to class object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 401  : 		return (&**this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::operator*

; 402  : 		}

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::operator->
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::operator==, COMDAT
; _this$ = ecx

; 316  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 317  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 318  : 		if (this->_Getcont() == 0
; 319  : 			|| this->_Getcont() != _Right._Getcont())
; 320  : 			{	// report error
; 321  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 322  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 323  : 			}
; 324  : 
; 325  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 326  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 327  : 			&& this->_Getcont() == _Right._Getcont());
; 328  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 329  : 
; 330  : 		return (this->_Ptr == _Right._Ptr);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00012	8b 10		 mov	 edx, DWORD PTR [eax]
  00014	33 c0		 xor	 eax, eax
  00016	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00018	0f 94 c0	 sete	 al

; 331  : 		}

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::operator==
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::operator!=, COMDAT
; _this$ = ecx

; 334  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 335  : 		return (!(*this == _Right));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::operator==
  00018	0f b6 c0	 movzx	 eax, al
  0001b	f7 d8		 neg	 eax
  0001d	1b c0		 sbb	 eax, eax
  0001f	83 c0 01	 add	 eax, 1

; 336  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::operator!=
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@1@@Z ; std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >
PUBLIC	??0?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAE@XZ ; std::allocator<CASTLEDEEP_SPAWNTIME>::allocator<CASTLEDEEP_SPAWNTIME>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T239088 = -72						; size = 4
_this$ = -4						; size = 4
??0?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@XZ PROC ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	51		 push	 ecx
  0000d	8b cc		 mov	 ecx, esp
  0000f	89 65 b8	 mov	 DWORD PTR $T239088[ebp], esp
  00012	e8 00 00 00 00	 call	 ??0?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAE@XZ ; std::allocator<CASTLEDEEP_SPAWNTIME>::allocator<CASTLEDEEP_SPAWNTIME>
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@1@@Z ; std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >

; 508  : 		}

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@XZ ENDP ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@XZ ; std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::~_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >
PUBLIC	?_Tidy@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IAEXXZ ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??1?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@XZ PROC ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::~vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >, COMDAT
; _this$ = ecx

; 704  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 705  : 		_Tidy();

  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IAEXXZ ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Tidy

; 706  : 		}

  0003a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??1?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@XZ ; std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::~_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >
  00049	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@XZ ; std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::~_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >
__ehhandler$??1?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@XZ ENDP ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::~vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@PAUCASTLEDEEP_SPAWNTIME@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::_Vector_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ?begin@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@XZ PROC ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 782  : 		return (iterator(this->_Myfirst, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	52		 push	 edx
  00016	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00019	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@PAUCASTLEDEEP_SPAWNTIME@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::_Vector_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >
  0001e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 783  : 		}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?begin@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@XZ ENDP ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::begin
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?end@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@XZ PROC ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 792  : 		return (iterator(this->_Mylast, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	52		 push	 edx
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@PAUCASTLEDEEP_SPAWNTIME@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::_Vector_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >
  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 793  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?end@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@XZ ENDP ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::end
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@UCASTLEDEEP_SPAWNTIME@@ABU3@@std@@YAXAAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@PAUCASTLEDEEP_SPAWNTIME@@ABU2@@Z ; std::_Cons_val<std::allocator<CASTLEDEEP_SPAWNTIME>,CASTLEDEEP_SPAWNTIME,CASTLEDEEP_SPAWNTIME const &>
PUBLIC	??$_Cons_val@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@UCASTLEDEEP_SPAWNTIME@@AAU3@@std@@YAXAAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@PAUCASTLEDEEP_SPAWNTIME@@AAU2@@Z ; std::_Cons_val<std::allocator<CASTLEDEEP_SPAWNTIME>,CASTLEDEEP_SPAWNTIME,CASTLEDEEP_SPAWNTIME &>
PUBLIC	?_Orphan_range@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IBEXPAUCASTLEDEEP_SPAWNTIME@@0@Z ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Orphan_range
PUBLIC	?_Reserve@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IAEXI@Z ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Reserve
PUBLIC	?_Inside@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IBE_NPBUCASTLEDEEP_SPAWNTIME@@@Z ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Inside
PUBLIC	??$addressof@$$CBUCASTLEDEEP_SPAWNTIME@@@std@@YAPBUCASTLEDEEP_SPAWNTIME@@ABU1@@Z ; std::addressof<CASTLEDEEP_SPAWNTIME const >
; Function compile flags: /Odtp /ZI
;	COMDAT ?push_back@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAEXABUCASTLEDEEP_SPAWNTIME@@@Z
_TEXT	SEGMENT
__Idx$233726 = -8					; size = 4
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAEXABUCASTLEDEEP_SPAWNTIME@@@Z PROC ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$addressof@$$CBUCASTLEDEEP_SPAWNTIME@@@std@@YAPBUCASTLEDEEP_SPAWNTIME@@ABU1@@Z ; std::addressof<CASTLEDEEP_SPAWNTIME const >
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Inside@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IBE_NPBUCASTLEDEEP_SPAWNTIME@@@Z ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Inside
  00021	0f b6 c8	 movzx	 ecx, al
  00024	85 c9		 test	 ecx, ecx
  00026	74 78		 je	 SHORT $LN4@push_back@3

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$addressof@$$CBUCASTLEDEEP_SPAWNTIME@@@std@@YAPBUCASTLEDEEP_SPAWNTIME@@ABU1@@Z ; std::addressof<CASTLEDEEP_SPAWNTIME const >
  00031	83 c4 04	 add	 esp, 4
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	2b 01		 sub	 eax, DWORD PTR [ecx]
  00039	c1 f8 03	 sar	 eax, 3
  0003c	89 45 f8	 mov	 DWORD PTR __Idx$233726[ebp], eax

; 980  : 			if (this->_Mylast == this->_Myend)

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00048	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0004b	75 0a		 jne	 SHORT $LN3@push_back@3

; 981  : 				_Reserve(1);

  0004d	6a 01		 push	 1
  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IAEXI@Z ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Reserve
$LN3@push_back@3:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  00057	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005d	51		 push	 ecx
  0005e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00061	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00064	50		 push	 eax
  00065	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IBEXPAUCASTLEDEEP_SPAWNTIME@@0@Z ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Orphan_range

; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  0006d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00070	8b 08		 mov	 ecx, DWORD PTR [eax]
  00072	8b 55 f8	 mov	 edx, DWORD PTR __Idx$233726[ebp]
  00075	8d 04 d1	 lea	 eax, DWORD PTR [ecx+edx*8]
  00078	50		 push	 eax
  00079	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007f	52		 push	 edx
  00080	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00083	83 c0 0c	 add	 eax, 12			; 0000000cH
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@UCASTLEDEEP_SPAWNTIME@@AAU3@@std@@YAXAAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@PAUCASTLEDEEP_SPAWNTIME@@AAU2@@Z ; std::_Cons_val<std::allocator<CASTLEDEEP_SPAWNTIME>,CASTLEDEEP_SPAWNTIME,CASTLEDEEP_SPAWNTIME &>
  0008c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 986  : 			++this->_Mylast;

  0008f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00092	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00095	83 c1 08	 add	 ecx, 8
  00098	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0009b	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 987  : 			}
; 988  : 		else

  0009e	eb 57		 jmp	 SHORT $LN5@push_back@3
$LN4@push_back@3:

; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  000a0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a9	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  000ac	75 0a		 jne	 SHORT $LN1@push_back@3

; 991  : 				_Reserve(1);

  000ae	6a 01		 push	 1
  000b0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b3	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IAEXI@Z ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Reserve
$LN1@push_back@3:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  000b8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000bb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000be	51		 push	 ecx
  000bf	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c2	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000c5	50		 push	 eax
  000c6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c9	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IBEXPAUCASTLEDEEP_SPAWNTIME@@0@Z ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Orphan_range

; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  000ce	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  000d1	50		 push	 eax
  000d2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d5	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000d8	52		 push	 edx
  000d9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000dc	83 c0 0c	 add	 eax, 12			; 0000000cH
  000df	50		 push	 eax
  000e0	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@UCASTLEDEEP_SPAWNTIME@@ABU3@@std@@YAXAAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@PAUCASTLEDEEP_SPAWNTIME@@ABU2@@Z ; std::_Cons_val<std::allocator<CASTLEDEEP_SPAWNTIME>,CASTLEDEEP_SPAWNTIME,CASTLEDEEP_SPAWNTIME const &>
  000e5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  000e8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000eb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ee	83 c1 08	 add	 ecx, 8
  000f1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000f4	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN5@push_back@3:

; 997  : 			}
; 998  : 		}

  000f7	5f		 pop	 edi
  000f8	5e		 pop	 esi
  000f9	5b		 pop	 ebx
  000fa	8b e5		 mov	 esp, ebp
  000fc	5d		 pop	 ebp
  000fd	c2 04 00	 ret	 4
?push_back@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAEXABUCASTLEDEEP_SPAWNTIME@@@Z ENDP ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::push_back
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QBEAAUCASTLEDEEP_SPAWNTIME@@XZ ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::operator*
; Function compile flags: /Odtp /ZI
;	COMDAT ??C?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QBEPAUCASTLEDEEP_SPAWNTIME@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??C?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QBEPAUCASTLEDEEP_SPAWNTIME@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::operator->, COMDAT
; _this$ = ecx

; 326  : 		{	// return pointer to class object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 327  : 		return (&**this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QBEAAUCASTLEDEEP_SPAWNTIME@@XZ ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::operator*

; 328  : 		}

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??C?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QBEPAUCASTLEDEEP_SPAWNTIME@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::operator->
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::operator++
; Function compile flags: /Odtp /ZI
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::operator++, COMDAT
; _this$ = ecx

; 337  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 338  : 		_Myiter _Tmp = *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	89 4d f8	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 339  : 		++*this;

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::operator++

; 340  : 		return (_Tmp);

  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Tmp$[ebp]
  00022	89 08		 mov	 DWORD PTR [eax], ecx
  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 341  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
??E?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::operator==
; Function compile flags: /Odtp /ZI
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 208  : 		return (!(*this == _Right));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??8?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::operator==
  00018	0f b6 c0	 movzx	 eax, al
  0001b	f7 d8		 neg	 eax
  0001d	1b c0		 sbb	 eax, eax
  0001f	83 c0 01	 add	 eax, 1

; 209  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::operator!=
_TEXT	ENDS
PUBLIC	??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHH@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator*
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHH@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHH@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator->, COMDAT
; _this$ = ecx

; 400  : 		{	// return pointer to class object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 401  : 		return (&**this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHH@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator*

; 402  : 		}

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHH@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator->
_TEXT	ENDS
PUBLIC	??E?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator++
; Function compile flags: /Odtp /ZI
;	COMDAT ??E?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator++, COMDAT
; _this$ = ecx

; 411  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 412  : 		_Myiter _Tmp = *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	89 4d f8	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 413  : 		++*this;

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??E?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator++

; 414  : 		return (_Tmp);

  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Tmp$[ebp]
  00022	89 08		 mov	 DWORD PTR [eax], ecx
  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 415  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
??E?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator==
; Function compile flags: /Odtp /ZI
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator!=, COMDAT
; _this$ = ecx

; 334  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 335  : 		return (!(*this == _Right));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator==
  00018	0f b6 c0	 movzx	 eax, al
  0001b	f7 d8		 neg	 eax
  0001d	1b c0		 sbb	 eax, eax
  0001f	83 c0 01	 add	 eax, 1

; 336  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator!=
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@1@@Z ; std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >
PUBLIC	??0?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAE@XZ ; std::allocator<CASTLEDEEP_MONSTERINFO>::allocator<CASTLEDEEP_MONSTERINFO>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T239119 = -72						; size = 4
_this$ = -4						; size = 4
??0?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@XZ PROC ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	51		 push	 ecx
  0000d	8b cc		 mov	 ecx, esp
  0000f	89 65 b8	 mov	 DWORD PTR $T239119[ebp], esp
  00012	e8 00 00 00 00	 call	 ??0?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAE@XZ ; std::allocator<CASTLEDEEP_MONSTERINFO>::allocator<CASTLEDEEP_MONSTERINFO>
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@1@@Z ; std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >

; 508  : 		}

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@XZ ENDP ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@XZ ; std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::~_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >
PUBLIC	?_Tidy@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IAEXXZ ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??1?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@XZ PROC ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::~vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >, COMDAT
; _this$ = ecx

; 704  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 705  : 		_Tidy();

  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IAEXXZ ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Tidy

; 706  : 		}

  0003a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??1?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@XZ ; std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::~_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >
  00049	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@XZ ; std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::~_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >
__ehhandler$??1?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@XZ ENDP ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::~vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@PAUCASTLEDEEP_MONSTERINFO@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::_Vector_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ?begin@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@XZ PROC ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 782  : 		return (iterator(this->_Myfirst, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	52		 push	 edx
  00016	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00019	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@PAUCASTLEDEEP_MONSTERINFO@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::_Vector_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >
  0001e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 783  : 		}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?begin@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@XZ ENDP ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::begin
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?end@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@XZ PROC ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 792  : 		return (iterator(this->_Mylast, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	52		 push	 edx
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@PAUCASTLEDEEP_MONSTERINFO@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::_Vector_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >
  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 793  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?end@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@XZ ENDP ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::end
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@UCASTLEDEEP_MONSTERINFO@@ABU3@@std@@YAXAAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@PAUCASTLEDEEP_MONSTERINFO@@ABU2@@Z ; std::_Cons_val<std::allocator<CASTLEDEEP_MONSTERINFO>,CASTLEDEEP_MONSTERINFO,CASTLEDEEP_MONSTERINFO const &>
PUBLIC	??$_Cons_val@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@UCASTLEDEEP_MONSTERINFO@@AAU3@@std@@YAXAAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@PAUCASTLEDEEP_MONSTERINFO@@AAU2@@Z ; std::_Cons_val<std::allocator<CASTLEDEEP_MONSTERINFO>,CASTLEDEEP_MONSTERINFO,CASTLEDEEP_MONSTERINFO &>
PUBLIC	?_Orphan_range@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IBEXPAUCASTLEDEEP_MONSTERINFO@@0@Z ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Orphan_range
PUBLIC	?_Reserve@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IAEXI@Z ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Reserve
PUBLIC	?_Inside@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IBE_NPBUCASTLEDEEP_MONSTERINFO@@@Z ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Inside
PUBLIC	??$addressof@$$CBUCASTLEDEEP_MONSTERINFO@@@std@@YAPBUCASTLEDEEP_MONSTERINFO@@ABU1@@Z ; std::addressof<CASTLEDEEP_MONSTERINFO const >
; Function compile flags: /Odtp /ZI
;	COMDAT ?push_back@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAEXABUCASTLEDEEP_MONSTERINFO@@@Z
_TEXT	SEGMENT
__Idx$233821 = -8					; size = 4
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAEXABUCASTLEDEEP_MONSTERINFO@@@Z PROC ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$addressof@$$CBUCASTLEDEEP_MONSTERINFO@@@std@@YAPBUCASTLEDEEP_MONSTERINFO@@ABU1@@Z ; std::addressof<CASTLEDEEP_MONSTERINFO const >
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Inside@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IBE_NPBUCASTLEDEEP_MONSTERINFO@@@Z ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Inside
  00021	0f b6 c8	 movzx	 ecx, al
  00024	85 c9		 test	 ecx, ecx
  00026	74 7d		 je	 SHORT $LN4@push_back@4

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$addressof@$$CBUCASTLEDEEP_MONSTERINFO@@@std@@YAPBUCASTLEDEEP_MONSTERINFO@@ABU1@@Z ; std::addressof<CASTLEDEEP_MONSTERINFO const >
  00031	83 c4 04	 add	 esp, 4
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	2b 01		 sub	 eax, DWORD PTR [ecx]
  00039	99		 cdq
  0003a	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  0003f	f7 f9		 idiv	 ecx
  00041	89 45 f8	 mov	 DWORD PTR __Idx$233821[ebp], eax

; 980  : 			if (this->_Mylast == this->_Myend)

  00044	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0004d	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00050	75 0a		 jne	 SHORT $LN3@push_back@4

; 981  : 				_Reserve(1);

  00052	6a 01		 push	 1
  00054	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IAEXI@Z ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Reserve
$LN3@push_back@4:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  0005c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00062	51		 push	 ecx
  00063	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00066	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00069	50		 push	 eax
  0006a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006d	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IBEXPAUCASTLEDEEP_MONSTERINFO@@0@Z ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Orphan_range

; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  00072	8b 45 f8	 mov	 eax, DWORD PTR __Idx$233821[ebp]
  00075	6b c0 1c	 imul	 eax, 28			; 0000001cH
  00078	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	03 01		 add	 eax, DWORD PTR [ecx]
  0007d	50		 push	 eax
  0007e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00081	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00084	50		 push	 eax
  00085	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00088	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0008b	51		 push	 ecx
  0008c	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@UCASTLEDEEP_MONSTERINFO@@AAU3@@std@@YAXAAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@PAUCASTLEDEEP_MONSTERINFO@@AAU2@@Z ; std::_Cons_val<std::allocator<CASTLEDEEP_MONSTERINFO>,CASTLEDEEP_MONSTERINFO,CASTLEDEEP_MONSTERINFO &>
  00091	83 c4 0c	 add	 esp, 12			; 0000000cH

; 986  : 			++this->_Mylast;

  00094	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00097	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0009a	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0009d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000a0	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 987  : 			}
; 988  : 		else

  000a3	eb 57		 jmp	 SHORT $LN5@push_back@4
$LN4@push_back@4:

; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  000a5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ab	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000ae	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  000b1	75 0a		 jne	 SHORT $LN1@push_back@4

; 991  : 				_Reserve(1);

  000b3	6a 01		 push	 1
  000b5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b8	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IAEXI@Z ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Reserve
$LN1@push_back@4:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  000bd	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000c3	51		 push	 ecx
  000c4	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c7	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000ca	50		 push	 eax
  000cb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ce	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IBEXPAUCASTLEDEEP_MONSTERINFO@@0@Z ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Orphan_range

; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  000d3	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  000d6	50		 push	 eax
  000d7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000da	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000dd	52		 push	 edx
  000de	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000e1	83 c0 0c	 add	 eax, 12			; 0000000cH
  000e4	50		 push	 eax
  000e5	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@UCASTLEDEEP_MONSTERINFO@@ABU3@@std@@YAXAAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@PAUCASTLEDEEP_MONSTERINFO@@ABU2@@Z ; std::_Cons_val<std::allocator<CASTLEDEEP_MONSTERINFO>,CASTLEDEEP_MONSTERINFO,CASTLEDEEP_MONSTERINFO const &>
  000ea	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  000ed	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000f0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000f3	83 c1 1c	 add	 ecx, 28			; 0000001cH
  000f6	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000f9	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN5@push_back@4:

; 997  : 			}
; 998  : 		}

  000fc	5f		 pop	 edi
  000fd	5e		 pop	 esi
  000fe	5b		 pop	 ebx
  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c2 04 00	 ret	 4
?push_back@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAEXABUCASTLEDEEP_MONSTERINFO@@@Z ENDP ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::push_back
_TEXT	ENDS
PUBLIC	??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::operator*
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::operator->, COMDAT
; _this$ = ecx

; 400  : 		{	// return pointer to class object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 401  : 		return (&**this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::operator*

; 402  : 		}

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::operator->
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::operator==, COMDAT
; _this$ = ecx

; 316  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 317  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 318  : 		if (this->_Getcont() == 0
; 319  : 			|| this->_Getcont() != _Right._Getcont())
; 320  : 			{	// report error
; 321  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 322  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 323  : 			}
; 324  : 
; 325  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 326  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 327  : 			&& this->_Getcont() == _Right._Getcont());
; 328  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 329  : 
; 330  : 		return (this->_Ptr == _Right._Ptr);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00012	8b 10		 mov	 edx, DWORD PTR [eax]
  00014	33 c0		 xor	 eax, eax
  00016	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00018	0f 94 c0	 sete	 al

; 331  : 		}

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::operator==
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::operator!=, COMDAT
; _this$ = ecx

; 334  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 335  : 		return (!(*this == _Right));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::operator==
  00018	0f b6 c0	 movzx	 eax, al
  0001b	f7 d8		 neg	 eax
  0001d	1b c0		 sbb	 eax, eax
  0001f	83 c0 01	 add	 eax, 1

; 336  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::operator!=
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::_Vector_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >, COMDAT
; _this$ = ecx

; 298  : 	_Vector_iterator()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >

; 299  : 		{	// construct with null vector pointer
; 300  : 		}

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::_Vector_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QBEAAUCASTLEDEEP_EVENTTIME@@XZ ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::operator*
; Function compile flags: /Odtp /ZI
;	COMDAT ??C?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QBEPAUCASTLEDEEP_EVENTTIME@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??C?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QBEPAUCASTLEDEEP_EVENTTIME@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::operator->, COMDAT
; _this$ = ecx

; 326  : 		{	// return pointer to class object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 327  : 		return (&**this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QBEAAUCASTLEDEEP_EVENTTIME@@XZ ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::operator*

; 328  : 		}

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??C?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QBEPAUCASTLEDEEP_EVENTTIME@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::operator->
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::operator++
; Function compile flags: /Odtp /ZI
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::operator++, COMDAT
; _this$ = ecx

; 337  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 338  : 		_Myiter _Tmp = *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	89 4d f8	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 339  : 		++*this;

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::operator++

; 340  : 		return (_Tmp);

  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Tmp$[ebp]
  00022	89 08		 mov	 DWORD PTR [eax], ecx
  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 341  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
??E?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::operator==
; Function compile flags: /Odtp /ZI
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 208  : 		return (!(*this == _Right));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??8?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::operator==
  00018	0f b6 c0	 movzx	 eax, al
  0001b	f7 d8		 neg	 eax
  0001d	1b c0		 sbb	 eax, eax
  0001f	83 c0 01	 add	 eax, 1

; 209  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::operator!=
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::_Vector_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >, COMDAT
; _this$ = ecx

; 298  : 	_Vector_iterator()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >

; 299  : 		{	// construct with null vector pointer
; 300  : 		}

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::_Vector_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QBEAAUCASTLEDEEP_MONSTERINFO@@XZ ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::operator*
; Function compile flags: /Odtp /ZI
;	COMDAT ??C?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QBEPAUCASTLEDEEP_MONSTERINFO@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??C?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QBEPAUCASTLEDEEP_MONSTERINFO@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::operator->, COMDAT
; _this$ = ecx

; 326  : 		{	// return pointer to class object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 327  : 		return (&**this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QBEAAUCASTLEDEEP_MONSTERINFO@@XZ ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::operator*

; 328  : 		}

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??C?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QBEPAUCASTLEDEEP_MONSTERINFO@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::operator->
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::operator++
; Function compile flags: /Odtp /ZI
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::operator++, COMDAT
; _this$ = ecx

; 337  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 338  : 		_Myiter _Tmp = *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	89 4d f8	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 339  : 		++*this;

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::operator++

; 340  : 		return (_Tmp);

  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Tmp$[ebp]
  00022	89 08		 mov	 DWORD PTR [eax], ecx
  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 341  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
??E?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::operator==
; Function compile flags: /Odtp /ZI
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 208  : 		return (!(*this == _Right));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??8?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::operator==
  00018	0f b6 c0	 movzx	 eax, al
  0001b	f7 d8		 neg	 eax
  0001d	1b c0		 sbb	 eax, eax
  0001f	83 c0 01	 add	 eax, 1

; 209  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::operator!=
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xfunctional
_TEXT	ENDS
;	COMDAT ??R?$less@H@std@@QBE_NABH0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@H@std@@QBE_NABH0@Z PROC			; std::less<int>::operator(), COMDAT
; _this$ = ecx

; 124  : 		{	// apply operator< to operands

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 125  : 		return (_Left < _Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0000f	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00012	8b 10		 mov	 edx, DWORD PTR [eax]
  00014	33 c0		 xor	 eax, eax
  00016	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00018	0f 9c c0	 setl	 al

; 126  : 		}

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
??R?$less@H@std@@QBE_NABH0@Z ENDP			; std::less<int>::operator()
_TEXT	ENDS
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
PUBLIC	??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,int> >::allocator<std::pair<int const ,int> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
$T239162 = -72						; size = 4
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 698  : 		{	// construct empty tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	51		 push	 ecx
  0000d	8b cc		 mov	 ecx, esp
  0000f	89 65 b8	 mov	 DWORD PTR $T239162[ebp], esp
  00012	8b 45 0c	 mov	 eax, DWORD PTR __Al$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,int> >::allocator<std::pair<int const ,int> >
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ??0?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >

; 699  : 		}

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8
??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$233927 = -8					; size = 4
_this$ = -4						; size = 4
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1610 : 		{	// free entire subtree, recursively

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1611 : 		for (_Nodeptr _Pnode = _Rootnode;

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __Pnode$233927[ebp], eax
  00012	eb 06		 jmp	 SHORT $LN3@Erase
$LN2@Erase:

; 1612 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  00014	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$233927[ebp]
  00017	89 45 08	 mov	 DWORD PTR __Rootnode$[ebp], eax
$LN3@Erase:
  0001a	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$233927[ebp]
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  00023	83 c4 04	 add	 esp, 4
  00026	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00029	85 c9		 test	 ecx, ecx
  0002b	75 60		 jne	 SHORT $LN4@Erase

; 1613 : 			{	// free subtrees, then node
; 1614 : 			_Erase(this->_Right(_Pnode));

  0002d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$233927[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  00036	83 c4 04	 add	 esp, 4
  00039	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003b	51		 push	 ecx
  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Erase

; 1615 : 			_Pnode = this->_Left(_Pnode);

  00044	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$233927[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 08		 mov	 ecx, DWORD PTR [eax]
  00052	89 4d f8	 mov	 DWORD PTR __Pnode$233927[ebp], ecx

; 1616 : 			_Dest_val(this->_Alval,
; 1617 : 				_STD addressof(this->_Myval(_Rootnode)));

  00055	8b 45 08	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Myval
  0005e	83 c4 04	 add	 esp, 4
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ??$addressof@U?$pair@$$CBHH@std@@@std@@YAPAU?$pair@$$CBHH@0@AAU10@@Z ; std::addressof<std::pair<int const ,int> >
  00067	83 c4 04	 add	 esp, 4
  0006a	50		 push	 eax
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006e	83 c1 0d	 add	 ecx, 13			; 0000000dH
  00071	51		 push	 ecx
  00072	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBHH@std@@@std@@U?$pair@$$CBHH@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHH@std@@@0@PAU?$pair@$$CBHH@0@@Z ; std::_Dest_val<std::allocator<std::pair<int const ,int> >,std::pair<int const ,int> >
  00077	83 c4 08	 add	 esp, 8

; 1618 : 
; 1619 : 			this->_Alnod.deallocate(_Rootnode, 1);

  0007a	6a 01		 push	 1
  0007c	8b 45 08	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  0007f	50		 push	 eax
  00080	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00083	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00086	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::deallocate

; 1620 : 			}

  0008b	eb 87		 jmp	 SHORT $LN2@Erase
$LN4@Erase:

; 1621 : 		}

  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	5b		 pop	 ebx
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c2 04 00	 ret	 4
?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Erase
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Lmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1758 : 		{	// return leftmost node in nonmutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1759 : 		return (this->_Left(this->_Myhead));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  00018	83 c4 04	 add	 esp, 4

; 1760 : 		}

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lmost
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = -8						; size = 4
_this$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1763 : 		{	// promote right node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1764 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  00015	83 c4 04	 add	 esp, 4
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d f8	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 1765 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

  0001d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  00026	83 c4 04	 add	 esp, 4
  00029	8b f0		 mov	 esi, eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  00034	83 c4 04	 add	 esp, 4
  00037	8b 16		 mov	 edx, DWORD PTR [esi]
  00039	89 10		 mov	 DWORD PTR [eax], edx

; 1766 : 
; 1767 : 		if (!this->_Isnil(this->_Left(_Pnode)))

  0003b	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  00044	83 c4 04	 add	 esp, 4
  00047	8b 08		 mov	 ecx, DWORD PTR [eax]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  0004f	83 c4 04	 add	 esp, 4
  00052	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00055	85 d2		 test	 edx, edx
  00057	75 1c		 jne	 SHORT $LN5@Lrotate

; 1768 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

  00059	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  00062	83 c4 04	 add	 esp, 4
  00065	8b 08		 mov	 ecx, DWORD PTR [eax]
  00067	51		 push	 ecx
  00068	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  0006d	83 c4 04	 add	 esp, 4
  00070	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00073	89 10		 mov	 DWORD PTR [eax], edx
$LN5@Lrotate:

; 1769 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  00075	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  0007e	83 c4 04	 add	 esp, 4
  00081	8b f0		 mov	 esi, eax
  00083	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00086	51		 push	 ecx
  00087	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  0008c	83 c4 04	 add	 esp, 4
  0008f	8b 16		 mov	 edx, DWORD PTR [esi]
  00091	89 10		 mov	 DWORD PTR [eax], edx

; 1770 : 
; 1771 : 		if (_Wherenode == _Root())

  00093	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root
  0009b	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0009e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000a0	75 0f		 jne	 SHORT $LN4@Lrotate

; 1772 : 			_Root() = _Pnode;

  000a2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root
  000aa	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  000ad	89 08		 mov	 DWORD PTR [eax], ecx
  000af	eb 58		 jmp	 SHORT $LN3@Lrotate
$LN4@Lrotate:

; 1773 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  000b1	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000b4	50		 push	 eax
  000b5	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  000ba	83 c4 04	 add	 esp, 4
  000bd	8b 08		 mov	 ecx, DWORD PTR [eax]
  000bf	51		 push	 ecx
  000c0	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  000c5	83 c4 04	 add	 esp, 4
  000c8	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  000cb	3b 10		 cmp	 edx, DWORD PTR [eax]
  000cd	75 1e		 jne	 SHORT $LN2@Lrotate

; 1774 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  000cf	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000d2	50		 push	 eax
  000d3	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  000d8	83 c4 04	 add	 esp, 4
  000db	8b 08		 mov	 ecx, DWORD PTR [eax]
  000dd	51		 push	 ecx
  000de	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  000e3	83 c4 04	 add	 esp, 4
  000e6	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  000e9	89 10		 mov	 DWORD PTR [eax], edx

; 1775 : 		else

  000eb	eb 1c		 jmp	 SHORT $LN3@Lrotate
$LN2@Lrotate:

; 1776 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  000ed	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000f0	50		 push	 eax
  000f1	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  000f6	83 c4 04	 add	 esp, 4
  000f9	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fb	51		 push	 ecx
  000fc	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  00101	83 c4 04	 add	 esp, 4
  00104	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00107	89 10		 mov	 DWORD PTR [eax], edx
$LN3@Lrotate:

; 1777 : 
; 1778 : 		this->_Left(_Pnode) = _Wherenode;

  00109	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0010c	50		 push	 eax
  0010d	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  00112	83 c4 04	 add	 esp, 4
  00115	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00118	89 08		 mov	 DWORD PTR [eax], ecx

; 1779 : 		this->_Parent(_Wherenode) = _Pnode;

  0011a	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0011d	50		 push	 eax
  0011e	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  00123	83 c4 04	 add	 esp, 4
  00126	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00129	89 08		 mov	 DWORD PTR [eax], ecx

; 1780 : 		}

  0012b	5f		 pop	 edi
  0012c	5e		 pop	 esi
  0012d	5b		 pop	 ebx
  0012e	8b e5		 mov	 esp, ebp
  00130	5d		 pop	 ebp
  00131	c2 04 00	 ret	 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Rmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1783 : 		{	// return rightmost node in nonmutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1784 : 		return (this->_Right(this->_Myhead));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  00018	83 c4 04	 add	 esp, 4

; 1785 : 		}

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?_Rmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rmost
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root, COMDAT
; _this$ = ecx

; 1788 : 		{	// return root of nonmutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1789 : 		return (this->_Parent(this->_Myhead));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  00018	83 c4 04	 add	 esp, 4

; 1790 : 		}

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = -8						; size = 4
_this$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1793 : 		{	// promote left node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1794 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  00015	83 c4 04	 add	 esp, 4
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d f8	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 1795 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

  0001d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  00026	83 c4 04	 add	 esp, 4
  00029	8b f0		 mov	 esi, eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  00034	83 c4 04	 add	 esp, 4
  00037	8b 16		 mov	 edx, DWORD PTR [esi]
  00039	89 10		 mov	 DWORD PTR [eax], edx

; 1796 : 
; 1797 : 		if (!this->_Isnil(this->_Right(_Pnode)))

  0003b	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  00044	83 c4 04	 add	 esp, 4
  00047	8b 08		 mov	 ecx, DWORD PTR [eax]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  0004f	83 c4 04	 add	 esp, 4
  00052	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00055	85 d2		 test	 edx, edx
  00057	75 1c		 jne	 SHORT $LN5@Rrotate

; 1798 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

  00059	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  00062	83 c4 04	 add	 esp, 4
  00065	8b 08		 mov	 ecx, DWORD PTR [eax]
  00067	51		 push	 ecx
  00068	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  0006d	83 c4 04	 add	 esp, 4
  00070	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00073	89 10		 mov	 DWORD PTR [eax], edx
$LN5@Rrotate:

; 1799 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  00075	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  0007e	83 c4 04	 add	 esp, 4
  00081	8b f0		 mov	 esi, eax
  00083	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00086	51		 push	 ecx
  00087	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  0008c	83 c4 04	 add	 esp, 4
  0008f	8b 16		 mov	 edx, DWORD PTR [esi]
  00091	89 10		 mov	 DWORD PTR [eax], edx

; 1800 : 
; 1801 : 		if (_Wherenode == _Root())

  00093	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root
  0009b	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0009e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000a0	75 0f		 jne	 SHORT $LN4@Rrotate

; 1802 : 			_Root() = _Pnode;

  000a2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root
  000aa	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  000ad	89 08		 mov	 DWORD PTR [eax], ecx
  000af	eb 58		 jmp	 SHORT $LN3@Rrotate
$LN4@Rrotate:

; 1803 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

  000b1	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000b4	50		 push	 eax
  000b5	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  000ba	83 c4 04	 add	 esp, 4
  000bd	8b 08		 mov	 ecx, DWORD PTR [eax]
  000bf	51		 push	 ecx
  000c0	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  000c5	83 c4 04	 add	 esp, 4
  000c8	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  000cb	3b 10		 cmp	 edx, DWORD PTR [eax]
  000cd	75 1e		 jne	 SHORT $LN2@Rrotate

; 1804 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  000cf	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000d2	50		 push	 eax
  000d3	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  000d8	83 c4 04	 add	 esp, 4
  000db	8b 08		 mov	 ecx, DWORD PTR [eax]
  000dd	51		 push	 ecx
  000de	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  000e3	83 c4 04	 add	 esp, 4
  000e6	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  000e9	89 10		 mov	 DWORD PTR [eax], edx

; 1805 : 		else

  000eb	eb 1c		 jmp	 SHORT $LN3@Rrotate
$LN2@Rrotate:

; 1806 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  000ed	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000f0	50		 push	 eax
  000f1	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  000f6	83 c4 04	 add	 esp, 4
  000f9	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fb	51		 push	 ecx
  000fc	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  00101	83 c4 04	 add	 esp, 4
  00104	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00107	89 10		 mov	 DWORD PTR [eax], edx
$LN3@Rrotate:

; 1807 : 
; 1808 : 		this->_Right(_Pnode) = _Wherenode;

  00109	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0010c	50		 push	 eax
  0010d	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  00112	83 c4 04	 add	 esp, 4
  00115	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00118	89 08		 mov	 DWORD PTR [eax], ecx

; 1809 : 		this->_Parent(_Wherenode) = _Pnode;

  0011a	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0011d	50		 push	 eax
  0011e	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  00123	83 c4 04	 add	 esp, 4
  00126	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00129	89 08		 mov	 DWORD PTR [eax], ecx

; 1810 : 		}

  0012b	5f		 pop	 edi
  0012c	5e		 pop	 esi
  0012d	5b		 pop	 ebx
  0012e	8b e5		 mov	 esp, ebp
  00130	5d		 pop	 ebp
  00131	c2 04 00	 ret	 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T239178 = -88						; size = 4
$T239179 = -84						; size = 4
$T239180 = -80						; size = 4
$T239181 = -76						; size = 4
$T239182 = -72						; size = 4
_this$ = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1865 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1866 : 		erase(begin(), end());

  0000c	8d 45 ac	 lea	 eax, DWORD PTR $T239179[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::end
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d a8	 mov	 DWORD PTR $T239178[ebp], ecx
  0001d	8d 55 b4	 lea	 edx, DWORD PTR $T239181[ebp]
  00020	52		 push	 edx
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::begin
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 b0	 mov	 DWORD PTR $T239180[ebp], eax
  0002e	8b 4d a8	 mov	 ecx, DWORD PTR $T239178[ebp]
  00031	51		 push	 ecx
  00032	8b 55 b0	 mov	 edx, DWORD PTR $T239180[ebp]
  00035	52		 push	 edx
  00036	8d 45 b8	 lea	 eax, DWORD PTR $T239182[ebp]
  00039	50		 push	 eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase

; 1867 : 		}

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tidy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 554  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 555  : 		this->_Alnod.deallocate(this->_Myhead, 1);

  0000c	6a 01		 push	 1
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00014	51		 push	 ecx
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0001b	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::deallocate

; 556  : 		}

  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color, COMDAT

; 606  : 		{	// return reference to color in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 607  : 		return ((char&)(*_Pnode)._Color);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	83 c0 14	 add	 eax, 20			; 00000014H

; 608  : 		}

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil, COMDAT

; 611  : 		{	// return reference to nil flag in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 612  : 		return ((char&)(*_Pnode)._Isnil);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	83 c0 15	 add	 eax, 21			; 00000015H

; 613  : 		}

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left, COMDAT

; 621  : 		{	// return reference to left pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 622  : 		return ((_Nodepref)(*_Pnode)._Left);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 623  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent, COMDAT

; 626  : 		{	// return reference to parent pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 627  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	83 c0 04	 add	 eax, 4

; 628  : 		}

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right, COMDAT

; 631  : 		{	// return reference to right pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 632  : 		return ((_Nodepref)(*_Pnode)._Right);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	83 c0 08	 add	 eax, 8

; 633  : 		}

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Myval, COMDAT

; 636  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 637  : 		return ((reference)(*_Pnode)._Myval);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	83 c0 0c	 add	 eax, 12			; 0000000cH

; 638  : 		}

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Myval@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Myval
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Max, COMDAT

; 641  : 		{	// return rightmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@Max:

; 642  : 		while (!_Isnil(_Right(_Pnode)))

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  00012	83 c4 04	 add	 esp, 4
  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  0001d	83 c4 04	 add	 esp, 4
  00020	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00023	85 d2		 test	 edx, edx
  00025	75 13		 jne	 SHORT $LN1@Max

; 643  : 			_Pnode = _Right(_Pnode);

  00027	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  00030	83 c4 04	 add	 esp, 4
  00033	8b 08		 mov	 ecx, DWORD PTR [eax]
  00035	89 4d 08	 mov	 DWORD PTR __Pnode$[ebp], ecx
  00038	eb cf		 jmp	 SHORT $LN2@Max
$LN1@Max:

; 644  : 		return (_Pnode);

  0003a	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 645  : 		}

  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
  0003f	5b		 pop	 ebx
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?_Max@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Max
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Min, COMDAT

; 648  : 		{	// return leftmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@Min:

; 649  : 		while (!_Isnil(_Left(_Pnode)))

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  00012	83 c4 04	 add	 esp, 4
  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  0001d	83 c4 04	 add	 esp, 4
  00020	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00023	85 d2		 test	 edx, edx
  00025	75 13		 jne	 SHORT $LN1@Min

; 650  : 			_Pnode = _Left(_Pnode);

  00027	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  00030	83 c4 04	 add	 esp, 4
  00033	8b 08		 mov	 ecx, DWORD PTR [eax]
  00035	89 4d 08	 mov	 DWORD PTR __Pnode$[ebp], ecx
  00038	eb cf		 jmp	 SHORT $LN2@Min
$LN1@Min:

; 651  : 		return (_Pnode);

  0003a	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 652  : 		}

  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
  0003f	5b		 pop	 ebx
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?_Min@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Min
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@XZ PROC	; std::allocator<std::pair<int const ,int> >::allocator<std::pair<int const ,int> >, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@XZ ENDP	; std::allocator<std::pair<int const ,int> >::allocator<std::pair<int const ,int> >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 182  : 		::operator delete(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4

; 183  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<int,std::allocator<int> > >::_Vector_iterator<std::_Vector_val<int,std::allocator<int> > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 782  : 		return (iterator(this->_Myfirst, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	52		 push	 edx
  00016	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00019	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<int,std::allocator<int> > >::_Vector_iterator<std::_Vector_val<int,std::allocator<int> > >
  0001e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 783  : 		}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::begin
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 792  : 		return (iterator(this->_Mylast, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	52		 push	 edx
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<int,std::allocator<int> > >::_Vector_iterator<std::_Vector_val<int,std::allocator<int> > >
  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 793  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::end
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy
PUBLIC	??$_Move@PAHPAH@std@@YAPAHPAH00@Z		; std::_Move<int *,int *>
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::operator!=
PUBLIC	?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@@Z ; std::vector<int,std::allocator<int> >::_Make_iter
; Function compile flags: /Odtp /ZI
;	COMDAT ?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T239211 = -84						; size = 4
__Ptr$234030 = -16					; size = 4
__Last$ = -12						; size = 4
__First$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@0@Z PROC ; std::vector<int,std::allocator<int> >::erase, COMDAT
; _this$ = ecx

; 1190 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1191 : 		iterator _First = _Make_iter(_First_arg);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __First_arg$[ebp]
  0000f	50		 push	 eax
  00010	8d 4d f8	 lea	 ecx, DWORD PTR __First$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@@Z ; std::vector<int,std::allocator<int> >::_Make_iter

; 1192 : 		iterator _Last = _Make_iter(_Last_arg);

  0001c	8b 45 10	 mov	 eax, DWORD PTR __Last_arg$[ebp]
  0001f	50		 push	 eax
  00020	8d 4d f4	 lea	 ecx, DWORD PTR __Last$[ebp]
  00023	51		 push	 ecx
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@@Z ; std::vector<int,std::allocator<int> >::_Make_iter

; 1193 : 
; 1194 : 		if (_First != _Last)

  0002c	8d 45 f4	 lea	 eax, DWORD PTR __Last$[ebp]
  0002f	50		 push	 eax
  00030	8d 4d f8	 lea	 ecx, DWORD PTR __First$[ebp]
  00033	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::operator!=
  00038	0f b6 c8	 movzx	 ecx, al
  0003b	85 c9		 test	 ecx, ecx
  0003d	74 36		 je	 SHORT $LN1@erase@2

; 1195 : 			{	// worth doing, copy down over hole
; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 			if (_Last < _First || _VICONT(_First) != this
; 1198 : 				|| _VIPTR(_First) < this->_Myfirst
; 1199 : 				|| this->_Mylast < _VIPTR(_Last))
; 1200 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1201 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1202 : 				_VIPTR(_First));
; 1203 : 			_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1204 : 
; 1205 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1206 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1207 : 				_VIPTR(_First));

  0003f	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00042	50		 push	 eax
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00049	52		 push	 edx
  0004a	8b 45 f4	 mov	 eax, DWORD PTR __Last$[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ??$_Move@PAHPAH@std@@YAPAHPAH00@Z ; std::_Move<int *,int *>
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH
  00056	89 45 f0	 mov	 DWORD PTR __Ptr$234030[ebp], eax

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 			_Destroy(_Ptr, this->_Mylast);

  00059	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005f	51		 push	 ecx
  00060	8b 55 f0	 mov	 edx, DWORD PTR __Ptr$234030[ebp]
  00063	52		 push	 edx
  00064	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	e8 00 00 00 00	 call	 ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy

; 1211 : 			this->_Mylast = _Ptr;

  0006c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006f	8b 4d f0	 mov	 ecx, DWORD PTR __Ptr$234030[ebp]
  00072	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@erase@2:

; 1212 : 			}
; 1213 : 		return (_Make_iter(_First));

  00075	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00078	89 45 ac	 mov	 DWORD PTR $T239211[ebp], eax
  0007b	8b 4d ac	 mov	 ecx, DWORD PTR $T239211[ebp]
  0007e	51		 push	 ecx
  0007f	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00082	52		 push	 edx
  00083	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@@Z ; std::vector<int,std::allocator<int> >::_Make_iter
  0008b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1214 : 		}

  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@0@Z ENDP ; std::vector<int,std::allocator<int> >::erase
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Inside@?$vector@HV?$allocator@H@std@@@std@@IBE_NPBH@Z
_TEXT	SEGMENT
tv76 = -72						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$vector@HV?$allocator@H@std@@@std@@IBE_NPBH@Z PROC ; std::vector<int,std::allocator<int> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00012	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00015	73 13		 jae	 SHORT $LN3@Inside
  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	3b 45 08	 cmp	 eax, DWORD PTR __Ptr$[ebp]
  0001f	77 09		 ja	 SHORT $LN3@Inside
  00021	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  00028	eb 07		 jmp	 SHORT $LN4@Inside
$LN3@Inside:
  0002a	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN4@Inside:
  00031	8a 45 b8	 mov	 al, BYTE PTR tv76[ebp]

; 1287 : 		}

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?_Inside@?$vector@HV?$allocator@H@std@@@std@@IBE_NPBH@Z ENDP ; std::vector<int,std::allocator<int> >::_Inside
_TEXT	ENDS
PUBLIC	?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z ; std::vector<int,std::allocator<int> >::reserve
PUBLIC	?_Grow_to@?$vector@HV?$allocator@H@std@@@std@@IBEII@Z ; std::vector<int,std::allocator<int> >::_Grow_to
PUBLIC	?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::capacity
PUBLIC	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ ; std::vector<int,std::allocator<int> >::_Xlen
PUBLIC	?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$ = -8						; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z PROC ; std::vector<int,std::allocator<int> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1291 : 		size_type _Size = size();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
  00014	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax

; 1292 : 		if (max_size() - _Count < _Size)

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
  0001f	2b 45 08	 sub	 eax, DWORD PTR __Count$[ebp]
  00022	3b 45 f8	 cmp	 eax, DWORD PTR __Size$[ebp]
  00025	73 0a		 jae	 SHORT $LN4@Reserve

; 1293 : 			_Xlen();

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ ; std::vector<int,std::allocator<int> >::_Xlen
  0002f	eb 2d		 jmp	 SHORT $LN6@Reserve
$LN4@Reserve:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00031	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  00034	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]
  00037	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::capacity
  00042	39 45 f8	 cmp	 DWORD PTR __Size$[ebp], eax
  00045	77 02		 ja	 SHORT $LN2@Reserve

; 1295 : 			;
; 1296 : 		else

  00047	eb 15		 jmp	 SHORT $LN6@Reserve
$LN2@Reserve:

; 1297 : 			reserve(_Grow_to(_Size));

  00049	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?_Grow_to@?$vector@HV?$allocator@H@std@@@std@@IBEII@Z ; std::vector<int,std::allocator<int> >::_Grow_to
  00055	50		 push	 eax
  00056	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z ; std::vector<int,std::allocator<int> >::reserve
$LN6@Reserve:

; 1298 : 		}

  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z ENDP ; std::vector<int,std::allocator<int> >::_Reserve
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@H@std@@QAEXPAHI@Z	; std::allocator<int>::deallocate
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ PROC	; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1302 : 		if (this->_Myfirst != 0)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00012	74 3d		 je	 SHORT $LN1@Tidy

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00022	51		 push	 ecx
  00023	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00026	8b 02		 mov	 eax, DWORD PTR [edx]
  00028	50		 push	 eax
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy

; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0003a	2b 11		 sub	 edx, DWORD PTR [ecx]
  0003c	c1 fa 02	 sar	 edx, 2
  0003f	52		 push	 edx
  00040	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b 08		 mov	 ecx, DWORD PTR [eax]
  00045	51		 push	 ecx
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0004c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@H@std@@QAEXPAHI@Z ; std::allocator<int>::deallocate
$LN1@Tidy:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00051	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00054	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1310 : 		this->_Mylast = 0;

  0005a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1311 : 		this->_Myend = 0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 1312 : 		}

  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z PROC ; std::vector<int,std::allocator<int> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1453 : 		{	// orphan iterators within specified (inclusive) range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1454 : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??0?$allocator@H@std@@QAE@ABV01@@Z		; std::allocator<int>::allocator<int>
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@V?$allocator@H@1@@Z PROC ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00016	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@ABV01@@Z ; std::allocator<int>::allocator<int>

; 427  : 		_Myfirst = 0;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 428  : 		_Mylast = 0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 429  : 		_Myend = 0;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 430  : 		}

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
??0?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@V?$allocator@H@1@@Z ENDP ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 433  : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 434  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@H@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@H@std@@QAE@XZ PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@H@std@@QAE@XZ ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >
PUBLIC	??0?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
$T239230 = -72						; size = 4
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >, COMDAT
; _this$ = ecx

; 698  : 		{	// construct empty tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	51		 push	 ecx
  0000d	8b cc		 mov	 ecx, esp
  0000f	89 65 b8	 mov	 DWORD PTR $T239230[ebp], esp
  00012	8b 45 0c	 mov	 eax, DWORD PTR __Al$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??0?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ??0?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >

; 699  : 		}

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8
??0?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >
_TEXT	ENDS
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Lbound
; Function compile flags: /Odtp /ZI
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@ABH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1449 : 		{	// find leftmost node not less than _Keyval in mutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1450 : 		return (iterator(_Lbound(_Keyval), this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Keyval$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Lbound
  0001c	50		 push	 eax
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00020	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >
  00025	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1451 : 		}

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
?lower_bound@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Node>::deallocate
PUBLIC	??$_Dest_val@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@0@PAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >
PUBLIC	??$addressof@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@YAPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@AAU10@@Z ; std::addressof<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >
PUBLIC	?_Myval@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Myval
PUBLIC	?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Left
PUBLIC	?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Right
PUBLIC	?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Isnil
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$234074 = -8					; size = 4
_this$ = -4						; size = 4
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1610 : 		{	// free entire subtree, recursively

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1611 : 		for (_Nodeptr _Pnode = _Rootnode;

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __Pnode$234074[ebp], eax
  00012	eb 06		 jmp	 SHORT $LN3@Erase@2
$LN2@Erase@2:

; 1612 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  00014	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$234074[ebp]
  00017	89 45 08	 mov	 DWORD PTR __Rootnode$[ebp], eax
$LN3@Erase@2:
  0001a	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$234074[ebp]
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Isnil
  00023	83 c4 04	 add	 esp, 4
  00026	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00029	85 c9		 test	 ecx, ecx
  0002b	75 60		 jne	 SHORT $LN4@Erase@2

; 1613 : 			{	// free subtrees, then node
; 1614 : 			_Erase(this->_Right(_Pnode));

  0002d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$234074[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Right
  00036	83 c4 04	 add	 esp, 4
  00039	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003b	51		 push	 ecx
  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Erase

; 1615 : 			_Pnode = this->_Left(_Pnode);

  00044	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$234074[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Left
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 08		 mov	 ecx, DWORD PTR [eax]
  00052	89 4d f8	 mov	 DWORD PTR __Pnode$234074[ebp], ecx

; 1616 : 			_Dest_val(this->_Alval,
; 1617 : 				_STD addressof(this->_Myval(_Rootnode)));

  00055	8b 45 08	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Myval
  0005e	83 c4 04	 add	 esp, 4
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ??$addressof@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@YAPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@AAU10@@Z ; std::addressof<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >
  00067	83 c4 04	 add	 esp, 4
  0006a	50		 push	 eax
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006e	83 c1 0d	 add	 ecx, 13			; 0000000dH
  00071	51		 push	 ecx
  00072	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@0@PAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >
  00077	83 c4 08	 add	 esp, 8

; 1618 : 
; 1619 : 			this->_Alnod.deallocate(_Rootnode, 1);

  0007a	6a 01		 push	 1
  0007c	8b 45 08	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  0007f	50		 push	 eax
  00080	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00083	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00086	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Node>::deallocate

; 1620 : 			}

  0008b	eb 87		 jmp	 SHORT $LN2@Erase@2
$LN4@Erase@2:

; 1621 : 		}

  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	5b		 pop	 ebx
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c2 04 00	 ret	 4
?_Erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Erase
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Lmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1758 : 		{	// return leftmost node in nonmutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1759 : 		return (this->_Left(this->_Myhead));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Left
  00018	83 c4 04	 add	 esp, 4

; 1760 : 		}

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Lmost
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Rmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1783 : 		{	// return rightmost node in nonmutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1784 : 		return (this->_Right(this->_Myhead));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Right
  00018	83 c4 04	 add	 esp, 4

; 1785 : 		}

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?_Rmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Rmost
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Root@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Root, COMDAT
; _this$ = ecx

; 1788 : 		{	// return root of nonmutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1789 : 		return (this->_Parent(this->_Myhead));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  00018	83 c4 04	 add	 esp, 4

; 1790 : 		}

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Root
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::erase
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::begin
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T239244 = -88						; size = 4
$T239245 = -84						; size = 4
$T239246 = -80						; size = 4
$T239247 = -76						; size = 4
$T239248 = -72						; size = 4
_this$ = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1865 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1866 : 		erase(begin(), end());

  0000c	8d 45 ac	 lea	 eax, DWORD PTR $T239245[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::end
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d a8	 mov	 DWORD PTR $T239244[ebp], ecx
  0001d	8d 55 b4	 lea	 edx, DWORD PTR $T239247[ebp]
  00020	52		 push	 edx
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::begin
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 b0	 mov	 DWORD PTR $T239246[ebp], eax
  0002e	8b 4d a8	 mov	 ecx, DWORD PTR $T239244[ebp]
  00031	51		 push	 ecx
  00032	8b 55 b0	 mov	 edx, DWORD PTR $T239246[ebp]
  00035	52		 push	 edx
  00036	8d 45 b8	 lea	 eax, DWORD PTR $T239248[ebp]
  00039	50		 push	 eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::erase

; 1867 : 		}

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?_Tidy@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Tidy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::~_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >, COMDAT
; _this$ = ecx

; 554  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 555  : 		this->_Alnod.deallocate(this->_Myhead, 1);

  0000c	6a 01		 push	 1
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00014	51		 push	 ecx
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0001b	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Node>::deallocate

; 556  : 		}

  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??1?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::~_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >
_TEXT	ENDS
PUBLIC	??$_Kfn@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z ; std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0>::_Kfn<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Key@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Key, COMDAT

; 616  : 		{	// return reference to key in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 617  : 		return ((key_type&)_Traits::_Kfn(_Myval(_Pnode)));

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Myval
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??$_Kfn@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z ; std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0>::_Kfn<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >
  0001b	83 c4 04	 add	 esp, 4

; 618  : 		}

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
?_Key@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Key
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >
_TEXT	ENDS
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >
PUBLIC	??0?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
$T239257 = -72						; size = 4
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >, COMDAT
; _this$ = ecx

; 698  : 		{	// construct empty tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	51		 push	 ecx
  0000d	8b cc		 mov	 ecx, esp
  0000f	89 65 b8	 mov	 DWORD PTR $T239257[ebp], esp
  00012	8b 45 0c	 mov	 eax, DWORD PTR __Al$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??0?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ??0?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >

; 699  : 		}

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8
??0?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >
_TEXT	ENDS
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Lbound
; Function compile flags: /Odtp /ZI
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@ABH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1449 : 		{	// find leftmost node not less than _Keyval in mutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1450 : 		return (iterator(_Lbound(_Keyval), this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Keyval$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Lbound
  0001c	50		 push	 eax
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00020	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >
  00025	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1451 : 		}

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
?lower_bound@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Node>::deallocate
PUBLIC	??$_Dest_val@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@0@PAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >
PUBLIC	??$addressof@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@YAPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@AAU10@@Z ; std::addressof<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >
PUBLIC	?_Myval@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Myval
PUBLIC	?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Left
PUBLIC	?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Right
PUBLIC	?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Isnil
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$234127 = -8					; size = 4
_this$ = -4						; size = 4
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1610 : 		{	// free entire subtree, recursively

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1611 : 		for (_Nodeptr _Pnode = _Rootnode;

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __Pnode$234127[ebp], eax
  00012	eb 06		 jmp	 SHORT $LN3@Erase@3
$LN2@Erase@3:

; 1612 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  00014	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$234127[ebp]
  00017	89 45 08	 mov	 DWORD PTR __Rootnode$[ebp], eax
$LN3@Erase@3:
  0001a	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$234127[ebp]
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Isnil
  00023	83 c4 04	 add	 esp, 4
  00026	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00029	85 c9		 test	 ecx, ecx
  0002b	75 60		 jne	 SHORT $LN4@Erase@3

; 1613 : 			{	// free subtrees, then node
; 1614 : 			_Erase(this->_Right(_Pnode));

  0002d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$234127[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Right
  00036	83 c4 04	 add	 esp, 4
  00039	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003b	51		 push	 ecx
  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Erase

; 1615 : 			_Pnode = this->_Left(_Pnode);

  00044	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$234127[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Left
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 08		 mov	 ecx, DWORD PTR [eax]
  00052	89 4d f8	 mov	 DWORD PTR __Pnode$234127[ebp], ecx

; 1616 : 			_Dest_val(this->_Alval,
; 1617 : 				_STD addressof(this->_Myval(_Rootnode)));

  00055	8b 45 08	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Myval
  0005e	83 c4 04	 add	 esp, 4
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ??$addressof@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@YAPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@AAU10@@Z ; std::addressof<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >
  00067	83 c4 04	 add	 esp, 4
  0006a	50		 push	 eax
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006e	83 c1 0d	 add	 ecx, 13			; 0000000dH
  00071	51		 push	 ecx
  00072	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@0@PAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >
  00077	83 c4 08	 add	 esp, 8

; 1618 : 
; 1619 : 			this->_Alnod.deallocate(_Rootnode, 1);

  0007a	6a 01		 push	 1
  0007c	8b 45 08	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  0007f	50		 push	 eax
  00080	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00083	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00086	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Node>::deallocate

; 1620 : 			}

  0008b	eb 87		 jmp	 SHORT $LN2@Erase@3
$LN4@Erase@3:

; 1621 : 		}

  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	5b		 pop	 ebx
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c2 04 00	 ret	 4
?_Erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Erase
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Lmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1758 : 		{	// return leftmost node in nonmutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1759 : 		return (this->_Left(this->_Myhead));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Left
  00018	83 c4 04	 add	 esp, 4

; 1760 : 		}

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Lmost
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Rmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1783 : 		{	// return rightmost node in nonmutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1784 : 		return (this->_Right(this->_Myhead));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Right
  00018	83 c4 04	 add	 esp, 4

; 1785 : 		}

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?_Rmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Rmost
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Root@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Root, COMDAT
; _this$ = ecx

; 1788 : 		{	// return root of nonmutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1789 : 		return (this->_Parent(this->_Myhead));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  00018	83 c4 04	 add	 esp, 4

; 1790 : 		}

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Root
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::erase
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::begin
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T239271 = -88						; size = 4
$T239272 = -84						; size = 4
$T239273 = -80						; size = 4
$T239274 = -76						; size = 4
$T239275 = -72						; size = 4
_this$ = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1865 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1866 : 		erase(begin(), end());

  0000c	8d 45 ac	 lea	 eax, DWORD PTR $T239272[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::end
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d a8	 mov	 DWORD PTR $T239271[ebp], ecx
  0001d	8d 55 b4	 lea	 edx, DWORD PTR $T239274[ebp]
  00020	52		 push	 edx
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::begin
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 b0	 mov	 DWORD PTR $T239273[ebp], eax
  0002e	8b 4d a8	 mov	 ecx, DWORD PTR $T239271[ebp]
  00031	51		 push	 ecx
  00032	8b 55 b0	 mov	 edx, DWORD PTR $T239273[ebp]
  00035	52		 push	 edx
  00036	8d 45 b8	 lea	 eax, DWORD PTR $T239275[ebp]
  00039	50		 push	 eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::erase

; 1867 : 		}

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?_Tidy@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Tidy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::~_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >, COMDAT
; _this$ = ecx

; 554  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 555  : 		this->_Alnod.deallocate(this->_Myhead, 1);

  0000c	6a 01		 push	 1
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00014	51		 push	 ecx
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0001b	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Node>::deallocate

; 556  : 		}

  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??1?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::~_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >
_TEXT	ENDS
PUBLIC	??$_Kfn@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z ; std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0>::_Kfn<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Key@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Key, COMDAT

; 616  : 		{	// return reference to key in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 617  : 		return ((key_type&)_Traits::_Kfn(_Myval(_Pnode)));

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Myval
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??$_Kfn@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z ; std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0>::_Kfn<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >
  0001b	83 c4 04	 add	 esp, 4

; 618  : 		}

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
?_Key@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Key
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@IAEXPAUCASTLEDEEP_EVENTTIME@@0@Z ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::_Destroy
PUBLIC	??$_Move@PAUCASTLEDEEP_EVENTTIME@@PAU1@@std@@YAPAUCASTLEDEEP_EVENTTIME@@PAU1@00@Z ; std::_Move<CASTLEDEEP_EVENTTIME *,CASTLEDEEP_EVENTTIME *>
PUBLIC	?_Make_iter@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@2@@Z ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::_Make_iter
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?erase@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T239284 = -84						; size = 4
__Ptr$234174 = -16					; size = 4
__Last$ = -12						; size = 4
__First$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@2@0@Z PROC ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::erase, COMDAT
; _this$ = ecx

; 1190 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1191 : 		iterator _First = _Make_iter(_First_arg);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __First_arg$[ebp]
  0000f	50		 push	 eax
  00010	8d 4d f8	 lea	 ecx, DWORD PTR __First$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@2@@Z ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::_Make_iter

; 1192 : 		iterator _Last = _Make_iter(_Last_arg);

  0001c	8b 45 10	 mov	 eax, DWORD PTR __Last_arg$[ebp]
  0001f	50		 push	 eax
  00020	8d 4d f4	 lea	 ecx, DWORD PTR __Last$[ebp]
  00023	51		 push	 ecx
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@2@@Z ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::_Make_iter

; 1193 : 
; 1194 : 		if (_First != _Last)

  0002c	8d 45 f4	 lea	 eax, DWORD PTR __Last$[ebp]
  0002f	50		 push	 eax
  00030	8d 4d f8	 lea	 ecx, DWORD PTR __First$[ebp]
  00033	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::operator!=
  00038	0f b6 c8	 movzx	 ecx, al
  0003b	85 c9		 test	 ecx, ecx
  0003d	74 36		 je	 SHORT $LN1@erase@3

; 1195 : 			{	// worth doing, copy down over hole
; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 			if (_Last < _First || _VICONT(_First) != this
; 1198 : 				|| _VIPTR(_First) < this->_Myfirst
; 1199 : 				|| this->_Mylast < _VIPTR(_Last))
; 1200 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1201 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1202 : 				_VIPTR(_First));
; 1203 : 			_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1204 : 
; 1205 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1206 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1207 : 				_VIPTR(_First));

  0003f	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00042	50		 push	 eax
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00049	52		 push	 edx
  0004a	8b 45 f4	 mov	 eax, DWORD PTR __Last$[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ??$_Move@PAUCASTLEDEEP_EVENTTIME@@PAU1@@std@@YAPAUCASTLEDEEP_EVENTTIME@@PAU1@00@Z ; std::_Move<CASTLEDEEP_EVENTTIME *,CASTLEDEEP_EVENTTIME *>
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH
  00056	89 45 f0	 mov	 DWORD PTR __Ptr$234174[ebp], eax

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 			_Destroy(_Ptr, this->_Mylast);

  00059	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005f	51		 push	 ecx
  00060	8b 55 f0	 mov	 edx, DWORD PTR __Ptr$234174[ebp]
  00063	52		 push	 edx
  00064	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@IAEXPAUCASTLEDEEP_EVENTTIME@@0@Z ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::_Destroy

; 1211 : 			this->_Mylast = _Ptr;

  0006c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006f	8b 4d f0	 mov	 ecx, DWORD PTR __Ptr$234174[ebp]
  00072	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@erase@3:

; 1212 : 			}
; 1213 : 		return (_Make_iter(_First));

  00075	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00078	89 45 ac	 mov	 DWORD PTR $T239284[ebp], eax
  0007b	8b 4d ac	 mov	 ecx, DWORD PTR $T239284[ebp]
  0007e	51		 push	 ecx
  0007f	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00082	52		 push	 edx
  00083	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@2@@Z ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::_Make_iter
  0008b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1214 : 		}

  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@2@0@Z ENDP ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::erase
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Inside@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@IBE_NPBUCASTLEDEEP_EVENTTIME@@@Z
_TEXT	SEGMENT
tv76 = -72						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@IBE_NPBUCASTLEDEEP_EVENTTIME@@@Z PROC ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00012	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00015	73 13		 jae	 SHORT $LN3@Inside@2
  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	3b 45 08	 cmp	 eax, DWORD PTR __Ptr$[ebp]
  0001f	77 09		 ja	 SHORT $LN3@Inside@2
  00021	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  00028	eb 07		 jmp	 SHORT $LN4@Inside@2
$LN3@Inside@2:
  0002a	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN4@Inside@2:
  00031	8a 45 b8	 mov	 al, BYTE PTR tv76[ebp]

; 1287 : 		}

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?_Inside@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@IBE_NPBUCASTLEDEEP_EVENTTIME@@@Z ENDP ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::_Inside
_TEXT	ENDS
PUBLIC	?reserve@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAEXI@Z ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::reserve
PUBLIC	?_Grow_to@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@IBEII@Z ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::_Grow_to
PUBLIC	?capacity@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QBEIXZ ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::capacity
PUBLIC	?_Xlen@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@IBEXXZ ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::_Xlen
PUBLIC	?max_size@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QBEIXZ ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::max_size
PUBLIC	?size@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QBEIXZ ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::size
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Reserve@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$ = -8						; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@IAEXI@Z PROC ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1291 : 		size_type _Size = size();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?size@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QBEIXZ ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::size
  00014	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax

; 1292 : 		if (max_size() - _Count < _Size)

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QBEIXZ ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::max_size
  0001f	2b 45 08	 sub	 eax, DWORD PTR __Count$[ebp]
  00022	3b 45 f8	 cmp	 eax, DWORD PTR __Size$[ebp]
  00025	73 0a		 jae	 SHORT $LN4@Reserve@2

; 1293 : 			_Xlen();

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@IBEXXZ ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::_Xlen
  0002f	eb 2d		 jmp	 SHORT $LN6@Reserve@2
$LN4@Reserve@2:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00031	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  00034	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]
  00037	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?capacity@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QBEIXZ ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::capacity
  00042	39 45 f8	 cmp	 DWORD PTR __Size$[ebp], eax
  00045	77 02		 ja	 SHORT $LN2@Reserve@2

; 1295 : 			;
; 1296 : 		else

  00047	eb 15		 jmp	 SHORT $LN6@Reserve@2
$LN2@Reserve@2:

; 1297 : 			reserve(_Grow_to(_Size));

  00049	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?_Grow_to@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@IBEII@Z ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::_Grow_to
  00055	50		 push	 eax
  00056	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ?reserve@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAEXI@Z ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::reserve
$LN6@Reserve@2:

; 1298 : 		}

  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?_Reserve@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::_Reserve
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAEXPAUCASTLEDEEP_EVENTTIME@@I@Z ; std::allocator<CASTLEDEEP_EVENTTIME>::deallocate
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Tidy@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@IAEXXZ PROC ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1302 : 		if (this->_Myfirst != 0)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00012	74 3d		 je	 SHORT $LN1@Tidy@2

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00022	51		 push	 ecx
  00023	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00026	8b 02		 mov	 eax, DWORD PTR [edx]
  00028	50		 push	 eax
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@IAEXPAUCASTLEDEEP_EVENTTIME@@0@Z ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::_Destroy

; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0003a	2b 11		 sub	 edx, DWORD PTR [ecx]
  0003c	c1 fa 03	 sar	 edx, 3
  0003f	52		 push	 edx
  00040	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b 08		 mov	 ecx, DWORD PTR [eax]
  00045	51		 push	 ecx
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0004c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAEXPAUCASTLEDEEP_EVENTTIME@@I@Z ; std::allocator<CASTLEDEEP_EVENTTIME>::deallocate
$LN1@Tidy@2:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00051	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00054	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1310 : 		this->_Mylast = 0;

  0005a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1311 : 		this->_Myend = 0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 1312 : 		}

  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
?_Tidy@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@IAEXXZ ENDP ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::_Tidy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Orphan_range@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@IBEXPAUCASTLEDEEP_EVENTTIME@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@IBEXPAUCASTLEDEEP_EVENTTIME@@0@Z PROC ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1453 : 		{	// orphan iterators within specified (inclusive) range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1454 : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@IBEXPAUCASTLEDEEP_EVENTTIME@@0@Z ENDP ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??0?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAE@ABV01@@Z ; std::allocator<CASTLEDEEP_EVENTTIME>::allocator<CASTLEDEEP_EVENTTIME>
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE@V?$allocator@UCASTLEDEEP_EVENTTIME@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE@V?$allocator@UCASTLEDEEP_EVENTTIME@@@1@@Z PROC ; std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00016	e8 00 00 00 00	 call	 ??0?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAE@ABV01@@Z ; std::allocator<CASTLEDEEP_EVENTTIME>::allocator<CASTLEDEEP_EVENTTIME>

; 427  : 		_Myfirst = 0;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 428  : 		_Mylast = 0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 429  : 		_Myend = 0;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 430  : 		}

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
??0?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE@V?$allocator@UCASTLEDEEP_EVENTTIME@@@1@@Z ENDP ; std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::~_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >, COMDAT
; _this$ = ecx

; 433  : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 434  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::~_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAE@XZ PROC	; std::allocator<CASTLEDEEP_EVENTTIME>::allocator<CASTLEDEEP_EVENTTIME>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAE@XZ ENDP	; std::allocator<CASTLEDEEP_EVENTTIME>::allocator<CASTLEDEEP_EVENTTIME>
_TEXT	ENDS
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >, COMDAT
; _this$ = ecx

; 378  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Plist$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >

; 379  : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >
_TEXT	ENDS
PUBLIC	??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::operator*
; Function compile flags: /Odtp /ZI
;	COMDAT ??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::operator*, COMDAT
; _this$ = ecx

; 395  : 		{	// return designated value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 396  : 		return ((reference)**(_Mybase *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::operator*

; 397  : 		}

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::operator*
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 121  : 		{	// return node pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 122  : 		return (_Ptr);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]

; 123  : 		}

  00011	5f		 pop	 edi
  00012	5e		 pop	 esi
  00013	5b		 pop	 ebx
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >,std::_Iterator_base0>::_Mynode
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Inside@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IBE_NPBUCASTLEDEEP_SPAWNTIME@@@Z
_TEXT	SEGMENT
tv76 = -72						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IBE_NPBUCASTLEDEEP_SPAWNTIME@@@Z PROC ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00012	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00015	73 13		 jae	 SHORT $LN3@Inside@3
  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	3b 45 08	 cmp	 eax, DWORD PTR __Ptr$[ebp]
  0001f	77 09		 ja	 SHORT $LN3@Inside@3
  00021	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  00028	eb 07		 jmp	 SHORT $LN4@Inside@3
$LN3@Inside@3:
  0002a	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN4@Inside@3:
  00031	8a 45 b8	 mov	 al, BYTE PTR tv76[ebp]

; 1287 : 		}

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?_Inside@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IBE_NPBUCASTLEDEEP_SPAWNTIME@@@Z ENDP ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Inside
_TEXT	ENDS
PUBLIC	?reserve@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAEXI@Z ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::reserve
PUBLIC	?_Grow_to@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IBEII@Z ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Grow_to
PUBLIC	?capacity@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QBEIXZ ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::capacity
PUBLIC	?_Xlen@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IBEXXZ ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Xlen
PUBLIC	?max_size@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QBEIXZ ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::max_size
PUBLIC	?size@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QBEIXZ ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::size
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Reserve@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$ = -8						; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IAEXI@Z PROC ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1291 : 		size_type _Size = size();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?size@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QBEIXZ ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::size
  00014	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax

; 1292 : 		if (max_size() - _Count < _Size)

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QBEIXZ ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::max_size
  0001f	2b 45 08	 sub	 eax, DWORD PTR __Count$[ebp]
  00022	3b 45 f8	 cmp	 eax, DWORD PTR __Size$[ebp]
  00025	73 0a		 jae	 SHORT $LN4@Reserve@3

; 1293 : 			_Xlen();

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IBEXXZ ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Xlen
  0002f	eb 2d		 jmp	 SHORT $LN6@Reserve@3
$LN4@Reserve@3:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00031	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  00034	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]
  00037	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?capacity@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QBEIXZ ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::capacity
  00042	39 45 f8	 cmp	 DWORD PTR __Size$[ebp], eax
  00045	77 02		 ja	 SHORT $LN2@Reserve@3

; 1295 : 			;
; 1296 : 		else

  00047	eb 15		 jmp	 SHORT $LN6@Reserve@3
$LN2@Reserve@3:

; 1297 : 			reserve(_Grow_to(_Size));

  00049	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?_Grow_to@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IBEII@Z ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Grow_to
  00055	50		 push	 eax
  00056	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ?reserve@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAEXI@Z ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::reserve
$LN6@Reserve@3:

; 1298 : 		}

  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?_Reserve@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Reserve
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEXPAUCASTLEDEEP_SPAWNTIME@@I@Z ; std::allocator<CASTLEDEEP_SPAWNTIME>::deallocate
PUBLIC	?_Destroy@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IAEXPAUCASTLEDEEP_SPAWNTIME@@0@Z ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Destroy
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Tidy@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IAEXXZ PROC ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1302 : 		if (this->_Myfirst != 0)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00012	74 3d		 je	 SHORT $LN1@Tidy@3

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00022	51		 push	 ecx
  00023	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00026	8b 02		 mov	 eax, DWORD PTR [edx]
  00028	50		 push	 eax
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IAEXPAUCASTLEDEEP_SPAWNTIME@@0@Z ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Destroy

; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0003a	2b 11		 sub	 edx, DWORD PTR [ecx]
  0003c	c1 fa 03	 sar	 edx, 3
  0003f	52		 push	 edx
  00040	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b 08		 mov	 ecx, DWORD PTR [eax]
  00045	51		 push	 ecx
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0004c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEXPAUCASTLEDEEP_SPAWNTIME@@I@Z ; std::allocator<CASTLEDEEP_SPAWNTIME>::deallocate
$LN1@Tidy@3:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00051	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00054	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1310 : 		this->_Mylast = 0;

  0005a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1311 : 		this->_Myend = 0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 1312 : 		}

  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
?_Tidy@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IAEXXZ ENDP ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Tidy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Orphan_range@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IBEXPAUCASTLEDEEP_SPAWNTIME@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IBEXPAUCASTLEDEEP_SPAWNTIME@@0@Z PROC ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1453 : 		{	// orphan iterators within specified (inclusive) range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1454 : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IBEXPAUCASTLEDEEP_SPAWNTIME@@0@Z ENDP ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??0?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAE@ABV01@@Z ; std::allocator<CASTLEDEEP_SPAWNTIME>::allocator<CASTLEDEEP_SPAWNTIME>
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@1@@Z PROC ; std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00016	e8 00 00 00 00	 call	 ??0?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAE@ABV01@@Z ; std::allocator<CASTLEDEEP_SPAWNTIME>::allocator<CASTLEDEEP_SPAWNTIME>

; 427  : 		_Myfirst = 0;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 428  : 		_Mylast = 0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 429  : 		_Myend = 0;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 430  : 		}

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
??0?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@1@@Z ENDP ; std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::~_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >, COMDAT
; _this$ = ecx

; 433  : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 434  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::~_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAE@XZ PROC	; std::allocator<CASTLEDEEP_SPAWNTIME>::allocator<CASTLEDEEP_SPAWNTIME>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAE@XZ ENDP	; std::allocator<CASTLEDEEP_SPAWNTIME>::allocator<CASTLEDEEP_SPAWNTIME>
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@PAUCASTLEDEEP_SPAWNTIME@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@PAUCASTLEDEEP_SPAWNTIME@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@PAUCASTLEDEEP_SPAWNTIME@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::_Vector_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@PAUCASTLEDEEP_SPAWNTIME@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >

; 305  : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@PAUCASTLEDEEP_SPAWNTIME@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::_Vector_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QBEABUCASTLEDEEP_SPAWNTIME@@XZ ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::operator*
; Function compile flags: /Odtp /ZI
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QBEAAUCASTLEDEEP_SPAWNTIME@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QBEAAUCASTLEDEEP_SPAWNTIME@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::operator*, COMDAT
; _this$ = ecx

; 321  : 		{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 322  : 		return ((reference)**(_Mybase *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QBEABUCASTLEDEEP_SPAWNTIME@@XZ ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::operator*

; 323  : 		}

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QBEAAUCASTLEDEEP_SPAWNTIME@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::operator++
; Function compile flags: /Odtp /ZI
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::operator++, COMDAT
; _this$ = ecx

; 331  : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 332  : 		++*(_Mybase *)this;

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??E?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::operator++

; 333  : 		return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 334  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??E?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::operator++
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::_Compat
; Function compile flags: /Odtp /ZI
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		_Compat(_Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::_Compat

; 203  : 		return (this->_Ptr == _Right._Ptr);

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001e	8b 10		 mov	 edx, DWORD PTR [eax]
  00020	33 c0		 xor	 eax, eax
  00022	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00024	0f 94 c0	 sete	 al

; 204  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::operator==
_TEXT	ENDS
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >, COMDAT
; _this$ = ecx

; 378  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Plist$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >

; 379  : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >
_TEXT	ENDS
PUBLIC	??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHH@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator*
; Function compile flags: /Odtp /ZI
;	COMDAT ??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHH@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHH@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator*, COMDAT
; _this$ = ecx

; 395  : 		{	// return designated value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 396  : 		return ((reference)**(_Mybase *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHH@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator*

; 397  : 		}

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHH@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator*
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??E?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator++, COMDAT
; _this$ = ecx

; 405  : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 406  : 		++(*(_Mybase *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator++

; 407  : 		return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 408  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??E?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator++
_TEXT	ENDS
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::operator++
; Function compile flags: /Odtp /ZI
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator++, COMDAT
; _this$ = ecx

; 250  : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 251  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 252  : 		if (this->_Getcont() == 0
; 253  : 			|| this->_Ptr == 0
; 254  : 			|| _Mytree::_Isnil(this->_Ptr))
; 255  : 			{	// report error
; 256  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 257  : 			_SCL_SECURE_OUT_OF_RANGE;
; 258  : 			}
; 259  : 
; 260  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 261  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 262  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 263  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 264  : 
; 265  : 		++(*(_Mybase *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::operator++

; 266  : 		return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 267  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator++
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator==, COMDAT
; _this$ = ecx

; 316  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 317  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 318  : 		if (this->_Getcont() == 0
; 319  : 			|| this->_Getcont() != _Right._Getcont())
; 320  : 			{	// report error
; 321  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 322  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 323  : 			}
; 324  : 
; 325  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 326  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 327  : 			&& this->_Getcont() == _Right._Getcont());
; 328  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 329  : 
; 330  : 		return (this->_Ptr == _Right._Ptr);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00012	8b 10		 mov	 edx, DWORD PTR [eax]
  00014	33 c0		 xor	 eax, eax
  00016	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00018	0f 94 c0	 sete	 al

; 331  : 		}

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator==
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 121  : 		{	// return node pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 122  : 		return (_Ptr);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]

; 123  : 		}

  00011	5f		 pop	 edi
  00012	5e		 pop	 esi
  00013	5b		 pop	 ebx
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Mynode
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Inside@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IBE_NPBUCASTLEDEEP_MONSTERINFO@@@Z
_TEXT	SEGMENT
tv76 = -72						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IBE_NPBUCASTLEDEEP_MONSTERINFO@@@Z PROC ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00012	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00015	73 13		 jae	 SHORT $LN3@Inside@4
  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	3b 45 08	 cmp	 eax, DWORD PTR __Ptr$[ebp]
  0001f	77 09		 ja	 SHORT $LN3@Inside@4
  00021	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  00028	eb 07		 jmp	 SHORT $LN4@Inside@4
$LN3@Inside@4:
  0002a	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN4@Inside@4:
  00031	8a 45 b8	 mov	 al, BYTE PTR tv76[ebp]

; 1287 : 		}

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?_Inside@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IBE_NPBUCASTLEDEEP_MONSTERINFO@@@Z ENDP ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Inside
_TEXT	ENDS
PUBLIC	?reserve@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAEXI@Z ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::reserve
PUBLIC	?_Grow_to@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IBEII@Z ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Grow_to
PUBLIC	?capacity@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QBEIXZ ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::capacity
PUBLIC	?_Xlen@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IBEXXZ ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Xlen
PUBLIC	?max_size@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QBEIXZ ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::max_size
PUBLIC	?size@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QBEIXZ ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::size
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Reserve@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$ = -8						; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IAEXI@Z PROC ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1291 : 		size_type _Size = size();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?size@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QBEIXZ ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::size
  00014	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax

; 1292 : 		if (max_size() - _Count < _Size)

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QBEIXZ ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::max_size
  0001f	2b 45 08	 sub	 eax, DWORD PTR __Count$[ebp]
  00022	3b 45 f8	 cmp	 eax, DWORD PTR __Size$[ebp]
  00025	73 0a		 jae	 SHORT $LN4@Reserve@4

; 1293 : 			_Xlen();

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IBEXXZ ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Xlen
  0002f	eb 2d		 jmp	 SHORT $LN6@Reserve@4
$LN4@Reserve@4:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00031	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  00034	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]
  00037	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?capacity@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QBEIXZ ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::capacity
  00042	39 45 f8	 cmp	 DWORD PTR __Size$[ebp], eax
  00045	77 02		 ja	 SHORT $LN2@Reserve@4

; 1295 : 			;
; 1296 : 		else

  00047	eb 15		 jmp	 SHORT $LN6@Reserve@4
$LN2@Reserve@4:

; 1297 : 			reserve(_Grow_to(_Size));

  00049	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?_Grow_to@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IBEII@Z ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Grow_to
  00055	50		 push	 eax
  00056	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ?reserve@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAEXI@Z ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::reserve
$LN6@Reserve@4:

; 1298 : 		}

  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?_Reserve@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Reserve
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEXPAUCASTLEDEEP_MONSTERINFO@@I@Z ; std::allocator<CASTLEDEEP_MONSTERINFO>::deallocate
PUBLIC	?_Destroy@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IAEXPAUCASTLEDEEP_MONSTERINFO@@0@Z ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Destroy
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Tidy@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IAEXXZ PROC ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1302 : 		if (this->_Myfirst != 0)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00012	74 42		 je	 SHORT $LN1@Tidy@4

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00022	51		 push	 ecx
  00023	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00026	8b 02		 mov	 eax, DWORD PTR [edx]
  00028	50		 push	 eax
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IAEXPAUCASTLEDEEP_MONSTERINFO@@0@Z ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Destroy

; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0003a	2b 01		 sub	 eax, DWORD PTR [ecx]
  0003c	99		 cdq
  0003d	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  00042	f7 f9		 idiv	 ecx
  00044	50		 push	 eax
  00045	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00048	8b 02		 mov	 eax, DWORD PTR [edx]
  0004a	50		 push	 eax
  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00051	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEXPAUCASTLEDEEP_MONSTERINFO@@I@Z ; std::allocator<CASTLEDEEP_MONSTERINFO>::deallocate
$LN1@Tidy@4:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00056	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00059	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1310 : 		this->_Mylast = 0;

  0005f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00062	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1311 : 		this->_Myend = 0;

  00069	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 1312 : 		}

  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	5b		 pop	 ebx
  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
?_Tidy@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IAEXXZ ENDP ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Tidy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Orphan_range@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IBEXPAUCASTLEDEEP_MONSTERINFO@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IBEXPAUCASTLEDEEP_MONSTERINFO@@0@Z PROC ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1453 : 		{	// orphan iterators within specified (inclusive) range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1454 : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IBEXPAUCASTLEDEEP_MONSTERINFO@@0@Z ENDP ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??0?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAE@ABV01@@Z ; std::allocator<CASTLEDEEP_MONSTERINFO>::allocator<CASTLEDEEP_MONSTERINFO>
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@1@@Z PROC ; std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00016	e8 00 00 00 00	 call	 ??0?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAE@ABV01@@Z ; std::allocator<CASTLEDEEP_MONSTERINFO>::allocator<CASTLEDEEP_MONSTERINFO>

; 427  : 		_Myfirst = 0;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 428  : 		_Mylast = 0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 429  : 		_Myend = 0;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 430  : 		}

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
??0?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@1@@Z ENDP ; std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::~_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >, COMDAT
; _this$ = ecx

; 433  : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 434  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::~_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAE@XZ PROC ; std::allocator<CASTLEDEEP_MONSTERINFO>::allocator<CASTLEDEEP_MONSTERINFO>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAE@XZ ENDP ; std::allocator<CASTLEDEEP_MONSTERINFO>::allocator<CASTLEDEEP_MONSTERINFO>
_TEXT	ENDS
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >, COMDAT
; _this$ = ecx

; 378  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Plist$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >

; 379  : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >
_TEXT	ENDS
PUBLIC	??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::operator*
; Function compile flags: /Odtp /ZI
;	COMDAT ??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::operator*, COMDAT
; _this$ = ecx

; 395  : 		{	// return designated value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 396  : 		return ((reference)**(_Mybase *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::operator*

; 397  : 		}

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::operator*
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 121  : 		{	// return node pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 122  : 		return (_Ptr);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]

; 123  : 		}

  00011	5f		 pop	 edi
  00012	5e		 pop	 esi
  00013	5b		 pop	 ebx
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QAE@PAUCASTLEDEEP_EVENTTIME@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QAE@PAUCASTLEDEEP_EVENTTIME@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QAE@PAUCASTLEDEEP_EVENTTIME@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::_Vector_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QAE@PAUCASTLEDEEP_EVENTTIME@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >

; 305  : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QAE@PAUCASTLEDEEP_EVENTTIME@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::_Vector_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QBEABUCASTLEDEEP_EVENTTIME@@XZ ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::operator*
; Function compile flags: /Odtp /ZI
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QBEAAUCASTLEDEEP_EVENTTIME@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QBEAAUCASTLEDEEP_EVENTTIME@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::operator*, COMDAT
; _this$ = ecx

; 321  : 		{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 322  : 		return ((reference)**(_Mybase *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QBEABUCASTLEDEEP_EVENTTIME@@XZ ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::operator*

; 323  : 		}

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QBEAAUCASTLEDEEP_EVENTTIME@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::operator++
; Function compile flags: /Odtp /ZI
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::operator++, COMDAT
; _this$ = ecx

; 331  : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 332  : 		++*(_Mybase *)this;

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??E?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::operator++

; 333  : 		return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 334  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??E?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::operator++
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >, COMDAT
; _this$ = ecx

; 40   : 		{	// construct with null pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 41   : 		}

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::_Compat
; Function compile flags: /Odtp /ZI
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		_Compat(_Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::_Compat

; 203  : 		return (this->_Ptr == _Right._Ptr);

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001e	8b 10		 mov	 edx, DWORD PTR [eax]
  00020	33 c0		 xor	 eax, eax
  00022	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00024	0f 94 c0	 sete	 al

; 204  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::operator==
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@PAUCASTLEDEEP_MONSTERINFO@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@PAUCASTLEDEEP_MONSTERINFO@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@PAUCASTLEDEEP_MONSTERINFO@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::_Vector_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@PAUCASTLEDEEP_MONSTERINFO@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >

; 305  : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@PAUCASTLEDEEP_MONSTERINFO@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::_Vector_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QBEABUCASTLEDEEP_MONSTERINFO@@XZ ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::operator*
; Function compile flags: /Odtp /ZI
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QBEAAUCASTLEDEEP_MONSTERINFO@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QBEAAUCASTLEDEEP_MONSTERINFO@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::operator*, COMDAT
; _this$ = ecx

; 321  : 		{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 322  : 		return ((reference)**(_Mybase *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QBEABUCASTLEDEEP_MONSTERINFO@@XZ ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::operator*

; 323  : 		}

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QBEAAUCASTLEDEEP_MONSTERINFO@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::operator++
; Function compile flags: /Odtp /ZI
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::operator++, COMDAT
; _this$ = ecx

; 331  : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 332  : 		++*(_Mybase *)this;

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??E?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::operator++

; 333  : 		return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 334  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??E?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::operator++
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >, COMDAT
; _this$ = ecx

; 40   : 		{	// construct with null pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 41   : 		}

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::_Compat
; Function compile flags: /Odtp /ZI
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		_Compat(_Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::_Compat

; 203  : 		return (this->_Ptr == _Right._Ptr);

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001e	8b 10		 mov	 edx, DWORD PTR [eax]
  00020	33 c0		 xor	 eax, eax
  00022	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00024	0f 94 c0	 sete	 al

; 204  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::operator==
_TEXT	ENDS
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator++
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T239387 = -84						; size = 4
$T239388 = -80						; size = 4
$T239389 = -76						; size = 4
$T239390 = -72						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase, COMDAT
; _this$ = ecx

; 1379 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1380 : 		if (_First == begin() && _Last == end())

  0000c	8d 45 ac	 lea	 eax, DWORD PTR $T239387[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::begin
  00018	50		 push	 eax
  00019	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  0001c	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator==
  00021	0f b6 c8	 movzx	 ecx, al
  00024	85 c9		 test	 ecx, ecx
  00026	74 37		 je	 SHORT $LN2@erase@4
  00028	8d 45 b0	 lea	 eax, DWORD PTR $T239388[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::end
  00034	50		 push	 eax
  00035	8d 4d 10	 lea	 ecx, DWORD PTR __Last$[ebp]
  00038	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator==
  0003d	0f b6 c8	 movzx	 ecx, al
  00040	85 c9		 test	 ecx, ecx
  00042	74 1b		 je	 SHORT $LN2@erase@4

; 1381 : 			{	// erase all
; 1382 : 			clear();

  00044	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::clear

; 1383 : 			return (begin());

  0004c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0004f	50		 push	 eax
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::begin
  00058	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0005b	eb 47		 jmp	 SHORT $LN5@erase@4

; 1384 : 			}
; 1385 : 		else

  0005d	eb 45		 jmp	 SHORT $LN5@erase@4
$LN2@erase@4:

; 1386 : 			{	// partial erase, one at a time
; 1387 : 			while (_First != _Last)

  0005f	8d 45 10	 lea	 eax, DWORD PTR __Last$[ebp]
  00062	50		 push	 eax
  00063	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  00066	e8 00 00 00 00	 call	 ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator!=
  0006b	0f b6 c8	 movzx	 ecx, al
  0006e	85 c9		 test	 ecx, ecx
  00070	74 1f		 je	 SHORT $LN1@erase@4

; 1388 : 				erase(_First++);

  00072	6a 00		 push	 0
  00074	8d 45 b4	 lea	 eax, DWORD PTR $T239389[ebp]
  00077	50		 push	 eax
  00078	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  0007b	e8 00 00 00 00	 call	 ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator++
  00080	8b 08		 mov	 ecx, DWORD PTR [eax]
  00082	51		 push	 ecx
  00083	8d 55 b8	 lea	 edx, DWORD PTR $T239390[ebp]
  00086	52		 push	 edx
  00087	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008a	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
  0008f	eb ce		 jmp	 SHORT $LN2@erase@4
$LN1@erase@4:

; 1389 : 			return (iterator(_First._Ptr, this));

  00091	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00094	50		 push	 eax
  00095	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  00098	51		 push	 ecx
  00099	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0009c	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >
  000a1	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN5@erase@4:

; 1390 : 			}
; 1391 : 		}

  000a4	5f		 pop	 edi
  000a5	5e		 pop	 esi
  000a6	5b		 pop	 ebx
  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::allocate
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 542  : 		{	// construct base, and allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	51		 push	 ecx
  0000d	8b cc		 mov	 ecx, esp
  0000f	8d 45 0c	 lea	 eax, DWORD PTR __Al$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,int> >::allocator<std::pair<int const ,int> >
  00018	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  0001b	51		 push	 ecx
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ??0?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >

; 543  : 		this->_Mysize = 0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 544  : 		this->_Myhead = this->_Alnod.allocate(1);

  0002e	6a 01		 push	 1
  00030	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00036	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::allocate
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 545  : 
; 546  : 		this->_Left(this->_Myhead) = this->_Myhead;

  00041	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00044	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00053	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00056	89 08		 mov	 DWORD PTR [eax], ecx

; 547  : 		this->_Parent(this->_Myhead) = this->_Myhead;

  00058	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005e	51		 push	 ecx
  0005f	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  00064	83 c4 04	 add	 esp, 4
  00067	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0006a	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0006d	89 08		 mov	 DWORD PTR [eax], ecx

; 548  : 		this->_Right(this->_Myhead) = this->_Myhead;

  0006f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00072	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00075	51		 push	 ecx
  00076	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  0007b	83 c4 04	 add	 esp, 4
  0007e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00081	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00084	89 08		 mov	 DWORD PTR [eax], ecx

; 549  : 		this->_Color(this->_Myhead) = this->_Black;

  00086	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00089	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0008c	51		 push	 ecx
  0008d	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  00092	83 c4 04	 add	 esp, 4
  00095	c6 00 01	 mov	 BYTE PTR [eax], 1

; 550  : 		this->_Isnil(this->_Myhead) = true;

  00098	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0009e	51		 push	 ecx
  0009f	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  000a4	83 c4 04	 add	 esp, 4
  000a7	c6 00 01	 mov	 BYTE PTR [eax], 1

; 551  : 		}

  000aa	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ad	5f		 pop	 edi
  000ae	5e		 pop	 esi
  000af	5b		 pop	 ebx
  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c2 08 00	 ret	 8
??0?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<int const ,int> >::allocator<std::pair<int const ,int> >, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<int const ,int> >::allocator<std::pair<int const ,int> >
_TEXT	ENDS
PUBLIC	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>
PUBLIC	?allocate@?$allocator@H@std@@QAEPAHI@Z		; std::allocator<int>::allocate
EXTRN	__CxxThrowException@8:PROC
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\vector
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Size$234344 = -28					; size = 4
__Ptr$234337 = -24					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z PROC ; std::vector<int,std::allocator<int> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 747  : 		if (max_size() < _Count)

  0002f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
  00037	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0003a	73 0d		 jae	 SHORT $LN5@reserve

; 748  : 			_Xlen();	// result too long

  0003c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ ; std::vector<int,std::allocator<int> >::_Xlen
  00044	e9 eb 00 00 00	 jmp	 $LN7@reserve
$LN5@reserve:

; 749  : 		else if (capacity() < _Count)

  00049	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::capacity
  00051	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  00054	0f 83 da 00 00
	00		 jae	 $LN7@reserve

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  0005a	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00064	e8 00 00 00 00	 call	 ?allocate@?$allocator@H@std@@QAEPAHI@Z ; std::allocator<int>::allocate
  00069	89 45 e8	 mov	 DWORD PTR __Ptr$234337[ebp], eax

; 752  : 
; 753  : 			_TRY_BEGIN

  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00073	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$234337[ebp]
  00076	50		 push	 eax
  00077	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007d	52		 push	 edx
  0007e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 08		 mov	 ecx, DWORD PTR [eax]
  00083	51		 push	 ecx
  00084	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	e8 00 00 00 00	 call	 ??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>
  0008c	eb 29		 jmp	 SHORT $LN8@reserve
__catch$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  0008e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00091	50		 push	 eax
  00092	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$234337[ebp]
  00095	51		 push	 ecx
  00096	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0009c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@H@std@@QAEXPAHI@Z ; std::allocator<int>::deallocate

; 757  : 			_RERAISE;

  000a1	6a 00		 push	 0
  000a3	6a 00		 push	 0
  000a5	e8 00 00 00 00	 call	 __CxxThrowException@8

; 758  : 			_CATCH_END

  000aa	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000b1	b8 00 00 00 00	 mov	 eax, __tryend$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z$1
  000b6	c3		 ret	 0
$LN8@reserve:
  000b7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z$1:

; 759  : 
; 760  : 			size_type _Size = size();

  000be	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	e8 00 00 00 00	 call	 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
  000c6	89 45 e4	 mov	 DWORD PTR __Size$234344[ebp], eax

; 761  : 			if (this->_Myfirst != 0)

  000c9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000cc	83 38 00	 cmp	 DWORD PTR [eax], 0
  000cf	74 35		 je	 SHORT $LN1@reserve

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);

  000d1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d7	51		 push	 ecx
  000d8	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000db	8b 02		 mov	 eax, DWORD PTR [edx]
  000dd	50		 push	 eax
  000de	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	e8 00 00 00 00	 call	 ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy

; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  000e6	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000ef	2b 11		 sub	 edx, DWORD PTR [ecx]
  000f1	c1 fa 02	 sar	 edx, 2
  000f4	52		 push	 edx
  000f5	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000f8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fa	51		 push	 ecx
  000fb	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000fe	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00101	e8 00 00 00 00	 call	 ?deallocate@?$allocator@H@std@@QAEXPAHI@Z ; std::allocator<int>::deallocate
$LN1@reserve:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();

  00106	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 769  : 			this->_Myend = _Ptr + _Count;

  0010e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00111	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$234337[ebp]
  00114	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00117	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0011a	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 770  : 			this->_Mylast = _Ptr + _Size;

  0011d	8b 45 e4	 mov	 eax, DWORD PTR __Size$234344[ebp]
  00120	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$234337[ebp]
  00123	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00126	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00129	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 771  : 			this->_Myfirst = _Ptr;

  0012c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0012f	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$234337[ebp]
  00132	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@reserve:

; 772  : 			}
; 773  : 		}

  00134	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00137	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0013e	59		 pop	 ecx
  0013f	5f		 pop	 edi
  00140	5e		 pop	 esi
  00141	5b		 pop	 ebx
  00142	8b e5		 mov	 esp, ebp
  00144	5d		 pop	 ebp
  00145	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z ENDP ; std::vector<int,std::allocator<int> >::reserve
; Function compile flags: /Odtp /ZI
;	COMDAT ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::capacity, COMDAT
; _this$ = ecx

; 776  : 		{	// return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	c1 f8 02	 sar	 eax, 2

; 778  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::capacity
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@@Z PROC ; std::vector<int,std::allocator<int> >::_Make_iter, COMDAT
; _this$ = ecx

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  : 		return (iterator(_Where._Ptr, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<int,std::allocator<int> > >::_Vector_iterator<std::_Vector_val<int,std::allocator<int> > >
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 803  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@2@@Z ENDP ; std::vector<int,std::allocator<int> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@H@std@@QBEIXZ		; std::allocator<int>::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::max_size, COMDAT
; _this$ = ecx

; 883  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		return (this->_Alval.max_size());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00012	e8 00 00 00 00	 call	 ?max_size@?$allocator@H@std@@QBEIXZ ; std::allocator<int>::max_size

; 885  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z PROC ; std::vector<int,std::allocator<int> >::_Destroy, COMDAT
; _this$ = ecx

; 1269 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1271 : 		}

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Destroy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Grow_to@?$vector@HV?$allocator@H@std@@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -76						; size = 4
__Capacity$ = -8					; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@HV?$allocator@H@std@@@std@@IBEII@Z PROC ; std::vector<int,std::allocator<int> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1275 : 		size_type _Capacity = capacity();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::capacity
  00014	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  00022	d1 e9		 shr	 ecx, 1
  00024	2b c1		 sub	 eax, ecx
  00026	3b 45 f8	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  00029	73 09		 jae	 SHORT $LN4@Grow_to
  0002b	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  00032	eb 0b		 jmp	 SHORT $LN5@Grow_to
$LN4@Grow_to:
  00034	8b 55 f8	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00037	d1 ea		 shr	 edx, 1
  00039	03 55 f8	 add	 edx, DWORD PTR __Capacity$[ebp]
  0003c	89 55 b4	 mov	 DWORD PTR tv73[ebp], edx
$LN5@Grow_to:
  0003f	8b 45 b4	 mov	 eax, DWORD PTR tv73[ebp]
  00042	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1279 : 		if (_Capacity < _Count)

  00045	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00048	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0004b	73 06		 jae	 SHORT $LN1@Grow_to

; 1280 : 			_Capacity = _Count;

  0004d	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00050	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax
$LN1@Grow_to:

; 1281 : 		return (_Capacity);

  00053	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]

; 1282 : 		}

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
?_Grow_to@?$vector@HV?$allocator@H@std@@@std@@IBEII@Z ENDP ; std::vector<int,std::allocator<int> >::_Grow_to
_TEXT	ENDS
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ PROC	; std::vector<int,std::allocator<int> >::_Xlen, COMDAT
; _this$ = ecx

; 1426 : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00011	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen:

; 1428 : 		}

  00016	5f		 pop	 edi
  00017	5e		 pop	 esi
  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Xlen
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@H@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@H@std@@QAE@ABV01@@Z PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$allocator@H@std@@QAE@ABV01@@Z ENDP			; std::allocator<int>::allocator<int>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXPAHI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@H@std@@QAEXPAHI@Z PROC		; std::allocator<int>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 182  : 		::operator delete(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4

; 183  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?deallocate@?$allocator@H@std@@QAEXPAHI@Z ENDP		; std::allocator<int>::deallocate
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::begin, COMDAT
; _this$ = ecx

; 806  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 807  : 		return (iterator(_Lmost(), this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Lmost
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	51		 push	 ecx
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001e	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >
  00023	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 808  : 		}

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::begin
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::erase
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::operator++
; Function compile flags: /Odtp /ZI
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T239434 = -84						; size = 4
$T239435 = -80						; size = 4
$T239436 = -76						; size = 4
$T239437 = -72						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::erase, COMDAT
; _this$ = ecx

; 1379 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1380 : 		if (_First == begin() && _Last == end())

  0000c	8d 45 ac	 lea	 eax, DWORD PTR $T239434[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::begin
  00018	50		 push	 eax
  00019	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  0001c	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::operator==
  00021	0f b6 c8	 movzx	 ecx, al
  00024	85 c9		 test	 ecx, ecx
  00026	74 37		 je	 SHORT $LN2@erase@5
  00028	8d 45 b0	 lea	 eax, DWORD PTR $T239435[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::end
  00034	50		 push	 eax
  00035	8d 4d 10	 lea	 ecx, DWORD PTR __Last$[ebp]
  00038	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::operator==
  0003d	0f b6 c8	 movzx	 ecx, al
  00040	85 c9		 test	 ecx, ecx
  00042	74 1b		 je	 SHORT $LN2@erase@5

; 1381 : 			{	// erase all
; 1382 : 			clear();

  00044	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::clear

; 1383 : 			return (begin());

  0004c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0004f	50		 push	 eax
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::begin
  00058	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0005b	eb 47		 jmp	 SHORT $LN5@erase@5

; 1384 : 			}
; 1385 : 		else

  0005d	eb 45		 jmp	 SHORT $LN5@erase@5
$LN2@erase@5:

; 1386 : 			{	// partial erase, one at a time
; 1387 : 			while (_First != _Last)

  0005f	8d 45 10	 lea	 eax, DWORD PTR __Last$[ebp]
  00062	50		 push	 eax
  00063	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  00066	e8 00 00 00 00	 call	 ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::operator!=
  0006b	0f b6 c8	 movzx	 ecx, al
  0006e	85 c9		 test	 ecx, ecx
  00070	74 1f		 je	 SHORT $LN1@erase@5

; 1388 : 				erase(_First++);

  00072	6a 00		 push	 0
  00074	8d 45 b4	 lea	 eax, DWORD PTR $T239436[ebp]
  00077	50		 push	 eax
  00078	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  0007b	e8 00 00 00 00	 call	 ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::operator++
  00080	8b 08		 mov	 ecx, DWORD PTR [eax]
  00082	51		 push	 ecx
  00083	8d 55 b8	 lea	 edx, DWORD PTR $T239437[ebp]
  00086	52		 push	 edx
  00087	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008a	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::erase
  0008f	eb ce		 jmp	 SHORT $LN2@erase@5
$LN1@erase@5:

; 1389 : 			return (iterator(_First._Ptr, this));

  00091	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00094	50		 push	 eax
  00095	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  00098	51		 push	 ecx
  00099	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0009c	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >
  000a1	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN5@erase@5:

; 1390 : 			}
; 1391 : 		}

  000a4	5f		 pop	 edi
  000a5	5e		 pop	 esi
  000a6	5b		 pop	 ebx
  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::erase
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT
__Wherenode$ = -12					; size = 4
__Pnode$ = -8						; size = 4
_this$ = -4						; size = 4
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 1741 : 		{	// find leftmost node not less than _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1742 : 		_Nodeptr _Pnode = _Root();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Root
  00014	8b 00		 mov	 eax, DWORD PTR [eax]
  00016	89 45 f8	 mov	 DWORD PTR __Pnode$[ebp], eax

; 1743 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001f	89 4d f4	 mov	 DWORD PTR __Wherenode$[ebp], ecx
$LN4@Lbound:

; 1744 : 
; 1745 : 		while (!this->_Isnil(_Pnode))

  00022	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Isnil
  0002b	83 c4 04	 add	 esp, 4
  0002e	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00031	85 c9		 test	 ecx, ecx
  00033	75 4c		 jne	 SHORT $LN3@Lbound

; 1746 : 			if (_DEBUG_LT_PRED(this->comp, this->_Key(_Pnode), _Keyval))

  00035	8b 45 08	 mov	 eax, DWORD PTR __Keyval$[ebp]
  00038	50		 push	 eax
  00039	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0003c	51		 push	 ecx
  0003d	e8 00 00 00 00	 call	 ?_Key@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Key
  00042	83 c4 04	 add	 esp, 4
  00045	50		 push	 eax
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  0004e	0f b6 d0	 movzx	 edx, al
  00051	85 d2		 test	 edx, edx
  00053	74 13		 je	 SHORT $LN2@Lbound

; 1747 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00055	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Right
  0005e	83 c4 04	 add	 esp, 4
  00061	8b 08		 mov	 ecx, DWORD PTR [eax]
  00063	89 4d f8	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 1748 : 			else

  00066	eb 17		 jmp	 SHORT $LN1@Lbound
$LN2@Lbound:

; 1749 : 				{	// _Pnode not less than _Keyval, remember it
; 1750 : 				_Wherenode = _Pnode;

  00068	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0006b	89 45 f4	 mov	 DWORD PTR __Wherenode$[ebp], eax

; 1751 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  0006e	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Left
  00077	83 c4 04	 add	 esp, 4
  0007a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007c	89 4d f8	 mov	 DWORD PTR __Pnode$[ebp], ecx
$LN1@Lbound:

; 1752 : 				}

  0007f	eb a1		 jmp	 SHORT $LN4@Lbound
$LN3@Lbound:

; 1753 : 
; 1754 : 		return (_Wherenode);	// return best remembered candidate

  00081	8b 45 f4	 mov	 eax, DWORD PTR __Wherenode$[ebp]

; 1755 : 		}

  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c2 04 00	 ret	 4
?_Lbound@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Lbound
_TEXT	ENDS
PUBLIC	?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Node>::allocate
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >, COMDAT
; _this$ = ecx

; 542  : 		{	// construct base, and allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	51		 push	 ecx
  0000d	8b cc		 mov	 ecx, esp
  0000f	8d 45 0c	 lea	 eax, DWORD PTR __Al$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??0?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >
  00018	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  0001b	51		 push	 ecx
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ??0?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >

; 543  : 		this->_Mysize = 0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 544  : 		this->_Myhead = this->_Alnod.allocate(1);

  0002e	6a 01		 push	 1
  00030	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00036	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Node>::allocate
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 545  : 
; 546  : 		this->_Left(this->_Myhead) = this->_Myhead;

  00041	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00044	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Left
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00053	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00056	89 08		 mov	 DWORD PTR [eax], ecx

; 547  : 		this->_Parent(this->_Myhead) = this->_Myhead;

  00058	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005e	51		 push	 ecx
  0005f	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  00064	83 c4 04	 add	 esp, 4
  00067	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0006a	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0006d	89 08		 mov	 DWORD PTR [eax], ecx

; 548  : 		this->_Right(this->_Myhead) = this->_Myhead;

  0006f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00072	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00075	51		 push	 ecx
  00076	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Right
  0007b	83 c4 04	 add	 esp, 4
  0007e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00081	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00084	89 08		 mov	 DWORD PTR [eax], ecx

; 549  : 		this->_Color(this->_Myhead) = this->_Black;

  00086	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00089	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0008c	51		 push	 ecx
  0008d	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
  00092	83 c4 04	 add	 esp, 4
  00095	c6 00 01	 mov	 BYTE PTR [eax], 1

; 550  : 		this->_Isnil(this->_Myhead) = true;

  00098	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0009e	51		 push	 ecx
  0009f	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Isnil
  000a4	83 c4 04	 add	 esp, 4
  000a7	c6 00 01	 mov	 BYTE PTR [eax], 1

; 551  : 		}

  000aa	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ad	5f		 pop	 edi
  000ae	5e		 pop	 esi
  000af	5b		 pop	 ebx
  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c2 08 00	 ret	 8
??0?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Isnil, COMDAT

; 611  : 		{	// return reference to nil flag in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 612  : 		return ((char&)(*_Pnode)._Isnil);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	83 c0 21	 add	 eax, 33			; 00000021H

; 613  : 		}

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Isnil
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Left, COMDAT

; 621  : 		{	// return reference to left pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 622  : 		return ((_Nodepref)(*_Pnode)._Left);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 623  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Left
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent, COMDAT

; 626  : 		{	// return reference to parent pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 627  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	83 c0 04	 add	 eax, 4

; 628  : 		}

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Right, COMDAT

; 631  : 		{	// return reference to right pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 632  : 		return ((_Nodepref)(*_Pnode)._Right);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	83 c0 08	 add	 eax, 8

; 633  : 		}

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Right
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Myval, COMDAT

; 636  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 637  : 		return ((reference)(*_Pnode)._Myval);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	83 c0 0c	 add	 eax, 12			; 0000000cH

; 638  : 		}

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Myval@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Myval
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 182  : 		::operator delete(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4

; 183  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Node>::deallocate
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::begin, COMDAT
; _this$ = ecx

; 806  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 807  : 		return (iterator(_Lmost(), this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Lmost
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	51		 push	 ecx
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001e	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >
  00023	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 808  : 		}

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::begin
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::erase
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::operator++
; Function compile flags: /Odtp /ZI
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T239461 = -84						; size = 4
$T239462 = -80						; size = 4
$T239463 = -76						; size = 4
$T239464 = -72						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::erase, COMDAT
; _this$ = ecx

; 1379 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1380 : 		if (_First == begin() && _Last == end())

  0000c	8d 45 ac	 lea	 eax, DWORD PTR $T239461[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::begin
  00018	50		 push	 eax
  00019	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  0001c	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::operator==
  00021	0f b6 c8	 movzx	 ecx, al
  00024	85 c9		 test	 ecx, ecx
  00026	74 37		 je	 SHORT $LN2@erase@6
  00028	8d 45 b0	 lea	 eax, DWORD PTR $T239462[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::end
  00034	50		 push	 eax
  00035	8d 4d 10	 lea	 ecx, DWORD PTR __Last$[ebp]
  00038	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::operator==
  0003d	0f b6 c8	 movzx	 ecx, al
  00040	85 c9		 test	 ecx, ecx
  00042	74 1b		 je	 SHORT $LN2@erase@6

; 1381 : 			{	// erase all
; 1382 : 			clear();

  00044	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::clear

; 1383 : 			return (begin());

  0004c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0004f	50		 push	 eax
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::begin
  00058	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0005b	eb 47		 jmp	 SHORT $LN5@erase@6

; 1384 : 			}
; 1385 : 		else

  0005d	eb 45		 jmp	 SHORT $LN5@erase@6
$LN2@erase@6:

; 1386 : 			{	// partial erase, one at a time
; 1387 : 			while (_First != _Last)

  0005f	8d 45 10	 lea	 eax, DWORD PTR __Last$[ebp]
  00062	50		 push	 eax
  00063	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  00066	e8 00 00 00 00	 call	 ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::operator!=
  0006b	0f b6 c8	 movzx	 ecx, al
  0006e	85 c9		 test	 ecx, ecx
  00070	74 1f		 je	 SHORT $LN1@erase@6

; 1388 : 				erase(_First++);

  00072	6a 00		 push	 0
  00074	8d 45 b4	 lea	 eax, DWORD PTR $T239463[ebp]
  00077	50		 push	 eax
  00078	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  0007b	e8 00 00 00 00	 call	 ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::operator++
  00080	8b 08		 mov	 ecx, DWORD PTR [eax]
  00082	51		 push	 ecx
  00083	8d 55 b8	 lea	 edx, DWORD PTR $T239464[ebp]
  00086	52		 push	 edx
  00087	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008a	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::erase
  0008f	eb ce		 jmp	 SHORT $LN2@erase@6
$LN1@erase@6:

; 1389 : 			return (iterator(_First._Ptr, this));

  00091	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00094	50		 push	 eax
  00095	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  00098	51		 push	 ecx
  00099	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0009c	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >
  000a1	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN5@erase@6:

; 1390 : 			}
; 1391 : 		}

  000a4	5f		 pop	 edi
  000a5	5e		 pop	 esi
  000a6	5b		 pop	 ebx
  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::erase
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT
__Wherenode$ = -12					; size = 4
__Pnode$ = -8						; size = 4
_this$ = -4						; size = 4
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 1741 : 		{	// find leftmost node not less than _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1742 : 		_Nodeptr _Pnode = _Root();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Root
  00014	8b 00		 mov	 eax, DWORD PTR [eax]
  00016	89 45 f8	 mov	 DWORD PTR __Pnode$[ebp], eax

; 1743 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001f	89 4d f4	 mov	 DWORD PTR __Wherenode$[ebp], ecx
$LN4@Lbound@2:

; 1744 : 
; 1745 : 		while (!this->_Isnil(_Pnode))

  00022	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Isnil
  0002b	83 c4 04	 add	 esp, 4
  0002e	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00031	85 c9		 test	 ecx, ecx
  00033	75 4c		 jne	 SHORT $LN3@Lbound@2

; 1746 : 			if (_DEBUG_LT_PRED(this->comp, this->_Key(_Pnode), _Keyval))

  00035	8b 45 08	 mov	 eax, DWORD PTR __Keyval$[ebp]
  00038	50		 push	 eax
  00039	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0003c	51		 push	 ecx
  0003d	e8 00 00 00 00	 call	 ?_Key@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Key
  00042	83 c4 04	 add	 esp, 4
  00045	50		 push	 eax
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  0004e	0f b6 d0	 movzx	 edx, al
  00051	85 d2		 test	 edx, edx
  00053	74 13		 je	 SHORT $LN2@Lbound@2

; 1747 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00055	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Right
  0005e	83 c4 04	 add	 esp, 4
  00061	8b 08		 mov	 ecx, DWORD PTR [eax]
  00063	89 4d f8	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 1748 : 			else

  00066	eb 17		 jmp	 SHORT $LN1@Lbound@2
$LN2@Lbound@2:

; 1749 : 				{	// _Pnode not less than _Keyval, remember it
; 1750 : 				_Wherenode = _Pnode;

  00068	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0006b	89 45 f4	 mov	 DWORD PTR __Wherenode$[ebp], eax

; 1751 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  0006e	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Left
  00077	83 c4 04	 add	 esp, 4
  0007a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007c	89 4d f8	 mov	 DWORD PTR __Pnode$[ebp], ecx
$LN1@Lbound@2:

; 1752 : 				}

  0007f	eb a1		 jmp	 SHORT $LN4@Lbound@2
$LN3@Lbound@2:

; 1753 : 
; 1754 : 		return (_Wherenode);	// return best remembered candidate

  00081	8b 45 f4	 mov	 eax, DWORD PTR __Wherenode$[ebp]

; 1755 : 		}

  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c2 04 00	 ret	 4
?_Lbound@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Lbound
_TEXT	ENDS
PUBLIC	?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Node>::allocate
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >, COMDAT
; _this$ = ecx

; 542  : 		{	// construct base, and allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	51		 push	 ecx
  0000d	8b cc		 mov	 ecx, esp
  0000f	8d 45 0c	 lea	 eax, DWORD PTR __Al$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??0?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >
  00018	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  0001b	51		 push	 ecx
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ??0?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >

; 543  : 		this->_Mysize = 0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 544  : 		this->_Myhead = this->_Alnod.allocate(1);

  0002e	6a 01		 push	 1
  00030	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00036	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Node>::allocate
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 545  : 
; 546  : 		this->_Left(this->_Myhead) = this->_Myhead;

  00041	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00044	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Left
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00053	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00056	89 08		 mov	 DWORD PTR [eax], ecx

; 547  : 		this->_Parent(this->_Myhead) = this->_Myhead;

  00058	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005e	51		 push	 ecx
  0005f	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  00064	83 c4 04	 add	 esp, 4
  00067	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0006a	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0006d	89 08		 mov	 DWORD PTR [eax], ecx

; 548  : 		this->_Right(this->_Myhead) = this->_Myhead;

  0006f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00072	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00075	51		 push	 ecx
  00076	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Right
  0007b	83 c4 04	 add	 esp, 4
  0007e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00081	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00084	89 08		 mov	 DWORD PTR [eax], ecx

; 549  : 		this->_Color(this->_Myhead) = this->_Black;

  00086	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00089	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0008c	51		 push	 ecx
  0008d	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
  00092	83 c4 04	 add	 esp, 4
  00095	c6 00 01	 mov	 BYTE PTR [eax], 1

; 550  : 		this->_Isnil(this->_Myhead) = true;

  00098	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0009e	51		 push	 ecx
  0009f	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Isnil
  000a4	83 c4 04	 add	 esp, 4
  000a7	c6 00 01	 mov	 BYTE PTR [eax], 1

; 551  : 		}

  000aa	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ad	5f		 pop	 edi
  000ae	5e		 pop	 esi
  000af	5b		 pop	 ebx
  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c2 08 00	 ret	 8
??0?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Isnil, COMDAT

; 611  : 		{	// return reference to nil flag in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 612  : 		return ((char&)(*_Pnode)._Isnil);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	83 c0 21	 add	 eax, 33			; 00000021H

; 613  : 		}

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Isnil
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Left, COMDAT

; 621  : 		{	// return reference to left pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 622  : 		return ((_Nodepref)(*_Pnode)._Left);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 623  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Left
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent, COMDAT

; 626  : 		{	// return reference to parent pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 627  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	83 c0 04	 add	 eax, 4

; 628  : 		}

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Right, COMDAT

; 631  : 		{	// return reference to right pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 632  : 		return ((_Nodepref)(*_Pnode)._Right);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	83 c0 08	 add	 eax, 8

; 633  : 		}

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Right
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Myval, COMDAT

; 636  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 637  : 		return ((reference)(*_Pnode)._Myval);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	83 c0 0c	 add	 eax, 12			; 0000000cH

; 638  : 		}

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Myval@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Myval
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 182  : 		::operator delete(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4

; 183  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??$_Umove@PAUCASTLEDEEP_EVENTTIME@@@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@IAEPAUCASTLEDEEP_EVENTTIME@@PAU2@00@Z ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::_Umove<CASTLEDEEP_EVENTTIME *>
PUBLIC	?allocate@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAEPAUCASTLEDEEP_EVENTTIME@@I@Z ; std::allocator<CASTLEDEEP_EVENTTIME>::allocate
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\vector
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Size$234505 = -28					; size = 4
__Ptr$234498 = -24					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?reserve@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAEXI@Z PROC ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?reserve@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 747  : 		if (max_size() < _Count)

  0002f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?max_size@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QBEIXZ ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::max_size
  00037	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0003a	73 0d		 jae	 SHORT $LN5@reserve@2

; 748  : 			_Xlen();	// result too long

  0003c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@IBEXXZ ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::_Xlen
  00044	e9 eb 00 00 00	 jmp	 $LN7@reserve@2
$LN5@reserve@2:

; 749  : 		else if (capacity() < _Count)

  00049	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?capacity@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QBEIXZ ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::capacity
  00051	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  00054	0f 83 da 00 00
	00		 jae	 $LN7@reserve@2

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  0005a	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00064	e8 00 00 00 00	 call	 ?allocate@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAEPAUCASTLEDEEP_EVENTTIME@@I@Z ; std::allocator<CASTLEDEEP_EVENTTIME>::allocate
  00069	89 45 e8	 mov	 DWORD PTR __Ptr$234498[ebp], eax

; 752  : 
; 753  : 			_TRY_BEGIN

  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00073	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$234498[ebp]
  00076	50		 push	 eax
  00077	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007d	52		 push	 edx
  0007e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 08		 mov	 ecx, DWORD PTR [eax]
  00083	51		 push	 ecx
  00084	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	e8 00 00 00 00	 call	 ??$_Umove@PAUCASTLEDEEP_EVENTTIME@@@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@IAEPAUCASTLEDEEP_EVENTTIME@@PAU2@00@Z ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::_Umove<CASTLEDEEP_EVENTTIME *>
  0008c	eb 29		 jmp	 SHORT $LN8@reserve@2
__catch$?reserve@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  0008e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00091	50		 push	 eax
  00092	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$234498[ebp]
  00095	51		 push	 ecx
  00096	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0009c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAEXPAUCASTLEDEEP_EVENTTIME@@I@Z ; std::allocator<CASTLEDEEP_EVENTTIME>::deallocate

; 757  : 			_RERAISE;

  000a1	6a 00		 push	 0
  000a3	6a 00		 push	 0
  000a5	e8 00 00 00 00	 call	 __CxxThrowException@8

; 758  : 			_CATCH_END

  000aa	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000b1	b8 00 00 00 00	 mov	 eax, __tryend$?reserve@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAEXI@Z$1
  000b6	c3		 ret	 0
$LN8@reserve@2:
  000b7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?reserve@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAEXI@Z$1:

; 759  : 
; 760  : 			size_type _Size = size();

  000be	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	e8 00 00 00 00	 call	 ?size@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QBEIXZ ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::size
  000c6	89 45 e4	 mov	 DWORD PTR __Size$234505[ebp], eax

; 761  : 			if (this->_Myfirst != 0)

  000c9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000cc	83 38 00	 cmp	 DWORD PTR [eax], 0
  000cf	74 35		 je	 SHORT $LN1@reserve@2

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);

  000d1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d7	51		 push	 ecx
  000d8	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000db	8b 02		 mov	 eax, DWORD PTR [edx]
  000dd	50		 push	 eax
  000de	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@IAEXPAUCASTLEDEEP_EVENTTIME@@0@Z ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::_Destroy

; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  000e6	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000ef	2b 11		 sub	 edx, DWORD PTR [ecx]
  000f1	c1 fa 03	 sar	 edx, 3
  000f4	52		 push	 edx
  000f5	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000f8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fa	51		 push	 ecx
  000fb	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000fe	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00101	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAEXPAUCASTLEDEEP_EVENTTIME@@I@Z ; std::allocator<CASTLEDEEP_EVENTTIME>::deallocate
$LN1@reserve@2:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();

  00106	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 769  : 			this->_Myend = _Ptr + _Count;

  0010e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00111	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$234498[ebp]
  00114	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  00117	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0011a	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 770  : 			this->_Mylast = _Ptr + _Size;

  0011d	8b 45 e4	 mov	 eax, DWORD PTR __Size$234505[ebp]
  00120	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$234498[ebp]
  00123	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  00126	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00129	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 771  : 			this->_Myfirst = _Ptr;

  0012c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0012f	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$234498[ebp]
  00132	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@reserve@2:

; 772  : 			}
; 773  : 		}

  00134	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00137	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0013e	59		 pop	 ecx
  0013f	5f		 pop	 edi
  00140	5e		 pop	 esi
  00141	5b		 pop	 ebx
  00142	8b e5		 mov	 esp, ebp
  00144	5d		 pop	 ebp
  00145	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QAEXI@Z ENDP ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::reserve
; Function compile flags: /Odtp /ZI
;	COMDAT ?capacity@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?capacity@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QBEIXZ PROC ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::capacity, COMDAT
; _this$ = ecx

; 776  : 		{	// return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	c1 f8 03	 sar	 eax, 3

; 778  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?capacity@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QBEIXZ ENDP ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::capacity
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@2@@Z PROC ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::_Make_iter, COMDAT
; _this$ = ecx

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  : 		return (iterator(_Where._Ptr, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QAE@PAUCASTLEDEEP_EVENTTIME@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::_Vector_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 803  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
?_Make_iter@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@2@@Z ENDP ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::_Make_iter
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?size@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QBEIXZ PROC ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::size, COMDAT
; _this$ = ecx

; 878  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	c1 f8 03	 sar	 eax, 3

; 880  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?size@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QBEIXZ ENDP ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QBEIXZ ; std::allocator<CASTLEDEEP_EVENTTIME>::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?max_size@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QBEIXZ PROC ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::max_size, COMDAT
; _this$ = ecx

; 883  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		return (this->_Alval.max_size());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00012	e8 00 00 00 00	 call	 ?max_size@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QBEIXZ ; std::allocator<CASTLEDEEP_EVENTTIME>::max_size

; 885  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?max_size@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QBEIXZ ENDP ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@YAXPAUCASTLEDEEP_EVENTTIME@@0AAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@@Z ; std::_Destroy_range<std::allocator<CASTLEDEEP_EVENTTIME> >
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Destroy@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@IAEXPAUCASTLEDEEP_EVENTTIME@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@IAEXPAUCASTLEDEEP_EVENTTIME@@0@Z PROC ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::_Destroy, COMDAT
; _this$ = ecx

; 1269 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@YAXPAUCASTLEDEEP_EVENTTIME@@0AAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@@Z ; std::_Destroy_range<std::allocator<CASTLEDEEP_EVENTTIME> >
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1271 : 		}

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
?_Destroy@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@IAEXPAUCASTLEDEEP_EVENTTIME@@0@Z ENDP ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::_Destroy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Grow_to@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -76						; size = 4
__Capacity$ = -8					; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@IBEII@Z PROC ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1275 : 		size_type _Capacity = capacity();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?capacity@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QBEIXZ ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::capacity
  00014	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@QBEIXZ ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::max_size
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  00022	d1 e9		 shr	 ecx, 1
  00024	2b c1		 sub	 eax, ecx
  00026	3b 45 f8	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  00029	73 09		 jae	 SHORT $LN4@Grow_to@2
  0002b	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  00032	eb 0b		 jmp	 SHORT $LN5@Grow_to@2
$LN4@Grow_to@2:
  00034	8b 55 f8	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00037	d1 ea		 shr	 edx, 1
  00039	03 55 f8	 add	 edx, DWORD PTR __Capacity$[ebp]
  0003c	89 55 b4	 mov	 DWORD PTR tv73[ebp], edx
$LN5@Grow_to@2:
  0003f	8b 45 b4	 mov	 eax, DWORD PTR tv73[ebp]
  00042	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1279 : 		if (_Capacity < _Count)

  00045	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00048	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0004b	73 06		 jae	 SHORT $LN1@Grow_to@2

; 1280 : 			_Capacity = _Count;

  0004d	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00050	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax
$LN1@Grow_to@2:

; 1281 : 		return (_Capacity);

  00053	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]

; 1282 : 		}

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
?_Grow_to@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@IBEII@Z ENDP ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::_Grow_to
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@IBEXXZ PROC ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::_Xlen, COMDAT
; _this$ = ecx

; 1426 : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00011	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen@2:

; 1428 : 		}

  00016	5f		 pop	 edi
  00017	5e		 pop	 esi
  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Xlen@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@IBEXXZ ENDP ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::_Xlen
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CASTLEDEEP_EVENTTIME>::allocator<CASTLEDEEP_EVENTTIME>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CASTLEDEEP_EVENTTIME>::allocator<CASTLEDEEP_EVENTTIME>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAEXPAUCASTLEDEEP_EVENTTIME@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAEXPAUCASTLEDEEP_EVENTTIME@@I@Z PROC ; std::allocator<CASTLEDEEP_EVENTTIME>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 182  : 		::operator delete(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4

; 183  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?deallocate@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAEXPAUCASTLEDEEP_EVENTTIME@@I@Z ENDP ; std::allocator<CASTLEDEEP_EVENTTIME>::deallocate
_TEXT	ENDS
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >,std::_Iterator_base0>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >, COMDAT
; _this$ = ecx

; 213  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Plist$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >,std::_Iterator_base0>

; 214  : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::operator*, COMDAT
; _this$ = ecx

; 230  : 		{	// return designated value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 231  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 232  : 		if (this->_Getcont() == 0
; 233  : 			|| this->_Ptr == 0
; 234  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 235  : 			{	// report error
; 236  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 237  : 			_SCL_SECURE_OUT_OF_RANGE;
; 238  : 			}
; 239  : 
; 240  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 241  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 242  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 243  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 244  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 245  : 
; 246  : 		return (_Mytree::_Myval(this->_Ptr));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Myval
  00017	83 c4 04	 add	 esp, 4

; 247  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::operator*
_TEXT	ENDS
PUBLIC	??$_Umove@PAUCASTLEDEEP_SPAWNTIME@@@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IAEPAUCASTLEDEEP_SPAWNTIME@@PAU2@00@Z ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Umove<CASTLEDEEP_SPAWNTIME *>
PUBLIC	?allocate@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEPAUCASTLEDEEP_SPAWNTIME@@I@Z ; std::allocator<CASTLEDEEP_SPAWNTIME>::allocate
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\vector
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Size$234551 = -28					; size = 4
__Ptr$234544 = -24					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?reserve@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAEXI@Z PROC ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?reserve@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 747  : 		if (max_size() < _Count)

  0002f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?max_size@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QBEIXZ ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::max_size
  00037	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0003a	73 0d		 jae	 SHORT $LN5@reserve@3

; 748  : 			_Xlen();	// result too long

  0003c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IBEXXZ ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Xlen
  00044	e9 eb 00 00 00	 jmp	 $LN7@reserve@3
$LN5@reserve@3:

; 749  : 		else if (capacity() < _Count)

  00049	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?capacity@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QBEIXZ ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::capacity
  00051	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  00054	0f 83 da 00 00
	00		 jae	 $LN7@reserve@3

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  0005a	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00064	e8 00 00 00 00	 call	 ?allocate@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEPAUCASTLEDEEP_SPAWNTIME@@I@Z ; std::allocator<CASTLEDEEP_SPAWNTIME>::allocate
  00069	89 45 e8	 mov	 DWORD PTR __Ptr$234544[ebp], eax

; 752  : 
; 753  : 			_TRY_BEGIN

  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00073	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$234544[ebp]
  00076	50		 push	 eax
  00077	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007d	52		 push	 edx
  0007e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 08		 mov	 ecx, DWORD PTR [eax]
  00083	51		 push	 ecx
  00084	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	e8 00 00 00 00	 call	 ??$_Umove@PAUCASTLEDEEP_SPAWNTIME@@@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IAEPAUCASTLEDEEP_SPAWNTIME@@PAU2@00@Z ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Umove<CASTLEDEEP_SPAWNTIME *>
  0008c	eb 29		 jmp	 SHORT $LN8@reserve@3
__catch$?reserve@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  0008e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00091	50		 push	 eax
  00092	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$234544[ebp]
  00095	51		 push	 ecx
  00096	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0009c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEXPAUCASTLEDEEP_SPAWNTIME@@I@Z ; std::allocator<CASTLEDEEP_SPAWNTIME>::deallocate

; 757  : 			_RERAISE;

  000a1	6a 00		 push	 0
  000a3	6a 00		 push	 0
  000a5	e8 00 00 00 00	 call	 __CxxThrowException@8

; 758  : 			_CATCH_END

  000aa	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000b1	b8 00 00 00 00	 mov	 eax, __tryend$?reserve@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAEXI@Z$1
  000b6	c3		 ret	 0
$LN8@reserve@3:
  000b7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?reserve@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAEXI@Z$1:

; 759  : 
; 760  : 			size_type _Size = size();

  000be	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	e8 00 00 00 00	 call	 ?size@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QBEIXZ ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::size
  000c6	89 45 e4	 mov	 DWORD PTR __Size$234551[ebp], eax

; 761  : 			if (this->_Myfirst != 0)

  000c9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000cc	83 38 00	 cmp	 DWORD PTR [eax], 0
  000cf	74 35		 je	 SHORT $LN1@reserve@3

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);

  000d1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d7	51		 push	 ecx
  000d8	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000db	8b 02		 mov	 eax, DWORD PTR [edx]
  000dd	50		 push	 eax
  000de	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IAEXPAUCASTLEDEEP_SPAWNTIME@@0@Z ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Destroy

; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  000e6	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000ef	2b 11		 sub	 edx, DWORD PTR [ecx]
  000f1	c1 fa 03	 sar	 edx, 3
  000f4	52		 push	 edx
  000f5	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000f8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fa	51		 push	 ecx
  000fb	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000fe	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00101	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEXPAUCASTLEDEEP_SPAWNTIME@@I@Z ; std::allocator<CASTLEDEEP_SPAWNTIME>::deallocate
$LN1@reserve@3:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();

  00106	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 769  : 			this->_Myend = _Ptr + _Count;

  0010e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00111	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$234544[ebp]
  00114	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  00117	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0011a	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 770  : 			this->_Mylast = _Ptr + _Size;

  0011d	8b 45 e4	 mov	 eax, DWORD PTR __Size$234551[ebp]
  00120	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$234544[ebp]
  00123	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  00126	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00129	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 771  : 			this->_Myfirst = _Ptr;

  0012c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0012f	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$234544[ebp]
  00132	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@reserve@3:

; 772  : 			}
; 773  : 		}

  00134	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00137	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0013e	59		 pop	 ecx
  0013f	5f		 pop	 edi
  00140	5e		 pop	 esi
  00141	5b		 pop	 ebx
  00142	8b e5		 mov	 esp, ebp
  00144	5d		 pop	 ebp
  00145	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAEXI@Z ENDP ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::reserve
; Function compile flags: /Odtp /ZI
;	COMDAT ?capacity@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?capacity@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QBEIXZ PROC ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::capacity, COMDAT
; _this$ = ecx

; 776  : 		{	// return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	c1 f8 03	 sar	 eax, 3

; 778  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?capacity@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QBEIXZ ENDP ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::capacity
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?size@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QBEIXZ PROC ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::size, COMDAT
; _this$ = ecx

; 878  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	c1 f8 03	 sar	 eax, 3

; 880  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?size@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QBEIXZ ENDP ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QBEIXZ ; std::allocator<CASTLEDEEP_SPAWNTIME>::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?max_size@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QBEIXZ PROC ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::max_size, COMDAT
; _this$ = ecx

; 883  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		return (this->_Alval.max_size());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00012	e8 00 00 00 00	 call	 ?max_size@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QBEIXZ ; std::allocator<CASTLEDEEP_SPAWNTIME>::max_size

; 885  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?max_size@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QBEIXZ ENDP ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@YAXPAUCASTLEDEEP_SPAWNTIME@@0AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@@Z ; std::_Destroy_range<std::allocator<CASTLEDEEP_SPAWNTIME> >
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Destroy@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IAEXPAUCASTLEDEEP_SPAWNTIME@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IAEXPAUCASTLEDEEP_SPAWNTIME@@0@Z PROC ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Destroy, COMDAT
; _this$ = ecx

; 1269 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@YAXPAUCASTLEDEEP_SPAWNTIME@@0AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@@Z ; std::_Destroy_range<std::allocator<CASTLEDEEP_SPAWNTIME> >
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1271 : 		}

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
?_Destroy@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IAEXPAUCASTLEDEEP_SPAWNTIME@@0@Z ENDP ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Destroy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Grow_to@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -76						; size = 4
__Capacity$ = -8					; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IBEII@Z PROC ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1275 : 		size_type _Capacity = capacity();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?capacity@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QBEIXZ ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::capacity
  00014	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QBEIXZ ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::max_size
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  00022	d1 e9		 shr	 ecx, 1
  00024	2b c1		 sub	 eax, ecx
  00026	3b 45 f8	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  00029	73 09		 jae	 SHORT $LN4@Grow_to@3
  0002b	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  00032	eb 0b		 jmp	 SHORT $LN5@Grow_to@3
$LN4@Grow_to@3:
  00034	8b 55 f8	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00037	d1 ea		 shr	 edx, 1
  00039	03 55 f8	 add	 edx, DWORD PTR __Capacity$[ebp]
  0003c	89 55 b4	 mov	 DWORD PTR tv73[ebp], edx
$LN5@Grow_to@3:
  0003f	8b 45 b4	 mov	 eax, DWORD PTR tv73[ebp]
  00042	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1279 : 		if (_Capacity < _Count)

  00045	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00048	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0004b	73 06		 jae	 SHORT $LN1@Grow_to@3

; 1280 : 			_Capacity = _Count;

  0004d	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00050	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax
$LN1@Grow_to@3:

; 1281 : 		return (_Capacity);

  00053	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]

; 1282 : 		}

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
?_Grow_to@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IBEII@Z ENDP ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Grow_to
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IBEXXZ PROC ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Xlen, COMDAT
; _this$ = ecx

; 1426 : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00011	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen@3:

; 1428 : 		}

  00016	5f		 pop	 edi
  00017	5e		 pop	 esi
  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Xlen@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IBEXXZ ENDP ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Xlen
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CASTLEDEEP_SPAWNTIME>::allocator<CASTLEDEEP_SPAWNTIME>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CASTLEDEEP_SPAWNTIME>::allocator<CASTLEDEEP_SPAWNTIME>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEXPAUCASTLEDEEP_SPAWNTIME@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEXPAUCASTLEDEEP_SPAWNTIME@@I@Z PROC ; std::allocator<CASTLEDEEP_SPAWNTIME>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 182  : 		::operator delete(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4

; 183  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?deallocate@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEXPAUCASTLEDEEP_SPAWNTIME@@I@Z ENDP ; std::allocator<CASTLEDEEP_SPAWNTIME>::deallocate
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@PAUCASTLEDEEP_SPAWNTIME@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@PAUCASTLEDEEP_SPAWNTIME@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 47   : 		}

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@PAUCASTLEDEEP_SPAWNTIME@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QBEABUCASTLEDEEP_SPAWNTIME@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QBEABUCASTLEDEEP_SPAWNTIME@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::operator*, COMDAT
; _this$ = ecx

; 63   : 		{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
$LN2@operator:

; 64   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 65   : 		if (this->_Getcont() == 0
; 66   : 			|| this->_Ptr == 0
; 67   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 68   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 69   : 			{	// report error
; 70   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 71   : 			_SCL_SECURE_OUT_OF_RANGE;
; 72   : 			}
; 73   : 
; 74   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 75   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 76   : 		_SCL_SECURE_VALIDATE_RANGE(
; 77   : 			this->_Ptr != 0
; 78   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 79   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 80   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 81   : 
; 82   : 		__analysis_assume(this->_Ptr != 0);

  0000c	33 c0		 xor	 eax, eax
  0000e	75 fc		 jne	 SHORT $LN2@operator

; 83   : 
; 84   : 		return (*this->_Ptr);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 00		 mov	 eax, DWORD PTR [eax]

; 85   : 		}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QBEABUCASTLEDEEP_SPAWNTIME@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::operator*
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::operator++, COMDAT
; _this$ = ecx

; 93   : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 94   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 95   : 		if (this->_Getcont() == 0
; 96   : 			|| this->_Ptr == 0
; 97   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 98   : 			{	// report error
; 99   : 			_DEBUG_ERROR("vector iterator not incrementable");
; 100  : 			_SCL_SECURE_OUT_OF_RANGE;
; 101  : 			}
; 102  : 
; 103  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 104  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 105  : 		_SCL_SECURE_VALIDATE_RANGE(
; 106  : 			this->_Ptr != 0
; 107  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 108  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 109  : 
; 110  : 		++this->_Ptr;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	83 c1 08	 add	 ecx, 8
  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	89 0a		 mov	 DWORD PTR [edx], ecx

; 111  : 		return (*this);

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 112  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::operator++
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::_Compat, COMDAT
; _this$ = ecx

; 252  : 		{	// test for compatible iterator pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 253  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::_Compat
_TEXT	ENDS
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >, COMDAT
; _this$ = ecx

; 213  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Plist$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>

; 214  : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHH@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHH@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator*, COMDAT
; _this$ = ecx

; 230  : 		{	// return designated value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 231  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 232  : 		if (this->_Getcont() == 0
; 233  : 			|| this->_Ptr == 0
; 234  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 235  : 			{	// report error
; 236  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 237  : 			_SCL_SECURE_OUT_OF_RANGE;
; 238  : 			}
; 239  : 
; 240  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 241  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 242  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 243  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 244  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 245  : 
; 246  : 		return (_Mytree::_Myval(this->_Ptr));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Myval
  00017	83 c4 04	 add	 esp, 4

; 247  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHH@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator*
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
__Pnode$234598 = -8					; size = 4
_this$ = -4						; size = 4
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 58   : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 59   : 		if (_Mytree::_Isnil(_Ptr))

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  00017	83 c4 04	 add	 esp, 4
  0001a	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0001d	85 d2		 test	 edx, edx
  0001f	74 05		 je	 SHORT $LN6@operator@2
  00021	e9 8d 00 00 00	 jmp	 $LN5@operator@2
$LN6@operator@2:

; 60   : 			;	// end() shouldn't be incremented, don't move
; 61   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002b	51		 push	 ecx
  0002c	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  00031	83 c4 04	 add	 esp, 4
  00034	8b 10		 mov	 edx, DWORD PTR [eax]
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  0003c	83 c4 04	 add	 esp, 4
  0003f	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00042	85 c0		 test	 eax, eax
  00044	75 20		 jne	 SHORT $LN2@operator@2

; 62   : 			_Ptr = _Mytree::_Min(
; 63   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

  00046	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00049	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  00051	83 c4 04	 add	 esp, 4
  00054	8b 10		 mov	 edx, DWORD PTR [eax]
  00056	52		 push	 edx
  00057	e8 00 00 00 00	 call	 ?_Min@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Min
  0005c	83 c4 04	 add	 esp, 4
  0005f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00062	89 01		 mov	 DWORD PTR [ecx], eax

; 64   : 		else

  00064	eb 4d		 jmp	 SHORT $LN5@operator@2
$LN2@operator@2:

; 65   : 			{	// climb looking for right subtree
; 66   : 			_Nodeptr _Pnode;
; 67   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 68   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  00066	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00069	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006b	51		 push	 ecx
  0006c	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  00071	83 c4 04	 add	 esp, 4
  00074	8b 10		 mov	 edx, DWORD PTR [eax]
  00076	89 55 f8	 mov	 DWORD PTR __Pnode$234598[ebp], edx
  00079	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$234598[ebp]
  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  00082	83 c4 04	 add	 esp, 4
  00085	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00088	85 c9		 test	 ecx, ecx
  0008a	75 1f		 jne	 SHORT $LN1@operator@2
  0008c	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$234598[ebp]
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  00095	83 c4 04	 add	 esp, 4
  00098	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0009d	3b 10		 cmp	 edx, DWORD PTR [eax]
  0009f	75 0a		 jne	 SHORT $LN1@operator@2

; 69   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  000a1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a4	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$234598[ebp]
  000a7	89 08		 mov	 DWORD PTR [eax], ecx
  000a9	eb bb		 jmp	 SHORT $LN2@operator@2
$LN1@operator@2:

; 70   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  000ab	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$234598[ebp]
  000b1	89 08		 mov	 DWORD PTR [eax], ecx
$LN5@operator@2:

; 71   : 			}
; 72   : 		return (*this);

  000b3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 73   : 		}

  000b6	5f		 pop	 edi
  000b7	5e		 pop	 esi
  000b8	5b		 pop	 ebx
  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c3		 ret	 0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::operator++
_TEXT	ENDS
PUBLIC	??$_Umove@PAUCASTLEDEEP_MONSTERINFO@@@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IAEPAUCASTLEDEEP_MONSTERINFO@@PAU2@00@Z ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Umove<CASTLEDEEP_MONSTERINFO *>
PUBLIC	?allocate@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEPAUCASTLEDEEP_MONSTERINFO@@I@Z ; std::allocator<CASTLEDEEP_MONSTERINFO>::allocate
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\vector
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Size$234614 = -28					; size = 4
__Ptr$234607 = -24					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?reserve@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAEXI@Z PROC ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?reserve@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 747  : 		if (max_size() < _Count)

  0002f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?max_size@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QBEIXZ ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::max_size
  00037	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0003a	73 0d		 jae	 SHORT $LN5@reserve@4

; 748  : 			_Xlen();	// result too long

  0003c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IBEXXZ ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Xlen
  00044	e9 f0 00 00 00	 jmp	 $LN7@reserve@4
$LN5@reserve@4:

; 749  : 		else if (capacity() < _Count)

  00049	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?capacity@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QBEIXZ ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::capacity
  00051	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  00054	0f 83 df 00 00
	00		 jae	 $LN7@reserve@4

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  0005a	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00064	e8 00 00 00 00	 call	 ?allocate@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEPAUCASTLEDEEP_MONSTERINFO@@I@Z ; std::allocator<CASTLEDEEP_MONSTERINFO>::allocate
  00069	89 45 e8	 mov	 DWORD PTR __Ptr$234607[ebp], eax

; 752  : 
; 753  : 			_TRY_BEGIN

  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00073	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$234607[ebp]
  00076	50		 push	 eax
  00077	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007d	52		 push	 edx
  0007e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 08		 mov	 ecx, DWORD PTR [eax]
  00083	51		 push	 ecx
  00084	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	e8 00 00 00 00	 call	 ??$_Umove@PAUCASTLEDEEP_MONSTERINFO@@@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IAEPAUCASTLEDEEP_MONSTERINFO@@PAU2@00@Z ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Umove<CASTLEDEEP_MONSTERINFO *>
  0008c	eb 29		 jmp	 SHORT $LN8@reserve@4
__catch$?reserve@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  0008e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00091	50		 push	 eax
  00092	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$234607[ebp]
  00095	51		 push	 ecx
  00096	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0009c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEXPAUCASTLEDEEP_MONSTERINFO@@I@Z ; std::allocator<CASTLEDEEP_MONSTERINFO>::deallocate

; 757  : 			_RERAISE;

  000a1	6a 00		 push	 0
  000a3	6a 00		 push	 0
  000a5	e8 00 00 00 00	 call	 __CxxThrowException@8

; 758  : 			_CATCH_END

  000aa	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000b1	b8 00 00 00 00	 mov	 eax, __tryend$?reserve@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAEXI@Z$1
  000b6	c3		 ret	 0
$LN8@reserve@4:
  000b7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?reserve@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAEXI@Z$1:

; 759  : 
; 760  : 			size_type _Size = size();

  000be	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	e8 00 00 00 00	 call	 ?size@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QBEIXZ ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::size
  000c6	89 45 e4	 mov	 DWORD PTR __Size$234614[ebp], eax

; 761  : 			if (this->_Myfirst != 0)

  000c9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000cc	83 38 00	 cmp	 DWORD PTR [eax], 0
  000cf	74 3a		 je	 SHORT $LN1@reserve@4

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);

  000d1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d7	51		 push	 ecx
  000d8	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000db	8b 02		 mov	 eax, DWORD PTR [edx]
  000dd	50		 push	 eax
  000de	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IAEXPAUCASTLEDEEP_MONSTERINFO@@0@Z ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Destroy

; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  000e6	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000ef	2b 01		 sub	 eax, DWORD PTR [ecx]
  000f1	99		 cdq
  000f2	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  000f7	f7 f9		 idiv	 ecx
  000f9	50		 push	 eax
  000fa	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000fd	8b 02		 mov	 eax, DWORD PTR [edx]
  000ff	50		 push	 eax
  00100	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00103	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00106	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEXPAUCASTLEDEEP_MONSTERINFO@@I@Z ; std::allocator<CASTLEDEEP_MONSTERINFO>::deallocate
$LN1@reserve@4:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();

  0010b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0010e	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 769  : 			this->_Myend = _Ptr + _Count;

  00113	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00116	6b c0 1c	 imul	 eax, 28			; 0000001cH
  00119	03 45 e8	 add	 eax, DWORD PTR __Ptr$234607[ebp]
  0011c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0011f	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 770  : 			this->_Mylast = _Ptr + _Size;

  00122	8b 45 e4	 mov	 eax, DWORD PTR __Size$234614[ebp]
  00125	6b c0 1c	 imul	 eax, 28			; 0000001cH
  00128	03 45 e8	 add	 eax, DWORD PTR __Ptr$234607[ebp]
  0012b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0012e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 771  : 			this->_Myfirst = _Ptr;

  00131	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00134	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$234607[ebp]
  00137	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@reserve@4:

; 772  : 			}
; 773  : 		}

  00139	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0013c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00143	59		 pop	 ecx
  00144	5f		 pop	 edi
  00145	5e		 pop	 esi
  00146	5b		 pop	 ebx
  00147	8b e5		 mov	 esp, ebp
  00149	5d		 pop	 ebp
  0014a	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAEXI@Z ENDP ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::reserve
; Function compile flags: /Odtp /ZI
;	COMDAT ?capacity@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?capacity@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QBEIXZ PROC ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::capacity, COMDAT
; _this$ = ecx

; 776  : 		{	// return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	99		 cdq
  00018	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  0001d	f7 f9		 idiv	 ecx

; 778  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?capacity@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QBEIXZ ENDP ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::capacity
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?size@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QBEIXZ PROC ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::size, COMDAT
; _this$ = ecx

; 878  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	99		 cdq
  00018	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  0001d	f7 f9		 idiv	 ecx

; 880  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?size@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QBEIXZ ENDP ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QBEIXZ ; std::allocator<CASTLEDEEP_MONSTERINFO>::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?max_size@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QBEIXZ PROC ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::max_size, COMDAT
; _this$ = ecx

; 883  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		return (this->_Alval.max_size());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00012	e8 00 00 00 00	 call	 ?max_size@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QBEIXZ ; std::allocator<CASTLEDEEP_MONSTERINFO>::max_size

; 885  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?max_size@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QBEIXZ ENDP ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@YAXPAUCASTLEDEEP_MONSTERINFO@@0AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@@Z ; std::_Destroy_range<std::allocator<CASTLEDEEP_MONSTERINFO> >
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Destroy@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IAEXPAUCASTLEDEEP_MONSTERINFO@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IAEXPAUCASTLEDEEP_MONSTERINFO@@0@Z PROC ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Destroy, COMDAT
; _this$ = ecx

; 1269 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@YAXPAUCASTLEDEEP_MONSTERINFO@@0AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@@Z ; std::_Destroy_range<std::allocator<CASTLEDEEP_MONSTERINFO> >
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1271 : 		}

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
?_Destroy@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IAEXPAUCASTLEDEEP_MONSTERINFO@@0@Z ENDP ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Destroy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Grow_to@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -76						; size = 4
__Capacity$ = -8					; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IBEII@Z PROC ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1275 : 		size_type _Capacity = capacity();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?capacity@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QBEIXZ ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::capacity
  00014	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QBEIXZ ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::max_size
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  00022	d1 e9		 shr	 ecx, 1
  00024	2b c1		 sub	 eax, ecx
  00026	3b 45 f8	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  00029	73 09		 jae	 SHORT $LN4@Grow_to@4
  0002b	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  00032	eb 0b		 jmp	 SHORT $LN5@Grow_to@4
$LN4@Grow_to@4:
  00034	8b 55 f8	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00037	d1 ea		 shr	 edx, 1
  00039	03 55 f8	 add	 edx, DWORD PTR __Capacity$[ebp]
  0003c	89 55 b4	 mov	 DWORD PTR tv73[ebp], edx
$LN5@Grow_to@4:
  0003f	8b 45 b4	 mov	 eax, DWORD PTR tv73[ebp]
  00042	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1279 : 		if (_Capacity < _Count)

  00045	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00048	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0004b	73 06		 jae	 SHORT $LN1@Grow_to@4

; 1280 : 			_Capacity = _Count;

  0004d	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00050	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax
$LN1@Grow_to@4:

; 1281 : 		return (_Capacity);

  00053	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]

; 1282 : 		}

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
?_Grow_to@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IBEII@Z ENDP ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Grow_to
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IBEXXZ PROC ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Xlen, COMDAT
; _this$ = ecx

; 1426 : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00011	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen@4:

; 1428 : 		}

  00016	5f		 pop	 edi
  00017	5e		 pop	 esi
  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Xlen@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IBEXXZ ENDP ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Xlen
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CASTLEDEEP_MONSTERINFO>::allocator<CASTLEDEEP_MONSTERINFO>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CASTLEDEEP_MONSTERINFO>::allocator<CASTLEDEEP_MONSTERINFO>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEXPAUCASTLEDEEP_MONSTERINFO@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEXPAUCASTLEDEEP_MONSTERINFO@@I@Z PROC ; std::allocator<CASTLEDEEP_MONSTERINFO>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 182  : 		::operator delete(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4

; 183  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?deallocate@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEXPAUCASTLEDEEP_MONSTERINFO@@I@Z ENDP ; std::allocator<CASTLEDEEP_MONSTERINFO>::deallocate
_TEXT	ENDS
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >,std::_Iterator_base0>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >, COMDAT
; _this$ = ecx

; 213  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Plist$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >,std::_Iterator_base0>

; 214  : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::operator*, COMDAT
; _this$ = ecx

; 230  : 		{	// return designated value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 231  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 232  : 		if (this->_Getcont() == 0
; 233  : 			|| this->_Ptr == 0
; 234  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 235  : 			{	// report error
; 236  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 237  : 			_SCL_SECURE_OUT_OF_RANGE;
; 238  : 			}
; 239  : 
; 240  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 241  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 242  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 243  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 244  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 245  : 
; 246  : 		return (_Mytree::_Myval(this->_Ptr));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Myval
  00017	83 c4 04	 add	 esp, 4

; 247  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::operator*
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QAE@PAUCASTLEDEEP_EVENTTIME@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QAE@PAUCASTLEDEEP_EVENTTIME@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 47   : 		}

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QAE@PAUCASTLEDEEP_EVENTTIME@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QBEABUCASTLEDEEP_EVENTTIME@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QBEABUCASTLEDEEP_EVENTTIME@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::operator*, COMDAT
; _this$ = ecx

; 63   : 		{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
$LN2@operator@3:

; 64   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 65   : 		if (this->_Getcont() == 0
; 66   : 			|| this->_Ptr == 0
; 67   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 68   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 69   : 			{	// report error
; 70   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 71   : 			_SCL_SECURE_OUT_OF_RANGE;
; 72   : 			}
; 73   : 
; 74   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 75   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 76   : 		_SCL_SECURE_VALIDATE_RANGE(
; 77   : 			this->_Ptr != 0
; 78   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 79   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 80   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 81   : 
; 82   : 		__analysis_assume(this->_Ptr != 0);

  0000c	33 c0		 xor	 eax, eax
  0000e	75 fc		 jne	 SHORT $LN2@operator@3

; 83   : 
; 84   : 		return (*this->_Ptr);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 00		 mov	 eax, DWORD PTR [eax]

; 85   : 		}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QBEABUCASTLEDEEP_EVENTTIME@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::operator*
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::operator++, COMDAT
; _this$ = ecx

; 93   : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 94   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 95   : 		if (this->_Getcont() == 0
; 96   : 			|| this->_Ptr == 0
; 97   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 98   : 			{	// report error
; 99   : 			_DEBUG_ERROR("vector iterator not incrementable");
; 100  : 			_SCL_SECURE_OUT_OF_RANGE;
; 101  : 			}
; 102  : 
; 103  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 104  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 105  : 		_SCL_SECURE_VALIDATE_RANGE(
; 106  : 			this->_Ptr != 0
; 107  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 108  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 109  : 
; 110  : 		++this->_Ptr;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	83 c1 08	 add	 ecx, 8
  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	89 0a		 mov	 DWORD PTR [edx], ecx

; 111  : 		return (*this);

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 112  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::operator++
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::_Compat, COMDAT
; _this$ = ecx

; 252  : 		{	// test for compatible iterator pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 253  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> > >::_Compat
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@PAUCASTLEDEEP_MONSTERINFO@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@PAUCASTLEDEEP_MONSTERINFO@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 47   : 		}

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@PAUCASTLEDEEP_MONSTERINFO@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QBEABUCASTLEDEEP_MONSTERINFO@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QBEABUCASTLEDEEP_MONSTERINFO@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::operator*, COMDAT
; _this$ = ecx

; 63   : 		{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
$LN2@operator@4:

; 64   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 65   : 		if (this->_Getcont() == 0
; 66   : 			|| this->_Ptr == 0
; 67   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 68   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 69   : 			{	// report error
; 70   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 71   : 			_SCL_SECURE_OUT_OF_RANGE;
; 72   : 			}
; 73   : 
; 74   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 75   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 76   : 		_SCL_SECURE_VALIDATE_RANGE(
; 77   : 			this->_Ptr != 0
; 78   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 79   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 80   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 81   : 
; 82   : 		__analysis_assume(this->_Ptr != 0);

  0000c	33 c0		 xor	 eax, eax
  0000e	75 fc		 jne	 SHORT $LN2@operator@4

; 83   : 
; 84   : 		return (*this->_Ptr);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 00		 mov	 eax, DWORD PTR [eax]

; 85   : 		}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QBEABUCASTLEDEEP_MONSTERINFO@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::operator*
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::operator++, COMDAT
; _this$ = ecx

; 93   : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 94   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 95   : 		if (this->_Getcont() == 0
; 96   : 			|| this->_Ptr == 0
; 97   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 98   : 			{	// report error
; 99   : 			_DEBUG_ERROR("vector iterator not incrementable");
; 100  : 			_SCL_SECURE_OUT_OF_RANGE;
; 101  : 			}
; 102  : 
; 103  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 104  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 105  : 		_SCL_SECURE_VALIDATE_RANGE(
; 106  : 			this->_Ptr != 0
; 107  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 108  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 109  : 
; 110  : 		++this->_Ptr;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	89 0a		 mov	 DWORD PTR [edx], ecx

; 111  : 		return (*this);

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 112  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::operator++
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::_Compat, COMDAT
; _this$ = ecx

; 252  : 		{	// test for compatible iterator pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 253  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::_Compat
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<int,std::allocator<int> > >::_Vector_iterator<std::_Vector_val<int,std::allocator<int> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >

; 305  : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<int,std::allocator<int> > >::_Vector_iterator<std::_Vector_val<int,std::allocator<int> > >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::operator==
; Function compile flags: /Odtp /ZI
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 208  : 		return (!(*this == _Right));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??8?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::operator==
  00018	0f b6 c0	 movzx	 eax, al
  0001b	f7 d8		 neg	 eax
  0001d	1b c0		 sbb	 eax, eax
  0001f	83 c0 01	 add	 eax, 1

; 209  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::operator!=
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBHH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node><std::pair<int const ,int> >
PUBLIC	??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@QAE@U?$less@H@1@@Z ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 482  : 		{	// construct traits from _Parg and allocators from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  0000f	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00012	51		 push	 ecx
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@QAE@U?$less@H@1@@Z ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>
  0001b	8d 45 0c	 lea	 eax, DWORD PTR __Al$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00025	e8 00 00 00 00	 call	 ??$?0U?$pair@$$CBHH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node><std::pair<int const ,int> >
  0002a	8d 45 0c	 lea	 eax, DWORD PTR __Al$[ebp]
  0002d	50		 push	 eax
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	83 c1 0d	 add	 ecx, 13			; 0000000dH
  00034	e8 00 00 00 00	 call	 ??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,int> >::allocator<std::pair<int const ,int> >

; 483  : 		}

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 08 00	 ret	 8
??0?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 187  : 		return (_Allocate(_Count, (pointer)0));

  0000c	6a 00		 push	 0
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>
  00017	83 c4 08	 add	 esp, 8

; 188  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	??$_Allocate@H@std@@YAPAHIPAH@Z			; std::_Allocate<int>
; Function compile flags: /Odtp /ZI
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@H@std@@QAEPAHI@Z PROC		; std::allocator<int>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 187  : 		return (_Allocate(_Count, (pointer)0));

  0000c	6a 00		 push	 0
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Allocate@H@std@@YAPAHIPAH@Z ; std::_Allocate<int>
  00017	83 c4 08	 add	 esp, 8

; 188  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?allocate@?$allocator@H@std@@QAEPAHI@Z ENDP		; std::allocator<int>::allocate
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@H@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -76						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@H@std@@QBEIXZ PROC		; std::allocator<int>::max_size, COMDAT
; _this$ = ecx

; 217  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  0000c	c7 45 f8 ff ff
	ff 3f		 mov	 DWORD PTR __Count$[ebp], 1073741823 ; 3fffffffH

; 219  : 		return (0 < _Count ? _Count : 1);

  00013	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00017	76 08		 jbe	 SHORT $LN3@max_size
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0001c	89 45 b4	 mov	 DWORD PTR tv65[ebp], eax
  0001f	eb 07		 jmp	 SHORT $LN4@max_size
$LN3@max_size:
  00021	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$LN4@max_size:
  00028	8b 45 b4	 mov	 eax, DWORD PTR tv65[ebp]

; 220  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?max_size@?$allocator@H@std@@QBEIXZ ENDP		; std::allocator<int>::max_size
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Rrotate
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Lrotate
PUBLIC	?_Max@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Max
PUBLIC	?_Min@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Min
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::operator++
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@@Z
_TEXT	SEGMENT
tv182 = -88						; size = 4
tv170 = -88						; size = 4
__Pnode$ = -20						; size = 4
__Fixnodeparent$ = -16					; size = 4
__Fixnode$ = -12					; size = 4
__Erasednode$ = -8					; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::erase, COMDAT
; _this$ = ecx

; 1195 : 		{	// erase element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1198 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1199 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1200 : 		++_Where;	// save successor iterator for return
; 1201 : 		_Orphan_ptr(*this, _Erasednode);
; 1202 : 
; 1203 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1204 : 		if (this->_Isnil(_Where._Mynode()))

  0000c	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >,std::_Iterator_base0>::_Mynode
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Isnil
  0001a	83 c4 04	 add	 esp, 4
  0001d	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00020	85 c0		 test	 eax, eax
  00022	74 0a		 je	 SHORT $LN40@erase@7

; 1205 : 			_Xout_of_range("invalid map/set<T> iterator");

  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
  00029	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN40@erase@7:

; 1206 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

  0002e	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  00031	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >,std::_Iterator_base0>::_Mynode
  00036	89 45 f8	 mov	 DWORD PTR __Erasednode$[ebp], eax

; 1207 : 		++_Where;	// save successor iterator for return

  00039	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  0003c	e8 00 00 00 00	 call	 ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::operator++

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1211 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1212 : 		_Nodeptr _Pnode = _Erasednode;

  00041	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00044	89 45 ec	 mov	 DWORD PTR __Pnode$[ebp], eax

; 1213 : 
; 1214 : 		if (this->_Isnil(this->_Left(_Pnode)))

  00047	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Left
  00050	83 c4 04	 add	 esp, 4
  00053	8b 08		 mov	 ecx, DWORD PTR [eax]
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Isnil
  0005b	83 c4 04	 add	 esp, 4
  0005e	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00061	85 d2		 test	 edx, edx
  00063	74 13		 je	 SHORT $LN39@erase@7

; 1215 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree

  00065	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Right
  0006e	83 c4 04	 add	 esp, 4
  00071	8b 08		 mov	 ecx, DWORD PTR [eax]
  00073	89 4d f4	 mov	 DWORD PTR __Fixnode$[ebp], ecx
  00076	eb 4d		 jmp	 SHORT $LN38@erase@7
$LN39@erase@7:

; 1216 : 		else if (this->_Isnil(this->_Right(_Pnode)))

  00078	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Right
  00081	83 c4 04	 add	 esp, 4
  00084	8b 08		 mov	 ecx, DWORD PTR [eax]
  00086	51		 push	 ecx
  00087	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Isnil
  0008c	83 c4 04	 add	 esp, 4
  0008f	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00092	85 d2		 test	 edx, edx
  00094	74 13		 je	 SHORT $LN37@erase@7

; 1217 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree

  00096	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Left
  0009f	83 c4 04	 add	 esp, 4
  000a2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a4	89 4d f4	 mov	 DWORD PTR __Fixnode$[ebp], ecx

; 1218 : 		else

  000a7	eb 1c		 jmp	 SHORT $LN38@erase@7
$LN37@erase@7:

; 1219 : 			{	// two subtrees, must lift successor node to replace erased
; 1220 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

  000a9	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  000ac	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >,std::_Iterator_base0>::_Mynode
  000b1	89 45 ec	 mov	 DWORD PTR __Pnode$[ebp], eax

; 1221 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree

  000b4	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Right
  000bd	83 c4 04	 add	 esp, 4
  000c0	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c2	89 4d f4	 mov	 DWORD PTR __Fixnode$[ebp], ecx
$LN38@erase@7:

; 1222 : 			}
; 1223 : 
; 1224 : 		if (_Pnode == _Erasednode)

  000c5	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  000c8	3b 45 f8	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  000cb	0f 85 1b 01 00
	00		 jne	 $LN35@erase@7

; 1225 : 			{	// at most one subtree, relink it
; 1226 : 			_Fixnodeparent = this->_Parent(_Erasednode);

  000d1	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  000d4	50		 push	 eax
  000d5	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  000da	83 c4 04	 add	 esp, 4
  000dd	8b 08		 mov	 ecx, DWORD PTR [eax]
  000df	89 4d f0	 mov	 DWORD PTR __Fixnodeparent$[ebp], ecx

; 1227 : 			if (!this->_Isnil(_Fixnode))

  000e2	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Isnil
  000eb	83 c4 04	 add	 esp, 4
  000ee	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000f1	85 c9		 test	 ecx, ecx
  000f3	75 11		 jne	 SHORT $LN34@erase@7

; 1228 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up

  000f5	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  000f8	50		 push	 eax
  000f9	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  000fe	83 c4 04	 add	 esp, 4
  00101	8b 4d f0	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  00104	89 08		 mov	 DWORD PTR [eax], ecx
$LN34@erase@7:

; 1229 : 
; 1230 : 			if (_Root() == _Erasednode)

  00106	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Root
  0010e	8b 00		 mov	 eax, DWORD PTR [eax]
  00110	3b 45 f8	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  00113	75 0f		 jne	 SHORT $LN33@erase@7

; 1231 : 				_Root() = _Fixnode;	// link down from root

  00115	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00118	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Root
  0011d	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  00120	89 08		 mov	 DWORD PTR [eax], ecx
  00122	eb 37		 jmp	 SHORT $LN32@erase@7
$LN33@erase@7:

; 1232 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)

  00124	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00127	50		 push	 eax
  00128	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Left
  0012d	83 c4 04	 add	 esp, 4
  00130	8b 08		 mov	 ecx, DWORD PTR [eax]
  00132	3b 4d f8	 cmp	 ecx, DWORD PTR __Erasednode$[ebp]
  00135	75 13		 jne	 SHORT $LN31@erase@7

; 1233 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left

  00137	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0013a	50		 push	 eax
  0013b	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Left
  00140	83 c4 04	 add	 esp, 4
  00143	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  00146	89 08		 mov	 DWORD PTR [eax], ecx

; 1234 : 			else

  00148	eb 11		 jmp	 SHORT $LN32@erase@7
$LN31@erase@7:

; 1235 : 				this->_Right(_Fixnodeparent) =
; 1236 : 					_Fixnode;	// link down to right

  0014a	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0014d	50		 push	 eax
  0014e	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Right
  00153	83 c4 04	 add	 esp, 4
  00156	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  00159	89 08		 mov	 DWORD PTR [eax], ecx
$LN32@erase@7:

; 1237 : 
; 1238 : 			if (_Lmost() == _Erasednode)

  0015b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0015e	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Lmost
  00163	8b 00		 mov	 eax, DWORD PTR [eax]
  00165	3b 45 f8	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  00168	75 37		 jne	 SHORT $LN29@erase@7

; 1239 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1240 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1241 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree

  0016a	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  0016d	50		 push	 eax
  0016e	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Isnil
  00173	83 c4 04	 add	 esp, 4
  00176	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00179	85 c9		 test	 ecx, ecx
  0017b	74 08		 je	 SHORT $LN43@erase@7
  0017d	8b 55 f0	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  00180	89 55 a8	 mov	 DWORD PTR tv170[ebp], edx
  00183	eb 0f		 jmp	 SHORT $LN44@erase@7
$LN43@erase@7:
  00185	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00188	50		 push	 eax
  00189	e8 00 00 00 00	 call	 ?_Min@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Min
  0018e	83 c4 04	 add	 esp, 4
  00191	89 45 a8	 mov	 DWORD PTR tv170[ebp], eax
$LN44@erase@7:
  00194	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00197	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Lmost
  0019c	8b 4d a8	 mov	 ecx, DWORD PTR tv170[ebp]
  0019f	89 08		 mov	 DWORD PTR [eax], ecx
$LN29@erase@7:

; 1242 : 
; 1243 : 			if (_Rmost() == _Erasednode)

  001a1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001a4	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Rmost
  001a9	8b 00		 mov	 eax, DWORD PTR [eax]
  001ab	3b 45 f8	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  001ae	75 37		 jne	 SHORT $LN28@erase@7

; 1244 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1245 : 					? _Fixnodeparent	// largest is parent of erased node
; 1246 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  001b0	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  001b3	50		 push	 eax
  001b4	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Isnil
  001b9	83 c4 04	 add	 esp, 4
  001bc	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  001bf	85 c9		 test	 ecx, ecx
  001c1	74 08		 je	 SHORT $LN45@erase@7
  001c3	8b 55 f0	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  001c6	89 55 a8	 mov	 DWORD PTR tv182[ebp], edx
  001c9	eb 0f		 jmp	 SHORT $LN46@erase@7
$LN45@erase@7:
  001cb	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  001ce	50		 push	 eax
  001cf	e8 00 00 00 00	 call	 ?_Max@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Max
  001d4	83 c4 04	 add	 esp, 4
  001d7	89 45 a8	 mov	 DWORD PTR tv182[ebp], eax
$LN46@erase@7:
  001da	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001dd	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Rmost
  001e2	8b 4d a8	 mov	 ecx, DWORD PTR tv182[ebp]
  001e5	89 08		 mov	 DWORD PTR [eax], ecx
$LN28@erase@7:

; 1247 : 			}
; 1248 : 		else

  001e7	e9 8e 01 00 00	 jmp	 $LN27@erase@7
$LN35@erase@7:

; 1249 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1250 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1251 : 				_Pnode;	// link left up

  001ec	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  001ef	50		 push	 eax
  001f0	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Left
  001f5	83 c4 04	 add	 esp, 4
  001f8	8b 08		 mov	 ecx, DWORD PTR [eax]
  001fa	51		 push	 ecx
  001fb	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  00200	83 c4 04	 add	 esp, 4
  00203	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00206	89 10		 mov	 DWORD PTR [eax], edx

; 1252 : 			this->_Left(_Pnode) =
; 1253 : 				this->_Left(_Erasednode);	// link successor down

  00208	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0020b	50		 push	 eax
  0020c	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Left
  00211	83 c4 04	 add	 esp, 4
  00214	8b f0		 mov	 esi, eax
  00216	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00219	51		 push	 ecx
  0021a	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Left
  0021f	83 c4 04	 add	 esp, 4
  00222	8b 16		 mov	 edx, DWORD PTR [esi]
  00224	89 10		 mov	 DWORD PTR [eax], edx

; 1254 : 
; 1255 : 			if (_Pnode == this->_Right(_Erasednode))

  00226	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00229	50		 push	 eax
  0022a	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Right
  0022f	83 c4 04	 add	 esp, 4
  00232	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00235	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00237	75 0b		 jne	 SHORT $LN26@erase@7

; 1256 : 				_Fixnodeparent = _Pnode;	// successor is next to erased

  00239	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0023c	89 45 f0	 mov	 DWORD PTR __Fixnodeparent$[ebp], eax

; 1257 : 			else

  0023f	e9 80 00 00 00	 jmp	 $LN25@erase@7
$LN26@erase@7:

; 1258 : 				{	// successor further down, link in place of erased
; 1259 : 				_Fixnodeparent =
; 1260 : 					this->_Parent(_Pnode);	// parent is successor's

  00244	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00247	50		 push	 eax
  00248	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  0024d	83 c4 04	 add	 esp, 4
  00250	8b 08		 mov	 ecx, DWORD PTR [eax]
  00252	89 4d f0	 mov	 DWORD PTR __Fixnodeparent$[ebp], ecx

; 1261 : 				if (!this->_Isnil(_Fixnode))

  00255	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00258	50		 push	 eax
  00259	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Isnil
  0025e	83 c4 04	 add	 esp, 4
  00261	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00264	85 c9		 test	 ecx, ecx
  00266	75 11		 jne	 SHORT $LN24@erase@7

; 1262 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

  00268	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  0026b	50		 push	 eax
  0026c	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  00271	83 c4 04	 add	 esp, 4
  00274	8b 4d f0	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  00277	89 08		 mov	 DWORD PTR [eax], ecx
$LN24@erase@7:

; 1263 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down

  00279	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0027c	50		 push	 eax
  0027d	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Left
  00282	83 c4 04	 add	 esp, 4
  00285	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  00288	89 08		 mov	 DWORD PTR [eax], ecx

; 1264 : 				this->_Right(_Pnode) =
; 1265 : 					this->_Right(_Erasednode);	// link next down

  0028a	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0028d	50		 push	 eax
  0028e	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Right
  00293	83 c4 04	 add	 esp, 4
  00296	8b f0		 mov	 esi, eax
  00298	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0029b	51		 push	 ecx
  0029c	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Right
  002a1	83 c4 04	 add	 esp, 4
  002a4	8b 16		 mov	 edx, DWORD PTR [esi]
  002a6	89 10		 mov	 DWORD PTR [eax], edx

; 1266 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1267 : 					_Pnode;	// right up

  002a8	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  002ab	50		 push	 eax
  002ac	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Right
  002b1	83 c4 04	 add	 esp, 4
  002b4	8b 08		 mov	 ecx, DWORD PTR [eax]
  002b6	51		 push	 ecx
  002b7	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  002bc	83 c4 04	 add	 esp, 4
  002bf	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$[ebp]
  002c2	89 10		 mov	 DWORD PTR [eax], edx
$LN25@erase@7:

; 1268 : 				}
; 1269 : 
; 1270 : 			if (_Root() == _Erasednode)

  002c4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002c7	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Root
  002cc	8b 00		 mov	 eax, DWORD PTR [eax]
  002ce	3b 45 f8	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  002d1	75 0f		 jne	 SHORT $LN23@erase@7

; 1271 : 				_Root() = _Pnode;	// link down from root

  002d3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002d6	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Root
  002db	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  002de	89 08		 mov	 DWORD PTR [eax], ecx
  002e0	eb 58		 jmp	 SHORT $LN22@erase@7
$LN23@erase@7:

; 1272 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

  002e2	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  002e5	50		 push	 eax
  002e6	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  002eb	83 c4 04	 add	 esp, 4
  002ee	8b 08		 mov	 ecx, DWORD PTR [eax]
  002f0	51		 push	 ecx
  002f1	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Left
  002f6	83 c4 04	 add	 esp, 4
  002f9	8b 10		 mov	 edx, DWORD PTR [eax]
  002fb	3b 55 f8	 cmp	 edx, DWORD PTR __Erasednode$[ebp]
  002fe	75 1e		 jne	 SHORT $LN21@erase@7

; 1273 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1274 : 					_Pnode;	// link down to left

  00300	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00303	50		 push	 eax
  00304	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  00309	83 c4 04	 add	 esp, 4
  0030c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0030e	51		 push	 ecx
  0030f	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Left
  00314	83 c4 04	 add	 esp, 4
  00317	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$[ebp]
  0031a	89 10		 mov	 DWORD PTR [eax], edx

; 1275 : 			else

  0031c	eb 1c		 jmp	 SHORT $LN22@erase@7
$LN21@erase@7:

; 1276 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1277 : 					_Pnode;	// link down to right

  0031e	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00321	50		 push	 eax
  00322	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  00327	83 c4 04	 add	 esp, 4
  0032a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0032c	51		 push	 ecx
  0032d	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Right
  00332	83 c4 04	 add	 esp, 4
  00335	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00338	89 10		 mov	 DWORD PTR [eax], edx
$LN22@erase@7:

; 1278 : 
; 1279 : 			this->_Parent(_Pnode) =
; 1280 : 				this->_Parent(_Erasednode);	// link successor up

  0033a	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0033d	50		 push	 eax
  0033e	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  00343	83 c4 04	 add	 esp, 4
  00346	8b f0		 mov	 esi, eax
  00348	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0034b	51		 push	 ecx
  0034c	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  00351	83 c4 04	 add	 esp, 4
  00354	8b 16		 mov	 edx, DWORD PTR [esi]
  00356	89 10		 mov	 DWORD PTR [eax], edx

; 1281 : 			_STD swap(this->_Color(_Pnode),
; 1282 : 				this->_Color(_Erasednode));	// recolor it

  00358	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0035b	50		 push	 eax
  0035c	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
  00361	83 c4 04	 add	 esp, 4
  00364	50		 push	 eax
  00365	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00368	51		 push	 ecx
  00369	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
  0036e	83 c4 04	 add	 esp, 4
  00371	50		 push	 eax
  00372	e8 00 00 00 00	 call	 ??$swap@D@std@@YAXAAD0@Z ; std::swap<char>
  00377	83 c4 08	 add	 esp, 8
$LN27@erase@7:

; 1283 : 			}
; 1284 : 
; 1285 : 		if (this->_Color(_Erasednode) == this->_Black)

  0037a	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0037d	50		 push	 eax
  0037e	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
  00383	83 c4 04	 add	 esp, 4
  00386	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00389	83 f9 01	 cmp	 ecx, 1
  0038c	0f 85 8f 03 00
	00		 jne	 $LN19@erase@7
  00392	eb 11		 jmp	 SHORT $LN18@erase@7
$LN17@erase@7:

; 1286 : 			{	// erasing black link, must recolor/rebalance tree
; 1287 : 			for (; _Fixnode != _Root()
; 1288 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1289 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  00394	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00397	50		 push	 eax
  00398	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  0039d	83 c4 04	 add	 esp, 4
  003a0	8b 08		 mov	 ecx, DWORD PTR [eax]
  003a2	89 4d f0	 mov	 DWORD PTR __Fixnodeparent$[ebp], ecx
$LN18@erase@7:
  003a5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003a8	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Root
  003ad	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  003b0	3b 08		 cmp	 ecx, DWORD PTR [eax]
  003b2	0f 84 5a 03 00
	00		 je	 $LN16@erase@7
  003b8	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  003bb	50		 push	 eax
  003bc	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
  003c1	83 c4 04	 add	 esp, 4
  003c4	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  003c7	83 f9 01	 cmp	 ecx, 1
  003ca	0f 85 42 03 00
	00		 jne	 $LN16@erase@7

; 1290 : 				if (_Fixnode == this->_Left(_Fixnodeparent))

  003d0	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  003d3	50		 push	 eax
  003d4	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Left
  003d9	83 c4 04	 add	 esp, 4
  003dc	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  003df	3b 08		 cmp	 ecx, DWORD PTR [eax]
  003e1	0f 85 97 01 00
	00		 jne	 $LN15@erase@7

; 1291 : 					{	// fixup left subtree
; 1292 : 					_Pnode = this->_Right(_Fixnodeparent);

  003e7	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  003ea	50		 push	 eax
  003eb	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Right
  003f0	83 c4 04	 add	 esp, 4
  003f3	8b 08		 mov	 ecx, DWORD PTR [eax]
  003f5	89 4d ec	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 1293 : 					if (this->_Color(_Pnode) == this->_Red)

  003f8	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  003fb	50		 push	 eax
  003fc	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
  00401	83 c4 04	 add	 esp, 4
  00404	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00407	85 c9		 test	 ecx, ecx
  00409	75 3b		 jne	 SHORT $LN14@erase@7

; 1294 : 						{	// rotate red up from right subtree
; 1295 : 						this->_Color(_Pnode) = this->_Black;

  0040b	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0040e	50		 push	 eax
  0040f	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
  00414	83 c4 04	 add	 esp, 4
  00417	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1296 : 						this->_Color(_Fixnodeparent) = this->_Red;

  0041a	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0041d	50		 push	 eax
  0041e	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
  00423	83 c4 04	 add	 esp, 4
  00426	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1297 : 						_Lrotate(_Fixnodeparent);

  00429	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0042c	50		 push	 eax
  0042d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00430	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Lrotate

; 1298 : 						_Pnode = this->_Right(_Fixnodeparent);

  00435	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00438	50		 push	 eax
  00439	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Right
  0043e	83 c4 04	 add	 esp, 4
  00441	8b 08		 mov	 ecx, DWORD PTR [eax]
  00443	89 4d ec	 mov	 DWORD PTR __Pnode$[ebp], ecx
$LN14@erase@7:

; 1299 : 						}
; 1300 : 
; 1301 : 					if (this->_Isnil(_Pnode))

  00446	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00449	50		 push	 eax
  0044a	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Isnil
  0044f	83 c4 04	 add	 esp, 4
  00452	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00455	85 c9		 test	 ecx, ecx
  00457	74 0b		 je	 SHORT $LN13@erase@7

; 1302 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

  00459	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0045c	89 45 f4	 mov	 DWORD PTR __Fixnode$[ebp], eax

; 1303 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black

  0045f	e9 15 01 00 00	 jmp	 $LN12@erase@7
$LN13@erase@7:

; 1304 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)

  00464	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00467	50		 push	 eax
  00468	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Left
  0046d	83 c4 04	 add	 esp, 4
  00470	8b 08		 mov	 ecx, DWORD PTR [eax]
  00472	51		 push	 ecx
  00473	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
  00478	83 c4 04	 add	 esp, 4
  0047b	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0047e	83 fa 01	 cmp	 edx, 1
  00481	75 39		 jne	 SHORT $LN11@erase@7
  00483	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00486	50		 push	 eax
  00487	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Right
  0048c	83 c4 04	 add	 esp, 4
  0048f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00491	51		 push	 ecx
  00492	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
  00497	83 c4 04	 add	 esp, 4
  0049a	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0049d	83 fa 01	 cmp	 edx, 1
  004a0	75 1a		 jne	 SHORT $LN11@erase@7

; 1305 : 						{	// redden right subtree with black children
; 1306 : 						this->_Color(_Pnode) = this->_Red;

  004a2	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  004a5	50		 push	 eax
  004a6	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
  004ab	83 c4 04	 add	 esp, 4
  004ae	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1307 : 						_Fixnode = _Fixnodeparent;

  004b1	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  004b4	89 45 f4	 mov	 DWORD PTR __Fixnode$[ebp], eax

; 1308 : 						}
; 1309 : 					else

  004b7	e9 bd 00 00 00	 jmp	 $LN12@erase@7
$LN11@erase@7:

; 1310 : 						{	// must rearrange right subtree
; 1311 : 						if (this->_Color(this->_Right(_Pnode))
; 1312 : 							== this->_Black)

  004bc	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  004bf	50		 push	 eax
  004c0	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Right
  004c5	83 c4 04	 add	 esp, 4
  004c8	8b 08		 mov	 ecx, DWORD PTR [eax]
  004ca	51		 push	 ecx
  004cb	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
  004d0	83 c4 04	 add	 esp, 4
  004d3	0f be 10	 movsx	 edx, BYTE PTR [eax]
  004d6	83 fa 01	 cmp	 edx, 1
  004d9	75 46		 jne	 SHORT $LN9@erase@7

; 1313 : 							{	// rotate red up from left sub-subtree
; 1314 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;

  004db	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  004de	50		 push	 eax
  004df	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Left
  004e4	83 c4 04	 add	 esp, 4
  004e7	8b 08		 mov	 ecx, DWORD PTR [eax]
  004e9	51		 push	 ecx
  004ea	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
  004ef	83 c4 04	 add	 esp, 4
  004f2	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1315 : 							this->_Color(_Pnode) = this->_Red;

  004f5	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  004f8	50		 push	 eax
  004f9	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
  004fe	83 c4 04	 add	 esp, 4
  00501	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1316 : 							_Rrotate(_Pnode);

  00504	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00507	50		 push	 eax
  00508	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0050b	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Rrotate

; 1317 : 							_Pnode = this->_Right(_Fixnodeparent);

  00510	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00513	50		 push	 eax
  00514	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Right
  00519	83 c4 04	 add	 esp, 4
  0051c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0051e	89 4d ec	 mov	 DWORD PTR __Pnode$[ebp], ecx
$LN9@erase@7:

; 1318 : 							}
; 1319 : 
; 1320 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  00521	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00524	50		 push	 eax
  00525	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
  0052a	83 c4 04	 add	 esp, 4
  0052d	8b f0		 mov	 esi, eax
  0052f	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00532	51		 push	 ecx
  00533	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
  00538	83 c4 04	 add	 esp, 4
  0053b	8a 16		 mov	 dl, BYTE PTR [esi]
  0053d	88 10		 mov	 BYTE PTR [eax], dl

; 1321 : 						this->_Color(_Fixnodeparent) = this->_Black;

  0053f	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00542	50		 push	 eax
  00543	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
  00548	83 c4 04	 add	 esp, 4
  0054b	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1322 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;

  0054e	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00551	50		 push	 eax
  00552	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Right
  00557	83 c4 04	 add	 esp, 4
  0055a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0055c	51		 push	 ecx
  0055d	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
  00562	83 c4 04	 add	 esp, 4
  00565	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1323 : 						_Lrotate(_Fixnodeparent);

  00568	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0056b	50		 push	 eax
  0056c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0056f	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Lrotate

; 1324 : 						break;	// tree now recolored/rebalanced

  00574	e9 99 01 00 00	 jmp	 $LN16@erase@7
$LN12@erase@7:

; 1325 : 						}
; 1326 : 					}
; 1327 : 				else

  00579	e9 8f 01 00 00	 jmp	 $LN8@erase@7
$LN15@erase@7:

; 1328 : 					{	// fixup right subtree
; 1329 : 					_Pnode = this->_Left(_Fixnodeparent);

  0057e	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00581	50		 push	 eax
  00582	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Left
  00587	83 c4 04	 add	 esp, 4
  0058a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0058c	89 4d ec	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 1330 : 					if (this->_Color(_Pnode) == this->_Red)

  0058f	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00592	50		 push	 eax
  00593	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
  00598	83 c4 04	 add	 esp, 4
  0059b	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0059e	85 c9		 test	 ecx, ecx
  005a0	75 3b		 jne	 SHORT $LN7@erase@7

; 1331 : 						{	// rotate red up from left subtree
; 1332 : 						this->_Color(_Pnode) = this->_Black;

  005a2	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  005a5	50		 push	 eax
  005a6	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
  005ab	83 c4 04	 add	 esp, 4
  005ae	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1333 : 						this->_Color(_Fixnodeparent) = this->_Red;

  005b1	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  005b4	50		 push	 eax
  005b5	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
  005ba	83 c4 04	 add	 esp, 4
  005bd	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1334 : 						_Rrotate(_Fixnodeparent);

  005c0	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  005c3	50		 push	 eax
  005c4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  005c7	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Rrotate

; 1335 : 						_Pnode = this->_Left(_Fixnodeparent);

  005cc	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  005cf	50		 push	 eax
  005d0	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Left
  005d5	83 c4 04	 add	 esp, 4
  005d8	8b 08		 mov	 ecx, DWORD PTR [eax]
  005da	89 4d ec	 mov	 DWORD PTR __Pnode$[ebp], ecx
$LN7@erase@7:

; 1336 : 						}
; 1337 : 					if (this->_Isnil(_Pnode))

  005dd	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  005e0	50		 push	 eax
  005e1	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Isnil
  005e6	83 c4 04	 add	 esp, 4
  005e9	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  005ec	85 c9		 test	 ecx, ecx
  005ee	74 0b		 je	 SHORT $LN6@erase@7

; 1338 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

  005f0	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  005f3	89 45 f4	 mov	 DWORD PTR __Fixnode$[ebp], eax

; 1339 : 					else if (this->_Color(this->_Right(_Pnode)) ==

  005f6	e9 12 01 00 00	 jmp	 $LN8@erase@7
$LN6@erase@7:

; 1340 : 						this->_Black
; 1341 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)

  005fb	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  005fe	50		 push	 eax
  005ff	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Right
  00604	83 c4 04	 add	 esp, 4
  00607	8b 08		 mov	 ecx, DWORD PTR [eax]
  00609	51		 push	 ecx
  0060a	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
  0060f	83 c4 04	 add	 esp, 4
  00612	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00615	83 fa 01	 cmp	 edx, 1
  00618	75 39		 jne	 SHORT $LN4@erase@7
  0061a	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0061d	50		 push	 eax
  0061e	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Left
  00623	83 c4 04	 add	 esp, 4
  00626	8b 08		 mov	 ecx, DWORD PTR [eax]
  00628	51		 push	 ecx
  00629	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
  0062e	83 c4 04	 add	 esp, 4
  00631	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00634	83 fa 01	 cmp	 edx, 1
  00637	75 1a		 jne	 SHORT $LN4@erase@7

; 1342 : 						{	// redden left subtree with black children
; 1343 : 						this->_Color(_Pnode) = this->_Red;

  00639	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0063c	50		 push	 eax
  0063d	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
  00642	83 c4 04	 add	 esp, 4
  00645	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1344 : 						_Fixnode = _Fixnodeparent;

  00648	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0064b	89 45 f4	 mov	 DWORD PTR __Fixnode$[ebp], eax

; 1345 : 						}
; 1346 : 					else

  0064e	e9 ba 00 00 00	 jmp	 $LN8@erase@7
$LN4@erase@7:

; 1347 : 						{	// must rearrange left subtree
; 1348 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)

  00653	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00656	50		 push	 eax
  00657	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Left
  0065c	83 c4 04	 add	 esp, 4
  0065f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00661	51		 push	 ecx
  00662	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
  00667	83 c4 04	 add	 esp, 4
  0066a	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0066d	83 fa 01	 cmp	 edx, 1
  00670	75 46		 jne	 SHORT $LN2@erase@7

; 1349 : 							{	// rotate red up from right sub-subtree
; 1350 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;

  00672	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00675	50		 push	 eax
  00676	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Right
  0067b	83 c4 04	 add	 esp, 4
  0067e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00680	51		 push	 ecx
  00681	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
  00686	83 c4 04	 add	 esp, 4
  00689	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1351 : 							this->_Color(_Pnode) = this->_Red;

  0068c	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0068f	50		 push	 eax
  00690	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
  00695	83 c4 04	 add	 esp, 4
  00698	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1352 : 							_Lrotate(_Pnode);

  0069b	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0069e	50		 push	 eax
  0069f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  006a2	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Lrotate

; 1353 : 							_Pnode = this->_Left(_Fixnodeparent);

  006a7	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  006aa	50		 push	 eax
  006ab	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Left
  006b0	83 c4 04	 add	 esp, 4
  006b3	8b 08		 mov	 ecx, DWORD PTR [eax]
  006b5	89 4d ec	 mov	 DWORD PTR __Pnode$[ebp], ecx
$LN2@erase@7:

; 1354 : 							}
; 1355 : 
; 1356 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  006b8	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  006bb	50		 push	 eax
  006bc	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
  006c1	83 c4 04	 add	 esp, 4
  006c4	8b f0		 mov	 esi, eax
  006c6	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  006c9	51		 push	 ecx
  006ca	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
  006cf	83 c4 04	 add	 esp, 4
  006d2	8a 16		 mov	 dl, BYTE PTR [esi]
  006d4	88 10		 mov	 BYTE PTR [eax], dl

; 1357 : 						this->_Color(_Fixnodeparent) = this->_Black;

  006d6	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  006d9	50		 push	 eax
  006da	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
  006df	83 c4 04	 add	 esp, 4
  006e2	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1358 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;

  006e5	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  006e8	50		 push	 eax
  006e9	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Left
  006ee	83 c4 04	 add	 esp, 4
  006f1	8b 08		 mov	 ecx, DWORD PTR [eax]
  006f3	51		 push	 ecx
  006f4	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
  006f9	83 c4 04	 add	 esp, 4
  006fc	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1359 : 						_Rrotate(_Fixnodeparent);

  006ff	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00702	50		 push	 eax
  00703	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00706	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Rrotate

; 1360 : 						break;	// tree now recolored/rebalanced

  0070b	eb 05		 jmp	 SHORT $LN16@erase@7
$LN8@erase@7:

; 1361 : 						}
; 1362 : 					}

  0070d	e9 82 fc ff ff	 jmp	 $LN17@erase@7
$LN16@erase@7:

; 1363 : 
; 1364 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black

  00712	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00715	50		 push	 eax
  00716	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
  0071b	83 c4 04	 add	 esp, 4
  0071e	c6 00 01	 mov	 BYTE PTR [eax], 1
$LN19@erase@7:

; 1365 : 			}
; 1366 : 
; 1367 : 		_Dest_val(this->_Alval,
; 1368 : 			_STD addressof(this->_Myval(_Erasednode)));	// delete erased node

  00721	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00724	50		 push	 eax
  00725	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Myval
  0072a	83 c4 04	 add	 esp, 4
  0072d	50		 push	 eax
  0072e	e8 00 00 00 00	 call	 ??$addressof@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@YAPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@AAU10@@Z ; std::addressof<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >
  00733	83 c4 04	 add	 esp, 4
  00736	50		 push	 eax
  00737	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0073a	83 c1 0d	 add	 ecx, 13			; 0000000dH
  0073d	51		 push	 ecx
  0073e	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@0@PAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >
  00743	83 c4 08	 add	 esp, 8

; 1369 : 
; 1370 : 		this->_Alnod.deallocate(_Erasednode, 1);

  00746	6a 01		 push	 1
  00748	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0074b	50		 push	 eax
  0074c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0074f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00752	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Node>::deallocate

; 1371 : 
; 1372 : 		if (0 < this->_Mysize)

  00757	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0075a	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0075e	76 0f		 jbe	 SHORT $LN1@erase@7

; 1373 : 			--this->_Mysize;

  00760	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00763	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00766	83 e9 01	 sub	 ecx, 1
  00769	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0076c	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
$LN1@erase@7:

; 1374 : 
; 1375 : 		return (iterator(_Where._Ptr, this));	// return successor iterator

  0076f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00772	50		 push	 eax
  00773	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00776	51		 push	 ecx
  00777	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0077a	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >
  0077f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN42@erase@7:

; 1376 : 		}

  00782	5f		 pop	 edi
  00783	5e		 pop	 esi
  00784	5b		 pop	 ebx
  00785	8b e5		 mov	 esp, ebp
  00787	5d		 pop	 ebp
  00788	c2 08 00	 ret	 8
?erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::erase
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color, COMDAT

; 606  : 		{	// return reference to color in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 607  : 		return ((char&)(*_Pnode)._Color);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	83 c0 20	 add	 eax, 32			; 00000020H

; 608  : 		}

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Node><std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >
PUBLIC	??0?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@QAE@U?$less@H@1@@Z ; std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0>::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0>
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >, COMDAT
; _this$ = ecx

; 482  : 		{	// construct traits from _Parg and allocators from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  0000f	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00012	51		 push	 ecx
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ??0?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@QAE@U?$less@H@1@@Z ; std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0>::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0>
  0001b	8d 45 0c	 lea	 eax, DWORD PTR __Al$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00025	e8 00 00 00 00	 call	 ??$?0U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Node><std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >
  0002a	8d 45 0c	 lea	 eax, DWORD PTR __Al$[ebp]
  0002d	50		 push	 eax
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	83 c1 0d	 add	 ecx, 13			; 0000000dH
  00034	e8 00 00 00 00	 call	 ??0?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >

; 483  : 		}

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 08 00	 ret	 8
??0?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Node>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 187  : 		return (_Allocate(_Count, (pointer)0));

  0000c	6a 00		 push	 0
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Node>
  00017	83 c4 08	 add	 esp, 8

; 188  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Rrotate
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Lrotate
PUBLIC	?_Max@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Max
PUBLIC	?_Min@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Min
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::operator++
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@@Z
_TEXT	SEGMENT
tv182 = -88						; size = 4
tv170 = -88						; size = 4
__Pnode$ = -20						; size = 4
__Fixnodeparent$ = -16					; size = 4
__Fixnode$ = -12					; size = 4
__Erasednode$ = -8					; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::erase, COMDAT
; _this$ = ecx

; 1195 : 		{	// erase element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1198 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1199 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1200 : 		++_Where;	// save successor iterator for return
; 1201 : 		_Orphan_ptr(*this, _Erasednode);
; 1202 : 
; 1203 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1204 : 		if (this->_Isnil(_Where._Mynode()))

  0000c	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >,std::_Iterator_base0>::_Mynode
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Isnil
  0001a	83 c4 04	 add	 esp, 4
  0001d	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00020	85 c0		 test	 eax, eax
  00022	74 0a		 je	 SHORT $LN40@erase@8

; 1205 : 			_Xout_of_range("invalid map/set<T> iterator");

  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
  00029	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN40@erase@8:

; 1206 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

  0002e	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  00031	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >,std::_Iterator_base0>::_Mynode
  00036	89 45 f8	 mov	 DWORD PTR __Erasednode$[ebp], eax

; 1207 : 		++_Where;	// save successor iterator for return

  00039	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  0003c	e8 00 00 00 00	 call	 ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::operator++

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1211 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1212 : 		_Nodeptr _Pnode = _Erasednode;

  00041	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00044	89 45 ec	 mov	 DWORD PTR __Pnode$[ebp], eax

; 1213 : 
; 1214 : 		if (this->_Isnil(this->_Left(_Pnode)))

  00047	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Left
  00050	83 c4 04	 add	 esp, 4
  00053	8b 08		 mov	 ecx, DWORD PTR [eax]
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Isnil
  0005b	83 c4 04	 add	 esp, 4
  0005e	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00061	85 d2		 test	 edx, edx
  00063	74 13		 je	 SHORT $LN39@erase@8

; 1215 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree

  00065	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Right
  0006e	83 c4 04	 add	 esp, 4
  00071	8b 08		 mov	 ecx, DWORD PTR [eax]
  00073	89 4d f4	 mov	 DWORD PTR __Fixnode$[ebp], ecx
  00076	eb 4d		 jmp	 SHORT $LN38@erase@8
$LN39@erase@8:

; 1216 : 		else if (this->_Isnil(this->_Right(_Pnode)))

  00078	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Right
  00081	83 c4 04	 add	 esp, 4
  00084	8b 08		 mov	 ecx, DWORD PTR [eax]
  00086	51		 push	 ecx
  00087	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Isnil
  0008c	83 c4 04	 add	 esp, 4
  0008f	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00092	85 d2		 test	 edx, edx
  00094	74 13		 je	 SHORT $LN37@erase@8

; 1217 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree

  00096	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Left
  0009f	83 c4 04	 add	 esp, 4
  000a2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a4	89 4d f4	 mov	 DWORD PTR __Fixnode$[ebp], ecx

; 1218 : 		else

  000a7	eb 1c		 jmp	 SHORT $LN38@erase@8
$LN37@erase@8:

; 1219 : 			{	// two subtrees, must lift successor node to replace erased
; 1220 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

  000a9	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  000ac	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >,std::_Iterator_base0>::_Mynode
  000b1	89 45 ec	 mov	 DWORD PTR __Pnode$[ebp], eax

; 1221 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree

  000b4	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Right
  000bd	83 c4 04	 add	 esp, 4
  000c0	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c2	89 4d f4	 mov	 DWORD PTR __Fixnode$[ebp], ecx
$LN38@erase@8:

; 1222 : 			}
; 1223 : 
; 1224 : 		if (_Pnode == _Erasednode)

  000c5	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  000c8	3b 45 f8	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  000cb	0f 85 1b 01 00
	00		 jne	 $LN35@erase@8

; 1225 : 			{	// at most one subtree, relink it
; 1226 : 			_Fixnodeparent = this->_Parent(_Erasednode);

  000d1	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  000d4	50		 push	 eax
  000d5	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  000da	83 c4 04	 add	 esp, 4
  000dd	8b 08		 mov	 ecx, DWORD PTR [eax]
  000df	89 4d f0	 mov	 DWORD PTR __Fixnodeparent$[ebp], ecx

; 1227 : 			if (!this->_Isnil(_Fixnode))

  000e2	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Isnil
  000eb	83 c4 04	 add	 esp, 4
  000ee	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000f1	85 c9		 test	 ecx, ecx
  000f3	75 11		 jne	 SHORT $LN34@erase@8

; 1228 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up

  000f5	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  000f8	50		 push	 eax
  000f9	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  000fe	83 c4 04	 add	 esp, 4
  00101	8b 4d f0	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  00104	89 08		 mov	 DWORD PTR [eax], ecx
$LN34@erase@8:

; 1229 : 
; 1230 : 			if (_Root() == _Erasednode)

  00106	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Root
  0010e	8b 00		 mov	 eax, DWORD PTR [eax]
  00110	3b 45 f8	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  00113	75 0f		 jne	 SHORT $LN33@erase@8

; 1231 : 				_Root() = _Fixnode;	// link down from root

  00115	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00118	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Root
  0011d	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  00120	89 08		 mov	 DWORD PTR [eax], ecx
  00122	eb 37		 jmp	 SHORT $LN32@erase@8
$LN33@erase@8:

; 1232 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)

  00124	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00127	50		 push	 eax
  00128	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Left
  0012d	83 c4 04	 add	 esp, 4
  00130	8b 08		 mov	 ecx, DWORD PTR [eax]
  00132	3b 4d f8	 cmp	 ecx, DWORD PTR __Erasednode$[ebp]
  00135	75 13		 jne	 SHORT $LN31@erase@8

; 1233 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left

  00137	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0013a	50		 push	 eax
  0013b	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Left
  00140	83 c4 04	 add	 esp, 4
  00143	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  00146	89 08		 mov	 DWORD PTR [eax], ecx

; 1234 : 			else

  00148	eb 11		 jmp	 SHORT $LN32@erase@8
$LN31@erase@8:

; 1235 : 				this->_Right(_Fixnodeparent) =
; 1236 : 					_Fixnode;	// link down to right

  0014a	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0014d	50		 push	 eax
  0014e	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Right
  00153	83 c4 04	 add	 esp, 4
  00156	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  00159	89 08		 mov	 DWORD PTR [eax], ecx
$LN32@erase@8:

; 1237 : 
; 1238 : 			if (_Lmost() == _Erasednode)

  0015b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0015e	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Lmost
  00163	8b 00		 mov	 eax, DWORD PTR [eax]
  00165	3b 45 f8	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  00168	75 37		 jne	 SHORT $LN29@erase@8

; 1239 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1240 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1241 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree

  0016a	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  0016d	50		 push	 eax
  0016e	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Isnil
  00173	83 c4 04	 add	 esp, 4
  00176	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00179	85 c9		 test	 ecx, ecx
  0017b	74 08		 je	 SHORT $LN43@erase@8
  0017d	8b 55 f0	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  00180	89 55 a8	 mov	 DWORD PTR tv170[ebp], edx
  00183	eb 0f		 jmp	 SHORT $LN44@erase@8
$LN43@erase@8:
  00185	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00188	50		 push	 eax
  00189	e8 00 00 00 00	 call	 ?_Min@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Min
  0018e	83 c4 04	 add	 esp, 4
  00191	89 45 a8	 mov	 DWORD PTR tv170[ebp], eax
$LN44@erase@8:
  00194	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00197	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Lmost
  0019c	8b 4d a8	 mov	 ecx, DWORD PTR tv170[ebp]
  0019f	89 08		 mov	 DWORD PTR [eax], ecx
$LN29@erase@8:

; 1242 : 
; 1243 : 			if (_Rmost() == _Erasednode)

  001a1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001a4	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Rmost
  001a9	8b 00		 mov	 eax, DWORD PTR [eax]
  001ab	3b 45 f8	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  001ae	75 37		 jne	 SHORT $LN28@erase@8

; 1244 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1245 : 					? _Fixnodeparent	// largest is parent of erased node
; 1246 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  001b0	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  001b3	50		 push	 eax
  001b4	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Isnil
  001b9	83 c4 04	 add	 esp, 4
  001bc	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  001bf	85 c9		 test	 ecx, ecx
  001c1	74 08		 je	 SHORT $LN45@erase@8
  001c3	8b 55 f0	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  001c6	89 55 a8	 mov	 DWORD PTR tv182[ebp], edx
  001c9	eb 0f		 jmp	 SHORT $LN46@erase@8
$LN45@erase@8:
  001cb	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  001ce	50		 push	 eax
  001cf	e8 00 00 00 00	 call	 ?_Max@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Max
  001d4	83 c4 04	 add	 esp, 4
  001d7	89 45 a8	 mov	 DWORD PTR tv182[ebp], eax
$LN46@erase@8:
  001da	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001dd	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Rmost
  001e2	8b 4d a8	 mov	 ecx, DWORD PTR tv182[ebp]
  001e5	89 08		 mov	 DWORD PTR [eax], ecx
$LN28@erase@8:

; 1247 : 			}
; 1248 : 		else

  001e7	e9 8e 01 00 00	 jmp	 $LN27@erase@8
$LN35@erase@8:

; 1249 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1250 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1251 : 				_Pnode;	// link left up

  001ec	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  001ef	50		 push	 eax
  001f0	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Left
  001f5	83 c4 04	 add	 esp, 4
  001f8	8b 08		 mov	 ecx, DWORD PTR [eax]
  001fa	51		 push	 ecx
  001fb	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  00200	83 c4 04	 add	 esp, 4
  00203	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00206	89 10		 mov	 DWORD PTR [eax], edx

; 1252 : 			this->_Left(_Pnode) =
; 1253 : 				this->_Left(_Erasednode);	// link successor down

  00208	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0020b	50		 push	 eax
  0020c	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Left
  00211	83 c4 04	 add	 esp, 4
  00214	8b f0		 mov	 esi, eax
  00216	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00219	51		 push	 ecx
  0021a	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Left
  0021f	83 c4 04	 add	 esp, 4
  00222	8b 16		 mov	 edx, DWORD PTR [esi]
  00224	89 10		 mov	 DWORD PTR [eax], edx

; 1254 : 
; 1255 : 			if (_Pnode == this->_Right(_Erasednode))

  00226	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00229	50		 push	 eax
  0022a	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Right
  0022f	83 c4 04	 add	 esp, 4
  00232	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00235	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00237	75 0b		 jne	 SHORT $LN26@erase@8

; 1256 : 				_Fixnodeparent = _Pnode;	// successor is next to erased

  00239	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0023c	89 45 f0	 mov	 DWORD PTR __Fixnodeparent$[ebp], eax

; 1257 : 			else

  0023f	e9 80 00 00 00	 jmp	 $LN25@erase@8
$LN26@erase@8:

; 1258 : 				{	// successor further down, link in place of erased
; 1259 : 				_Fixnodeparent =
; 1260 : 					this->_Parent(_Pnode);	// parent is successor's

  00244	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00247	50		 push	 eax
  00248	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  0024d	83 c4 04	 add	 esp, 4
  00250	8b 08		 mov	 ecx, DWORD PTR [eax]
  00252	89 4d f0	 mov	 DWORD PTR __Fixnodeparent$[ebp], ecx

; 1261 : 				if (!this->_Isnil(_Fixnode))

  00255	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00258	50		 push	 eax
  00259	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Isnil
  0025e	83 c4 04	 add	 esp, 4
  00261	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00264	85 c9		 test	 ecx, ecx
  00266	75 11		 jne	 SHORT $LN24@erase@8

; 1262 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

  00268	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  0026b	50		 push	 eax
  0026c	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  00271	83 c4 04	 add	 esp, 4
  00274	8b 4d f0	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  00277	89 08		 mov	 DWORD PTR [eax], ecx
$LN24@erase@8:

; 1263 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down

  00279	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0027c	50		 push	 eax
  0027d	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Left
  00282	83 c4 04	 add	 esp, 4
  00285	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  00288	89 08		 mov	 DWORD PTR [eax], ecx

; 1264 : 				this->_Right(_Pnode) =
; 1265 : 					this->_Right(_Erasednode);	// link next down

  0028a	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0028d	50		 push	 eax
  0028e	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Right
  00293	83 c4 04	 add	 esp, 4
  00296	8b f0		 mov	 esi, eax
  00298	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0029b	51		 push	 ecx
  0029c	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Right
  002a1	83 c4 04	 add	 esp, 4
  002a4	8b 16		 mov	 edx, DWORD PTR [esi]
  002a6	89 10		 mov	 DWORD PTR [eax], edx

; 1266 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1267 : 					_Pnode;	// right up

  002a8	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  002ab	50		 push	 eax
  002ac	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Right
  002b1	83 c4 04	 add	 esp, 4
  002b4	8b 08		 mov	 ecx, DWORD PTR [eax]
  002b6	51		 push	 ecx
  002b7	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  002bc	83 c4 04	 add	 esp, 4
  002bf	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$[ebp]
  002c2	89 10		 mov	 DWORD PTR [eax], edx
$LN25@erase@8:

; 1268 : 				}
; 1269 : 
; 1270 : 			if (_Root() == _Erasednode)

  002c4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002c7	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Root
  002cc	8b 00		 mov	 eax, DWORD PTR [eax]
  002ce	3b 45 f8	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  002d1	75 0f		 jne	 SHORT $LN23@erase@8

; 1271 : 				_Root() = _Pnode;	// link down from root

  002d3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002d6	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Root
  002db	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  002de	89 08		 mov	 DWORD PTR [eax], ecx
  002e0	eb 58		 jmp	 SHORT $LN22@erase@8
$LN23@erase@8:

; 1272 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

  002e2	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  002e5	50		 push	 eax
  002e6	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  002eb	83 c4 04	 add	 esp, 4
  002ee	8b 08		 mov	 ecx, DWORD PTR [eax]
  002f0	51		 push	 ecx
  002f1	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Left
  002f6	83 c4 04	 add	 esp, 4
  002f9	8b 10		 mov	 edx, DWORD PTR [eax]
  002fb	3b 55 f8	 cmp	 edx, DWORD PTR __Erasednode$[ebp]
  002fe	75 1e		 jne	 SHORT $LN21@erase@8

; 1273 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1274 : 					_Pnode;	// link down to left

  00300	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00303	50		 push	 eax
  00304	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  00309	83 c4 04	 add	 esp, 4
  0030c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0030e	51		 push	 ecx
  0030f	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Left
  00314	83 c4 04	 add	 esp, 4
  00317	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$[ebp]
  0031a	89 10		 mov	 DWORD PTR [eax], edx

; 1275 : 			else

  0031c	eb 1c		 jmp	 SHORT $LN22@erase@8
$LN21@erase@8:

; 1276 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1277 : 					_Pnode;	// link down to right

  0031e	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00321	50		 push	 eax
  00322	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  00327	83 c4 04	 add	 esp, 4
  0032a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0032c	51		 push	 ecx
  0032d	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Right
  00332	83 c4 04	 add	 esp, 4
  00335	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00338	89 10		 mov	 DWORD PTR [eax], edx
$LN22@erase@8:

; 1278 : 
; 1279 : 			this->_Parent(_Pnode) =
; 1280 : 				this->_Parent(_Erasednode);	// link successor up

  0033a	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0033d	50		 push	 eax
  0033e	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  00343	83 c4 04	 add	 esp, 4
  00346	8b f0		 mov	 esi, eax
  00348	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0034b	51		 push	 ecx
  0034c	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  00351	83 c4 04	 add	 esp, 4
  00354	8b 16		 mov	 edx, DWORD PTR [esi]
  00356	89 10		 mov	 DWORD PTR [eax], edx

; 1281 : 			_STD swap(this->_Color(_Pnode),
; 1282 : 				this->_Color(_Erasednode));	// recolor it

  00358	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0035b	50		 push	 eax
  0035c	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
  00361	83 c4 04	 add	 esp, 4
  00364	50		 push	 eax
  00365	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00368	51		 push	 ecx
  00369	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
  0036e	83 c4 04	 add	 esp, 4
  00371	50		 push	 eax
  00372	e8 00 00 00 00	 call	 ??$swap@D@std@@YAXAAD0@Z ; std::swap<char>
  00377	83 c4 08	 add	 esp, 8
$LN27@erase@8:

; 1283 : 			}
; 1284 : 
; 1285 : 		if (this->_Color(_Erasednode) == this->_Black)

  0037a	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0037d	50		 push	 eax
  0037e	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
  00383	83 c4 04	 add	 esp, 4
  00386	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00389	83 f9 01	 cmp	 ecx, 1
  0038c	0f 85 8f 03 00
	00		 jne	 $LN19@erase@8
  00392	eb 11		 jmp	 SHORT $LN18@erase@8
$LN17@erase@8:

; 1286 : 			{	// erasing black link, must recolor/rebalance tree
; 1287 : 			for (; _Fixnode != _Root()
; 1288 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1289 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  00394	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00397	50		 push	 eax
  00398	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  0039d	83 c4 04	 add	 esp, 4
  003a0	8b 08		 mov	 ecx, DWORD PTR [eax]
  003a2	89 4d f0	 mov	 DWORD PTR __Fixnodeparent$[ebp], ecx
$LN18@erase@8:
  003a5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003a8	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Root
  003ad	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  003b0	3b 08		 cmp	 ecx, DWORD PTR [eax]
  003b2	0f 84 5a 03 00
	00		 je	 $LN16@erase@8
  003b8	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  003bb	50		 push	 eax
  003bc	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
  003c1	83 c4 04	 add	 esp, 4
  003c4	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  003c7	83 f9 01	 cmp	 ecx, 1
  003ca	0f 85 42 03 00
	00		 jne	 $LN16@erase@8

; 1290 : 				if (_Fixnode == this->_Left(_Fixnodeparent))

  003d0	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  003d3	50		 push	 eax
  003d4	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Left
  003d9	83 c4 04	 add	 esp, 4
  003dc	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  003df	3b 08		 cmp	 ecx, DWORD PTR [eax]
  003e1	0f 85 97 01 00
	00		 jne	 $LN15@erase@8

; 1291 : 					{	// fixup left subtree
; 1292 : 					_Pnode = this->_Right(_Fixnodeparent);

  003e7	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  003ea	50		 push	 eax
  003eb	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Right
  003f0	83 c4 04	 add	 esp, 4
  003f3	8b 08		 mov	 ecx, DWORD PTR [eax]
  003f5	89 4d ec	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 1293 : 					if (this->_Color(_Pnode) == this->_Red)

  003f8	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  003fb	50		 push	 eax
  003fc	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
  00401	83 c4 04	 add	 esp, 4
  00404	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00407	85 c9		 test	 ecx, ecx
  00409	75 3b		 jne	 SHORT $LN14@erase@8

; 1294 : 						{	// rotate red up from right subtree
; 1295 : 						this->_Color(_Pnode) = this->_Black;

  0040b	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0040e	50		 push	 eax
  0040f	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
  00414	83 c4 04	 add	 esp, 4
  00417	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1296 : 						this->_Color(_Fixnodeparent) = this->_Red;

  0041a	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0041d	50		 push	 eax
  0041e	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
  00423	83 c4 04	 add	 esp, 4
  00426	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1297 : 						_Lrotate(_Fixnodeparent);

  00429	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0042c	50		 push	 eax
  0042d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00430	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Lrotate

; 1298 : 						_Pnode = this->_Right(_Fixnodeparent);

  00435	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00438	50		 push	 eax
  00439	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Right
  0043e	83 c4 04	 add	 esp, 4
  00441	8b 08		 mov	 ecx, DWORD PTR [eax]
  00443	89 4d ec	 mov	 DWORD PTR __Pnode$[ebp], ecx
$LN14@erase@8:

; 1299 : 						}
; 1300 : 
; 1301 : 					if (this->_Isnil(_Pnode))

  00446	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00449	50		 push	 eax
  0044a	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Isnil
  0044f	83 c4 04	 add	 esp, 4
  00452	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00455	85 c9		 test	 ecx, ecx
  00457	74 0b		 je	 SHORT $LN13@erase@8

; 1302 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

  00459	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0045c	89 45 f4	 mov	 DWORD PTR __Fixnode$[ebp], eax

; 1303 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black

  0045f	e9 15 01 00 00	 jmp	 $LN12@erase@8
$LN13@erase@8:

; 1304 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)

  00464	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00467	50		 push	 eax
  00468	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Left
  0046d	83 c4 04	 add	 esp, 4
  00470	8b 08		 mov	 ecx, DWORD PTR [eax]
  00472	51		 push	 ecx
  00473	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
  00478	83 c4 04	 add	 esp, 4
  0047b	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0047e	83 fa 01	 cmp	 edx, 1
  00481	75 39		 jne	 SHORT $LN11@erase@8
  00483	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00486	50		 push	 eax
  00487	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Right
  0048c	83 c4 04	 add	 esp, 4
  0048f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00491	51		 push	 ecx
  00492	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
  00497	83 c4 04	 add	 esp, 4
  0049a	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0049d	83 fa 01	 cmp	 edx, 1
  004a0	75 1a		 jne	 SHORT $LN11@erase@8

; 1305 : 						{	// redden right subtree with black children
; 1306 : 						this->_Color(_Pnode) = this->_Red;

  004a2	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  004a5	50		 push	 eax
  004a6	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
  004ab	83 c4 04	 add	 esp, 4
  004ae	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1307 : 						_Fixnode = _Fixnodeparent;

  004b1	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  004b4	89 45 f4	 mov	 DWORD PTR __Fixnode$[ebp], eax

; 1308 : 						}
; 1309 : 					else

  004b7	e9 bd 00 00 00	 jmp	 $LN12@erase@8
$LN11@erase@8:

; 1310 : 						{	// must rearrange right subtree
; 1311 : 						if (this->_Color(this->_Right(_Pnode))
; 1312 : 							== this->_Black)

  004bc	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  004bf	50		 push	 eax
  004c0	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Right
  004c5	83 c4 04	 add	 esp, 4
  004c8	8b 08		 mov	 ecx, DWORD PTR [eax]
  004ca	51		 push	 ecx
  004cb	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
  004d0	83 c4 04	 add	 esp, 4
  004d3	0f be 10	 movsx	 edx, BYTE PTR [eax]
  004d6	83 fa 01	 cmp	 edx, 1
  004d9	75 46		 jne	 SHORT $LN9@erase@8

; 1313 : 							{	// rotate red up from left sub-subtree
; 1314 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;

  004db	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  004de	50		 push	 eax
  004df	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Left
  004e4	83 c4 04	 add	 esp, 4
  004e7	8b 08		 mov	 ecx, DWORD PTR [eax]
  004e9	51		 push	 ecx
  004ea	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
  004ef	83 c4 04	 add	 esp, 4
  004f2	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1315 : 							this->_Color(_Pnode) = this->_Red;

  004f5	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  004f8	50		 push	 eax
  004f9	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
  004fe	83 c4 04	 add	 esp, 4
  00501	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1316 : 							_Rrotate(_Pnode);

  00504	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00507	50		 push	 eax
  00508	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0050b	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Rrotate

; 1317 : 							_Pnode = this->_Right(_Fixnodeparent);

  00510	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00513	50		 push	 eax
  00514	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Right
  00519	83 c4 04	 add	 esp, 4
  0051c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0051e	89 4d ec	 mov	 DWORD PTR __Pnode$[ebp], ecx
$LN9@erase@8:

; 1318 : 							}
; 1319 : 
; 1320 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  00521	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00524	50		 push	 eax
  00525	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
  0052a	83 c4 04	 add	 esp, 4
  0052d	8b f0		 mov	 esi, eax
  0052f	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00532	51		 push	 ecx
  00533	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
  00538	83 c4 04	 add	 esp, 4
  0053b	8a 16		 mov	 dl, BYTE PTR [esi]
  0053d	88 10		 mov	 BYTE PTR [eax], dl

; 1321 : 						this->_Color(_Fixnodeparent) = this->_Black;

  0053f	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00542	50		 push	 eax
  00543	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
  00548	83 c4 04	 add	 esp, 4
  0054b	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1322 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;

  0054e	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00551	50		 push	 eax
  00552	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Right
  00557	83 c4 04	 add	 esp, 4
  0055a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0055c	51		 push	 ecx
  0055d	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
  00562	83 c4 04	 add	 esp, 4
  00565	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1323 : 						_Lrotate(_Fixnodeparent);

  00568	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0056b	50		 push	 eax
  0056c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0056f	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Lrotate

; 1324 : 						break;	// tree now recolored/rebalanced

  00574	e9 99 01 00 00	 jmp	 $LN16@erase@8
$LN12@erase@8:

; 1325 : 						}
; 1326 : 					}
; 1327 : 				else

  00579	e9 8f 01 00 00	 jmp	 $LN8@erase@8
$LN15@erase@8:

; 1328 : 					{	// fixup right subtree
; 1329 : 					_Pnode = this->_Left(_Fixnodeparent);

  0057e	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00581	50		 push	 eax
  00582	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Left
  00587	83 c4 04	 add	 esp, 4
  0058a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0058c	89 4d ec	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 1330 : 					if (this->_Color(_Pnode) == this->_Red)

  0058f	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00592	50		 push	 eax
  00593	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
  00598	83 c4 04	 add	 esp, 4
  0059b	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0059e	85 c9		 test	 ecx, ecx
  005a0	75 3b		 jne	 SHORT $LN7@erase@8

; 1331 : 						{	// rotate red up from left subtree
; 1332 : 						this->_Color(_Pnode) = this->_Black;

  005a2	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  005a5	50		 push	 eax
  005a6	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
  005ab	83 c4 04	 add	 esp, 4
  005ae	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1333 : 						this->_Color(_Fixnodeparent) = this->_Red;

  005b1	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  005b4	50		 push	 eax
  005b5	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
  005ba	83 c4 04	 add	 esp, 4
  005bd	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1334 : 						_Rrotate(_Fixnodeparent);

  005c0	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  005c3	50		 push	 eax
  005c4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  005c7	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Rrotate

; 1335 : 						_Pnode = this->_Left(_Fixnodeparent);

  005cc	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  005cf	50		 push	 eax
  005d0	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Left
  005d5	83 c4 04	 add	 esp, 4
  005d8	8b 08		 mov	 ecx, DWORD PTR [eax]
  005da	89 4d ec	 mov	 DWORD PTR __Pnode$[ebp], ecx
$LN7@erase@8:

; 1336 : 						}
; 1337 : 					if (this->_Isnil(_Pnode))

  005dd	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  005e0	50		 push	 eax
  005e1	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Isnil
  005e6	83 c4 04	 add	 esp, 4
  005e9	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  005ec	85 c9		 test	 ecx, ecx
  005ee	74 0b		 je	 SHORT $LN6@erase@8

; 1338 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

  005f0	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  005f3	89 45 f4	 mov	 DWORD PTR __Fixnode$[ebp], eax

; 1339 : 					else if (this->_Color(this->_Right(_Pnode)) ==

  005f6	e9 12 01 00 00	 jmp	 $LN8@erase@8
$LN6@erase@8:

; 1340 : 						this->_Black
; 1341 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)

  005fb	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  005fe	50		 push	 eax
  005ff	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Right
  00604	83 c4 04	 add	 esp, 4
  00607	8b 08		 mov	 ecx, DWORD PTR [eax]
  00609	51		 push	 ecx
  0060a	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
  0060f	83 c4 04	 add	 esp, 4
  00612	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00615	83 fa 01	 cmp	 edx, 1
  00618	75 39		 jne	 SHORT $LN4@erase@8
  0061a	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0061d	50		 push	 eax
  0061e	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Left
  00623	83 c4 04	 add	 esp, 4
  00626	8b 08		 mov	 ecx, DWORD PTR [eax]
  00628	51		 push	 ecx
  00629	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
  0062e	83 c4 04	 add	 esp, 4
  00631	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00634	83 fa 01	 cmp	 edx, 1
  00637	75 1a		 jne	 SHORT $LN4@erase@8

; 1342 : 						{	// redden left subtree with black children
; 1343 : 						this->_Color(_Pnode) = this->_Red;

  00639	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0063c	50		 push	 eax
  0063d	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
  00642	83 c4 04	 add	 esp, 4
  00645	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1344 : 						_Fixnode = _Fixnodeparent;

  00648	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0064b	89 45 f4	 mov	 DWORD PTR __Fixnode$[ebp], eax

; 1345 : 						}
; 1346 : 					else

  0064e	e9 ba 00 00 00	 jmp	 $LN8@erase@8
$LN4@erase@8:

; 1347 : 						{	// must rearrange left subtree
; 1348 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)

  00653	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00656	50		 push	 eax
  00657	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Left
  0065c	83 c4 04	 add	 esp, 4
  0065f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00661	51		 push	 ecx
  00662	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
  00667	83 c4 04	 add	 esp, 4
  0066a	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0066d	83 fa 01	 cmp	 edx, 1
  00670	75 46		 jne	 SHORT $LN2@erase@8

; 1349 : 							{	// rotate red up from right sub-subtree
; 1350 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;

  00672	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00675	50		 push	 eax
  00676	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Right
  0067b	83 c4 04	 add	 esp, 4
  0067e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00680	51		 push	 ecx
  00681	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
  00686	83 c4 04	 add	 esp, 4
  00689	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1351 : 							this->_Color(_Pnode) = this->_Red;

  0068c	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0068f	50		 push	 eax
  00690	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
  00695	83 c4 04	 add	 esp, 4
  00698	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1352 : 							_Lrotate(_Pnode);

  0069b	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0069e	50		 push	 eax
  0069f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  006a2	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Lrotate

; 1353 : 							_Pnode = this->_Left(_Fixnodeparent);

  006a7	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  006aa	50		 push	 eax
  006ab	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Left
  006b0	83 c4 04	 add	 esp, 4
  006b3	8b 08		 mov	 ecx, DWORD PTR [eax]
  006b5	89 4d ec	 mov	 DWORD PTR __Pnode$[ebp], ecx
$LN2@erase@8:

; 1354 : 							}
; 1355 : 
; 1356 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  006b8	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  006bb	50		 push	 eax
  006bc	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
  006c1	83 c4 04	 add	 esp, 4
  006c4	8b f0		 mov	 esi, eax
  006c6	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  006c9	51		 push	 ecx
  006ca	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
  006cf	83 c4 04	 add	 esp, 4
  006d2	8a 16		 mov	 dl, BYTE PTR [esi]
  006d4	88 10		 mov	 BYTE PTR [eax], dl

; 1357 : 						this->_Color(_Fixnodeparent) = this->_Black;

  006d6	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  006d9	50		 push	 eax
  006da	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
  006df	83 c4 04	 add	 esp, 4
  006e2	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1358 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;

  006e5	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  006e8	50		 push	 eax
  006e9	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Left
  006ee	83 c4 04	 add	 esp, 4
  006f1	8b 08		 mov	 ecx, DWORD PTR [eax]
  006f3	51		 push	 ecx
  006f4	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
  006f9	83 c4 04	 add	 esp, 4
  006fc	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1359 : 						_Rrotate(_Fixnodeparent);

  006ff	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00702	50		 push	 eax
  00703	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00706	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Rrotate

; 1360 : 						break;	// tree now recolored/rebalanced

  0070b	eb 05		 jmp	 SHORT $LN16@erase@8
$LN8@erase@8:

; 1361 : 						}
; 1362 : 					}

  0070d	e9 82 fc ff ff	 jmp	 $LN17@erase@8
$LN16@erase@8:

; 1363 : 
; 1364 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black

  00712	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00715	50		 push	 eax
  00716	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
  0071b	83 c4 04	 add	 esp, 4
  0071e	c6 00 01	 mov	 BYTE PTR [eax], 1
$LN19@erase@8:

; 1365 : 			}
; 1366 : 
; 1367 : 		_Dest_val(this->_Alval,
; 1368 : 			_STD addressof(this->_Myval(_Erasednode)));	// delete erased node

  00721	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00724	50		 push	 eax
  00725	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Myval
  0072a	83 c4 04	 add	 esp, 4
  0072d	50		 push	 eax
  0072e	e8 00 00 00 00	 call	 ??$addressof@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@YAPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@AAU10@@Z ; std::addressof<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >
  00733	83 c4 04	 add	 esp, 4
  00736	50		 push	 eax
  00737	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0073a	83 c1 0d	 add	 ecx, 13			; 0000000dH
  0073d	51		 push	 ecx
  0073e	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@0@PAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >
  00743	83 c4 08	 add	 esp, 8

; 1369 : 
; 1370 : 		this->_Alnod.deallocate(_Erasednode, 1);

  00746	6a 01		 push	 1
  00748	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0074b	50		 push	 eax
  0074c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0074f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00752	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Node>::deallocate

; 1371 : 
; 1372 : 		if (0 < this->_Mysize)

  00757	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0075a	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0075e	76 0f		 jbe	 SHORT $LN1@erase@8

; 1373 : 			--this->_Mysize;

  00760	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00763	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00766	83 e9 01	 sub	 ecx, 1
  00769	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0076c	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
$LN1@erase@8:

; 1374 : 
; 1375 : 		return (iterator(_Where._Ptr, this));	// return successor iterator

  0076f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00772	50		 push	 eax
  00773	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00776	51		 push	 ecx
  00777	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0077a	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >
  0077f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN42@erase@8:

; 1376 : 		}

  00782	5f		 pop	 edi
  00783	5e		 pop	 esi
  00784	5b		 pop	 ebx
  00785	8b e5		 mov	 esp, ebp
  00787	5d		 pop	 ebp
  00788	c2 08 00	 ret	 8
?erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::erase
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color, COMDAT

; 606  : 		{	// return reference to color in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 607  : 		return ((char&)(*_Pnode)._Color);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	83 c0 20	 add	 eax, 32			; 00000020H

; 608  : 		}

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Node><std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >
PUBLIC	??0?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@QAE@U?$less@H@1@@Z ; std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0>::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0>
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >, COMDAT
; _this$ = ecx

; 482  : 		{	// construct traits from _Parg and allocators from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  0000f	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00012	51		 push	 ecx
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ??0?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@QAE@U?$less@H@1@@Z ; std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0>::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0>
  0001b	8d 45 0c	 lea	 eax, DWORD PTR __Al$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00025	e8 00 00 00 00	 call	 ??$?0U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Node><std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >
  0002a	8d 45 0c	 lea	 eax, DWORD PTR __Al$[ebp]
  0002d	50		 push	 eax
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	83 c1 0d	 add	 ecx, 13			; 0000000dH
  00034	e8 00 00 00 00	 call	 ??0?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >

; 483  : 		}

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 08 00	 ret	 8
??0?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Node>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 187  : 		return (_Allocate(_Count, (pointer)0));

  0000c	6a 00		 push	 0
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Node>
  00017	83 c4 08	 add	 esp, 8

; 188  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	??$_Allocate@UCASTLEDEEP_EVENTTIME@@@std@@YAPAUCASTLEDEEP_EVENTTIME@@IPAU1@@Z ; std::_Allocate<CASTLEDEEP_EVENTTIME>
; Function compile flags: /Odtp /ZI
;	COMDAT ?allocate@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAEPAUCASTLEDEEP_EVENTTIME@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAEPAUCASTLEDEEP_EVENTTIME@@I@Z PROC ; std::allocator<CASTLEDEEP_EVENTTIME>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 187  : 		return (_Allocate(_Count, (pointer)0));

  0000c	6a 00		 push	 0
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Allocate@UCASTLEDEEP_EVENTTIME@@@std@@YAPAUCASTLEDEEP_EVENTTIME@@IPAU1@@Z ; std::_Allocate<CASTLEDEEP_EVENTTIME>
  00017	83 c4 08	 add	 esp, 8

; 188  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?allocate@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAEPAUCASTLEDEEP_EVENTTIME@@I@Z ENDP ; std::allocator<CASTLEDEEP_EVENTTIME>::allocate
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -76						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QBEIXZ PROC ; std::allocator<CASTLEDEEP_EVENTTIME>::max_size, COMDAT
; _this$ = ecx

; 217  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  0000c	c7 45 f8 ff ff
	ff 1f		 mov	 DWORD PTR __Count$[ebp], 536870911 ; 1fffffffH

; 219  : 		return (0 < _Count ? _Count : 1);

  00013	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00017	76 08		 jbe	 SHORT $LN3@max_size@2
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0001c	89 45 b4	 mov	 DWORD PTR tv65[ebp], eax
  0001f	eb 07		 jmp	 SHORT $LN4@max_size@2
$LN3@max_size@2:
  00021	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$LN4@max_size@2:
  00028	8b 45 b4	 mov	 eax, DWORD PTR tv65[ebp]

; 220  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?max_size@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QBEIXZ ENDP ; std::allocator<CASTLEDEEP_EVENTTIME>::max_size
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::operator++, COMDAT
; _this$ = ecx

; 270  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 271  : 		_Myiter _Tmp = *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	89 4d f8	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 272  : 		++*this;

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::operator++

; 273  : 		return (_Tmp);

  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Tmp$[ebp]
  00022	89 08		 mov	 DWORD PTR [eax], ecx
  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 274  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::operator++
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 43   : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 44   : 		this->_Adopt(_Plist);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Plist$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 45   : 		}

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >,std::_Iterator_base0>
_TEXT	ENDS
PUBLIC	??$_Allocate@UCASTLEDEEP_SPAWNTIME@@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@IPAU1@@Z ; std::_Allocate<CASTLEDEEP_SPAWNTIME>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEPAUCASTLEDEEP_SPAWNTIME@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEPAUCASTLEDEEP_SPAWNTIME@@I@Z PROC ; std::allocator<CASTLEDEEP_SPAWNTIME>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 187  : 		return (_Allocate(_Count, (pointer)0));

  0000c	6a 00		 push	 0
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Allocate@UCASTLEDEEP_SPAWNTIME@@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@IPAU1@@Z ; std::_Allocate<CASTLEDEEP_SPAWNTIME>
  00017	83 c4 08	 add	 esp, 8

; 188  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?allocate@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEPAUCASTLEDEEP_SPAWNTIME@@I@Z ENDP ; std::allocator<CASTLEDEEP_SPAWNTIME>::allocate
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -76						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QBEIXZ PROC ; std::allocator<CASTLEDEEP_SPAWNTIME>::max_size, COMDAT
; _this$ = ecx

; 217  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  0000c	c7 45 f8 ff ff
	ff 1f		 mov	 DWORD PTR __Count$[ebp], 536870911 ; 1fffffffH

; 219  : 		return (0 < _Count ? _Count : 1);

  00013	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00017	76 08		 jbe	 SHORT $LN3@max_size@3
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0001c	89 45 b4	 mov	 DWORD PTR tv65[ebp], eax
  0001f	eb 07		 jmp	 SHORT $LN4@max_size@3
$LN3@max_size@3:
  00021	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$LN4@max_size@3:
  00028	8b 45 b4	 mov	 eax, DWORD PTR tv65[ebp]

; 220  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?max_size@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QBEIXZ ENDP ; std::allocator<CASTLEDEEP_SPAWNTIME>::max_size
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator++, COMDAT
; _this$ = ecx

; 270  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 271  : 		_Myiter _Tmp = *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	89 4d f8	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 272  : 		++*this;

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator++

; 273  : 		return (_Tmp);

  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Tmp$[ebp]
  00022	89 08		 mov	 DWORD PTR [eax], ecx
  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 274  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator++
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 43   : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 44   : 		this->_Adopt(_Plist);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Plist$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 45   : 		}

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>
_TEXT	ENDS
PUBLIC	??$_Allocate@UCASTLEDEEP_MONSTERINFO@@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@IPAU1@@Z ; std::_Allocate<CASTLEDEEP_MONSTERINFO>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEPAUCASTLEDEEP_MONSTERINFO@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEPAUCASTLEDEEP_MONSTERINFO@@I@Z PROC ; std::allocator<CASTLEDEEP_MONSTERINFO>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 187  : 		return (_Allocate(_Count, (pointer)0));

  0000c	6a 00		 push	 0
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Allocate@UCASTLEDEEP_MONSTERINFO@@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@IPAU1@@Z ; std::_Allocate<CASTLEDEEP_MONSTERINFO>
  00017	83 c4 08	 add	 esp, 8

; 188  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?allocate@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEPAUCASTLEDEEP_MONSTERINFO@@I@Z ENDP ; std::allocator<CASTLEDEEP_MONSTERINFO>::allocate
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -76						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QBEIXZ PROC ; std::allocator<CASTLEDEEP_MONSTERINFO>::max_size, COMDAT
; _this$ = ecx

; 217  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  0000c	c7 45 f8 49 92
	24 09		 mov	 DWORD PTR __Count$[ebp], 153391689 ; 09249249H

; 219  : 		return (0 < _Count ? _Count : 1);

  00013	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00017	76 08		 jbe	 SHORT $LN3@max_size@4
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0001c	89 45 b4	 mov	 DWORD PTR tv65[ebp], eax
  0001f	eb 07		 jmp	 SHORT $LN4@max_size@4
$LN3@max_size@4:
  00021	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$LN4@max_size@4:
  00028	8b 45 b4	 mov	 eax, DWORD PTR tv65[ebp]

; 220  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?max_size@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QBEIXZ ENDP ; std::allocator<CASTLEDEEP_MONSTERINFO>::max_size
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::operator++, COMDAT
; _this$ = ecx

; 270  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 271  : 		_Myiter _Tmp = *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	89 4d f8	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 272  : 		++*this;

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::operator++

; 273  : 		return (_Tmp);

  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Tmp$[ebp]
  00022	89 08		 mov	 DWORD PTR [eax], ecx
  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 274  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::operator++
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 43   : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 44   : 		this->_Adopt(_Plist);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Plist$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 45   : 		}

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >,std::_Iterator_base0>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 47   : 		}

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::_Compat
; Function compile flags: /Odtp /ZI
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		_Compat(_Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::_Compat

; 203  : 		return (this->_Ptr == _Right._Ptr);

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001e	8b 10		 mov	 edx, DWORD PTR [eax]
  00020	33 c0		 xor	 eax, eax
  00022	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00024	0f 94 c0	 sete	 al

; 204  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::operator==
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\map
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@QAE@U?$less@H@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 1
??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@QAE@U?$less@H@1@@Z PROC ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>, COMDAT
; _this$ = ecx

; 40   : 		{	// construct with specified comparator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 41   : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@QAE@U?$less@H@1@@Z ENDP ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = -8						; size = 4
_this$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1763 : 		{	// promote right node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1764 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Right
  00015	83 c4 04	 add	 esp, 4
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d f8	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 1765 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

  0001d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Left
  00026	83 c4 04	 add	 esp, 4
  00029	8b f0		 mov	 esi, eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Right
  00034	83 c4 04	 add	 esp, 4
  00037	8b 16		 mov	 edx, DWORD PTR [esi]
  00039	89 10		 mov	 DWORD PTR [eax], edx

; 1766 : 
; 1767 : 		if (!this->_Isnil(this->_Left(_Pnode)))

  0003b	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Left
  00044	83 c4 04	 add	 esp, 4
  00047	8b 08		 mov	 ecx, DWORD PTR [eax]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Isnil
  0004f	83 c4 04	 add	 esp, 4
  00052	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00055	85 d2		 test	 edx, edx
  00057	75 1c		 jne	 SHORT $LN5@Lrotate@2

; 1768 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

  00059	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Left
  00062	83 c4 04	 add	 esp, 4
  00065	8b 08		 mov	 ecx, DWORD PTR [eax]
  00067	51		 push	 ecx
  00068	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  0006d	83 c4 04	 add	 esp, 4
  00070	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00073	89 10		 mov	 DWORD PTR [eax], edx
$LN5@Lrotate@2:

; 1769 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  00075	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  0007e	83 c4 04	 add	 esp, 4
  00081	8b f0		 mov	 esi, eax
  00083	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00086	51		 push	 ecx
  00087	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  0008c	83 c4 04	 add	 esp, 4
  0008f	8b 16		 mov	 edx, DWORD PTR [esi]
  00091	89 10		 mov	 DWORD PTR [eax], edx

; 1770 : 
; 1771 : 		if (_Wherenode == _Root())

  00093	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Root
  0009b	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0009e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000a0	75 0f		 jne	 SHORT $LN4@Lrotate@2

; 1772 : 			_Root() = _Pnode;

  000a2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Root
  000aa	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  000ad	89 08		 mov	 DWORD PTR [eax], ecx
  000af	eb 58		 jmp	 SHORT $LN3@Lrotate@2
$LN4@Lrotate@2:

; 1773 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  000b1	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000b4	50		 push	 eax
  000b5	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  000ba	83 c4 04	 add	 esp, 4
  000bd	8b 08		 mov	 ecx, DWORD PTR [eax]
  000bf	51		 push	 ecx
  000c0	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Left
  000c5	83 c4 04	 add	 esp, 4
  000c8	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  000cb	3b 10		 cmp	 edx, DWORD PTR [eax]
  000cd	75 1e		 jne	 SHORT $LN2@Lrotate@2

; 1774 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  000cf	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000d2	50		 push	 eax
  000d3	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  000d8	83 c4 04	 add	 esp, 4
  000db	8b 08		 mov	 ecx, DWORD PTR [eax]
  000dd	51		 push	 ecx
  000de	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Left
  000e3	83 c4 04	 add	 esp, 4
  000e6	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  000e9	89 10		 mov	 DWORD PTR [eax], edx

; 1775 : 		else

  000eb	eb 1c		 jmp	 SHORT $LN3@Lrotate@2
$LN2@Lrotate@2:

; 1776 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  000ed	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000f0	50		 push	 eax
  000f1	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  000f6	83 c4 04	 add	 esp, 4
  000f9	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fb	51		 push	 ecx
  000fc	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Right
  00101	83 c4 04	 add	 esp, 4
  00104	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00107	89 10		 mov	 DWORD PTR [eax], edx
$LN3@Lrotate@2:

; 1777 : 
; 1778 : 		this->_Left(_Pnode) = _Wherenode;

  00109	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0010c	50		 push	 eax
  0010d	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Left
  00112	83 c4 04	 add	 esp, 4
  00115	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00118	89 08		 mov	 DWORD PTR [eax], ecx

; 1779 : 		this->_Parent(_Wherenode) = _Pnode;

  0011a	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0011d	50		 push	 eax
  0011e	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  00123	83 c4 04	 add	 esp, 4
  00126	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00129	89 08		 mov	 DWORD PTR [eax], ecx

; 1780 : 		}

  0012b	5f		 pop	 edi
  0012c	5e		 pop	 esi
  0012d	5b		 pop	 ebx
  0012e	8b e5		 mov	 esp, ebp
  00130	5d		 pop	 ebp
  00131	c2 04 00	 ret	 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Lrotate
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = -8						; size = 4
_this$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1793 : 		{	// promote left node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1794 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Left
  00015	83 c4 04	 add	 esp, 4
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d f8	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 1795 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

  0001d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Right
  00026	83 c4 04	 add	 esp, 4
  00029	8b f0		 mov	 esi, eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Left
  00034	83 c4 04	 add	 esp, 4
  00037	8b 16		 mov	 edx, DWORD PTR [esi]
  00039	89 10		 mov	 DWORD PTR [eax], edx

; 1796 : 
; 1797 : 		if (!this->_Isnil(this->_Right(_Pnode)))

  0003b	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Right
  00044	83 c4 04	 add	 esp, 4
  00047	8b 08		 mov	 ecx, DWORD PTR [eax]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Isnil
  0004f	83 c4 04	 add	 esp, 4
  00052	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00055	85 d2		 test	 edx, edx
  00057	75 1c		 jne	 SHORT $LN5@Rrotate@2

; 1798 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

  00059	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Right
  00062	83 c4 04	 add	 esp, 4
  00065	8b 08		 mov	 ecx, DWORD PTR [eax]
  00067	51		 push	 ecx
  00068	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  0006d	83 c4 04	 add	 esp, 4
  00070	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00073	89 10		 mov	 DWORD PTR [eax], edx
$LN5@Rrotate@2:

; 1799 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  00075	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  0007e	83 c4 04	 add	 esp, 4
  00081	8b f0		 mov	 esi, eax
  00083	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00086	51		 push	 ecx
  00087	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  0008c	83 c4 04	 add	 esp, 4
  0008f	8b 16		 mov	 edx, DWORD PTR [esi]
  00091	89 10		 mov	 DWORD PTR [eax], edx

; 1800 : 
; 1801 : 		if (_Wherenode == _Root())

  00093	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Root
  0009b	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0009e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000a0	75 0f		 jne	 SHORT $LN4@Rrotate@2

; 1802 : 			_Root() = _Pnode;

  000a2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Root
  000aa	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  000ad	89 08		 mov	 DWORD PTR [eax], ecx
  000af	eb 58		 jmp	 SHORT $LN3@Rrotate@2
$LN4@Rrotate@2:

; 1803 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

  000b1	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000b4	50		 push	 eax
  000b5	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  000ba	83 c4 04	 add	 esp, 4
  000bd	8b 08		 mov	 ecx, DWORD PTR [eax]
  000bf	51		 push	 ecx
  000c0	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Right
  000c5	83 c4 04	 add	 esp, 4
  000c8	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  000cb	3b 10		 cmp	 edx, DWORD PTR [eax]
  000cd	75 1e		 jne	 SHORT $LN2@Rrotate@2

; 1804 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  000cf	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000d2	50		 push	 eax
  000d3	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  000d8	83 c4 04	 add	 esp, 4
  000db	8b 08		 mov	 ecx, DWORD PTR [eax]
  000dd	51		 push	 ecx
  000de	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Right
  000e3	83 c4 04	 add	 esp, 4
  000e6	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  000e9	89 10		 mov	 DWORD PTR [eax], edx

; 1805 : 		else

  000eb	eb 1c		 jmp	 SHORT $LN3@Rrotate@2
$LN2@Rrotate@2:

; 1806 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  000ed	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000f0	50		 push	 eax
  000f1	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  000f6	83 c4 04	 add	 esp, 4
  000f9	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fb	51		 push	 ecx
  000fc	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Left
  00101	83 c4 04	 add	 esp, 4
  00104	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00107	89 10		 mov	 DWORD PTR [eax], edx
$LN3@Rrotate@2:

; 1807 : 
; 1808 : 		this->_Right(_Pnode) = _Wherenode;

  00109	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0010c	50		 push	 eax
  0010d	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Right
  00112	83 c4 04	 add	 esp, 4
  00115	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00118	89 08		 mov	 DWORD PTR [eax], ecx

; 1809 : 		this->_Parent(_Wherenode) = _Pnode;

  0011a	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0011d	50		 push	 eax
  0011e	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  00123	83 c4 04	 add	 esp, 4
  00126	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00129	89 08		 mov	 DWORD PTR [eax], ecx

; 1810 : 		}

  0012b	5f		 pop	 edi
  0012c	5e		 pop	 esi
  0012d	5b		 pop	 ebx
  0012e	8b e5		 mov	 esp, ebp
  00130	5d		 pop	 ebp
  00131	c2 04 00	 ret	 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Rrotate
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Max, COMDAT

; 641  : 		{	// return rightmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@Max@2:

; 642  : 		while (!_Isnil(_Right(_Pnode)))

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Right
  00012	83 c4 04	 add	 esp, 4
  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Isnil
  0001d	83 c4 04	 add	 esp, 4
  00020	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00023	85 d2		 test	 edx, edx
  00025	75 13		 jne	 SHORT $LN1@Max@2

; 643  : 			_Pnode = _Right(_Pnode);

  00027	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Right
  00030	83 c4 04	 add	 esp, 4
  00033	8b 08		 mov	 ecx, DWORD PTR [eax]
  00035	89 4d 08	 mov	 DWORD PTR __Pnode$[ebp], ecx
  00038	eb cf		 jmp	 SHORT $LN2@Max@2
$LN1@Max@2:

; 644  : 		return (_Pnode);

  0003a	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 645  : 		}

  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
  0003f	5b		 pop	 ebx
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?_Max@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Max
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Min, COMDAT

; 648  : 		{	// return leftmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@Min@2:

; 649  : 		while (!_Isnil(_Left(_Pnode)))

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Left
  00012	83 c4 04	 add	 esp, 4
  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Isnil
  0001d	83 c4 04	 add	 esp, 4
  00020	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00023	85 d2		 test	 edx, edx
  00025	75 13		 jne	 SHORT $LN1@Min@2

; 650  : 			_Pnode = _Left(_Pnode);

  00027	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Left
  00030	83 c4 04	 add	 esp, 4
  00033	8b 08		 mov	 ecx, DWORD PTR [eax]
  00035	89 4d 08	 mov	 DWORD PTR __Pnode$[ebp], ecx
  00038	eb cf		 jmp	 SHORT $LN2@Min@2
$LN1@Min@2:

; 651  : 		return (_Pnode);

  0003a	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 652  : 		}

  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
  0003f	5b		 pop	 ebx
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?_Min@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Min
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\map
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@QAE@U?$less@H@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 1
??0?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@QAE@U?$less@H@1@@Z PROC ; std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0>::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0>, COMDAT
; _this$ = ecx

; 40   : 		{	// construct with specified comparator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 41   : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@QAE@U?$less@H@1@@Z ENDP ; std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0>::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = -8						; size = 4
_this$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1763 : 		{	// promote right node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1764 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Right
  00015	83 c4 04	 add	 esp, 4
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d f8	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 1765 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

  0001d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Left
  00026	83 c4 04	 add	 esp, 4
  00029	8b f0		 mov	 esi, eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Right
  00034	83 c4 04	 add	 esp, 4
  00037	8b 16		 mov	 edx, DWORD PTR [esi]
  00039	89 10		 mov	 DWORD PTR [eax], edx

; 1766 : 
; 1767 : 		if (!this->_Isnil(this->_Left(_Pnode)))

  0003b	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Left
  00044	83 c4 04	 add	 esp, 4
  00047	8b 08		 mov	 ecx, DWORD PTR [eax]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Isnil
  0004f	83 c4 04	 add	 esp, 4
  00052	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00055	85 d2		 test	 edx, edx
  00057	75 1c		 jne	 SHORT $LN5@Lrotate@3

; 1768 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

  00059	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Left
  00062	83 c4 04	 add	 esp, 4
  00065	8b 08		 mov	 ecx, DWORD PTR [eax]
  00067	51		 push	 ecx
  00068	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  0006d	83 c4 04	 add	 esp, 4
  00070	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00073	89 10		 mov	 DWORD PTR [eax], edx
$LN5@Lrotate@3:

; 1769 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  00075	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  0007e	83 c4 04	 add	 esp, 4
  00081	8b f0		 mov	 esi, eax
  00083	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00086	51		 push	 ecx
  00087	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  0008c	83 c4 04	 add	 esp, 4
  0008f	8b 16		 mov	 edx, DWORD PTR [esi]
  00091	89 10		 mov	 DWORD PTR [eax], edx

; 1770 : 
; 1771 : 		if (_Wherenode == _Root())

  00093	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Root
  0009b	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0009e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000a0	75 0f		 jne	 SHORT $LN4@Lrotate@3

; 1772 : 			_Root() = _Pnode;

  000a2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Root
  000aa	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  000ad	89 08		 mov	 DWORD PTR [eax], ecx
  000af	eb 58		 jmp	 SHORT $LN3@Lrotate@3
$LN4@Lrotate@3:

; 1773 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  000b1	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000b4	50		 push	 eax
  000b5	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  000ba	83 c4 04	 add	 esp, 4
  000bd	8b 08		 mov	 ecx, DWORD PTR [eax]
  000bf	51		 push	 ecx
  000c0	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Left
  000c5	83 c4 04	 add	 esp, 4
  000c8	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  000cb	3b 10		 cmp	 edx, DWORD PTR [eax]
  000cd	75 1e		 jne	 SHORT $LN2@Lrotate@3

; 1774 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  000cf	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000d2	50		 push	 eax
  000d3	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  000d8	83 c4 04	 add	 esp, 4
  000db	8b 08		 mov	 ecx, DWORD PTR [eax]
  000dd	51		 push	 ecx
  000de	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Left
  000e3	83 c4 04	 add	 esp, 4
  000e6	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  000e9	89 10		 mov	 DWORD PTR [eax], edx

; 1775 : 		else

  000eb	eb 1c		 jmp	 SHORT $LN3@Lrotate@3
$LN2@Lrotate@3:

; 1776 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  000ed	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000f0	50		 push	 eax
  000f1	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  000f6	83 c4 04	 add	 esp, 4
  000f9	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fb	51		 push	 ecx
  000fc	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Right
  00101	83 c4 04	 add	 esp, 4
  00104	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00107	89 10		 mov	 DWORD PTR [eax], edx
$LN3@Lrotate@3:

; 1777 : 
; 1778 : 		this->_Left(_Pnode) = _Wherenode;

  00109	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0010c	50		 push	 eax
  0010d	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Left
  00112	83 c4 04	 add	 esp, 4
  00115	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00118	89 08		 mov	 DWORD PTR [eax], ecx

; 1779 : 		this->_Parent(_Wherenode) = _Pnode;

  0011a	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0011d	50		 push	 eax
  0011e	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  00123	83 c4 04	 add	 esp, 4
  00126	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00129	89 08		 mov	 DWORD PTR [eax], ecx

; 1780 : 		}

  0012b	5f		 pop	 edi
  0012c	5e		 pop	 esi
  0012d	5b		 pop	 ebx
  0012e	8b e5		 mov	 esp, ebp
  00130	5d		 pop	 ebp
  00131	c2 04 00	 ret	 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Lrotate
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = -8						; size = 4
_this$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1793 : 		{	// promote left node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1794 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Left
  00015	83 c4 04	 add	 esp, 4
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d f8	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 1795 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

  0001d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Right
  00026	83 c4 04	 add	 esp, 4
  00029	8b f0		 mov	 esi, eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Left
  00034	83 c4 04	 add	 esp, 4
  00037	8b 16		 mov	 edx, DWORD PTR [esi]
  00039	89 10		 mov	 DWORD PTR [eax], edx

; 1796 : 
; 1797 : 		if (!this->_Isnil(this->_Right(_Pnode)))

  0003b	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Right
  00044	83 c4 04	 add	 esp, 4
  00047	8b 08		 mov	 ecx, DWORD PTR [eax]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Isnil
  0004f	83 c4 04	 add	 esp, 4
  00052	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00055	85 d2		 test	 edx, edx
  00057	75 1c		 jne	 SHORT $LN5@Rrotate@3

; 1798 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

  00059	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Right
  00062	83 c4 04	 add	 esp, 4
  00065	8b 08		 mov	 ecx, DWORD PTR [eax]
  00067	51		 push	 ecx
  00068	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  0006d	83 c4 04	 add	 esp, 4
  00070	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00073	89 10		 mov	 DWORD PTR [eax], edx
$LN5@Rrotate@3:

; 1799 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  00075	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  0007e	83 c4 04	 add	 esp, 4
  00081	8b f0		 mov	 esi, eax
  00083	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00086	51		 push	 ecx
  00087	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  0008c	83 c4 04	 add	 esp, 4
  0008f	8b 16		 mov	 edx, DWORD PTR [esi]
  00091	89 10		 mov	 DWORD PTR [eax], edx

; 1800 : 
; 1801 : 		if (_Wherenode == _Root())

  00093	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Root
  0009b	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0009e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000a0	75 0f		 jne	 SHORT $LN4@Rrotate@3

; 1802 : 			_Root() = _Pnode;

  000a2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Root
  000aa	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  000ad	89 08		 mov	 DWORD PTR [eax], ecx
  000af	eb 58		 jmp	 SHORT $LN3@Rrotate@3
$LN4@Rrotate@3:

; 1803 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

  000b1	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000b4	50		 push	 eax
  000b5	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  000ba	83 c4 04	 add	 esp, 4
  000bd	8b 08		 mov	 ecx, DWORD PTR [eax]
  000bf	51		 push	 ecx
  000c0	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Right
  000c5	83 c4 04	 add	 esp, 4
  000c8	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  000cb	3b 10		 cmp	 edx, DWORD PTR [eax]
  000cd	75 1e		 jne	 SHORT $LN2@Rrotate@3

; 1804 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  000cf	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000d2	50		 push	 eax
  000d3	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  000d8	83 c4 04	 add	 esp, 4
  000db	8b 08		 mov	 ecx, DWORD PTR [eax]
  000dd	51		 push	 ecx
  000de	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Right
  000e3	83 c4 04	 add	 esp, 4
  000e6	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  000e9	89 10		 mov	 DWORD PTR [eax], edx

; 1805 : 		else

  000eb	eb 1c		 jmp	 SHORT $LN3@Rrotate@3
$LN2@Rrotate@3:

; 1806 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  000ed	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000f0	50		 push	 eax
  000f1	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  000f6	83 c4 04	 add	 esp, 4
  000f9	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fb	51		 push	 ecx
  000fc	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Left
  00101	83 c4 04	 add	 esp, 4
  00104	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00107	89 10		 mov	 DWORD PTR [eax], edx
$LN3@Rrotate@3:

; 1807 : 
; 1808 : 		this->_Right(_Pnode) = _Wherenode;

  00109	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0010c	50		 push	 eax
  0010d	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Right
  00112	83 c4 04	 add	 esp, 4
  00115	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00118	89 08		 mov	 DWORD PTR [eax], ecx

; 1809 : 		this->_Parent(_Wherenode) = _Pnode;

  0011a	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0011d	50		 push	 eax
  0011e	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  00123	83 c4 04	 add	 esp, 4
  00126	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00129	89 08		 mov	 DWORD PTR [eax], ecx

; 1810 : 		}

  0012b	5f		 pop	 edi
  0012c	5e		 pop	 esi
  0012d	5b		 pop	 ebx
  0012e	8b e5		 mov	 esp, ebp
  00130	5d		 pop	 ebp
  00131	c2 04 00	 ret	 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Rrotate
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Max, COMDAT

; 641  : 		{	// return rightmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@Max@3:

; 642  : 		while (!_Isnil(_Right(_Pnode)))

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Right
  00012	83 c4 04	 add	 esp, 4
  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Isnil
  0001d	83 c4 04	 add	 esp, 4
  00020	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00023	85 d2		 test	 edx, edx
  00025	75 13		 jne	 SHORT $LN1@Max@3

; 643  : 			_Pnode = _Right(_Pnode);

  00027	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Right
  00030	83 c4 04	 add	 esp, 4
  00033	8b 08		 mov	 ecx, DWORD PTR [eax]
  00035	89 4d 08	 mov	 DWORD PTR __Pnode$[ebp], ecx
  00038	eb cf		 jmp	 SHORT $LN2@Max@3
$LN1@Max@3:

; 644  : 		return (_Pnode);

  0003a	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 645  : 		}

  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
  0003f	5b		 pop	 ebx
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?_Max@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Max
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Min, COMDAT

; 648  : 		{	// return leftmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@Min@3:

; 649  : 		while (!_Isnil(_Left(_Pnode)))

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Left
  00012	83 c4 04	 add	 esp, 4
  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Isnil
  0001d	83 c4 04	 add	 esp, 4
  00020	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00023	85 d2		 test	 edx, edx
  00025	75 13		 jne	 SHORT $LN1@Min@3

; 650  : 			_Pnode = _Left(_Pnode);

  00027	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Left
  00030	83 c4 04	 add	 esp, 4
  00033	8b 08		 mov	 ecx, DWORD PTR [eax]
  00035	89 4d 08	 mov	 DWORD PTR __Pnode$[ebp], ecx
  00038	eb cf		 jmp	 SHORT $LN2@Min@3
$LN1@Min@3:

; 651  : 		return (_Pnode);

  0003a	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 652  : 		}

  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
  0003f	5b		 pop	 ebx
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?_Min@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Min
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\map
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@QAE@U?$less@H@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 1
??0?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@QAE@U?$less@H@1@@Z PROC ; std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0>::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0>, COMDAT
; _this$ = ecx

; 40   : 		{	// construct with specified comparator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 41   : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@QAE@U?$less@H@1@@Z ENDP ; std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0>::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0>
_TEXT	ENDS
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >,std::_Iterator_base0>::operator++
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::operator++, COMDAT
; _this$ = ecx

; 250  : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 251  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 252  : 		if (this->_Getcont() == 0
; 253  : 			|| this->_Ptr == 0
; 254  : 			|| _Mytree::_Isnil(this->_Ptr))
; 255  : 			{	// report error
; 256  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 257  : 			_SCL_SECURE_OUT_OF_RANGE;
; 258  : 			}
; 259  : 
; 260  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 261  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 262  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 263  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 264  : 
; 265  : 		++(*(_Mybase *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >,std::_Iterator_base0>::operator++

; 266  : 		return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 267  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::operator++
_TEXT	ENDS
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >,std::_Iterator_base0>::operator++
; Function compile flags: /Odtp /ZI
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::operator++, COMDAT
; _this$ = ecx

; 250  : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 251  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 252  : 		if (this->_Getcont() == 0
; 253  : 			|| this->_Ptr == 0
; 254  : 			|| _Mytree::_Isnil(this->_Ptr))
; 255  : 			{	// report error
; 256  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 257  : 			_SCL_SECURE_OUT_OF_RANGE;
; 258  : 			}
; 259  : 
; 260  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 261  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 262  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 263  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 264  : 
; 265  : 		++(*(_Mybase *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >,std::_Iterator_base0>::operator++

; 266  : 		return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 267  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::operator++
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::_Compat, COMDAT
; _this$ = ecx

; 252  : 		{	// test for compatible iterator pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 253  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@HV?$allocator@H@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<int,std::allocator<int> > >::_Compat
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
__Pnode$234973 = -8					; size = 4
_this$ = -4						; size = 4
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 58   : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 59   : 		if (_Mytree::_Isnil(_Ptr))

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Isnil
  00017	83 c4 04	 add	 esp, 4
  0001a	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0001d	85 d2		 test	 edx, edx
  0001f	74 05		 je	 SHORT $LN6@operator@5
  00021	e9 8d 00 00 00	 jmp	 $LN5@operator@5
$LN6@operator@5:

; 60   : 			;	// end() shouldn't be incremented, don't move
; 61   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002b	51		 push	 ecx
  0002c	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Right
  00031	83 c4 04	 add	 esp, 4
  00034	8b 10		 mov	 edx, DWORD PTR [eax]
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Isnil
  0003c	83 c4 04	 add	 esp, 4
  0003f	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00042	85 c0		 test	 eax, eax
  00044	75 20		 jne	 SHORT $LN2@operator@5

; 62   : 			_Ptr = _Mytree::_Min(
; 63   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

  00046	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00049	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Right
  00051	83 c4 04	 add	 esp, 4
  00054	8b 10		 mov	 edx, DWORD PTR [eax]
  00056	52		 push	 edx
  00057	e8 00 00 00 00	 call	 ?_Min@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Min
  0005c	83 c4 04	 add	 esp, 4
  0005f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00062	89 01		 mov	 DWORD PTR [ecx], eax

; 64   : 		else

  00064	eb 4d		 jmp	 SHORT $LN5@operator@5
$LN2@operator@5:

; 65   : 			{	// climb looking for right subtree
; 66   : 			_Nodeptr _Pnode;
; 67   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 68   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  00066	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00069	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006b	51		 push	 ecx
  0006c	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  00071	83 c4 04	 add	 esp, 4
  00074	8b 10		 mov	 edx, DWORD PTR [eax]
  00076	89 55 f8	 mov	 DWORD PTR __Pnode$234973[ebp], edx
  00079	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$234973[ebp]
  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Isnil
  00082	83 c4 04	 add	 esp, 4
  00085	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00088	85 c9		 test	 ecx, ecx
  0008a	75 1f		 jne	 SHORT $LN1@operator@5
  0008c	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$234973[ebp]
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Right
  00095	83 c4 04	 add	 esp, 4
  00098	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0009d	3b 10		 cmp	 edx, DWORD PTR [eax]
  0009f	75 0a		 jne	 SHORT $LN1@operator@5

; 69   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  000a1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a4	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$234973[ebp]
  000a7	89 08		 mov	 DWORD PTR [eax], ecx
  000a9	eb bb		 jmp	 SHORT $LN2@operator@5
$LN1@operator@5:

; 70   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  000ab	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$234973[ebp]
  000b1	89 08		 mov	 DWORD PTR [eax], ecx
$LN5@operator@5:

; 71   : 			}
; 72   : 		return (*this);

  000b3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 73   : 		}

  000b6	5f		 pop	 edi
  000b7	5e		 pop	 esi
  000b8	5b		 pop	 ebx
  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c3		 ret	 0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >,std::_Iterator_base0>::operator++
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
__Pnode$234983 = -8					; size = 4
_this$ = -4						; size = 4
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 58   : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 59   : 		if (_Mytree::_Isnil(_Ptr))

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Isnil
  00017	83 c4 04	 add	 esp, 4
  0001a	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0001d	85 d2		 test	 edx, edx
  0001f	74 05		 je	 SHORT $LN6@operator@6
  00021	e9 8d 00 00 00	 jmp	 $LN5@operator@6
$LN6@operator@6:

; 60   : 			;	// end() shouldn't be incremented, don't move
; 61   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002b	51		 push	 ecx
  0002c	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Right
  00031	83 c4 04	 add	 esp, 4
  00034	8b 10		 mov	 edx, DWORD PTR [eax]
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Isnil
  0003c	83 c4 04	 add	 esp, 4
  0003f	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00042	85 c0		 test	 eax, eax
  00044	75 20		 jne	 SHORT $LN2@operator@6

; 62   : 			_Ptr = _Mytree::_Min(
; 63   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

  00046	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00049	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Right
  00051	83 c4 04	 add	 esp, 4
  00054	8b 10		 mov	 edx, DWORD PTR [eax]
  00056	52		 push	 edx
  00057	e8 00 00 00 00	 call	 ?_Min@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Min
  0005c	83 c4 04	 add	 esp, 4
  0005f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00062	89 01		 mov	 DWORD PTR [ecx], eax

; 64   : 		else

  00064	eb 4d		 jmp	 SHORT $LN5@operator@6
$LN2@operator@6:

; 65   : 			{	// climb looking for right subtree
; 66   : 			_Nodeptr _Pnode;
; 67   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 68   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  00066	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00069	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006b	51		 push	 ecx
  0006c	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  00071	83 c4 04	 add	 esp, 4
  00074	8b 10		 mov	 edx, DWORD PTR [eax]
  00076	89 55 f8	 mov	 DWORD PTR __Pnode$234983[ebp], edx
  00079	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$234983[ebp]
  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Isnil
  00082	83 c4 04	 add	 esp, 4
  00085	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00088	85 c9		 test	 ecx, ecx
  0008a	75 1f		 jne	 SHORT $LN1@operator@6
  0008c	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$234983[ebp]
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Right
  00095	83 c4 04	 add	 esp, 4
  00098	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0009d	3b 10		 cmp	 edx, DWORD PTR [eax]
  0009f	75 0a		 jne	 SHORT $LN1@operator@6

; 69   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  000a1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a4	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$234983[ebp]
  000a7	89 08		 mov	 DWORD PTR [eax], ecx
  000a9	eb bb		 jmp	 SHORT $LN2@operator@6
$LN1@operator@6:

; 70   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  000ab	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$234983[ebp]
  000b1	89 08		 mov	 DWORD PTR [eax], ecx
$LN5@operator@6:

; 71   : 			}
; 72   : 		return (*this);

  000b3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 73   : 		}

  000b6	5f		 pop	 edi
  000b7	5e		 pop	 esi
  000b8	5b		 pop	 ebx
  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c3		 ret	 0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >,std::_Iterator_base0>::operator++
_TEXT	ENDS
PUBLIC	??$?0AAHAAH@?$_Pair_base@HH@std@@QAE@AAH0@Z	; std::_Pair_base<int,int>::_Pair_base<int,int><int &,int &>
PUBLIC	??$forward@AAH@std@@YAAAHAAH@Z			; std::forward<int &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$?0AAHAAH@?$pair@HH@std@@QAE@AAH0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAHAAH@?$pair@HH@std@@QAE@AAH0@Z PROC		; std::pair<int,int>::pair<int,int><int &,int &>, COMDAT
; _this$ = ecx

; 247  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>
  00022	83 c4 04	 add	 esp, 4
  00025	50		 push	 eax
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ??$?0AAHAAH@?$_Pair_base@HH@std@@QAE@AAH0@Z ; std::_Pair_base<int,int>::_Pair_base<int,int><int &,int &>

; 248  : 		}

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
??$?0AAHAAH@?$pair@HH@std@@QAE@AAH0@Z ENDP		; std::pair<int,int>::pair<int,int><int &,int &>
_TEXT	ENDS
PUBLIC	?_Linsert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Linsert
PUBLIC	??$_Buynode@U?$pair@HH@std@@@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@$$QAU?$pair@HH@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode<std::pair<int,int> >
PUBLIC	??$forward@U?$pair@HH@std@@@std@@YA$$QAU?$pair@HH@0@AAU10@@Z ; std::forward<std::pair<int,int> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??$insert@U?$pair@HH@std@@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HH@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
??$insert@U?$pair@HH@std@@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HH@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::insert<std::pair<int,int> >, COMDAT
; _this$ = ecx

; 753  : 		_Pairib insert(_Valty&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 754  : 		{	// try to insert node with value _Val, favoring right side
; 755  : 		return (_Linsert(this->_Buynode(_STD forward<_Valty>(_Val)),
; 756  : 			false));

  0000c	6a 00		 push	 0
  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$forward@U?$pair@HH@std@@@std@@YA$$QAU?$pair@HH@0@AAU10@@Z ; std::forward<std::pair<int,int> >
  00017	83 c4 04	 add	 esp, 4
  0001a	50		 push	 eax
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@HH@std@@@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@$$QAU?$pair@HH@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode<std::pair<int,int> >
  00023	50		 push	 eax
  00024	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00027	51		 push	 ecx
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ?_Linsert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Linsert
  00030	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 757  : 		}

  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
??$insert@U?$pair@HH@std@@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HH@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::insert<std::pair<int,int> >
_TEXT	ENDS
PUBLIC	??$?0AAHAAV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@?$_Pair_base@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@AAHAAV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@1@@Z ; std::_Pair_base<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::_Pair_base<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > ><int &,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > &>
PUBLIC	??$forward@AAV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@YAAAV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@0@AAV10@@Z ; std::forward<std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$?0AAHAAV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@AAHAAV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAHAAV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@AAHAAV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@1@@Z PROC ; std::pair<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::pair<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > ><int &,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > &>, COMDAT
; _this$ = ecx

; 247  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$forward@AAV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@YAAAV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@0@AAV10@@Z ; std::forward<std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > &>
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>
  00022	83 c4 04	 add	 esp, 4
  00025	50		 push	 eax
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ??$?0AAHAAV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@?$_Pair_base@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@AAHAAV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@1@@Z ; std::_Pair_base<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::_Pair_base<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > ><int &,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > &>

; 248  : 		}

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
??$?0AAHAAV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@AAHAAV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@1@@Z ENDP ; std::pair<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::pair<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > ><int &,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > &>
_TEXT	ENDS
PUBLIC	?_Linsert@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Linsert
PUBLIC	??$_Buynode@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Buynode<std::pair<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >
PUBLIC	??$forward@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@YA$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@AAU10@@Z ; std::forward<std::pair<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??$insert@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
??$insert@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::insert<std::pair<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >, COMDAT
; _this$ = ecx

; 753  : 		_Pairib insert(_Valty&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 754  : 		{	// try to insert node with value _Val, favoring right side
; 755  : 		return (_Linsert(this->_Buynode(_STD forward<_Valty>(_Val)),
; 756  : 			false));

  0000c	6a 00		 push	 0
  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$forward@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@YA$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@AAU10@@Z ; std::forward<std::pair<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >
  00017	83 c4 04	 add	 esp, 4
  0001a	50		 push	 eax
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Buynode<std::pair<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >
  00023	50		 push	 eax
  00024	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00027	51		 push	 ecx
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ?_Linsert@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Linsert
  00030	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 757  : 		}

  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
??$insert@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::insert<std::pair<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >
_TEXT	ENDS
PUBLIC	??$?0AAHAAV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@?$_Pair_base@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@AAHAAV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@1@@Z ; std::_Pair_base<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::_Pair_base<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > ><int &,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > &>
PUBLIC	??$forward@AAV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@YAAAV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@0@AAV10@@Z ; std::forward<std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$?0AAHAAV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@AAHAAV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAHAAV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@AAHAAV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@1@@Z PROC ; std::pair<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::pair<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > ><int &,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > &>, COMDAT
; _this$ = ecx

; 247  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$forward@AAV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@YAAAV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@0@AAV10@@Z ; std::forward<std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > &>
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>
  00022	83 c4 04	 add	 esp, 4
  00025	50		 push	 eax
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ??$?0AAHAAV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@?$_Pair_base@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@AAHAAV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@1@@Z ; std::_Pair_base<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::_Pair_base<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > ><int &,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > &>

; 248  : 		}

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
??$?0AAHAAV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@AAHAAV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@1@@Z ENDP ; std::pair<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::pair<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > ><int &,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > &>
_TEXT	ENDS
PUBLIC	?_Linsert@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Linsert
PUBLIC	??$_Buynode@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Buynode<std::pair<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >
PUBLIC	??$forward@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@YA$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@AAU10@@Z ; std::forward<std::pair<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??$insert@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
??$insert@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::insert<std::pair<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >, COMDAT
; _this$ = ecx

; 753  : 		_Pairib insert(_Valty&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 754  : 		{	// try to insert node with value _Val, favoring right side
; 755  : 		return (_Linsert(this->_Buynode(_STD forward<_Valty>(_Val)),
; 756  : 			false));

  0000c	6a 00		 push	 0
  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$forward@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@YA$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@AAU10@@Z ; std::forward<std::pair<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >
  00017	83 c4 04	 add	 esp, 4
  0001a	50		 push	 eax
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Buynode<std::pair<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >
  00023	50		 push	 eax
  00024	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00027	51		 push	 ecx
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ?_Linsert@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Linsert
  00030	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 757  : 		}

  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
??$insert@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::insert<std::pair<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >
_TEXT	ENDS
PUBLIC	??$_Move@AAD@std@@YA$$QADAAD@Z			; std::_Move<char &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$swap@D@std@@YAXAAD0@Z
_TEXT	SEGMENT
__Tmp$ = -1						; size = 1
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@D@std@@YAXAAD0@Z PROC				; std::swap<char>, COMDAT

; 101  : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 102  : 	_Ty _Tmp = _Move(_Left);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$_Move@AAD@std@@YA$$QADAAD@Z ; std::_Move<char &>
  00012	83 c4 04	 add	 esp, 4
  00015	8a 08		 mov	 cl, BYTE PTR [eax]
  00017	88 4d ff	 mov	 BYTE PTR __Tmp$[ebp], cl

; 103  : 	_Left = _Move(_Right);

  0001a	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??$_Move@AAD@std@@YA$$QADAAD@Z ; std::_Move<char &>
  00023	83 c4 04	 add	 esp, 4
  00026	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00029	8a 10		 mov	 dl, BYTE PTR [eax]
  0002b	88 11		 mov	 BYTE PTR [ecx], dl

; 104  : 	_Right = _Move(_Tmp);

  0002d	8d 45 ff	 lea	 eax, DWORD PTR __Tmp$[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ??$_Move@AAD@std@@YA$$QADAAD@Z ; std::_Move<char &>
  00036	83 c4 04	 add	 esp, 4
  00039	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  0003c	8a 10		 mov	 dl, BYTE PTR [eax]
  0003e	88 11		 mov	 BYTE PTR [ecx], dl

; 105  : 	}

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
??$swap@D@std@@YAXAAD0@Z ENDP				; std::swap<char>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$addressof@U?$pair@$$CBHH@std@@@std@@YAPAU?$pair@$$CBHH@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U?$pair@$$CBHH@std@@@std@@YAPAU?$pair@$$CBHH@0@AAU10@@Z PROC ; std::addressof<std::pair<int const ,int> >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 111  : 	return ((_Ty *) &(char&)_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@U?$pair@$$CBHH@std@@@std@@YAPAU?$pair@$$CBHH@0@AAU10@@Z ENDP ; std::addressof<std::pair<int const ,int> >
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U?$pair@$$CBHH@std@@@std@@QAEXPAU?$pair@$$CBHH@2@@Z ; std::allocator<std::pair<int const ,int> >::destroy
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Dest_val@V?$allocator@U?$pair@$$CBHH@std@@@std@@U?$pair@$$CBHH@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHH@std@@@0@PAU?$pair@$$CBHH@0@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@U?$pair@$$CBHH@std@@@std@@U?$pair@$$CBHH@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHH@std@@@0@PAU?$pair@$$CBHH@0@@Z PROC ; std::_Dest_val<std::allocator<std::pair<int const ,int> >,std::pair<int const ,int> >, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 287  : 	_Alval.destroy(_Pdest);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  00010	e8 00 00 00 00	 call	 ?destroy@?$allocator@U?$pair@$$CBHH@std@@@std@@QAEXPAU?$pair@$$CBHH@2@@Z ; std::allocator<std::pair<int const ,int> >::destroy

; 288  : 	}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Dest_val@V?$allocator@U?$pair@$$CBHH@std@@@std@@U?$pair@$$CBHH@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHH@std@@@0@PAU?$pair@$$CBHH@0@@Z ENDP ; std::_Dest_val<std::allocator<std::pair<int const ,int> >,std::pair<int const ,int> >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$addressof@$$CBH@std@@YAPBHABH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBH@std@@YAPBHABH@Z PROC			; std::addressof<int const >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 111  : 	return ((_Ty *) &(char&)_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@$$CBH@std@@YAPBHABH@Z ENDP			; std::addressof<int const >
_TEXT	ENDS
PUBLIC	??$construct@AAH@?$allocator@H@std@@QAEXPAHAAH@Z ; std::allocator<int>::construct<int &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@H@std@@HAAH@std@@YAXAAV?$allocator@H@0@PAHAAH@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@H@std@@HAAH@std@@YAXAAV?$allocator@H@0@PAHAAH@Z PROC ; std::_Cons_val<std::allocator<int>,int,int &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ??$construct@AAH@?$allocator@H@std@@QAEXPAHAAH@Z ; std::allocator<int>::construct<int &>

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@H@std@@HAAH@std@@YAXAAV?$allocator@H@0@PAHAAH@Z ENDP ; std::_Cons_val<std::allocator<int>,int,int &>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@H@std@@QAEXPAHABH@Z	; std::allocator<int>::construct
PUBLIC	??$forward@ABH@std@@YAABHABH@Z			; std::forward<int const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@H@std@@HABH@std@@YAXAAV?$allocator@H@0@PAHABH@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@H@std@@HABH@std@@YAXAAV?$allocator@H@0@PAHABH@Z PROC ; std::_Cons_val<std::allocator<int>,int,int const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@ABH@std@@YAABHABH@Z ; std::forward<int const &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@H@std@@QAEXPAHABH@Z ; std::allocator<int>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@H@std@@HABH@std@@YAXAAV?$allocator@H@0@PAHABH@Z ENDP ; std::_Cons_val<std::allocator<int>,int,int const &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$addressof@$$CBUCASTLEDEEP_EVENTTIME@@@std@@YAPBUCASTLEDEEP_EVENTTIME@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUCASTLEDEEP_EVENTTIME@@@std@@YAPBUCASTLEDEEP_EVENTTIME@@ABU1@@Z PROC ; std::addressof<CASTLEDEEP_EVENTTIME const >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 111  : 	return ((_Ty *) &(char&)_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@$$CBUCASTLEDEEP_EVENTTIME@@@std@@YAPBUCASTLEDEEP_EVENTTIME@@ABU1@@Z ENDP ; std::addressof<CASTLEDEEP_EVENTTIME const >
_TEXT	ENDS
PUBLIC	??$construct@AAUCASTLEDEEP_EVENTTIME@@@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAEXPAUCASTLEDEEP_EVENTTIME@@AAU2@@Z ; std::allocator<CASTLEDEEP_EVENTTIME>::construct<CASTLEDEEP_EVENTTIME &>
PUBLIC	??$forward@AAUCASTLEDEEP_EVENTTIME@@@std@@YAAAUCASTLEDEEP_EVENTTIME@@AAU1@@Z ; std::forward<CASTLEDEEP_EVENTTIME &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@UCASTLEDEEP_EVENTTIME@@AAU3@@std@@YAXAAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@PAUCASTLEDEEP_EVENTTIME@@AAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@UCASTLEDEEP_EVENTTIME@@AAU3@@std@@YAXAAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@PAUCASTLEDEEP_EVENTTIME@@AAU2@@Z PROC ; std::_Cons_val<std::allocator<CASTLEDEEP_EVENTTIME>,CASTLEDEEP_EVENTTIME,CASTLEDEEP_EVENTTIME &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@AAUCASTLEDEEP_EVENTTIME@@@std@@YAAAUCASTLEDEEP_EVENTTIME@@AAU1@@Z ; std::forward<CASTLEDEEP_EVENTTIME &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ??$construct@AAUCASTLEDEEP_EVENTTIME@@@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAEXPAUCASTLEDEEP_EVENTTIME@@AAU2@@Z ; std::allocator<CASTLEDEEP_EVENTTIME>::construct<CASTLEDEEP_EVENTTIME &>

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@UCASTLEDEEP_EVENTTIME@@AAU3@@std@@YAXAAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@PAUCASTLEDEEP_EVENTTIME@@AAU2@@Z ENDP ; std::_Cons_val<std::allocator<CASTLEDEEP_EVENTTIME>,CASTLEDEEP_EVENTTIME,CASTLEDEEP_EVENTTIME &>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAEXPAUCASTLEDEEP_EVENTTIME@@ABU3@@Z ; std::allocator<CASTLEDEEP_EVENTTIME>::construct
PUBLIC	??$forward@ABUCASTLEDEEP_EVENTTIME@@@std@@YAABUCASTLEDEEP_EVENTTIME@@ABU1@@Z ; std::forward<CASTLEDEEP_EVENTTIME const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@UCASTLEDEEP_EVENTTIME@@ABU3@@std@@YAXAAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@PAUCASTLEDEEP_EVENTTIME@@ABU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@UCASTLEDEEP_EVENTTIME@@ABU3@@std@@YAXAAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@PAUCASTLEDEEP_EVENTTIME@@ABU2@@Z PROC ; std::_Cons_val<std::allocator<CASTLEDEEP_EVENTTIME>,CASTLEDEEP_EVENTTIME,CASTLEDEEP_EVENTTIME const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@ABUCASTLEDEEP_EVENTTIME@@@std@@YAABUCASTLEDEEP_EVENTTIME@@ABU1@@Z ; std::forward<CASTLEDEEP_EVENTTIME const &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAEXPAUCASTLEDEEP_EVENTTIME@@ABU3@@Z ; std::allocator<CASTLEDEEP_EVENTTIME>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@UCASTLEDEEP_EVENTTIME@@ABU3@@std@@YAXAAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@PAUCASTLEDEEP_EVENTTIME@@ABU2@@Z ENDP ; std::_Cons_val<std::allocator<CASTLEDEEP_EVENTTIME>,CASTLEDEEP_EVENTTIME,CASTLEDEEP_EVENTTIME const &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$addressof@$$CBUCASTLEDEEP_SPAWNTIME@@@std@@YAPBUCASTLEDEEP_SPAWNTIME@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUCASTLEDEEP_SPAWNTIME@@@std@@YAPBUCASTLEDEEP_SPAWNTIME@@ABU1@@Z PROC ; std::addressof<CASTLEDEEP_SPAWNTIME const >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 111  : 	return ((_Ty *) &(char&)_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@$$CBUCASTLEDEEP_SPAWNTIME@@@std@@YAPBUCASTLEDEEP_SPAWNTIME@@ABU1@@Z ENDP ; std::addressof<CASTLEDEEP_SPAWNTIME const >
_TEXT	ENDS
PUBLIC	??$construct@AAUCASTLEDEEP_SPAWNTIME@@@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEXPAUCASTLEDEEP_SPAWNTIME@@AAU2@@Z ; std::allocator<CASTLEDEEP_SPAWNTIME>::construct<CASTLEDEEP_SPAWNTIME &>
PUBLIC	??$forward@AAUCASTLEDEEP_SPAWNTIME@@@std@@YAAAUCASTLEDEEP_SPAWNTIME@@AAU1@@Z ; std::forward<CASTLEDEEP_SPAWNTIME &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@UCASTLEDEEP_SPAWNTIME@@AAU3@@std@@YAXAAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@PAUCASTLEDEEP_SPAWNTIME@@AAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@UCASTLEDEEP_SPAWNTIME@@AAU3@@std@@YAXAAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@PAUCASTLEDEEP_SPAWNTIME@@AAU2@@Z PROC ; std::_Cons_val<std::allocator<CASTLEDEEP_SPAWNTIME>,CASTLEDEEP_SPAWNTIME,CASTLEDEEP_SPAWNTIME &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@AAUCASTLEDEEP_SPAWNTIME@@@std@@YAAAUCASTLEDEEP_SPAWNTIME@@AAU1@@Z ; std::forward<CASTLEDEEP_SPAWNTIME &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ??$construct@AAUCASTLEDEEP_SPAWNTIME@@@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEXPAUCASTLEDEEP_SPAWNTIME@@AAU2@@Z ; std::allocator<CASTLEDEEP_SPAWNTIME>::construct<CASTLEDEEP_SPAWNTIME &>

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@UCASTLEDEEP_SPAWNTIME@@AAU3@@std@@YAXAAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@PAUCASTLEDEEP_SPAWNTIME@@AAU2@@Z ENDP ; std::_Cons_val<std::allocator<CASTLEDEEP_SPAWNTIME>,CASTLEDEEP_SPAWNTIME,CASTLEDEEP_SPAWNTIME &>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEXPAUCASTLEDEEP_SPAWNTIME@@ABU3@@Z ; std::allocator<CASTLEDEEP_SPAWNTIME>::construct
PUBLIC	??$forward@ABUCASTLEDEEP_SPAWNTIME@@@std@@YAABUCASTLEDEEP_SPAWNTIME@@ABU1@@Z ; std::forward<CASTLEDEEP_SPAWNTIME const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@UCASTLEDEEP_SPAWNTIME@@ABU3@@std@@YAXAAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@PAUCASTLEDEEP_SPAWNTIME@@ABU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@UCASTLEDEEP_SPAWNTIME@@ABU3@@std@@YAXAAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@PAUCASTLEDEEP_SPAWNTIME@@ABU2@@Z PROC ; std::_Cons_val<std::allocator<CASTLEDEEP_SPAWNTIME>,CASTLEDEEP_SPAWNTIME,CASTLEDEEP_SPAWNTIME const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@ABUCASTLEDEEP_SPAWNTIME@@@std@@YAABUCASTLEDEEP_SPAWNTIME@@ABU1@@Z ; std::forward<CASTLEDEEP_SPAWNTIME const &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEXPAUCASTLEDEEP_SPAWNTIME@@ABU3@@Z ; std::allocator<CASTLEDEEP_SPAWNTIME>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@UCASTLEDEEP_SPAWNTIME@@ABU3@@std@@YAXAAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@PAUCASTLEDEEP_SPAWNTIME@@ABU2@@Z ENDP ; std::_Cons_val<std::allocator<CASTLEDEEP_SPAWNTIME>,CASTLEDEEP_SPAWNTIME,CASTLEDEEP_SPAWNTIME const &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$addressof@$$CBUCASTLEDEEP_MONSTERINFO@@@std@@YAPBUCASTLEDEEP_MONSTERINFO@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUCASTLEDEEP_MONSTERINFO@@@std@@YAPBUCASTLEDEEP_MONSTERINFO@@ABU1@@Z PROC ; std::addressof<CASTLEDEEP_MONSTERINFO const >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 111  : 	return ((_Ty *) &(char&)_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@$$CBUCASTLEDEEP_MONSTERINFO@@@std@@YAPBUCASTLEDEEP_MONSTERINFO@@ABU1@@Z ENDP ; std::addressof<CASTLEDEEP_MONSTERINFO const >
_TEXT	ENDS
PUBLIC	??$construct@AAUCASTLEDEEP_MONSTERINFO@@@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEXPAUCASTLEDEEP_MONSTERINFO@@AAU2@@Z ; std::allocator<CASTLEDEEP_MONSTERINFO>::construct<CASTLEDEEP_MONSTERINFO &>
PUBLIC	??$forward@AAUCASTLEDEEP_MONSTERINFO@@@std@@YAAAUCASTLEDEEP_MONSTERINFO@@AAU1@@Z ; std::forward<CASTLEDEEP_MONSTERINFO &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@UCASTLEDEEP_MONSTERINFO@@AAU3@@std@@YAXAAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@PAUCASTLEDEEP_MONSTERINFO@@AAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@UCASTLEDEEP_MONSTERINFO@@AAU3@@std@@YAXAAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@PAUCASTLEDEEP_MONSTERINFO@@AAU2@@Z PROC ; std::_Cons_val<std::allocator<CASTLEDEEP_MONSTERINFO>,CASTLEDEEP_MONSTERINFO,CASTLEDEEP_MONSTERINFO &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@AAUCASTLEDEEP_MONSTERINFO@@@std@@YAAAUCASTLEDEEP_MONSTERINFO@@AAU1@@Z ; std::forward<CASTLEDEEP_MONSTERINFO &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ??$construct@AAUCASTLEDEEP_MONSTERINFO@@@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEXPAUCASTLEDEEP_MONSTERINFO@@AAU2@@Z ; std::allocator<CASTLEDEEP_MONSTERINFO>::construct<CASTLEDEEP_MONSTERINFO &>

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@UCASTLEDEEP_MONSTERINFO@@AAU3@@std@@YAXAAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@PAUCASTLEDEEP_MONSTERINFO@@AAU2@@Z ENDP ; std::_Cons_val<std::allocator<CASTLEDEEP_MONSTERINFO>,CASTLEDEEP_MONSTERINFO,CASTLEDEEP_MONSTERINFO &>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEXPAUCASTLEDEEP_MONSTERINFO@@ABU3@@Z ; std::allocator<CASTLEDEEP_MONSTERINFO>::construct
PUBLIC	??$forward@ABUCASTLEDEEP_MONSTERINFO@@@std@@YAABUCASTLEDEEP_MONSTERINFO@@ABU1@@Z ; std::forward<CASTLEDEEP_MONSTERINFO const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@UCASTLEDEEP_MONSTERINFO@@ABU3@@std@@YAXAAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@PAUCASTLEDEEP_MONSTERINFO@@ABU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@UCASTLEDEEP_MONSTERINFO@@ABU3@@std@@YAXAAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@PAUCASTLEDEEP_MONSTERINFO@@ABU2@@Z PROC ; std::_Cons_val<std::allocator<CASTLEDEEP_MONSTERINFO>,CASTLEDEEP_MONSTERINFO,CASTLEDEEP_MONSTERINFO const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@ABUCASTLEDEEP_MONSTERINFO@@@std@@YAABUCASTLEDEEP_MONSTERINFO@@ABU1@@Z ; std::forward<CASTLEDEEP_MONSTERINFO const &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEXPAUCASTLEDEEP_MONSTERINFO@@ABU3@@Z ; std::allocator<CASTLEDEEP_MONSTERINFO>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@UCASTLEDEEP_MONSTERINFO@@ABU3@@std@@YAXAAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@PAUCASTLEDEEP_MONSTERINFO@@ABU2@@Z ENDP ; std::_Cons_val<std::allocator<CASTLEDEEP_MONSTERINFO>,CASTLEDEEP_MONSTERINFO,CASTLEDEEP_MONSTERINFO const &>
_TEXT	ENDS
PUBLIC	??$_Move@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Move<int *,int *>
PUBLIC	??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z ; std::_Ptr_cat<int,int>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAHPAH@std@@YAPAHPAH00@Z
_TEXT	SEGMENT
$T239773 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAHPAH@std@@YAPAHPAH00@Z PROC			; std::_Move<int *,int *>, COMDAT

; 2533 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2534 : 	return (_Move(_First, _Last,
; 2535 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z ; std::_Ptr_cat<int,int>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T239773[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T239773[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Move@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Move<int *,int *>
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 2536 : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Move@PAHPAH@std@@YAPAHPAH00@Z ENDP			; std::_Move<int *,int *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$addressof@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@YAPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@YAPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@AAU10@@Z PROC ; std::addressof<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 111  : 	return ((_Ty *) &(char&)_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@YAPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@AAU10@@Z ENDP ; std::addressof<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@QAEXPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@@Z ; std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >::destroy
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Dest_val@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@0@PAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@0@PAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@@Z PROC ; std::_Dest_val<std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 287  : 	_Alval.destroy(_Pdest);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  00010	e8 00 00 00 00	 call	 ?destroy@?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@QAEXPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@@Z ; std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >::destroy

; 288  : 	}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Dest_val@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@0@PAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@@Z ENDP ; std::_Dest_val<std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\map
_TEXT	ENDS
;	COMDAT ??$_Kfn@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Kfn@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z PROC ; std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0>::_Kfn<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >, COMDAT

; 66   : 		static const _Kty& _Kfn(const _STD pair<_Ty1, _Ty2>& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 67   : 		{	// extract key from element value
; 68   : 		return (_Val.first);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 69   : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Kfn@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z ENDP ; std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0>::_Kfn<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$addressof@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@YAPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@YAPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@AAU10@@Z PROC ; std::addressof<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 111  : 	return ((_Ty *) &(char&)_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@YAPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@AAU10@@Z ENDP ; std::addressof<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@QAEXPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@@Z ; std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >::destroy
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Dest_val@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@0@PAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@0@PAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@@Z PROC ; std::_Dest_val<std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 287  : 	_Alval.destroy(_Pdest);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  00010	e8 00 00 00 00	 call	 ?destroy@?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@QAEXPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@@Z ; std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >::destroy

; 288  : 	}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Dest_val@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@0@PAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@@Z ENDP ; std::_Dest_val<std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\map
_TEXT	ENDS
;	COMDAT ??$_Kfn@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Kfn@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z PROC ; std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0>::_Kfn<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >, COMDAT

; 66   : 		static const _Kty& _Kfn(const _STD pair<_Ty1, _Ty2>& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 67   : 		{	// extract key from element value
; 68   : 		return (_Val.first);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 69   : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Kfn@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z ENDP ; std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0>::_Kfn<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >
_TEXT	ENDS
PUBLIC	??$_Move@PAUCASTLEDEEP_EVENTTIME@@PAU1@@std@@YAPAUCASTLEDEEP_EVENTTIME@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<CASTLEDEEP_EVENTTIME *,CASTLEDEEP_EVENTTIME *>
PUBLIC	??$_Ptr_cat@UCASTLEDEEP_EVENTTIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUCASTLEDEEP_EVENTTIME@@0@Z ; std::_Ptr_cat<CASTLEDEEP_EVENTTIME,CASTLEDEEP_EVENTTIME>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAUCASTLEDEEP_EVENTTIME@@PAU1@@std@@YAPAUCASTLEDEEP_EVENTTIME@@PAU1@00@Z
_TEXT	SEGMENT
$T239788 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAUCASTLEDEEP_EVENTTIME@@PAU1@@std@@YAPAUCASTLEDEEP_EVENTTIME@@PAU1@00@Z PROC ; std::_Move<CASTLEDEEP_EVENTTIME *,CASTLEDEEP_EVENTTIME *>, COMDAT

; 2533 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2534 : 	return (_Move(_First, _Last,
; 2535 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UCASTLEDEEP_EVENTTIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUCASTLEDEEP_EVENTTIME@@0@Z ; std::_Ptr_cat<CASTLEDEEP_EVENTTIME,CASTLEDEEP_EVENTTIME>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T239788[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T239788[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Move@PAUCASTLEDEEP_EVENTTIME@@PAU1@@std@@YAPAUCASTLEDEEP_EVENTTIME@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<CASTLEDEEP_EVENTTIME *,CASTLEDEEP_EVENTTIME *>
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 2536 : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Move@PAUCASTLEDEEP_EVENTTIME@@PAU1@@std@@YAPAUCASTLEDEEP_EVENTTIME@@PAU1@00@Z ENDP ; std::_Move<CASTLEDEEP_EVENTTIME *,CASTLEDEEP_EVENTTIME *>
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z ; std::_Uninitialized_move<int *,int *,std::allocator<int> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z PROC ; std::vector<int,std::allocator<int> >::_Umove<int *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z ; std::_Uninitialized_move<int *,int *,std::allocator<int> >
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 1326 : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ENDP ; std::vector<int,std::allocator<int> >::_Umove<int *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z
_TEXT	SEGMENT
$T239793 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 87   : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z ; std::_Ptr_cat<int,int>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T239793[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T239793[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<int> >
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 89   : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAUCASTLEDEEP_EVENTTIME@@PAU1@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@YAPAUCASTLEDEEP_EVENTTIME@@PAU1@00AAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@@Z ; std::_Uninitialized_move<CASTLEDEEP_EVENTTIME *,CASTLEDEEP_EVENTTIME *,std::allocator<CASTLEDEEP_EVENTTIME> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??$_Umove@PAUCASTLEDEEP_EVENTTIME@@@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@IAEPAUCASTLEDEEP_EVENTTIME@@PAU2@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAUCASTLEDEEP_EVENTTIME@@@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@IAEPAUCASTLEDEEP_EVENTTIME@@PAU2@00@Z PROC ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::_Umove<CASTLEDEEP_EVENTTIME *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUCASTLEDEEP_EVENTTIME@@PAU1@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@YAPAUCASTLEDEEP_EVENTTIME@@PAU1@00AAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@@Z ; std::_Uninitialized_move<CASTLEDEEP_EVENTTIME *,CASTLEDEEP_EVENTTIME *,std::allocator<CASTLEDEEP_EVENTTIME> >
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 1326 : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUCASTLEDEEP_EVENTTIME@@@?$vector@UCASTLEDEEP_EVENTTIME@@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@IAEPAUCASTLEDEEP_EVENTTIME@@PAU2@00@Z ENDP ; std::vector<CASTLEDEEP_EVENTTIME,std::allocator<CASTLEDEEP_EVENTTIME> >::_Umove<CASTLEDEEP_EVENTTIME *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@YAXPAUCASTLEDEEP_EVENTTIME@@0AAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CASTLEDEEP_EVENTTIME> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@YAXPAUCASTLEDEEP_EVENTTIME@@0AAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@@Z
_TEXT	SEGMENT
$T239798 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@YAXPAUCASTLEDEEP_EVENTTIME@@0AAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CASTLEDEEP_EVENTTIME> >, COMDAT

; 87   : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UCASTLEDEEP_EVENTTIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUCASTLEDEEP_EVENTTIME@@0@Z ; std::_Ptr_cat<CASTLEDEEP_EVENTTIME,CASTLEDEEP_EVENTTIME>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T239798[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T239798[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@YAXPAUCASTLEDEEP_EVENTTIME@@0AAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CASTLEDEEP_EVENTTIME> >
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 89   : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Destroy_range@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@YAXPAUCASTLEDEEP_EVENTTIME@@0AAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CASTLEDEEP_EVENTTIME> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAUCASTLEDEEP_SPAWNTIME@@PAU1@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@PAU1@00AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@@Z ; std::_Uninitialized_move<CASTLEDEEP_SPAWNTIME *,CASTLEDEEP_SPAWNTIME *,std::allocator<CASTLEDEEP_SPAWNTIME> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??$_Umove@PAUCASTLEDEEP_SPAWNTIME@@@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IAEPAUCASTLEDEEP_SPAWNTIME@@PAU2@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAUCASTLEDEEP_SPAWNTIME@@@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IAEPAUCASTLEDEEP_SPAWNTIME@@PAU2@00@Z PROC ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Umove<CASTLEDEEP_SPAWNTIME *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUCASTLEDEEP_SPAWNTIME@@PAU1@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@PAU1@00AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@@Z ; std::_Uninitialized_move<CASTLEDEEP_SPAWNTIME *,CASTLEDEEP_SPAWNTIME *,std::allocator<CASTLEDEEP_SPAWNTIME> >
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 1326 : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUCASTLEDEEP_SPAWNTIME@@@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IAEPAUCASTLEDEEP_SPAWNTIME@@PAU2@00@Z ENDP ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Umove<CASTLEDEEP_SPAWNTIME *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@YAXPAUCASTLEDEEP_SPAWNTIME@@0AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CASTLEDEEP_SPAWNTIME> >
PUBLIC	??$_Ptr_cat@UCASTLEDEEP_SPAWNTIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUCASTLEDEEP_SPAWNTIME@@0@Z ; std::_Ptr_cat<CASTLEDEEP_SPAWNTIME,CASTLEDEEP_SPAWNTIME>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@YAXPAUCASTLEDEEP_SPAWNTIME@@0AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@@Z
_TEXT	SEGMENT
$T239803 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@YAXPAUCASTLEDEEP_SPAWNTIME@@0AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CASTLEDEEP_SPAWNTIME> >, COMDAT

; 87   : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UCASTLEDEEP_SPAWNTIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUCASTLEDEEP_SPAWNTIME@@0@Z ; std::_Ptr_cat<CASTLEDEEP_SPAWNTIME,CASTLEDEEP_SPAWNTIME>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T239803[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T239803[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@YAXPAUCASTLEDEEP_SPAWNTIME@@0AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CASTLEDEEP_SPAWNTIME> >
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 89   : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Destroy_range@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@YAXPAUCASTLEDEEP_SPAWNTIME@@0AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CASTLEDEEP_SPAWNTIME> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAUCASTLEDEEP_MONSTERINFO@@PAU1@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@PAU1@00AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@@Z ; std::_Uninitialized_move<CASTLEDEEP_MONSTERINFO *,CASTLEDEEP_MONSTERINFO *,std::allocator<CASTLEDEEP_MONSTERINFO> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??$_Umove@PAUCASTLEDEEP_MONSTERINFO@@@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IAEPAUCASTLEDEEP_MONSTERINFO@@PAU2@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAUCASTLEDEEP_MONSTERINFO@@@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IAEPAUCASTLEDEEP_MONSTERINFO@@PAU2@00@Z PROC ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Umove<CASTLEDEEP_MONSTERINFO *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUCASTLEDEEP_MONSTERINFO@@PAU1@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@PAU1@00AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@@Z ; std::_Uninitialized_move<CASTLEDEEP_MONSTERINFO *,CASTLEDEEP_MONSTERINFO *,std::allocator<CASTLEDEEP_MONSTERINFO> >
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 1326 : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUCASTLEDEEP_MONSTERINFO@@@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IAEPAUCASTLEDEEP_MONSTERINFO@@PAU2@00@Z ENDP ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Umove<CASTLEDEEP_MONSTERINFO *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@YAXPAUCASTLEDEEP_MONSTERINFO@@0AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CASTLEDEEP_MONSTERINFO> >
PUBLIC	??$_Ptr_cat@UCASTLEDEEP_MONSTERINFO@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUCASTLEDEEP_MONSTERINFO@@0@Z ; std::_Ptr_cat<CASTLEDEEP_MONSTERINFO,CASTLEDEEP_MONSTERINFO>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@YAXPAUCASTLEDEEP_MONSTERINFO@@0AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@@Z
_TEXT	SEGMENT
$T239808 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@YAXPAUCASTLEDEEP_MONSTERINFO@@0AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CASTLEDEEP_MONSTERINFO> >, COMDAT

; 87   : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UCASTLEDEEP_MONSTERINFO@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUCASTLEDEEP_MONSTERINFO@@0@Z ; std::_Ptr_cat<CASTLEDEEP_MONSTERINFO,CASTLEDEEP_MONSTERINFO>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T239808[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T239808[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@YAXPAUCASTLEDEEP_MONSTERINFO@@0AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CASTLEDEEP_MONSTERINFO> >
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 89   : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Destroy_range@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@YAXPAUCASTLEDEEP_MONSTERINFO@@0AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CASTLEDEEP_MONSTERINFO> >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBHH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node><std::pair<int const ,int> >, COMDAT
; _this$ = ecx

; 170  : 		_ALLOCATOR(const _ALLOCATOR<_Other>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 171  : 		{	// construct from a related allocator (do nothing)
; 172  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??$?0U?$pair@$$CBHH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node><std::pair<int const ,int> >
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T239813 = -80						; size = 12
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 31   : 	void *_Ptr = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 32   : 
; 33   : 	if (_Count <= 0)

  00010	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	77 09		 ja	 SHORT $LN4@Allocate

; 34   : 		_Count = 0;

  00016	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __Count$[ebp], 0

; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0001d	eb 39		 jmp	 SHORT $LN3@Allocate
$LN4@Allocate:

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0001f	81 7d 08 aa aa
	aa 0a		 cmp	 DWORD PTR __Count$[ebp], 178956970 ; 0aaaaaaaH
  00026	77 18		 ja	 SHORT $LN1@Allocate
  00028	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002b	6b c0 18	 imul	 eax, 24			; 00000018H
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 fc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0003a	83 7d fc 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  0003e	75 18		 jne	 SHORT $LN3@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00040	6a 00		 push	 0
  00042	8d 4d b0	 lea	 ecx, DWORD PTR $T239813[ebp]
  00045	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0004a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0004f	8d 45 b0	 lea	 eax, DWORD PTR $T239813[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Allocate:

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00058	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 40   : 	}

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Allocate@H@std@@YAPAHIPAH@Z
_TEXT	SEGMENT
$T239816 = -80						; size = 12
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@H@std@@YAPAHIPAH@Z PROC			; std::_Allocate<int>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 31   : 	void *_Ptr = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 32   : 
; 33   : 	if (_Count <= 0)

  00010	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	77 09		 ja	 SHORT $LN4@Allocate@2

; 34   : 		_Count = 0;

  00016	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __Count$[ebp], 0

; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0001d	eb 39		 jmp	 SHORT $LN3@Allocate@2
$LN4@Allocate@2:

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0001f	81 7d 08 ff ff
	ff 3f		 cmp	 DWORD PTR __Count$[ebp], 1073741823 ; 3fffffffH
  00026	77 18		 ja	 SHORT $LN1@Allocate@2
  00028	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002b	c1 e0 02	 shl	 eax, 2
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 fc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0003a	83 7d fc 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  0003e	75 18		 jne	 SHORT $LN3@Allocate@2
$LN1@Allocate@2:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00040	6a 00		 push	 0
  00042	8d 4d b0	 lea	 ecx, DWORD PTR $T239816[ebp]
  00045	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0004a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0004f	8d 45 b0	 lea	 eax, DWORD PTR $T239816[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Allocate@2:

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00058	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate@2:

; 40   : 	}

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
??$_Allocate@H@std@@YAPAHIPAH@Z ENDP			; std::_Allocate<int>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Node><std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >, COMDAT
; _this$ = ecx

; 170  : 		_ALLOCATOR(const _ALLOCATOR<_Other>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 171  : 		{	// construct from a related allocator (do nothing)
; 172  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??$?0U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Node><std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T239821 = -80						; size = 12
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Node>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 31   : 	void *_Ptr = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 32   : 
; 33   : 	if (_Count <= 0)

  00010	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	77 09		 ja	 SHORT $LN4@Allocate@3

; 34   : 		_Count = 0;

  00016	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __Count$[ebp], 0

; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0001d	eb 39		 jmp	 SHORT $LN3@Allocate@3
$LN4@Allocate@3:

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0001f	81 7d 08 c7 71
	1c 07		 cmp	 DWORD PTR __Count$[ebp], 119304647 ; 071c71c7H
  00026	77 18		 ja	 SHORT $LN1@Allocate@3
  00028	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002b	6b c0 24	 imul	 eax, 36			; 00000024H
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 fc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0003a	83 7d fc 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  0003e	75 18		 jne	 SHORT $LN3@Allocate@3
$LN1@Allocate@3:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00040	6a 00		 push	 0
  00042	8d 4d b0	 lea	 ecx, DWORD PTR $T239821[ebp]
  00045	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0004a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0004f	8d 45 b0	 lea	 eax, DWORD PTR $T239821[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Allocate@3:

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00058	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate@3:

; 40   : 	}

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Node>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Node><std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >, COMDAT
; _this$ = ecx

; 170  : 		_ALLOCATOR(const _ALLOCATOR<_Other>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 171  : 		{	// construct from a related allocator (do nothing)
; 172  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??$?0U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Node><std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T239826 = -80						; size = 12
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Node>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 31   : 	void *_Ptr = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 32   : 
; 33   : 	if (_Count <= 0)

  00010	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	77 09		 ja	 SHORT $LN4@Allocate@4

; 34   : 		_Count = 0;

  00016	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __Count$[ebp], 0

; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0001d	eb 39		 jmp	 SHORT $LN3@Allocate@4
$LN4@Allocate@4:

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0001f	81 7d 08 c7 71
	1c 07		 cmp	 DWORD PTR __Count$[ebp], 119304647 ; 071c71c7H
  00026	77 18		 ja	 SHORT $LN1@Allocate@4
  00028	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002b	6b c0 24	 imul	 eax, 36			; 00000024H
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 fc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0003a	83 7d fc 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  0003e	75 18		 jne	 SHORT $LN3@Allocate@4
$LN1@Allocate@4:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00040	6a 00		 push	 0
  00042	8d 4d b0	 lea	 ecx, DWORD PTR $T239826[ebp]
  00045	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0004a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0004f	8d 45 b0	 lea	 eax, DWORD PTR $T239826[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Allocate@4:

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00058	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate@4:

; 40   : 	}

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Node>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Allocate@UCASTLEDEEP_EVENTTIME@@@std@@YAPAUCASTLEDEEP_EVENTTIME@@IPAU1@@Z
_TEXT	SEGMENT
$T239829 = -80						; size = 12
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UCASTLEDEEP_EVENTTIME@@@std@@YAPAUCASTLEDEEP_EVENTTIME@@IPAU1@@Z PROC ; std::_Allocate<CASTLEDEEP_EVENTTIME>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 31   : 	void *_Ptr = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 32   : 
; 33   : 	if (_Count <= 0)

  00010	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	77 09		 ja	 SHORT $LN4@Allocate@5

; 34   : 		_Count = 0;

  00016	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __Count$[ebp], 0

; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0001d	eb 39		 jmp	 SHORT $LN3@Allocate@5
$LN4@Allocate@5:

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0001f	81 7d 08 ff ff
	ff 1f		 cmp	 DWORD PTR __Count$[ebp], 536870911 ; 1fffffffH
  00026	77 18		 ja	 SHORT $LN1@Allocate@5
  00028	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002b	c1 e0 03	 shl	 eax, 3
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 fc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0003a	83 7d fc 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  0003e	75 18		 jne	 SHORT $LN3@Allocate@5
$LN1@Allocate@5:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00040	6a 00		 push	 0
  00042	8d 4d b0	 lea	 ecx, DWORD PTR $T239829[ebp]
  00045	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0004a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0004f	8d 45 b0	 lea	 eax, DWORD PTR $T239829[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Allocate@5:

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00058	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate@5:

; 40   : 	}

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
??$_Allocate@UCASTLEDEEP_EVENTTIME@@@std@@YAPAUCASTLEDEEP_EVENTTIME@@IPAU1@@Z ENDP ; std::_Allocate<CASTLEDEEP_EVENTTIME>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Allocate@UCASTLEDEEP_SPAWNTIME@@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@IPAU1@@Z
_TEXT	SEGMENT
$T239832 = -80						; size = 12
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UCASTLEDEEP_SPAWNTIME@@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@IPAU1@@Z PROC ; std::_Allocate<CASTLEDEEP_SPAWNTIME>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 31   : 	void *_Ptr = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 32   : 
; 33   : 	if (_Count <= 0)

  00010	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	77 09		 ja	 SHORT $LN4@Allocate@6

; 34   : 		_Count = 0;

  00016	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __Count$[ebp], 0

; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0001d	eb 39		 jmp	 SHORT $LN3@Allocate@6
$LN4@Allocate@6:

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0001f	81 7d 08 ff ff
	ff 1f		 cmp	 DWORD PTR __Count$[ebp], 536870911 ; 1fffffffH
  00026	77 18		 ja	 SHORT $LN1@Allocate@6
  00028	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002b	c1 e0 03	 shl	 eax, 3
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 fc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0003a	83 7d fc 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  0003e	75 18		 jne	 SHORT $LN3@Allocate@6
$LN1@Allocate@6:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00040	6a 00		 push	 0
  00042	8d 4d b0	 lea	 ecx, DWORD PTR $T239832[ebp]
  00045	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0004a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0004f	8d 45 b0	 lea	 eax, DWORD PTR $T239832[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Allocate@6:

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00058	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate@6:

; 40   : 	}

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
??$_Allocate@UCASTLEDEEP_SPAWNTIME@@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@IPAU1@@Z ENDP ; std::_Allocate<CASTLEDEEP_SPAWNTIME>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Allocate@UCASTLEDEEP_MONSTERINFO@@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@IPAU1@@Z
_TEXT	SEGMENT
$T239835 = -80						; size = 12
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UCASTLEDEEP_MONSTERINFO@@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@IPAU1@@Z PROC ; std::_Allocate<CASTLEDEEP_MONSTERINFO>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 31   : 	void *_Ptr = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 32   : 
; 33   : 	if (_Count <= 0)

  00010	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	77 09		 ja	 SHORT $LN4@Allocate@7

; 34   : 		_Count = 0;

  00016	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __Count$[ebp], 0

; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0001d	eb 39		 jmp	 SHORT $LN3@Allocate@7
$LN4@Allocate@7:

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0001f	81 7d 08 49 92
	24 09		 cmp	 DWORD PTR __Count$[ebp], 153391689 ; 09249249H
  00026	77 18		 ja	 SHORT $LN1@Allocate@7
  00028	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002b	6b c0 1c	 imul	 eax, 28			; 0000001cH
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 fc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0003a	83 7d fc 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  0003e	75 18		 jne	 SHORT $LN3@Allocate@7
$LN1@Allocate@7:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00040	6a 00		 push	 0
  00042	8d 4d b0	 lea	 ecx, DWORD PTR $T239835[ebp]
  00045	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0004a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0004f	8d 45 b0	 lea	 eax, DWORD PTR $T239835[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Allocate@7:

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00058	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate@7:

; 40   : 	}

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
??$_Allocate@UCASTLEDEEP_MONSTERINFO@@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@IPAU1@@Z ENDP ; std::_Allocate<CASTLEDEEP_MONSTERINFO>
_TEXT	ENDS
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > > &,bool>
PUBLIC	??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator--
PUBLIC	??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
PUBLIC	?_Key@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Key
PUBLIC	??$_Kfn@$$CBHH@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHH@1@@Z ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Kfn<int const ,int>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Linsert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@_N@Z
_TEXT	SEGMENT
tv147 = -124						; size = 4
$T239840 = -117						; size = 1
$T239841 = -116						; size = 4
$T239842 = -112						; size = 4
$T239843 = -105						; size = 1
$T239844 = -104						; size = 4
$T239845 = -97						; size = 1
$T239846 = -96						; size = 4
$T239847 = -89						; size = 1
__Where$236458 = -24					; size = 4
__Addleft$ = -17					; size = 1
__Wherenode$ = -16					; size = 4
__Trynode$ = -12					; size = 4
__Val$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Node$ = 12						; size = 4
__Leftish$ = 16						; size = 1
?_Linsert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@_N@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Linsert, COMDAT
; _this$ = ecx

; 944  : 		{	// try to insert node at _Node, on left if _Leftish

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 7c	 sub	 esp, 124		; 0000007cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 945  : 		const value_type& _Val = this->_Myval(_Node);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Node$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Myval
  00015	83 c4 04	 add	 esp, 4
  00018	89 45 f8	 mov	 DWORD PTR __Val$[ebp], eax

; 946  : 
; 947  : 		_Nodeptr _Trynode = _Root();

  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root
  00023	8b 00		 mov	 eax, DWORD PTR [eax]
  00025	89 45 f4	 mov	 DWORD PTR __Trynode$[ebp], eax

; 948  : 		_Nodeptr _Wherenode = this->_Myhead;

  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002e	89 4d f0	 mov	 DWORD PTR __Wherenode$[ebp], ecx

; 949  : 		bool _Addleft = true;	// add to left of head if tree empty

  00031	c6 45 ef 01	 mov	 BYTE PTR __Addleft$[ebp], 1
$LN12@Linsert:

; 950  : 		while (!this->_Isnil(_Trynode))

  00035	8b 45 f4	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  0003e	83 c4 04	 add	 esp, 4
  00041	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00044	85 c9		 test	 ecx, ecx
  00046	0f 85 9b 00 00
	00		 jne	 $LN11@Linsert

; 951  : 			{	// look for leaf to insert before (_Addleft) or after
; 952  : 			_Wherenode = _Trynode;

  0004c	8b 45 f4	 mov	 eax, DWORD PTR __Trynode$[ebp]
  0004f	89 45 f0	 mov	 DWORD PTR __Wherenode$[ebp], eax

; 953  : 			if (_Leftish)

  00052	0f b6 45 10	 movzx	 eax, BYTE PTR __Leftish$[ebp]
  00056	85 c0		 test	 eax, eax
  00058	74 31		 je	 SHORT $LN10@Linsert

; 954  : 				_Addleft = !_DEBUG_LT_PRED(this->comp,

  0005a	8b 45 f8	 mov	 eax, DWORD PTR __Val$[ebp]
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 ??$_Kfn@$$CBHH@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHH@1@@Z ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Kfn<int const ,int>
  00063	83 c4 04	 add	 esp, 4
  00066	50		 push	 eax
  00067	8b 4d f4	 mov	 ecx, DWORD PTR __Trynode$[ebp]
  0006a	51		 push	 ecx
  0006b	e8 00 00 00 00	 call	 ?_Key@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Key
  00070	83 c4 04	 add	 esp, 4
  00073	50		 push	 eax
  00074	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  0007c	0f b6 d0	 movzx	 edx, al
  0007f	f7 da		 neg	 edx
  00081	1b d2		 sbb	 edx, edx
  00083	83 c2 01	 add	 edx, 1
  00086	88 55 ef	 mov	 BYTE PTR __Addleft$[ebp], dl

; 955  : 					this->_Key(_Trynode),
; 956  : 					this->_Kfn(_Val));	// favor left end
; 957  : 			else

  00089	eb 25		 jmp	 SHORT $LN9@Linsert
$LN10@Linsert:

; 958  : 				_Addleft = _DEBUG_LT_PRED(this->comp,

  0008b	8b 45 f4	 mov	 eax, DWORD PTR __Trynode$[ebp]
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 ?_Key@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Key
  00094	83 c4 04	 add	 esp, 4
  00097	50		 push	 eax
  00098	8b 4d f8	 mov	 ecx, DWORD PTR __Val$[ebp]
  0009b	51		 push	 ecx
  0009c	e8 00 00 00 00	 call	 ??$_Kfn@$$CBHH@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHH@1@@Z ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Kfn<int const ,int>
  000a1	83 c4 04	 add	 esp, 4
  000a4	50		 push	 eax
  000a5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a8	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  000ad	88 45 ef	 mov	 BYTE PTR __Addleft$[ebp], al
$LN9@Linsert:

; 959  : 					this->_Kfn(_Val),
; 960  : 					this->_Key(_Trynode));	// favor right end
; 961  : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 962  : 				: this->_Right(_Trynode);

  000b0	0f b6 45 ef	 movzx	 eax, BYTE PTR __Addleft$[ebp]
  000b4	85 c0		 test	 eax, eax
  000b6	74 13		 je	 SHORT $LN15@Linsert
  000b8	8b 4d f4	 mov	 ecx, DWORD PTR __Trynode$[ebp]
  000bb	51		 push	 ecx
  000bc	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  000c1	83 c4 04	 add	 esp, 4
  000c4	8b 10		 mov	 edx, DWORD PTR [eax]
  000c6	89 55 84	 mov	 DWORD PTR tv147[ebp], edx
  000c9	eb 11		 jmp	 SHORT $LN16@Linsert
$LN15@Linsert:
  000cb	8b 45 f4	 mov	 eax, DWORD PTR __Trynode$[ebp]
  000ce	50		 push	 eax
  000cf	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  000d4	83 c4 04	 add	 esp, 4
  000d7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d9	89 4d 84	 mov	 DWORD PTR tv147[ebp], ecx
$LN16@Linsert:
  000dc	8b 55 84	 mov	 edx, DWORD PTR tv147[ebp]
  000df	89 55 f4	 mov	 DWORD PTR __Trynode$[ebp], edx

; 963  : 			}

  000e2	e9 4e ff ff ff	 jmp	 $LN12@Linsert
$LN11@Linsert:

; 964  : 
; 965  : 		if (this->_Multi)

  000e7	33 c0		 xor	 eax, eax
  000e9	74 37		 je	 SHORT $LN8@Linsert

; 966  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Node), true));

  000eb	c6 45 8b 01	 mov	 BYTE PTR $T239840[ebp], 1
  000ef	8d 45 8b	 lea	 eax, DWORD PTR $T239840[ebp]
  000f2	50		 push	 eax
  000f3	8b 4d 0c	 mov	 ecx, DWORD PTR __Node$[ebp]
  000f6	51		 push	 ecx
  000f7	8b 55 f0	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  000fa	52		 push	 edx
  000fb	0f b6 45 ef	 movzx	 eax, BYTE PTR __Addleft$[ebp]
  000ff	50		 push	 eax
  00100	8d 4d 8c	 lea	 ecx, DWORD PTR $T239841[ebp]
  00103	51		 push	 ecx
  00104	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00107	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
  0010c	50		 push	 eax
  0010d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00110	e8 00 00 00 00	 call	 ??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>
  00115	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00118	e9 20 01 00 00	 jmp	 $LN13@Linsert

; 967  : 		else

  0011d	e9 1b 01 00 00	 jmp	 $LN13@Linsert
$LN8@Linsert:

; 968  : 			{	// insert only if unique
; 969  : 			iterator _Where = iterator(_Wherenode, this);

  00122	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00125	50		 push	 eax
  00126	8b 4d f0	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00129	51		 push	 ecx
  0012a	8d 4d e8	 lea	 ecx, DWORD PTR __Where$236458[ebp]
  0012d	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >

; 970  : 			if (!_Addleft)

  00132	0f b6 45 ef	 movzx	 eax, BYTE PTR __Addleft$[ebp]
  00136	85 c0		 test	 eax, eax
  00138	75 02		 jne	 SHORT $LN6@Linsert
  0013a	eb 55		 jmp	 SHORT $LN5@Linsert
$LN6@Linsert:

; 971  : 				;	// need to test if insert after is okay
; 972  : 			else if (_Where == begin())

  0013c	8d 45 90	 lea	 eax, DWORD PTR $T239842[ebp]
  0013f	50		 push	 eax
  00140	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00143	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::begin
  00148	50		 push	 eax
  00149	8d 4d e8	 lea	 ecx, DWORD PTR __Where$236458[ebp]
  0014c	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator==
  00151	0f b6 c8	 movzx	 ecx, al
  00154	85 c9		 test	 ecx, ecx
  00156	74 31		 je	 SHORT $LN4@Linsert

; 973  : 				return (_Pairib(_Insert(true, _Wherenode, _Node), true));

  00158	c6 45 97 01	 mov	 BYTE PTR $T239843[ebp], 1
  0015c	8d 45 97	 lea	 eax, DWORD PTR $T239843[ebp]
  0015f	50		 push	 eax
  00160	8b 4d 0c	 mov	 ecx, DWORD PTR __Node$[ebp]
  00163	51		 push	 ecx
  00164	8b 55 f0	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00167	52		 push	 edx
  00168	6a 01		 push	 1
  0016a	8d 45 98	 lea	 eax, DWORD PTR $T239844[ebp]
  0016d	50		 push	 eax
  0016e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00171	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
  00176	50		 push	 eax
  00177	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0017a	e8 00 00 00 00	 call	 ??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>
  0017f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00182	e9 b6 00 00 00	 jmp	 $LN13@Linsert

; 974  : 			else

  00187	eb 08		 jmp	 SHORT $LN5@Linsert
$LN4@Linsert:

; 975  : 				--_Where;	// need to test if insert before is okay

  00189	8d 4d e8	 lea	 ecx, DWORD PTR __Where$236458[ebp]
  0018c	e8 00 00 00 00	 call	 ??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator--
$LN5@Linsert:

; 976  : 
; 977  : 			if (_DEBUG_LT_PRED(this->comp,

  00191	8b 45 f8	 mov	 eax, DWORD PTR __Val$[ebp]
  00194	50		 push	 eax
  00195	e8 00 00 00 00	 call	 ??$_Kfn@$$CBHH@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHH@1@@Z ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Kfn<int const ,int>
  0019a	83 c4 04	 add	 esp, 4
  0019d	50		 push	 eax
  0019e	8d 4d e8	 lea	 ecx, DWORD PTR __Where$236458[ebp]
  001a1	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::_Mynode
  001a6	50		 push	 eax
  001a7	e8 00 00 00 00	 call	 ?_Key@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Key
  001ac	83 c4 04	 add	 esp, 4
  001af	50		 push	 eax
  001b0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001b3	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  001b8	0f b6 c8	 movzx	 ecx, al
  001bb	85 c9		 test	 ecx, ecx
  001bd	74 31		 je	 SHORT $LN2@Linsert

; 978  : 				this->_Key(_Where._Mynode()),
; 979  : 				this->_Kfn(_Val)))
; 980  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Node), true));

  001bf	c6 45 9f 01	 mov	 BYTE PTR $T239845[ebp], 1
  001c3	8d 45 9f	 lea	 eax, DWORD PTR $T239845[ebp]
  001c6	50		 push	 eax
  001c7	8b 4d 0c	 mov	 ecx, DWORD PTR __Node$[ebp]
  001ca	51		 push	 ecx
  001cb	8b 55 f0	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  001ce	52		 push	 edx
  001cf	0f b6 45 ef	 movzx	 eax, BYTE PTR __Addleft$[ebp]
  001d3	50		 push	 eax
  001d4	8d 4d a0	 lea	 ecx, DWORD PTR $T239846[ebp]
  001d7	51		 push	 ecx
  001d8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001db	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
  001e0	50		 push	 eax
  001e1	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  001e4	e8 00 00 00 00	 call	 ??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>
  001e9	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  001ec	eb 4f		 jmp	 SHORT $LN13@Linsert

; 981  : 			else

  001ee	eb 4d		 jmp	 SHORT $LN13@Linsert
$LN2@Linsert:

; 982  : 				{	// duplicate, don't insert
; 983  : 				_Dest_val(this->_Alval,
; 984  : 					_STD addressof(this->_Myval(_Node)));

  001f0	8b 45 0c	 mov	 eax, DWORD PTR __Node$[ebp]
  001f3	50		 push	 eax
  001f4	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Myval
  001f9	83 c4 04	 add	 esp, 4
  001fc	50		 push	 eax
  001fd	e8 00 00 00 00	 call	 ??$addressof@U?$pair@$$CBHH@std@@@std@@YAPAU?$pair@$$CBHH@0@AAU10@@Z ; std::addressof<std::pair<int const ,int> >
  00202	83 c4 04	 add	 esp, 4
  00205	50		 push	 eax
  00206	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00209	83 c1 0d	 add	 ecx, 13			; 0000000dH
  0020c	51		 push	 ecx
  0020d	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBHH@std@@@std@@U?$pair@$$CBHH@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHH@std@@@0@PAU?$pair@$$CBHH@0@@Z ; std::_Dest_val<std::allocator<std::pair<int const ,int> >,std::pair<int const ,int> >
  00212	83 c4 08	 add	 esp, 8

; 985  : 
; 986  : 				this->_Alnod.deallocate(_Node, 1);

  00215	6a 01		 push	 1
  00217	8b 45 0c	 mov	 eax, DWORD PTR __Node$[ebp]
  0021a	50		 push	 eax
  0021b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0021e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00221	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::deallocate

; 987  : 
; 988  : 				return (_Pairib(_Where, false));

  00226	c6 45 a7 00	 mov	 BYTE PTR $T239847[ebp], 0
  0022a	8d 45 a7	 lea	 eax, DWORD PTR $T239847[ebp]
  0022d	50		 push	 eax
  0022e	8d 4d e8	 lea	 ecx, DWORD PTR __Where$236458[ebp]
  00231	51		 push	 ecx
  00232	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00235	e8 00 00 00 00	 call	 ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > > &,bool>
  0023a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN13@Linsert:

; 989  : 				}
; 990  : 			}
; 991  : 		}

  0023d	5f		 pop	 edi
  0023e	5e		 pop	 esi
  0023f	5b		 pop	 ebx
  00240	8b e5		 mov	 esp, ebp
  00242	5d		 pop	 ebp
  00243	c2 0c 00	 ret	 12			; 0000000cH
?_Linsert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@_N@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Linsert
_TEXT	ENDS
PUBLIC	??$_Destroy@U?$pair@$$CBHH@std@@@std@@YAXPAU?$pair@$$CBHH@0@@Z ; std::_Destroy<std::pair<int const ,int> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@U?$pair@$$CBHH@std@@@std@@QAEXPAU?$pair@$$CBHH@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U?$pair@$$CBHH@std@@@std@@QAEXPAU?$pair@$$CBHH@2@@Z PROC ; std::allocator<std::pair<int const ,int> >::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 213  : 		_Destroy(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Destroy@U?$pair@$$CBHH@std@@@std@@YAXPAU?$pair@$$CBHH@0@@Z ; std::_Destroy<std::pair<int const ,int> >
  00015	83 c4 04	 add	 esp, 4

; 214  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?destroy@?$allocator@U?$pair@$$CBHH@std@@@std@@QAEXPAU?$pair@$$CBHH@2@@Z ENDP ; std::allocator<std::pair<int const ,int> >::destroy
_TEXT	ENDS
PUBLIC	??$_Construct@HABH@std@@YAXPAHABH@Z		; std::_Construct<int,int const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ?construct@?$allocator@H@std@@QAEXPAHABH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@H@std@@QAEXPAHABH@Z PROC		; std::allocator<int>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 197  : 		_Construct(_Ptr, _Val);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ??$_Construct@HABH@std@@YAXPAHABH@Z ; std::_Construct<int,int const &>
  00019	83 c4 08	 add	 esp, 8

; 198  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
?construct@?$allocator@H@std@@QAEXPAHABH@Z ENDP		; std::allocator<int>::construct
_TEXT	ENDS
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > > &,bool>
PUBLIC	??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::operator--
PUBLIC	??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >,bool>
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Insert
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Linsert@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@_N@Z
_TEXT	SEGMENT
tv147 = -124						; size = 4
$T239856 = -117						; size = 1
$T239857 = -116						; size = 4
$T239858 = -112						; size = 4
$T239859 = -105						; size = 1
$T239860 = -104						; size = 4
$T239861 = -97						; size = 1
$T239862 = -96						; size = 4
$T239863 = -89						; size = 1
__Where$236516 = -24					; size = 4
__Addleft$ = -17					; size = 1
__Wherenode$ = -16					; size = 4
__Trynode$ = -12					; size = 4
__Val$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Node$ = 12						; size = 4
__Leftish$ = 16						; size = 1
?_Linsert@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@_N@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Linsert, COMDAT
; _this$ = ecx

; 944  : 		{	// try to insert node at _Node, on left if _Leftish

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 7c	 sub	 esp, 124		; 0000007cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 945  : 		const value_type& _Val = this->_Myval(_Node);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Node$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Myval
  00015	83 c4 04	 add	 esp, 4
  00018	89 45 f8	 mov	 DWORD PTR __Val$[ebp], eax

; 946  : 
; 947  : 		_Nodeptr _Trynode = _Root();

  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Root
  00023	8b 00		 mov	 eax, DWORD PTR [eax]
  00025	89 45 f4	 mov	 DWORD PTR __Trynode$[ebp], eax

; 948  : 		_Nodeptr _Wherenode = this->_Myhead;

  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002e	89 4d f0	 mov	 DWORD PTR __Wherenode$[ebp], ecx

; 949  : 		bool _Addleft = true;	// add to left of head if tree empty

  00031	c6 45 ef 01	 mov	 BYTE PTR __Addleft$[ebp], 1
$LN12@Linsert@2:

; 950  : 		while (!this->_Isnil(_Trynode))

  00035	8b 45 f4	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Isnil
  0003e	83 c4 04	 add	 esp, 4
  00041	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00044	85 c9		 test	 ecx, ecx
  00046	0f 85 9b 00 00
	00		 jne	 $LN11@Linsert@2

; 951  : 			{	// look for leaf to insert before (_Addleft) or after
; 952  : 			_Wherenode = _Trynode;

  0004c	8b 45 f4	 mov	 eax, DWORD PTR __Trynode$[ebp]
  0004f	89 45 f0	 mov	 DWORD PTR __Wherenode$[ebp], eax

; 953  : 			if (_Leftish)

  00052	0f b6 45 10	 movzx	 eax, BYTE PTR __Leftish$[ebp]
  00056	85 c0		 test	 eax, eax
  00058	74 31		 je	 SHORT $LN10@Linsert@2

; 954  : 				_Addleft = !_DEBUG_LT_PRED(this->comp,

  0005a	8b 45 f8	 mov	 eax, DWORD PTR __Val$[ebp]
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 ??$_Kfn@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z ; std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0>::_Kfn<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >
  00063	83 c4 04	 add	 esp, 4
  00066	50		 push	 eax
  00067	8b 4d f4	 mov	 ecx, DWORD PTR __Trynode$[ebp]
  0006a	51		 push	 ecx
  0006b	e8 00 00 00 00	 call	 ?_Key@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Key
  00070	83 c4 04	 add	 esp, 4
  00073	50		 push	 eax
  00074	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  0007c	0f b6 d0	 movzx	 edx, al
  0007f	f7 da		 neg	 edx
  00081	1b d2		 sbb	 edx, edx
  00083	83 c2 01	 add	 edx, 1
  00086	88 55 ef	 mov	 BYTE PTR __Addleft$[ebp], dl

; 955  : 					this->_Key(_Trynode),
; 956  : 					this->_Kfn(_Val));	// favor left end
; 957  : 			else

  00089	eb 25		 jmp	 SHORT $LN9@Linsert@2
$LN10@Linsert@2:

; 958  : 				_Addleft = _DEBUG_LT_PRED(this->comp,

  0008b	8b 45 f4	 mov	 eax, DWORD PTR __Trynode$[ebp]
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 ?_Key@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Key
  00094	83 c4 04	 add	 esp, 4
  00097	50		 push	 eax
  00098	8b 4d f8	 mov	 ecx, DWORD PTR __Val$[ebp]
  0009b	51		 push	 ecx
  0009c	e8 00 00 00 00	 call	 ??$_Kfn@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z ; std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0>::_Kfn<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >
  000a1	83 c4 04	 add	 esp, 4
  000a4	50		 push	 eax
  000a5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a8	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  000ad	88 45 ef	 mov	 BYTE PTR __Addleft$[ebp], al
$LN9@Linsert@2:

; 959  : 					this->_Kfn(_Val),
; 960  : 					this->_Key(_Trynode));	// favor right end
; 961  : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 962  : 				: this->_Right(_Trynode);

  000b0	0f b6 45 ef	 movzx	 eax, BYTE PTR __Addleft$[ebp]
  000b4	85 c0		 test	 eax, eax
  000b6	74 13		 je	 SHORT $LN15@Linsert@2
  000b8	8b 4d f4	 mov	 ecx, DWORD PTR __Trynode$[ebp]
  000bb	51		 push	 ecx
  000bc	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Left
  000c1	83 c4 04	 add	 esp, 4
  000c4	8b 10		 mov	 edx, DWORD PTR [eax]
  000c6	89 55 84	 mov	 DWORD PTR tv147[ebp], edx
  000c9	eb 11		 jmp	 SHORT $LN16@Linsert@2
$LN15@Linsert@2:
  000cb	8b 45 f4	 mov	 eax, DWORD PTR __Trynode$[ebp]
  000ce	50		 push	 eax
  000cf	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Right
  000d4	83 c4 04	 add	 esp, 4
  000d7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d9	89 4d 84	 mov	 DWORD PTR tv147[ebp], ecx
$LN16@Linsert@2:
  000dc	8b 55 84	 mov	 edx, DWORD PTR tv147[ebp]
  000df	89 55 f4	 mov	 DWORD PTR __Trynode$[ebp], edx

; 963  : 			}

  000e2	e9 4e ff ff ff	 jmp	 $LN12@Linsert@2
$LN11@Linsert@2:

; 964  : 
; 965  : 		if (this->_Multi)

  000e7	33 c0		 xor	 eax, eax
  000e9	74 37		 je	 SHORT $LN8@Linsert@2

; 966  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Node), true));

  000eb	c6 45 8b 01	 mov	 BYTE PTR $T239856[ebp], 1
  000ef	8d 45 8b	 lea	 eax, DWORD PTR $T239856[ebp]
  000f2	50		 push	 eax
  000f3	8b 4d 0c	 mov	 ecx, DWORD PTR __Node$[ebp]
  000f6	51		 push	 ecx
  000f7	8b 55 f0	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  000fa	52		 push	 edx
  000fb	0f b6 45 ef	 movzx	 eax, BYTE PTR __Addleft$[ebp]
  000ff	50		 push	 eax
  00100	8d 4d 8c	 lea	 ecx, DWORD PTR $T239857[ebp]
  00103	51		 push	 ecx
  00104	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00107	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Insert
  0010c	50		 push	 eax
  0010d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00110	e8 00 00 00 00	 call	 ??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >,bool>
  00115	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00118	e9 20 01 00 00	 jmp	 $LN13@Linsert@2

; 967  : 		else

  0011d	e9 1b 01 00 00	 jmp	 $LN13@Linsert@2
$LN8@Linsert@2:

; 968  : 			{	// insert only if unique
; 969  : 			iterator _Where = iterator(_Wherenode, this);

  00122	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00125	50		 push	 eax
  00126	8b 4d f0	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00129	51		 push	 ecx
  0012a	8d 4d e8	 lea	 ecx, DWORD PTR __Where$236516[ebp]
  0012d	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >

; 970  : 			if (!_Addleft)

  00132	0f b6 45 ef	 movzx	 eax, BYTE PTR __Addleft$[ebp]
  00136	85 c0		 test	 eax, eax
  00138	75 02		 jne	 SHORT $LN6@Linsert@2
  0013a	eb 55		 jmp	 SHORT $LN5@Linsert@2
$LN6@Linsert@2:

; 971  : 				;	// need to test if insert after is okay
; 972  : 			else if (_Where == begin())

  0013c	8d 45 90	 lea	 eax, DWORD PTR $T239858[ebp]
  0013f	50		 push	 eax
  00140	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00143	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::begin
  00148	50		 push	 eax
  00149	8d 4d e8	 lea	 ecx, DWORD PTR __Where$236516[ebp]
  0014c	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::operator==
  00151	0f b6 c8	 movzx	 ecx, al
  00154	85 c9		 test	 ecx, ecx
  00156	74 31		 je	 SHORT $LN4@Linsert@2

; 973  : 				return (_Pairib(_Insert(true, _Wherenode, _Node), true));

  00158	c6 45 97 01	 mov	 BYTE PTR $T239859[ebp], 1
  0015c	8d 45 97	 lea	 eax, DWORD PTR $T239859[ebp]
  0015f	50		 push	 eax
  00160	8b 4d 0c	 mov	 ecx, DWORD PTR __Node$[ebp]
  00163	51		 push	 ecx
  00164	8b 55 f0	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00167	52		 push	 edx
  00168	6a 01		 push	 1
  0016a	8d 45 98	 lea	 eax, DWORD PTR $T239860[ebp]
  0016d	50		 push	 eax
  0016e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00171	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Insert
  00176	50		 push	 eax
  00177	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0017a	e8 00 00 00 00	 call	 ??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >,bool>
  0017f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00182	e9 b6 00 00 00	 jmp	 $LN13@Linsert@2

; 974  : 			else

  00187	eb 08		 jmp	 SHORT $LN5@Linsert@2
$LN4@Linsert@2:

; 975  : 				--_Where;	// need to test if insert before is okay

  00189	8d 4d e8	 lea	 ecx, DWORD PTR __Where$236516[ebp]
  0018c	e8 00 00 00 00	 call	 ??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::operator--
$LN5@Linsert@2:

; 976  : 
; 977  : 			if (_DEBUG_LT_PRED(this->comp,

  00191	8b 45 f8	 mov	 eax, DWORD PTR __Val$[ebp]
  00194	50		 push	 eax
  00195	e8 00 00 00 00	 call	 ??$_Kfn@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z ; std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0>::_Kfn<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >
  0019a	83 c4 04	 add	 esp, 4
  0019d	50		 push	 eax
  0019e	8d 4d e8	 lea	 ecx, DWORD PTR __Where$236516[ebp]
  001a1	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >,std::_Iterator_base0>::_Mynode
  001a6	50		 push	 eax
  001a7	e8 00 00 00 00	 call	 ?_Key@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Key
  001ac	83 c4 04	 add	 esp, 4
  001af	50		 push	 eax
  001b0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001b3	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  001b8	0f b6 c8	 movzx	 ecx, al
  001bb	85 c9		 test	 ecx, ecx
  001bd	74 31		 je	 SHORT $LN2@Linsert@2

; 978  : 				this->_Key(_Where._Mynode()),
; 979  : 				this->_Kfn(_Val)))
; 980  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Node), true));

  001bf	c6 45 9f 01	 mov	 BYTE PTR $T239861[ebp], 1
  001c3	8d 45 9f	 lea	 eax, DWORD PTR $T239861[ebp]
  001c6	50		 push	 eax
  001c7	8b 4d 0c	 mov	 ecx, DWORD PTR __Node$[ebp]
  001ca	51		 push	 ecx
  001cb	8b 55 f0	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  001ce	52		 push	 edx
  001cf	0f b6 45 ef	 movzx	 eax, BYTE PTR __Addleft$[ebp]
  001d3	50		 push	 eax
  001d4	8d 4d a0	 lea	 ecx, DWORD PTR $T239862[ebp]
  001d7	51		 push	 ecx
  001d8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001db	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Insert
  001e0	50		 push	 eax
  001e1	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  001e4	e8 00 00 00 00	 call	 ??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >,bool>
  001e9	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  001ec	eb 4f		 jmp	 SHORT $LN13@Linsert@2

; 981  : 			else

  001ee	eb 4d		 jmp	 SHORT $LN13@Linsert@2
$LN2@Linsert@2:

; 982  : 				{	// duplicate, don't insert
; 983  : 				_Dest_val(this->_Alval,
; 984  : 					_STD addressof(this->_Myval(_Node)));

  001f0	8b 45 0c	 mov	 eax, DWORD PTR __Node$[ebp]
  001f3	50		 push	 eax
  001f4	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Myval
  001f9	83 c4 04	 add	 esp, 4
  001fc	50		 push	 eax
  001fd	e8 00 00 00 00	 call	 ??$addressof@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@YAPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@AAU10@@Z ; std::addressof<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >
  00202	83 c4 04	 add	 esp, 4
  00205	50		 push	 eax
  00206	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00209	83 c1 0d	 add	 ecx, 13			; 0000000dH
  0020c	51		 push	 ecx
  0020d	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@0@PAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >
  00212	83 c4 08	 add	 esp, 8

; 985  : 
; 986  : 				this->_Alnod.deallocate(_Node, 1);

  00215	6a 01		 push	 1
  00217	8b 45 0c	 mov	 eax, DWORD PTR __Node$[ebp]
  0021a	50		 push	 eax
  0021b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0021e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00221	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Node>::deallocate

; 987  : 
; 988  : 				return (_Pairib(_Where, false));

  00226	c6 45 a7 00	 mov	 BYTE PTR $T239863[ebp], 0
  0022a	8d 45 a7	 lea	 eax, DWORD PTR $T239863[ebp]
  0022d	50		 push	 eax
  0022e	8d 4d e8	 lea	 ecx, DWORD PTR __Where$236516[ebp]
  00231	51		 push	 ecx
  00232	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00235	e8 00 00 00 00	 call	 ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > > &,bool>
  0023a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN13@Linsert@2:

; 989  : 				}
; 990  : 			}
; 991  : 		}

  0023d	5f		 pop	 edi
  0023e	5e		 pop	 esi
  0023f	5b		 pop	 ebx
  00240	8b e5		 mov	 esp, ebp
  00242	5d		 pop	 ebp
  00243	c2 0c 00	 ret	 12			; 0000000cH
?_Linsert@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@_N@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Linsert
_TEXT	ENDS
PUBLIC	??$_Destroy@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@YAXPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@@Z ; std::_Destroy<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@QAEXPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@QAEXPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@@Z PROC ; std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 213  : 		_Destroy(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Destroy@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@YAXPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@@Z ; std::_Destroy<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >
  00015	83 c4 04	 add	 esp, 4

; 214  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?destroy@?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@QAEXPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@@Z ENDP ; std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >::destroy
_TEXT	ENDS
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > > &,bool>
PUBLIC	??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::operator--
PUBLIC	??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >,bool>
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Insert
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Linsert@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@_N@Z
_TEXT	SEGMENT
tv147 = -124						; size = 4
$T239870 = -117						; size = 1
$T239871 = -116						; size = 4
$T239872 = -112						; size = 4
$T239873 = -105						; size = 1
$T239874 = -104						; size = 4
$T239875 = -97						; size = 1
$T239876 = -96						; size = 4
$T239877 = -89						; size = 1
__Where$236566 = -24					; size = 4
__Addleft$ = -17					; size = 1
__Wherenode$ = -16					; size = 4
__Trynode$ = -12					; size = 4
__Val$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Node$ = 12						; size = 4
__Leftish$ = 16						; size = 1
?_Linsert@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@_N@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Linsert, COMDAT
; _this$ = ecx

; 944  : 		{	// try to insert node at _Node, on left if _Leftish

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 7c	 sub	 esp, 124		; 0000007cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 945  : 		const value_type& _Val = this->_Myval(_Node);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Node$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Myval
  00015	83 c4 04	 add	 esp, 4
  00018	89 45 f8	 mov	 DWORD PTR __Val$[ebp], eax

; 946  : 
; 947  : 		_Nodeptr _Trynode = _Root();

  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Root
  00023	8b 00		 mov	 eax, DWORD PTR [eax]
  00025	89 45 f4	 mov	 DWORD PTR __Trynode$[ebp], eax

; 948  : 		_Nodeptr _Wherenode = this->_Myhead;

  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002e	89 4d f0	 mov	 DWORD PTR __Wherenode$[ebp], ecx

; 949  : 		bool _Addleft = true;	// add to left of head if tree empty

  00031	c6 45 ef 01	 mov	 BYTE PTR __Addleft$[ebp], 1
$LN12@Linsert@3:

; 950  : 		while (!this->_Isnil(_Trynode))

  00035	8b 45 f4	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Isnil
  0003e	83 c4 04	 add	 esp, 4
  00041	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00044	85 c9		 test	 ecx, ecx
  00046	0f 85 9b 00 00
	00		 jne	 $LN11@Linsert@3

; 951  : 			{	// look for leaf to insert before (_Addleft) or after
; 952  : 			_Wherenode = _Trynode;

  0004c	8b 45 f4	 mov	 eax, DWORD PTR __Trynode$[ebp]
  0004f	89 45 f0	 mov	 DWORD PTR __Wherenode$[ebp], eax

; 953  : 			if (_Leftish)

  00052	0f b6 45 10	 movzx	 eax, BYTE PTR __Leftish$[ebp]
  00056	85 c0		 test	 eax, eax
  00058	74 31		 je	 SHORT $LN10@Linsert@3

; 954  : 				_Addleft = !_DEBUG_LT_PRED(this->comp,

  0005a	8b 45 f8	 mov	 eax, DWORD PTR __Val$[ebp]
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 ??$_Kfn@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z ; std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0>::_Kfn<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >
  00063	83 c4 04	 add	 esp, 4
  00066	50		 push	 eax
  00067	8b 4d f4	 mov	 ecx, DWORD PTR __Trynode$[ebp]
  0006a	51		 push	 ecx
  0006b	e8 00 00 00 00	 call	 ?_Key@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Key
  00070	83 c4 04	 add	 esp, 4
  00073	50		 push	 eax
  00074	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  0007c	0f b6 d0	 movzx	 edx, al
  0007f	f7 da		 neg	 edx
  00081	1b d2		 sbb	 edx, edx
  00083	83 c2 01	 add	 edx, 1
  00086	88 55 ef	 mov	 BYTE PTR __Addleft$[ebp], dl

; 955  : 					this->_Key(_Trynode),
; 956  : 					this->_Kfn(_Val));	// favor left end
; 957  : 			else

  00089	eb 25		 jmp	 SHORT $LN9@Linsert@3
$LN10@Linsert@3:

; 958  : 				_Addleft = _DEBUG_LT_PRED(this->comp,

  0008b	8b 45 f4	 mov	 eax, DWORD PTR __Trynode$[ebp]
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 ?_Key@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Key
  00094	83 c4 04	 add	 esp, 4
  00097	50		 push	 eax
  00098	8b 4d f8	 mov	 ecx, DWORD PTR __Val$[ebp]
  0009b	51		 push	 ecx
  0009c	e8 00 00 00 00	 call	 ??$_Kfn@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z ; std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0>::_Kfn<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >
  000a1	83 c4 04	 add	 esp, 4
  000a4	50		 push	 eax
  000a5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a8	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  000ad	88 45 ef	 mov	 BYTE PTR __Addleft$[ebp], al
$LN9@Linsert@3:

; 959  : 					this->_Kfn(_Val),
; 960  : 					this->_Key(_Trynode));	// favor right end
; 961  : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 962  : 				: this->_Right(_Trynode);

  000b0	0f b6 45 ef	 movzx	 eax, BYTE PTR __Addleft$[ebp]
  000b4	85 c0		 test	 eax, eax
  000b6	74 13		 je	 SHORT $LN15@Linsert@3
  000b8	8b 4d f4	 mov	 ecx, DWORD PTR __Trynode$[ebp]
  000bb	51		 push	 ecx
  000bc	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Left
  000c1	83 c4 04	 add	 esp, 4
  000c4	8b 10		 mov	 edx, DWORD PTR [eax]
  000c6	89 55 84	 mov	 DWORD PTR tv147[ebp], edx
  000c9	eb 11		 jmp	 SHORT $LN16@Linsert@3
$LN15@Linsert@3:
  000cb	8b 45 f4	 mov	 eax, DWORD PTR __Trynode$[ebp]
  000ce	50		 push	 eax
  000cf	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Right
  000d4	83 c4 04	 add	 esp, 4
  000d7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d9	89 4d 84	 mov	 DWORD PTR tv147[ebp], ecx
$LN16@Linsert@3:
  000dc	8b 55 84	 mov	 edx, DWORD PTR tv147[ebp]
  000df	89 55 f4	 mov	 DWORD PTR __Trynode$[ebp], edx

; 963  : 			}

  000e2	e9 4e ff ff ff	 jmp	 $LN12@Linsert@3
$LN11@Linsert@3:

; 964  : 
; 965  : 		if (this->_Multi)

  000e7	33 c0		 xor	 eax, eax
  000e9	74 37		 je	 SHORT $LN8@Linsert@3

; 966  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Node), true));

  000eb	c6 45 8b 01	 mov	 BYTE PTR $T239870[ebp], 1
  000ef	8d 45 8b	 lea	 eax, DWORD PTR $T239870[ebp]
  000f2	50		 push	 eax
  000f3	8b 4d 0c	 mov	 ecx, DWORD PTR __Node$[ebp]
  000f6	51		 push	 ecx
  000f7	8b 55 f0	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  000fa	52		 push	 edx
  000fb	0f b6 45 ef	 movzx	 eax, BYTE PTR __Addleft$[ebp]
  000ff	50		 push	 eax
  00100	8d 4d 8c	 lea	 ecx, DWORD PTR $T239871[ebp]
  00103	51		 push	 ecx
  00104	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00107	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Insert
  0010c	50		 push	 eax
  0010d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00110	e8 00 00 00 00	 call	 ??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >,bool>
  00115	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00118	e9 20 01 00 00	 jmp	 $LN13@Linsert@3

; 967  : 		else

  0011d	e9 1b 01 00 00	 jmp	 $LN13@Linsert@3
$LN8@Linsert@3:

; 968  : 			{	// insert only if unique
; 969  : 			iterator _Where = iterator(_Wherenode, this);

  00122	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00125	50		 push	 eax
  00126	8b 4d f0	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00129	51		 push	 ecx
  0012a	8d 4d e8	 lea	 ecx, DWORD PTR __Where$236566[ebp]
  0012d	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >

; 970  : 			if (!_Addleft)

  00132	0f b6 45 ef	 movzx	 eax, BYTE PTR __Addleft$[ebp]
  00136	85 c0		 test	 eax, eax
  00138	75 02		 jne	 SHORT $LN6@Linsert@3
  0013a	eb 55		 jmp	 SHORT $LN5@Linsert@3
$LN6@Linsert@3:

; 971  : 				;	// need to test if insert after is okay
; 972  : 			else if (_Where == begin())

  0013c	8d 45 90	 lea	 eax, DWORD PTR $T239872[ebp]
  0013f	50		 push	 eax
  00140	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00143	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::begin
  00148	50		 push	 eax
  00149	8d 4d e8	 lea	 ecx, DWORD PTR __Where$236566[ebp]
  0014c	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::operator==
  00151	0f b6 c8	 movzx	 ecx, al
  00154	85 c9		 test	 ecx, ecx
  00156	74 31		 je	 SHORT $LN4@Linsert@3

; 973  : 				return (_Pairib(_Insert(true, _Wherenode, _Node), true));

  00158	c6 45 97 01	 mov	 BYTE PTR $T239873[ebp], 1
  0015c	8d 45 97	 lea	 eax, DWORD PTR $T239873[ebp]
  0015f	50		 push	 eax
  00160	8b 4d 0c	 mov	 ecx, DWORD PTR __Node$[ebp]
  00163	51		 push	 ecx
  00164	8b 55 f0	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00167	52		 push	 edx
  00168	6a 01		 push	 1
  0016a	8d 45 98	 lea	 eax, DWORD PTR $T239874[ebp]
  0016d	50		 push	 eax
  0016e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00171	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Insert
  00176	50		 push	 eax
  00177	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0017a	e8 00 00 00 00	 call	 ??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >,bool>
  0017f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00182	e9 b6 00 00 00	 jmp	 $LN13@Linsert@3

; 974  : 			else

  00187	eb 08		 jmp	 SHORT $LN5@Linsert@3
$LN4@Linsert@3:

; 975  : 				--_Where;	// need to test if insert before is okay

  00189	8d 4d e8	 lea	 ecx, DWORD PTR __Where$236566[ebp]
  0018c	e8 00 00 00 00	 call	 ??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::operator--
$LN5@Linsert@3:

; 976  : 
; 977  : 			if (_DEBUG_LT_PRED(this->comp,

  00191	8b 45 f8	 mov	 eax, DWORD PTR __Val$[ebp]
  00194	50		 push	 eax
  00195	e8 00 00 00 00	 call	 ??$_Kfn@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z ; std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0>::_Kfn<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >
  0019a	83 c4 04	 add	 esp, 4
  0019d	50		 push	 eax
  0019e	8d 4d e8	 lea	 ecx, DWORD PTR __Where$236566[ebp]
  001a1	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >,std::_Iterator_base0>::_Mynode
  001a6	50		 push	 eax
  001a7	e8 00 00 00 00	 call	 ?_Key@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Key
  001ac	83 c4 04	 add	 esp, 4
  001af	50		 push	 eax
  001b0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001b3	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  001b8	0f b6 c8	 movzx	 ecx, al
  001bb	85 c9		 test	 ecx, ecx
  001bd	74 31		 je	 SHORT $LN2@Linsert@3

; 978  : 				this->_Key(_Where._Mynode()),
; 979  : 				this->_Kfn(_Val)))
; 980  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Node), true));

  001bf	c6 45 9f 01	 mov	 BYTE PTR $T239875[ebp], 1
  001c3	8d 45 9f	 lea	 eax, DWORD PTR $T239875[ebp]
  001c6	50		 push	 eax
  001c7	8b 4d 0c	 mov	 ecx, DWORD PTR __Node$[ebp]
  001ca	51		 push	 ecx
  001cb	8b 55 f0	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  001ce	52		 push	 edx
  001cf	0f b6 45 ef	 movzx	 eax, BYTE PTR __Addleft$[ebp]
  001d3	50		 push	 eax
  001d4	8d 4d a0	 lea	 ecx, DWORD PTR $T239876[ebp]
  001d7	51		 push	 ecx
  001d8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001db	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Insert
  001e0	50		 push	 eax
  001e1	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  001e4	e8 00 00 00 00	 call	 ??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >,bool>
  001e9	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  001ec	eb 4f		 jmp	 SHORT $LN13@Linsert@3

; 981  : 			else

  001ee	eb 4d		 jmp	 SHORT $LN13@Linsert@3
$LN2@Linsert@3:

; 982  : 				{	// duplicate, don't insert
; 983  : 				_Dest_val(this->_Alval,
; 984  : 					_STD addressof(this->_Myval(_Node)));

  001f0	8b 45 0c	 mov	 eax, DWORD PTR __Node$[ebp]
  001f3	50		 push	 eax
  001f4	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Myval
  001f9	83 c4 04	 add	 esp, 4
  001fc	50		 push	 eax
  001fd	e8 00 00 00 00	 call	 ??$addressof@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@YAPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@AAU10@@Z ; std::addressof<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >
  00202	83 c4 04	 add	 esp, 4
  00205	50		 push	 eax
  00206	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00209	83 c1 0d	 add	 ecx, 13			; 0000000dH
  0020c	51		 push	 ecx
  0020d	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@0@PAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >
  00212	83 c4 08	 add	 esp, 8

; 985  : 
; 986  : 				this->_Alnod.deallocate(_Node, 1);

  00215	6a 01		 push	 1
  00217	8b 45 0c	 mov	 eax, DWORD PTR __Node$[ebp]
  0021a	50		 push	 eax
  0021b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0021e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00221	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Node>::deallocate

; 987  : 
; 988  : 				return (_Pairib(_Where, false));

  00226	c6 45 a7 00	 mov	 BYTE PTR $T239877[ebp], 0
  0022a	8d 45 a7	 lea	 eax, DWORD PTR $T239877[ebp]
  0022d	50		 push	 eax
  0022e	8d 4d e8	 lea	 ecx, DWORD PTR __Where$236566[ebp]
  00231	51		 push	 ecx
  00232	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00235	e8 00 00 00 00	 call	 ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > > &,bool>
  0023a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN13@Linsert@3:

; 989  : 				}
; 990  : 			}
; 991  : 		}

  0023d	5f		 pop	 edi
  0023e	5e		 pop	 esi
  0023f	5b		 pop	 ebx
  00240	8b e5		 mov	 esp, ebp
  00242	5d		 pop	 ebp
  00243	c2 0c 00	 ret	 12			; 0000000cH
?_Linsert@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@_N@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Linsert
_TEXT	ENDS
PUBLIC	??$_Destroy@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@YAXPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@@Z ; std::_Destroy<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@QAEXPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@QAEXPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@@Z PROC ; std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 213  : 		_Destroy(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Destroy@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@YAXPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@@Z ; std::_Destroy<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >
  00015	83 c4 04	 add	 esp, 4

; 214  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?destroy@?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@QAEXPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@@Z ENDP ; std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >::destroy
_TEXT	ENDS
PUBLIC	??$_Construct@UCASTLEDEEP_EVENTTIME@@ABU1@@std@@YAXPAUCASTLEDEEP_EVENTTIME@@ABU1@@Z ; std::_Construct<CASTLEDEEP_EVENTTIME,CASTLEDEEP_EVENTTIME const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ?construct@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAEXPAUCASTLEDEEP_EVENTTIME@@ABU3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAEXPAUCASTLEDEEP_EVENTTIME@@ABU3@@Z PROC ; std::allocator<CASTLEDEEP_EVENTTIME>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 197  : 		_Construct(_Ptr, _Val);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ??$_Construct@UCASTLEDEEP_EVENTTIME@@ABU1@@std@@YAXPAUCASTLEDEEP_EVENTTIME@@ABU1@@Z ; std::_Construct<CASTLEDEEP_EVENTTIME,CASTLEDEEP_EVENTTIME const &>
  00019	83 c4 08	 add	 esp, 8

; 198  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
?construct@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAEXPAUCASTLEDEEP_EVENTTIME@@ABU3@@Z ENDP ; std::allocator<CASTLEDEEP_EVENTTIME>::construct
_TEXT	ENDS
PUBLIC	??$_Construct@UCASTLEDEEP_SPAWNTIME@@ABU1@@std@@YAXPAUCASTLEDEEP_SPAWNTIME@@ABU1@@Z ; std::_Construct<CASTLEDEEP_SPAWNTIME,CASTLEDEEP_SPAWNTIME const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ?construct@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEXPAUCASTLEDEEP_SPAWNTIME@@ABU3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEXPAUCASTLEDEEP_SPAWNTIME@@ABU3@@Z PROC ; std::allocator<CASTLEDEEP_SPAWNTIME>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 197  : 		_Construct(_Ptr, _Val);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ??$_Construct@UCASTLEDEEP_SPAWNTIME@@ABU1@@std@@YAXPAUCASTLEDEEP_SPAWNTIME@@ABU1@@Z ; std::_Construct<CASTLEDEEP_SPAWNTIME,CASTLEDEEP_SPAWNTIME const &>
  00019	83 c4 08	 add	 esp, 8

; 198  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
?construct@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEXPAUCASTLEDEEP_SPAWNTIME@@ABU3@@Z ENDP ; std::allocator<CASTLEDEEP_SPAWNTIME>::construct
_TEXT	ENDS
PUBLIC	??$_Construct@UCASTLEDEEP_MONSTERINFO@@ABU1@@std@@YAXPAUCASTLEDEEP_MONSTERINFO@@ABU1@@Z ; std::_Construct<CASTLEDEEP_MONSTERINFO,CASTLEDEEP_MONSTERINFO const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ?construct@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEXPAUCASTLEDEEP_MONSTERINFO@@ABU3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEXPAUCASTLEDEEP_MONSTERINFO@@ABU3@@Z PROC ; std::allocator<CASTLEDEEP_MONSTERINFO>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 197  : 		_Construct(_Ptr, _Val);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ??$_Construct@UCASTLEDEEP_MONSTERINFO@@ABU1@@std@@YAXPAUCASTLEDEEP_MONSTERINFO@@ABU1@@Z ; std::_Construct<CASTLEDEEP_MONSTERINFO,CASTLEDEEP_MONSTERINFO const &>
  00019	83 c4 08	 add	 esp, 8

; 198  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
?construct@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEXPAUCASTLEDEEP_MONSTERINFO@@ABU3@@Z ENDP ; std::allocator<CASTLEDEEP_MONSTERINFO>::construct
_TEXT	ENDS
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::max_size
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
; File d:\microsoft visual studio 10.0\vc\include\xtree
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@1@Z
_TEXT	SEGMENT
__Pnode$236629 = -8					; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Newnode$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@1@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert, COMDAT
; _this$ = ecx

; 1631 : 		{	// add node with value next to _Wherenode, to left if _Addleft

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1632 : 		if (max_size() - 1 <= this->_Mysize)

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?max_size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::max_size
  00014	83 e8 01	 sub	 eax, 1
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  0001d	77 40		 ja	 SHORT $LN17@Insert

; 1633 : 			{	// tree would get too big, fail
; 1634 : 			_Dest_val(this->_Alval,
; 1635 : 				_STD addressof(this->_Myval(_Newnode)));

  0001f	8b 45 14	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Myval
  00028	83 c4 04	 add	 esp, 4
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$addressof@U?$pair@$$CBHH@std@@@std@@YAPAU?$pair@$$CBHH@0@AAU10@@Z ; std::addressof<std::pair<int const ,int> >
  00031	83 c4 04	 add	 esp, 4
  00034	50		 push	 eax
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	83 c1 0d	 add	 ecx, 13			; 0000000dH
  0003b	51		 push	 ecx
  0003c	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBHH@std@@@std@@U?$pair@$$CBHH@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHH@std@@@0@PAU?$pair@$$CBHH@0@@Z ; std::_Dest_val<std::allocator<std::pair<int const ,int> >,std::pair<int const ,int> >
  00041	83 c4 08	 add	 esp, 8

; 1636 : 
; 1637 : 			this->_Alnod.deallocate(_Newnode, 1);

  00044	6a 01		 push	 1
  00046	8b 45 14	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00049	50		 push	 eax
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00050	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::deallocate

; 1638 : 
; 1639 : 			_Xlength_error("map/set<T> too long");

  00055	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
  0005a	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN17@Insert:

; 1640 : 			}
; 1641 : 		++this->_Mysize;

  0005f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00062	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00065	83 c1 01	 add	 ecx, 1
  00068	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0006b	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1642 : 		_Newnode->_Parent = _Wherenode;

  0006e	8b 45 14	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00071	8b 4d 10	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00074	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1643 : 
; 1644 : 		if (_Wherenode == this->_Myhead)

  00077	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007a	8b 4d 10	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0007d	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00080	75 29		 jne	 SHORT $LN16@Insert

; 1645 : 			{	// first node in tree, just set head values
; 1646 : 			_Root() = _Newnode;

  00082	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00085	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root
  0008a	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  0008d	89 08		 mov	 DWORD PTR [eax], ecx

; 1647 : 			_Lmost() = _Newnode;

  0008f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00092	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lmost
  00097	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  0009a	89 08		 mov	 DWORD PTR [eax], ecx

; 1648 : 			_Rmost() = _Newnode;

  0009c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009f	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rmost
  000a4	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  000a7	89 08		 mov	 DWORD PTR [eax], ecx
  000a9	eb 64		 jmp	 SHORT $LN15@Insert
$LN16@Insert:

; 1649 : 			}
; 1650 : 		else if (_Addleft)

  000ab	0f b6 45 0c	 movzx	 eax, BYTE PTR __Addleft$[ebp]
  000af	85 c0		 test	 eax, eax
  000b1	74 2f		 je	 SHORT $LN14@Insert

; 1651 : 			{	// add to left of _Wherenode
; 1652 : 			this->_Left(_Wherenode) = _Newnode;

  000b3	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000b6	50		 push	 eax
  000b7	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  000bc	83 c4 04	 add	 esp, 4
  000bf	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  000c2	89 08		 mov	 DWORD PTR [eax], ecx

; 1653 : 			if (_Wherenode == _Lmost())

  000c4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c7	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lmost
  000cc	8b 4d 10	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  000cf	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000d1	75 0d		 jne	 SHORT $LN13@Insert

; 1654 : 				_Lmost() = _Newnode;

  000d3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d6	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lmost
  000db	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  000de	89 08		 mov	 DWORD PTR [eax], ecx
$LN13@Insert:

; 1655 : 			}
; 1656 : 		else

  000e0	eb 2d		 jmp	 SHORT $LN15@Insert
$LN14@Insert:

; 1657 : 			{	// add to right of _Wherenode
; 1658 : 			this->_Right(_Wherenode) = _Newnode;

  000e2	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  000eb	83 c4 04	 add	 esp, 4
  000ee	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  000f1	89 08		 mov	 DWORD PTR [eax], ecx

; 1659 : 			if (_Wherenode == _Rmost())

  000f3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f6	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rmost
  000fb	8b 4d 10	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  000fe	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00100	75 0d		 jne	 SHORT $LN15@Insert

; 1660 : 				_Rmost() = _Newnode;

  00102	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00105	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rmost
  0010a	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  0010d	89 08		 mov	 DWORD PTR [eax], ecx
$LN15@Insert:

; 1661 : 			}
; 1662 : 
; 1663 : 		for (_Nodeptr _Pnode = _Newnode;

  0010f	8b 45 14	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00112	89 45 f8	 mov	 DWORD PTR __Pnode$236629[ebp], eax
$LN10@Insert:

; 1664 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  00115	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236629[ebp]
  00118	50		 push	 eax
  00119	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  0011e	83 c4 04	 add	 esp, 4
  00121	8b 08		 mov	 ecx, DWORD PTR [eax]
  00123	51		 push	 ecx
  00124	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  00129	83 c4 04	 add	 esp, 4
  0012c	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0012f	85 d2		 test	 edx, edx
  00131	0f 85 ce 02 00
	00		 jne	 $LN9@Insert

; 1665 : 			if (this->_Parent(_Pnode)
; 1666 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))

  00137	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236629[ebp]
  0013a	50		 push	 eax
  0013b	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  00140	83 c4 04	 add	 esp, 4
  00143	8b f0		 mov	 esi, eax
  00145	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$236629[ebp]
  00148	51		 push	 ecx
  00149	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  0014e	83 c4 04	 add	 esp, 4
  00151	8b 10		 mov	 edx, DWORD PTR [eax]
  00153	52		 push	 edx
  00154	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  00159	83 c4 04	 add	 esp, 4
  0015c	8b 00		 mov	 eax, DWORD PTR [eax]
  0015e	50		 push	 eax
  0015f	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  00164	83 c4 04	 add	 esp, 4
  00167	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00169	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0016b	0f 85 4a 01 00
	00		 jne	 $LN8@Insert

; 1667 : 				{	// fixup red-red in left subtree
; 1668 : 				_Wherenode =
; 1669 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));

  00171	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236629[ebp]
  00174	50		 push	 eax
  00175	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  0017a	83 c4 04	 add	 esp, 4
  0017d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0017f	51		 push	 ecx
  00180	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  00185	83 c4 04	 add	 esp, 4
  00188	8b 10		 mov	 edx, DWORD PTR [eax]
  0018a	52		 push	 edx
  0018b	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  00190	83 c4 04	 add	 esp, 4
  00193	8b 00		 mov	 eax, DWORD PTR [eax]
  00195	89 45 10	 mov	 DWORD PTR __Wherenode$[ebp], eax

; 1670 : 				if (this->_Color(_Wherenode) == this->_Red)

  00198	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0019b	50		 push	 eax
  0019c	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  001a1	83 c4 04	 add	 esp, 4
  001a4	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  001a7	85 c9		 test	 ecx, ecx
  001a9	75 6f		 jne	 SHORT $LN7@Insert

; 1671 : 					{	// parent has two red children, blacken both
; 1672 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  001ab	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236629[ebp]
  001ae	50		 push	 eax
  001af	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  001b4	83 c4 04	 add	 esp, 4
  001b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b9	51		 push	 ecx
  001ba	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  001bf	83 c4 04	 add	 esp, 4
  001c2	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1673 : 					this->_Color(_Wherenode) = this->_Black;

  001c5	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  001c8	50		 push	 eax
  001c9	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  001ce	83 c4 04	 add	 esp, 4
  001d1	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1674 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1675 : 						= this->_Red;

  001d4	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236629[ebp]
  001d7	50		 push	 eax
  001d8	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  001dd	83 c4 04	 add	 esp, 4
  001e0	8b 08		 mov	 ecx, DWORD PTR [eax]
  001e2	51		 push	 ecx
  001e3	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  001e8	83 c4 04	 add	 esp, 4
  001eb	8b 10		 mov	 edx, DWORD PTR [eax]
  001ed	52		 push	 edx
  001ee	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  001f3	83 c4 04	 add	 esp, 4
  001f6	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1676 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  001f9	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236629[ebp]
  001fc	50		 push	 eax
  001fd	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  00202	83 c4 04	 add	 esp, 4
  00205	8b 08		 mov	 ecx, DWORD PTR [eax]
  00207	51		 push	 ecx
  00208	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  0020d	83 c4 04	 add	 esp, 4
  00210	8b 10		 mov	 edx, DWORD PTR [eax]
  00212	89 55 f8	 mov	 DWORD PTR __Pnode$236629[ebp], edx

; 1677 : 					}
; 1678 : 				else

  00215	e9 9c 00 00 00	 jmp	 $LN6@Insert
$LN7@Insert:

; 1679 : 					{	// parent has red and black children
; 1680 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))

  0021a	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236629[ebp]
  0021d	50		 push	 eax
  0021e	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  00223	83 c4 04	 add	 esp, 4
  00226	8b 08		 mov	 ecx, DWORD PTR [eax]
  00228	51		 push	 ecx
  00229	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  0022e	83 c4 04	 add	 esp, 4
  00231	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$236629[ebp]
  00234	3b 10		 cmp	 edx, DWORD PTR [eax]
  00236	75 1d		 jne	 SHORT $LN5@Insert

; 1681 : 						{	// rotate right child to left
; 1682 : 						_Pnode = this->_Parent(_Pnode);

  00238	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236629[ebp]
  0023b	50		 push	 eax
  0023c	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  00241	83 c4 04	 add	 esp, 4
  00244	8b 08		 mov	 ecx, DWORD PTR [eax]
  00246	89 4d f8	 mov	 DWORD PTR __Pnode$236629[ebp], ecx

; 1683 : 						_Lrotate(_Pnode);

  00249	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236629[ebp]
  0024c	50		 push	 eax
  0024d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00250	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate
$LN5@Insert:

; 1684 : 						}
; 1685 : 					this->_Color(this->_Parent(_Pnode)) =
; 1686 : 						this->_Black;	// propagate red up

  00255	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236629[ebp]
  00258	50		 push	 eax
  00259	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  0025e	83 c4 04	 add	 esp, 4
  00261	8b 08		 mov	 ecx, DWORD PTR [eax]
  00263	51		 push	 ecx
  00264	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  00269	83 c4 04	 add	 esp, 4
  0026c	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1687 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1688 : 						this->_Red;

  0026f	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236629[ebp]
  00272	50		 push	 eax
  00273	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  00278	83 c4 04	 add	 esp, 4
  0027b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0027d	51		 push	 ecx
  0027e	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  00283	83 c4 04	 add	 esp, 4
  00286	8b 10		 mov	 edx, DWORD PTR [eax]
  00288	52		 push	 edx
  00289	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  0028e	83 c4 04	 add	 esp, 4
  00291	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1689 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

  00294	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236629[ebp]
  00297	50		 push	 eax
  00298	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  0029d	83 c4 04	 add	 esp, 4
  002a0	8b 08		 mov	 ecx, DWORD PTR [eax]
  002a2	51		 push	 ecx
  002a3	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  002a8	83 c4 04	 add	 esp, 4
  002ab	8b 10		 mov	 edx, DWORD PTR [eax]
  002ad	52		 push	 edx
  002ae	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002b1	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate
$LN6@Insert:

; 1690 : 					}
; 1691 : 				}
; 1692 : 			else

  002b6	e9 45 01 00 00	 jmp	 $LN4@Insert
$LN8@Insert:

; 1693 : 				{	// fixup red-red in right subtree
; 1694 : 				_Wherenode =
; 1695 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));

  002bb	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236629[ebp]
  002be	50		 push	 eax
  002bf	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  002c4	83 c4 04	 add	 esp, 4
  002c7	8b 08		 mov	 ecx, DWORD PTR [eax]
  002c9	51		 push	 ecx
  002ca	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  002cf	83 c4 04	 add	 esp, 4
  002d2	8b 10		 mov	 edx, DWORD PTR [eax]
  002d4	52		 push	 edx
  002d5	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  002da	83 c4 04	 add	 esp, 4
  002dd	8b 00		 mov	 eax, DWORD PTR [eax]
  002df	89 45 10	 mov	 DWORD PTR __Wherenode$[ebp], eax

; 1696 : 				if (this->_Color(_Wherenode) == this->_Red)

  002e2	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  002e5	50		 push	 eax
  002e6	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  002eb	83 c4 04	 add	 esp, 4
  002ee	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  002f1	85 c9		 test	 ecx, ecx
  002f3	75 6f		 jne	 SHORT $LN3@Insert

; 1697 : 					{	// parent has two red children, blacken both
; 1698 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  002f5	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236629[ebp]
  002f8	50		 push	 eax
  002f9	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  002fe	83 c4 04	 add	 esp, 4
  00301	8b 08		 mov	 ecx, DWORD PTR [eax]
  00303	51		 push	 ecx
  00304	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  00309	83 c4 04	 add	 esp, 4
  0030c	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1699 : 					this->_Color(_Wherenode) = this->_Black;

  0030f	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00312	50		 push	 eax
  00313	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  00318	83 c4 04	 add	 esp, 4
  0031b	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1700 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1701 : 						this->_Red;

  0031e	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236629[ebp]
  00321	50		 push	 eax
  00322	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  00327	83 c4 04	 add	 esp, 4
  0032a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0032c	51		 push	 ecx
  0032d	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  00332	83 c4 04	 add	 esp, 4
  00335	8b 10		 mov	 edx, DWORD PTR [eax]
  00337	52		 push	 edx
  00338	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  0033d	83 c4 04	 add	 esp, 4
  00340	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1702 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  00343	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236629[ebp]
  00346	50		 push	 eax
  00347	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  0034c	83 c4 04	 add	 esp, 4
  0034f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00351	51		 push	 ecx
  00352	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  00357	83 c4 04	 add	 esp, 4
  0035a	8b 10		 mov	 edx, DWORD PTR [eax]
  0035c	89 55 f8	 mov	 DWORD PTR __Pnode$236629[ebp], edx

; 1703 : 					}
; 1704 : 				else

  0035f	e9 9c 00 00 00	 jmp	 $LN4@Insert
$LN3@Insert:

; 1705 : 					{	// parent has red and black children
; 1706 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))

  00364	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236629[ebp]
  00367	50		 push	 eax
  00368	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  0036d	83 c4 04	 add	 esp, 4
  00370	8b 08		 mov	 ecx, DWORD PTR [eax]
  00372	51		 push	 ecx
  00373	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  00378	83 c4 04	 add	 esp, 4
  0037b	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$236629[ebp]
  0037e	3b 10		 cmp	 edx, DWORD PTR [eax]
  00380	75 1d		 jne	 SHORT $LN1@Insert

; 1707 : 						{	// rotate left child to right
; 1708 : 						_Pnode = this->_Parent(_Pnode);

  00382	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236629[ebp]
  00385	50		 push	 eax
  00386	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  0038b	83 c4 04	 add	 esp, 4
  0038e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00390	89 4d f8	 mov	 DWORD PTR __Pnode$236629[ebp], ecx

; 1709 : 						_Rrotate(_Pnode);

  00393	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236629[ebp]
  00396	50		 push	 eax
  00397	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0039a	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate
$LN1@Insert:

; 1710 : 						}
; 1711 : 					this->_Color(this->_Parent(_Pnode)) =
; 1712 : 						this->_Black;	// propagate red up

  0039f	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236629[ebp]
  003a2	50		 push	 eax
  003a3	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  003a8	83 c4 04	 add	 esp, 4
  003ab	8b 08		 mov	 ecx, DWORD PTR [eax]
  003ad	51		 push	 ecx
  003ae	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  003b3	83 c4 04	 add	 esp, 4
  003b6	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1713 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1714 : 						this->_Red;

  003b9	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236629[ebp]
  003bc	50		 push	 eax
  003bd	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  003c2	83 c4 04	 add	 esp, 4
  003c5	8b 08		 mov	 ecx, DWORD PTR [eax]
  003c7	51		 push	 ecx
  003c8	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  003cd	83 c4 04	 add	 esp, 4
  003d0	8b 10		 mov	 edx, DWORD PTR [eax]
  003d2	52		 push	 edx
  003d3	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  003d8	83 c4 04	 add	 esp, 4
  003db	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1715 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));

  003de	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236629[ebp]
  003e1	50		 push	 eax
  003e2	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  003e7	83 c4 04	 add	 esp, 4
  003ea	8b 08		 mov	 ecx, DWORD PTR [eax]
  003ec	51		 push	 ecx
  003ed	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  003f2	83 c4 04	 add	 esp, 4
  003f5	8b 10		 mov	 edx, DWORD PTR [eax]
  003f7	52		 push	 edx
  003f8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003fb	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate
$LN4@Insert:

; 1716 : 					}
; 1717 : 				}

  00400	e9 10 fd ff ff	 jmp	 $LN10@Insert
$LN9@Insert:

; 1718 : 
; 1719 : 		this->_Color(_Root()) = this->_Black;	// root is always black

  00405	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00408	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Root
  0040d	8b 00		 mov	 eax, DWORD PTR [eax]
  0040f	50		 push	 eax
  00410	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  00415	83 c4 04	 add	 esp, 4
  00418	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1720 : 		return (iterator(_Newnode, this));

  0041b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0041e	50		 push	 eax
  0041f	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00422	51		 push	 ecx
  00423	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00426	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >
  0042b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN19@Insert:

; 1721 : 		}

  0042e	5f		 pop	 edi
  0042f	5e		 pop	 esi
  00430	5b		 pop	 ebx
  00431	8b e5		 mov	 esp, ebp
  00433	5d		 pop	 ebp
  00434	c2 10 00	 ret	 16			; 00000010H
?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@1@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Key, COMDAT

; 616  : 		{	// return reference to key in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 617  : 		return ((key_type&)_Traits::_Kfn(_Myval(_Pnode)));

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Myval
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??$_Kfn@$$CBHH@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHH@1@@Z ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Kfn<int const ,int>
  0001b	83 c4 04	 add	 esp, 4

; 618  : 		}

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
?_Key@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Key
_TEXT	ENDS
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@1@Z
_TEXT	SEGMENT
__Pnode$236654 = -8					; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Newnode$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@1@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Insert, COMDAT
; _this$ = ecx

; 1631 : 		{	// add node with value next to _Wherenode, to left if _Addleft

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1632 : 		if (max_size() - 1 <= this->_Mysize)

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?max_size@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::max_size
  00014	83 e8 01	 sub	 eax, 1
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  0001d	77 40		 ja	 SHORT $LN17@Insert@2

; 1633 : 			{	// tree would get too big, fail
; 1634 : 			_Dest_val(this->_Alval,
; 1635 : 				_STD addressof(this->_Myval(_Newnode)));

  0001f	8b 45 14	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Myval
  00028	83 c4 04	 add	 esp, 4
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$addressof@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@YAPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@AAU10@@Z ; std::addressof<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >
  00031	83 c4 04	 add	 esp, 4
  00034	50		 push	 eax
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	83 c1 0d	 add	 ecx, 13			; 0000000dH
  0003b	51		 push	 ecx
  0003c	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@0@PAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >
  00041	83 c4 08	 add	 esp, 8

; 1636 : 
; 1637 : 			this->_Alnod.deallocate(_Newnode, 1);

  00044	6a 01		 push	 1
  00046	8b 45 14	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00049	50		 push	 eax
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00050	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Node>::deallocate

; 1638 : 
; 1639 : 			_Xlength_error("map/set<T> too long");

  00055	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
  0005a	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN17@Insert@2:

; 1640 : 			}
; 1641 : 		++this->_Mysize;

  0005f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00062	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00065	83 c1 01	 add	 ecx, 1
  00068	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0006b	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1642 : 		_Newnode->_Parent = _Wherenode;

  0006e	8b 45 14	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00071	8b 4d 10	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00074	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1643 : 
; 1644 : 		if (_Wherenode == this->_Myhead)

  00077	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007a	8b 4d 10	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0007d	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00080	75 29		 jne	 SHORT $LN16@Insert@2

; 1645 : 			{	// first node in tree, just set head values
; 1646 : 			_Root() = _Newnode;

  00082	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00085	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Root
  0008a	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  0008d	89 08		 mov	 DWORD PTR [eax], ecx

; 1647 : 			_Lmost() = _Newnode;

  0008f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00092	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Lmost
  00097	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  0009a	89 08		 mov	 DWORD PTR [eax], ecx

; 1648 : 			_Rmost() = _Newnode;

  0009c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009f	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Rmost
  000a4	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  000a7	89 08		 mov	 DWORD PTR [eax], ecx
  000a9	eb 64		 jmp	 SHORT $LN15@Insert@2
$LN16@Insert@2:

; 1649 : 			}
; 1650 : 		else if (_Addleft)

  000ab	0f b6 45 0c	 movzx	 eax, BYTE PTR __Addleft$[ebp]
  000af	85 c0		 test	 eax, eax
  000b1	74 2f		 je	 SHORT $LN14@Insert@2

; 1651 : 			{	// add to left of _Wherenode
; 1652 : 			this->_Left(_Wherenode) = _Newnode;

  000b3	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000b6	50		 push	 eax
  000b7	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Left
  000bc	83 c4 04	 add	 esp, 4
  000bf	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  000c2	89 08		 mov	 DWORD PTR [eax], ecx

; 1653 : 			if (_Wherenode == _Lmost())

  000c4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c7	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Lmost
  000cc	8b 4d 10	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  000cf	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000d1	75 0d		 jne	 SHORT $LN13@Insert@2

; 1654 : 				_Lmost() = _Newnode;

  000d3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d6	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Lmost
  000db	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  000de	89 08		 mov	 DWORD PTR [eax], ecx
$LN13@Insert@2:

; 1655 : 			}
; 1656 : 		else

  000e0	eb 2d		 jmp	 SHORT $LN15@Insert@2
$LN14@Insert@2:

; 1657 : 			{	// add to right of _Wherenode
; 1658 : 			this->_Right(_Wherenode) = _Newnode;

  000e2	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Right
  000eb	83 c4 04	 add	 esp, 4
  000ee	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  000f1	89 08		 mov	 DWORD PTR [eax], ecx

; 1659 : 			if (_Wherenode == _Rmost())

  000f3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f6	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Rmost
  000fb	8b 4d 10	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  000fe	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00100	75 0d		 jne	 SHORT $LN15@Insert@2

; 1660 : 				_Rmost() = _Newnode;

  00102	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00105	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Rmost
  0010a	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  0010d	89 08		 mov	 DWORD PTR [eax], ecx
$LN15@Insert@2:

; 1661 : 			}
; 1662 : 
; 1663 : 		for (_Nodeptr _Pnode = _Newnode;

  0010f	8b 45 14	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00112	89 45 f8	 mov	 DWORD PTR __Pnode$236654[ebp], eax
$LN10@Insert@2:

; 1664 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  00115	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236654[ebp]
  00118	50		 push	 eax
  00119	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  0011e	83 c4 04	 add	 esp, 4
  00121	8b 08		 mov	 ecx, DWORD PTR [eax]
  00123	51		 push	 ecx
  00124	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
  00129	83 c4 04	 add	 esp, 4
  0012c	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0012f	85 d2		 test	 edx, edx
  00131	0f 85 ce 02 00
	00		 jne	 $LN9@Insert@2

; 1665 : 			if (this->_Parent(_Pnode)
; 1666 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))

  00137	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236654[ebp]
  0013a	50		 push	 eax
  0013b	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  00140	83 c4 04	 add	 esp, 4
  00143	8b f0		 mov	 esi, eax
  00145	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$236654[ebp]
  00148	51		 push	 ecx
  00149	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  0014e	83 c4 04	 add	 esp, 4
  00151	8b 10		 mov	 edx, DWORD PTR [eax]
  00153	52		 push	 edx
  00154	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  00159	83 c4 04	 add	 esp, 4
  0015c	8b 00		 mov	 eax, DWORD PTR [eax]
  0015e	50		 push	 eax
  0015f	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Left
  00164	83 c4 04	 add	 esp, 4
  00167	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00169	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0016b	0f 85 4a 01 00
	00		 jne	 $LN8@Insert@2

; 1667 : 				{	// fixup red-red in left subtree
; 1668 : 				_Wherenode =
; 1669 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));

  00171	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236654[ebp]
  00174	50		 push	 eax
  00175	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  0017a	83 c4 04	 add	 esp, 4
  0017d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0017f	51		 push	 ecx
  00180	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  00185	83 c4 04	 add	 esp, 4
  00188	8b 10		 mov	 edx, DWORD PTR [eax]
  0018a	52		 push	 edx
  0018b	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Right
  00190	83 c4 04	 add	 esp, 4
  00193	8b 00		 mov	 eax, DWORD PTR [eax]
  00195	89 45 10	 mov	 DWORD PTR __Wherenode$[ebp], eax

; 1670 : 				if (this->_Color(_Wherenode) == this->_Red)

  00198	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0019b	50		 push	 eax
  0019c	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
  001a1	83 c4 04	 add	 esp, 4
  001a4	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  001a7	85 c9		 test	 ecx, ecx
  001a9	75 6f		 jne	 SHORT $LN7@Insert@2

; 1671 : 					{	// parent has two red children, blacken both
; 1672 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  001ab	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236654[ebp]
  001ae	50		 push	 eax
  001af	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  001b4	83 c4 04	 add	 esp, 4
  001b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b9	51		 push	 ecx
  001ba	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
  001bf	83 c4 04	 add	 esp, 4
  001c2	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1673 : 					this->_Color(_Wherenode) = this->_Black;

  001c5	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  001c8	50		 push	 eax
  001c9	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
  001ce	83 c4 04	 add	 esp, 4
  001d1	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1674 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1675 : 						= this->_Red;

  001d4	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236654[ebp]
  001d7	50		 push	 eax
  001d8	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  001dd	83 c4 04	 add	 esp, 4
  001e0	8b 08		 mov	 ecx, DWORD PTR [eax]
  001e2	51		 push	 ecx
  001e3	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  001e8	83 c4 04	 add	 esp, 4
  001eb	8b 10		 mov	 edx, DWORD PTR [eax]
  001ed	52		 push	 edx
  001ee	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
  001f3	83 c4 04	 add	 esp, 4
  001f6	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1676 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  001f9	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236654[ebp]
  001fc	50		 push	 eax
  001fd	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  00202	83 c4 04	 add	 esp, 4
  00205	8b 08		 mov	 ecx, DWORD PTR [eax]
  00207	51		 push	 ecx
  00208	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  0020d	83 c4 04	 add	 esp, 4
  00210	8b 10		 mov	 edx, DWORD PTR [eax]
  00212	89 55 f8	 mov	 DWORD PTR __Pnode$236654[ebp], edx

; 1677 : 					}
; 1678 : 				else

  00215	e9 9c 00 00 00	 jmp	 $LN6@Insert@2
$LN7@Insert@2:

; 1679 : 					{	// parent has red and black children
; 1680 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))

  0021a	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236654[ebp]
  0021d	50		 push	 eax
  0021e	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  00223	83 c4 04	 add	 esp, 4
  00226	8b 08		 mov	 ecx, DWORD PTR [eax]
  00228	51		 push	 ecx
  00229	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Right
  0022e	83 c4 04	 add	 esp, 4
  00231	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$236654[ebp]
  00234	3b 10		 cmp	 edx, DWORD PTR [eax]
  00236	75 1d		 jne	 SHORT $LN5@Insert@2

; 1681 : 						{	// rotate right child to left
; 1682 : 						_Pnode = this->_Parent(_Pnode);

  00238	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236654[ebp]
  0023b	50		 push	 eax
  0023c	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  00241	83 c4 04	 add	 esp, 4
  00244	8b 08		 mov	 ecx, DWORD PTR [eax]
  00246	89 4d f8	 mov	 DWORD PTR __Pnode$236654[ebp], ecx

; 1683 : 						_Lrotate(_Pnode);

  00249	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236654[ebp]
  0024c	50		 push	 eax
  0024d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00250	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Lrotate
$LN5@Insert@2:

; 1684 : 						}
; 1685 : 					this->_Color(this->_Parent(_Pnode)) =
; 1686 : 						this->_Black;	// propagate red up

  00255	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236654[ebp]
  00258	50		 push	 eax
  00259	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  0025e	83 c4 04	 add	 esp, 4
  00261	8b 08		 mov	 ecx, DWORD PTR [eax]
  00263	51		 push	 ecx
  00264	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
  00269	83 c4 04	 add	 esp, 4
  0026c	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1687 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1688 : 						this->_Red;

  0026f	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236654[ebp]
  00272	50		 push	 eax
  00273	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  00278	83 c4 04	 add	 esp, 4
  0027b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0027d	51		 push	 ecx
  0027e	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  00283	83 c4 04	 add	 esp, 4
  00286	8b 10		 mov	 edx, DWORD PTR [eax]
  00288	52		 push	 edx
  00289	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
  0028e	83 c4 04	 add	 esp, 4
  00291	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1689 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

  00294	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236654[ebp]
  00297	50		 push	 eax
  00298	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  0029d	83 c4 04	 add	 esp, 4
  002a0	8b 08		 mov	 ecx, DWORD PTR [eax]
  002a2	51		 push	 ecx
  002a3	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  002a8	83 c4 04	 add	 esp, 4
  002ab	8b 10		 mov	 edx, DWORD PTR [eax]
  002ad	52		 push	 edx
  002ae	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002b1	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Rrotate
$LN6@Insert@2:

; 1690 : 					}
; 1691 : 				}
; 1692 : 			else

  002b6	e9 45 01 00 00	 jmp	 $LN4@Insert@2
$LN8@Insert@2:

; 1693 : 				{	// fixup red-red in right subtree
; 1694 : 				_Wherenode =
; 1695 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));

  002bb	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236654[ebp]
  002be	50		 push	 eax
  002bf	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  002c4	83 c4 04	 add	 esp, 4
  002c7	8b 08		 mov	 ecx, DWORD PTR [eax]
  002c9	51		 push	 ecx
  002ca	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  002cf	83 c4 04	 add	 esp, 4
  002d2	8b 10		 mov	 edx, DWORD PTR [eax]
  002d4	52		 push	 edx
  002d5	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Left
  002da	83 c4 04	 add	 esp, 4
  002dd	8b 00		 mov	 eax, DWORD PTR [eax]
  002df	89 45 10	 mov	 DWORD PTR __Wherenode$[ebp], eax

; 1696 : 				if (this->_Color(_Wherenode) == this->_Red)

  002e2	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  002e5	50		 push	 eax
  002e6	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
  002eb	83 c4 04	 add	 esp, 4
  002ee	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  002f1	85 c9		 test	 ecx, ecx
  002f3	75 6f		 jne	 SHORT $LN3@Insert@2

; 1697 : 					{	// parent has two red children, blacken both
; 1698 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  002f5	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236654[ebp]
  002f8	50		 push	 eax
  002f9	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  002fe	83 c4 04	 add	 esp, 4
  00301	8b 08		 mov	 ecx, DWORD PTR [eax]
  00303	51		 push	 ecx
  00304	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
  00309	83 c4 04	 add	 esp, 4
  0030c	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1699 : 					this->_Color(_Wherenode) = this->_Black;

  0030f	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00312	50		 push	 eax
  00313	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
  00318	83 c4 04	 add	 esp, 4
  0031b	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1700 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1701 : 						this->_Red;

  0031e	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236654[ebp]
  00321	50		 push	 eax
  00322	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  00327	83 c4 04	 add	 esp, 4
  0032a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0032c	51		 push	 ecx
  0032d	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  00332	83 c4 04	 add	 esp, 4
  00335	8b 10		 mov	 edx, DWORD PTR [eax]
  00337	52		 push	 edx
  00338	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
  0033d	83 c4 04	 add	 esp, 4
  00340	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1702 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  00343	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236654[ebp]
  00346	50		 push	 eax
  00347	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  0034c	83 c4 04	 add	 esp, 4
  0034f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00351	51		 push	 ecx
  00352	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  00357	83 c4 04	 add	 esp, 4
  0035a	8b 10		 mov	 edx, DWORD PTR [eax]
  0035c	89 55 f8	 mov	 DWORD PTR __Pnode$236654[ebp], edx

; 1703 : 					}
; 1704 : 				else

  0035f	e9 9c 00 00 00	 jmp	 $LN4@Insert@2
$LN3@Insert@2:

; 1705 : 					{	// parent has red and black children
; 1706 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))

  00364	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236654[ebp]
  00367	50		 push	 eax
  00368	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  0036d	83 c4 04	 add	 esp, 4
  00370	8b 08		 mov	 ecx, DWORD PTR [eax]
  00372	51		 push	 ecx
  00373	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Left
  00378	83 c4 04	 add	 esp, 4
  0037b	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$236654[ebp]
  0037e	3b 10		 cmp	 edx, DWORD PTR [eax]
  00380	75 1d		 jne	 SHORT $LN1@Insert@2

; 1707 : 						{	// rotate left child to right
; 1708 : 						_Pnode = this->_Parent(_Pnode);

  00382	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236654[ebp]
  00385	50		 push	 eax
  00386	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  0038b	83 c4 04	 add	 esp, 4
  0038e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00390	89 4d f8	 mov	 DWORD PTR __Pnode$236654[ebp], ecx

; 1709 : 						_Rrotate(_Pnode);

  00393	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236654[ebp]
  00396	50		 push	 eax
  00397	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0039a	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Rrotate
$LN1@Insert@2:

; 1710 : 						}
; 1711 : 					this->_Color(this->_Parent(_Pnode)) =
; 1712 : 						this->_Black;	// propagate red up

  0039f	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236654[ebp]
  003a2	50		 push	 eax
  003a3	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  003a8	83 c4 04	 add	 esp, 4
  003ab	8b 08		 mov	 ecx, DWORD PTR [eax]
  003ad	51		 push	 ecx
  003ae	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
  003b3	83 c4 04	 add	 esp, 4
  003b6	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1713 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1714 : 						this->_Red;

  003b9	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236654[ebp]
  003bc	50		 push	 eax
  003bd	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  003c2	83 c4 04	 add	 esp, 4
  003c5	8b 08		 mov	 ecx, DWORD PTR [eax]
  003c7	51		 push	 ecx
  003c8	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  003cd	83 c4 04	 add	 esp, 4
  003d0	8b 10		 mov	 edx, DWORD PTR [eax]
  003d2	52		 push	 edx
  003d3	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
  003d8	83 c4 04	 add	 esp, 4
  003db	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1715 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));

  003de	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236654[ebp]
  003e1	50		 push	 eax
  003e2	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  003e7	83 c4 04	 add	 esp, 4
  003ea	8b 08		 mov	 ecx, DWORD PTR [eax]
  003ec	51		 push	 ecx
  003ed	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  003f2	83 c4 04	 add	 esp, 4
  003f5	8b 10		 mov	 edx, DWORD PTR [eax]
  003f7	52		 push	 edx
  003f8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003fb	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Lrotate
$LN4@Insert@2:

; 1716 : 					}
; 1717 : 				}

  00400	e9 10 fd ff ff	 jmp	 $LN10@Insert@2
$LN9@Insert@2:

; 1718 : 
; 1719 : 		this->_Color(_Root()) = this->_Black;	// root is always black

  00405	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00408	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Root
  0040d	8b 00		 mov	 eax, DWORD PTR [eax]
  0040f	50		 push	 eax
  00410	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
  00415	83 c4 04	 add	 esp, 4
  00418	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1720 : 		return (iterator(_Newnode, this));

  0041b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0041e	50		 push	 eax
  0041f	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00422	51		 push	 ecx
  00423	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00426	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >
  0042b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN19@Insert@2:

; 1721 : 		}

  0042e	5f		 pop	 edi
  0042f	5e		 pop	 esi
  00430	5b		 pop	 ebx
  00431	8b e5		 mov	 esp, ebp
  00433	5d		 pop	 ebp
  00434	c2 10 00	 ret	 16			; 00000010H
?_Insert@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@1@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Insert
_TEXT	ENDS
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@1@Z
_TEXT	SEGMENT
__Pnode$236677 = -8					; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Newnode$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@1@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Insert, COMDAT
; _this$ = ecx

; 1631 : 		{	// add node with value next to _Wherenode, to left if _Addleft

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1632 : 		if (max_size() - 1 <= this->_Mysize)

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?max_size@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::max_size
  00014	83 e8 01	 sub	 eax, 1
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  0001d	77 40		 ja	 SHORT $LN17@Insert@3

; 1633 : 			{	// tree would get too big, fail
; 1634 : 			_Dest_val(this->_Alval,
; 1635 : 				_STD addressof(this->_Myval(_Newnode)));

  0001f	8b 45 14	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Myval
  00028	83 c4 04	 add	 esp, 4
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$addressof@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@YAPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@AAU10@@Z ; std::addressof<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >
  00031	83 c4 04	 add	 esp, 4
  00034	50		 push	 eax
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	83 c1 0d	 add	 ecx, 13			; 0000000dH
  0003b	51		 push	 ecx
  0003c	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@0@PAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >
  00041	83 c4 08	 add	 esp, 8

; 1636 : 
; 1637 : 			this->_Alnod.deallocate(_Newnode, 1);

  00044	6a 01		 push	 1
  00046	8b 45 14	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00049	50		 push	 eax
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00050	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Node>::deallocate

; 1638 : 
; 1639 : 			_Xlength_error("map/set<T> too long");

  00055	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
  0005a	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN17@Insert@3:

; 1640 : 			}
; 1641 : 		++this->_Mysize;

  0005f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00062	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00065	83 c1 01	 add	 ecx, 1
  00068	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0006b	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1642 : 		_Newnode->_Parent = _Wherenode;

  0006e	8b 45 14	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00071	8b 4d 10	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00074	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1643 : 
; 1644 : 		if (_Wherenode == this->_Myhead)

  00077	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007a	8b 4d 10	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0007d	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00080	75 29		 jne	 SHORT $LN16@Insert@3

; 1645 : 			{	// first node in tree, just set head values
; 1646 : 			_Root() = _Newnode;

  00082	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00085	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Root
  0008a	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  0008d	89 08		 mov	 DWORD PTR [eax], ecx

; 1647 : 			_Lmost() = _Newnode;

  0008f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00092	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Lmost
  00097	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  0009a	89 08		 mov	 DWORD PTR [eax], ecx

; 1648 : 			_Rmost() = _Newnode;

  0009c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009f	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Rmost
  000a4	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  000a7	89 08		 mov	 DWORD PTR [eax], ecx
  000a9	eb 64		 jmp	 SHORT $LN15@Insert@3
$LN16@Insert@3:

; 1649 : 			}
; 1650 : 		else if (_Addleft)

  000ab	0f b6 45 0c	 movzx	 eax, BYTE PTR __Addleft$[ebp]
  000af	85 c0		 test	 eax, eax
  000b1	74 2f		 je	 SHORT $LN14@Insert@3

; 1651 : 			{	// add to left of _Wherenode
; 1652 : 			this->_Left(_Wherenode) = _Newnode;

  000b3	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000b6	50		 push	 eax
  000b7	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Left
  000bc	83 c4 04	 add	 esp, 4
  000bf	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  000c2	89 08		 mov	 DWORD PTR [eax], ecx

; 1653 : 			if (_Wherenode == _Lmost())

  000c4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c7	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Lmost
  000cc	8b 4d 10	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  000cf	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000d1	75 0d		 jne	 SHORT $LN13@Insert@3

; 1654 : 				_Lmost() = _Newnode;

  000d3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d6	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Lmost
  000db	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  000de	89 08		 mov	 DWORD PTR [eax], ecx
$LN13@Insert@3:

; 1655 : 			}
; 1656 : 		else

  000e0	eb 2d		 jmp	 SHORT $LN15@Insert@3
$LN14@Insert@3:

; 1657 : 			{	// add to right of _Wherenode
; 1658 : 			this->_Right(_Wherenode) = _Newnode;

  000e2	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Right
  000eb	83 c4 04	 add	 esp, 4
  000ee	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  000f1	89 08		 mov	 DWORD PTR [eax], ecx

; 1659 : 			if (_Wherenode == _Rmost())

  000f3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f6	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Rmost
  000fb	8b 4d 10	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  000fe	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00100	75 0d		 jne	 SHORT $LN15@Insert@3

; 1660 : 				_Rmost() = _Newnode;

  00102	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00105	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Rmost
  0010a	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  0010d	89 08		 mov	 DWORD PTR [eax], ecx
$LN15@Insert@3:

; 1661 : 			}
; 1662 : 
; 1663 : 		for (_Nodeptr _Pnode = _Newnode;

  0010f	8b 45 14	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00112	89 45 f8	 mov	 DWORD PTR __Pnode$236677[ebp], eax
$LN10@Insert@3:

; 1664 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  00115	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236677[ebp]
  00118	50		 push	 eax
  00119	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  0011e	83 c4 04	 add	 esp, 4
  00121	8b 08		 mov	 ecx, DWORD PTR [eax]
  00123	51		 push	 ecx
  00124	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
  00129	83 c4 04	 add	 esp, 4
  0012c	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0012f	85 d2		 test	 edx, edx
  00131	0f 85 ce 02 00
	00		 jne	 $LN9@Insert@3

; 1665 : 			if (this->_Parent(_Pnode)
; 1666 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))

  00137	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236677[ebp]
  0013a	50		 push	 eax
  0013b	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  00140	83 c4 04	 add	 esp, 4
  00143	8b f0		 mov	 esi, eax
  00145	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$236677[ebp]
  00148	51		 push	 ecx
  00149	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  0014e	83 c4 04	 add	 esp, 4
  00151	8b 10		 mov	 edx, DWORD PTR [eax]
  00153	52		 push	 edx
  00154	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  00159	83 c4 04	 add	 esp, 4
  0015c	8b 00		 mov	 eax, DWORD PTR [eax]
  0015e	50		 push	 eax
  0015f	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Left
  00164	83 c4 04	 add	 esp, 4
  00167	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00169	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0016b	0f 85 4a 01 00
	00		 jne	 $LN8@Insert@3

; 1667 : 				{	// fixup red-red in left subtree
; 1668 : 				_Wherenode =
; 1669 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));

  00171	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236677[ebp]
  00174	50		 push	 eax
  00175	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  0017a	83 c4 04	 add	 esp, 4
  0017d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0017f	51		 push	 ecx
  00180	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  00185	83 c4 04	 add	 esp, 4
  00188	8b 10		 mov	 edx, DWORD PTR [eax]
  0018a	52		 push	 edx
  0018b	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Right
  00190	83 c4 04	 add	 esp, 4
  00193	8b 00		 mov	 eax, DWORD PTR [eax]
  00195	89 45 10	 mov	 DWORD PTR __Wherenode$[ebp], eax

; 1670 : 				if (this->_Color(_Wherenode) == this->_Red)

  00198	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0019b	50		 push	 eax
  0019c	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
  001a1	83 c4 04	 add	 esp, 4
  001a4	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  001a7	85 c9		 test	 ecx, ecx
  001a9	75 6f		 jne	 SHORT $LN7@Insert@3

; 1671 : 					{	// parent has two red children, blacken both
; 1672 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  001ab	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236677[ebp]
  001ae	50		 push	 eax
  001af	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  001b4	83 c4 04	 add	 esp, 4
  001b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b9	51		 push	 ecx
  001ba	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
  001bf	83 c4 04	 add	 esp, 4
  001c2	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1673 : 					this->_Color(_Wherenode) = this->_Black;

  001c5	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  001c8	50		 push	 eax
  001c9	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
  001ce	83 c4 04	 add	 esp, 4
  001d1	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1674 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1675 : 						= this->_Red;

  001d4	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236677[ebp]
  001d7	50		 push	 eax
  001d8	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  001dd	83 c4 04	 add	 esp, 4
  001e0	8b 08		 mov	 ecx, DWORD PTR [eax]
  001e2	51		 push	 ecx
  001e3	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  001e8	83 c4 04	 add	 esp, 4
  001eb	8b 10		 mov	 edx, DWORD PTR [eax]
  001ed	52		 push	 edx
  001ee	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
  001f3	83 c4 04	 add	 esp, 4
  001f6	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1676 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  001f9	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236677[ebp]
  001fc	50		 push	 eax
  001fd	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  00202	83 c4 04	 add	 esp, 4
  00205	8b 08		 mov	 ecx, DWORD PTR [eax]
  00207	51		 push	 ecx
  00208	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  0020d	83 c4 04	 add	 esp, 4
  00210	8b 10		 mov	 edx, DWORD PTR [eax]
  00212	89 55 f8	 mov	 DWORD PTR __Pnode$236677[ebp], edx

; 1677 : 					}
; 1678 : 				else

  00215	e9 9c 00 00 00	 jmp	 $LN6@Insert@3
$LN7@Insert@3:

; 1679 : 					{	// parent has red and black children
; 1680 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))

  0021a	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236677[ebp]
  0021d	50		 push	 eax
  0021e	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  00223	83 c4 04	 add	 esp, 4
  00226	8b 08		 mov	 ecx, DWORD PTR [eax]
  00228	51		 push	 ecx
  00229	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Right
  0022e	83 c4 04	 add	 esp, 4
  00231	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$236677[ebp]
  00234	3b 10		 cmp	 edx, DWORD PTR [eax]
  00236	75 1d		 jne	 SHORT $LN5@Insert@3

; 1681 : 						{	// rotate right child to left
; 1682 : 						_Pnode = this->_Parent(_Pnode);

  00238	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236677[ebp]
  0023b	50		 push	 eax
  0023c	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  00241	83 c4 04	 add	 esp, 4
  00244	8b 08		 mov	 ecx, DWORD PTR [eax]
  00246	89 4d f8	 mov	 DWORD PTR __Pnode$236677[ebp], ecx

; 1683 : 						_Lrotate(_Pnode);

  00249	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236677[ebp]
  0024c	50		 push	 eax
  0024d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00250	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Lrotate
$LN5@Insert@3:

; 1684 : 						}
; 1685 : 					this->_Color(this->_Parent(_Pnode)) =
; 1686 : 						this->_Black;	// propagate red up

  00255	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236677[ebp]
  00258	50		 push	 eax
  00259	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  0025e	83 c4 04	 add	 esp, 4
  00261	8b 08		 mov	 ecx, DWORD PTR [eax]
  00263	51		 push	 ecx
  00264	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
  00269	83 c4 04	 add	 esp, 4
  0026c	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1687 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1688 : 						this->_Red;

  0026f	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236677[ebp]
  00272	50		 push	 eax
  00273	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  00278	83 c4 04	 add	 esp, 4
  0027b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0027d	51		 push	 ecx
  0027e	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  00283	83 c4 04	 add	 esp, 4
  00286	8b 10		 mov	 edx, DWORD PTR [eax]
  00288	52		 push	 edx
  00289	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
  0028e	83 c4 04	 add	 esp, 4
  00291	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1689 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

  00294	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236677[ebp]
  00297	50		 push	 eax
  00298	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  0029d	83 c4 04	 add	 esp, 4
  002a0	8b 08		 mov	 ecx, DWORD PTR [eax]
  002a2	51		 push	 ecx
  002a3	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  002a8	83 c4 04	 add	 esp, 4
  002ab	8b 10		 mov	 edx, DWORD PTR [eax]
  002ad	52		 push	 edx
  002ae	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002b1	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Rrotate
$LN6@Insert@3:

; 1690 : 					}
; 1691 : 				}
; 1692 : 			else

  002b6	e9 45 01 00 00	 jmp	 $LN4@Insert@3
$LN8@Insert@3:

; 1693 : 				{	// fixup red-red in right subtree
; 1694 : 				_Wherenode =
; 1695 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));

  002bb	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236677[ebp]
  002be	50		 push	 eax
  002bf	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  002c4	83 c4 04	 add	 esp, 4
  002c7	8b 08		 mov	 ecx, DWORD PTR [eax]
  002c9	51		 push	 ecx
  002ca	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  002cf	83 c4 04	 add	 esp, 4
  002d2	8b 10		 mov	 edx, DWORD PTR [eax]
  002d4	52		 push	 edx
  002d5	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Left
  002da	83 c4 04	 add	 esp, 4
  002dd	8b 00		 mov	 eax, DWORD PTR [eax]
  002df	89 45 10	 mov	 DWORD PTR __Wherenode$[ebp], eax

; 1696 : 				if (this->_Color(_Wherenode) == this->_Red)

  002e2	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  002e5	50		 push	 eax
  002e6	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
  002eb	83 c4 04	 add	 esp, 4
  002ee	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  002f1	85 c9		 test	 ecx, ecx
  002f3	75 6f		 jne	 SHORT $LN3@Insert@3

; 1697 : 					{	// parent has two red children, blacken both
; 1698 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  002f5	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236677[ebp]
  002f8	50		 push	 eax
  002f9	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  002fe	83 c4 04	 add	 esp, 4
  00301	8b 08		 mov	 ecx, DWORD PTR [eax]
  00303	51		 push	 ecx
  00304	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
  00309	83 c4 04	 add	 esp, 4
  0030c	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1699 : 					this->_Color(_Wherenode) = this->_Black;

  0030f	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00312	50		 push	 eax
  00313	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
  00318	83 c4 04	 add	 esp, 4
  0031b	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1700 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1701 : 						this->_Red;

  0031e	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236677[ebp]
  00321	50		 push	 eax
  00322	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  00327	83 c4 04	 add	 esp, 4
  0032a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0032c	51		 push	 ecx
  0032d	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  00332	83 c4 04	 add	 esp, 4
  00335	8b 10		 mov	 edx, DWORD PTR [eax]
  00337	52		 push	 edx
  00338	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
  0033d	83 c4 04	 add	 esp, 4
  00340	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1702 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  00343	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236677[ebp]
  00346	50		 push	 eax
  00347	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  0034c	83 c4 04	 add	 esp, 4
  0034f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00351	51		 push	 ecx
  00352	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  00357	83 c4 04	 add	 esp, 4
  0035a	8b 10		 mov	 edx, DWORD PTR [eax]
  0035c	89 55 f8	 mov	 DWORD PTR __Pnode$236677[ebp], edx

; 1703 : 					}
; 1704 : 				else

  0035f	e9 9c 00 00 00	 jmp	 $LN4@Insert@3
$LN3@Insert@3:

; 1705 : 					{	// parent has red and black children
; 1706 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))

  00364	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236677[ebp]
  00367	50		 push	 eax
  00368	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  0036d	83 c4 04	 add	 esp, 4
  00370	8b 08		 mov	 ecx, DWORD PTR [eax]
  00372	51		 push	 ecx
  00373	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Left
  00378	83 c4 04	 add	 esp, 4
  0037b	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$236677[ebp]
  0037e	3b 10		 cmp	 edx, DWORD PTR [eax]
  00380	75 1d		 jne	 SHORT $LN1@Insert@3

; 1707 : 						{	// rotate left child to right
; 1708 : 						_Pnode = this->_Parent(_Pnode);

  00382	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236677[ebp]
  00385	50		 push	 eax
  00386	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  0038b	83 c4 04	 add	 esp, 4
  0038e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00390	89 4d f8	 mov	 DWORD PTR __Pnode$236677[ebp], ecx

; 1709 : 						_Rrotate(_Pnode);

  00393	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236677[ebp]
  00396	50		 push	 eax
  00397	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0039a	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Rrotate
$LN1@Insert@3:

; 1710 : 						}
; 1711 : 					this->_Color(this->_Parent(_Pnode)) =
; 1712 : 						this->_Black;	// propagate red up

  0039f	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236677[ebp]
  003a2	50		 push	 eax
  003a3	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  003a8	83 c4 04	 add	 esp, 4
  003ab	8b 08		 mov	 ecx, DWORD PTR [eax]
  003ad	51		 push	 ecx
  003ae	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
  003b3	83 c4 04	 add	 esp, 4
  003b6	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1713 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1714 : 						this->_Red;

  003b9	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236677[ebp]
  003bc	50		 push	 eax
  003bd	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  003c2	83 c4 04	 add	 esp, 4
  003c5	8b 08		 mov	 ecx, DWORD PTR [eax]
  003c7	51		 push	 ecx
  003c8	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  003cd	83 c4 04	 add	 esp, 4
  003d0	8b 10		 mov	 edx, DWORD PTR [eax]
  003d2	52		 push	 edx
  003d3	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
  003d8	83 c4 04	 add	 esp, 4
  003db	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1715 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));

  003de	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236677[ebp]
  003e1	50		 push	 eax
  003e2	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  003e7	83 c4 04	 add	 esp, 4
  003ea	8b 08		 mov	 ecx, DWORD PTR [eax]
  003ec	51		 push	 ecx
  003ed	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  003f2	83 c4 04	 add	 esp, 4
  003f5	8b 10		 mov	 edx, DWORD PTR [eax]
  003f7	52		 push	 edx
  003f8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003fb	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Lrotate
$LN4@Insert@3:

; 1716 : 					}
; 1717 : 				}

  00400	e9 10 fd ff ff	 jmp	 $LN10@Insert@3
$LN9@Insert@3:

; 1718 : 
; 1719 : 		this->_Color(_Root()) = this->_Black;	// root is always black

  00405	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00408	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Root
  0040d	8b 00		 mov	 eax, DWORD PTR [eax]
  0040f	50		 push	 eax
  00410	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
  00415	83 c4 04	 add	 esp, 4
  00418	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1720 : 		return (iterator(_Newnode, this));

  0041b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0041e	50		 push	 eax
  0041f	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00422	51		 push	 ecx
  00423	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00426	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >
  0042b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN19@Insert@3:

; 1721 : 		}

  0042e	5f		 pop	 edi
  0042f	5e		 pop	 esi
  00430	5b		 pop	 ebx
  00431	8b e5		 mov	 esp, ebp
  00433	5d		 pop	 ebp
  00434	c2 10 00	 ret	 16			; 00000010H
?_Insert@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@1@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Insert
_TEXT	ENDS
PUBLIC	??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::operator--
; Function compile flags: /Odtp /ZI
;	COMDAT ??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::operator--, COMDAT
; _this$ = ecx

; 418  : 		{	// predecrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 419  : 		--(*(_Mybase *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::operator--

; 420  : 		return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 421  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::operator--
_TEXT	ENDS
PUBLIC	??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>
PUBLIC	??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > > &>
PUBLIC	??$move@AA_N@std@@YA$$QA_NAA_N@Z		; std::move<bool &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>, COMDAT
; _this$ = ecx

; 227  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$move@AA_N@std@@YA$$QA_NAA_N@Z ; std::move<bool &>
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > > &>
  00022	83 c4 04	 add	 esp, 4
  00025	50		 push	 eax
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>

; 228  : 		}

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>
_TEXT	ENDS
PUBLIC	??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator--
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator--, COMDAT
; _this$ = ecx

; 418  : 		{	// predecrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 419  : 		--(*(_Mybase *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator--

; 420  : 		return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 421  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator--
_TEXT	ENDS
PUBLIC	??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >,bool>
PUBLIC	??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > > &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >,bool>, COMDAT
; _this$ = ecx

; 227  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$move@AA_N@std@@YA$$QA_NAA_N@Z ; std::move<bool &>
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > > &>
  00022	83 c4 04	 add	 esp, 4
  00025	50		 push	 eax
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >,bool>

; 228  : 		}

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >,bool>
_TEXT	ENDS
PUBLIC	??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::operator--
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::operator--, COMDAT
; _this$ = ecx

; 418  : 		{	// predecrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 419  : 		--(*(_Mybase *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::operator--

; 420  : 		return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 421  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::operator--
_TEXT	ENDS
PUBLIC	??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >,bool>
PUBLIC	??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > > &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >,bool>, COMDAT
; _this$ = ecx

; 227  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$move@AA_N@std@@YA$$QA_NAA_N@Z ; std::move<bool &>
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > > &>
  00022	83 c4 04	 add	 esp, 4
  00025	50		 push	 eax
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >,bool>

; 228  : 		}

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >,bool>
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U?$pair@$$CBHH@std@@@std@@QBEIXZ ; std::allocator<std::pair<int const ,int> >::max_size
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::max_size, COMDAT
; _this$ = ecx

; 873  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 874  : 		return (this->_Alval.max_size());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 0d	 add	 ecx, 13			; 0000000dH
  00012	e8 00 00 00 00	 call	 ?max_size@?$allocator@U?$pair@$$CBHH@std@@@std@@QBEIXZ ; std::allocator<std::pair<int const ,int> >::max_size

; 875  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::max_size, COMDAT
; _this$ = ecx

; 873  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 874  : 		return (this->_Alval.max_size());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 0d	 add	 ecx, 13			; 0000000dH
  00012	e8 00 00 00 00	 call	 ?max_size@?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >::max_size

; 875  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::max_size, COMDAT
; _this$ = ecx

; 873  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 874  : 		return (this->_Alval.max_size());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 0d	 add	 ecx, 13			; 0000000dH
  00012	e8 00 00 00 00	 call	 ?max_size@?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >::max_size

; 875  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::max_size
_TEXT	ENDS
PUBLIC	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >,std::_Iterator_base0>::operator--
; Function compile flags: /Odtp /ZI
;	COMDAT ??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::operator--, COMDAT
; _this$ = ecx

; 277  : 		{	// predecrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 278  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 279  : 		if (this->_Getcont() == 0
; 280  : 			|| this->_Ptr == 0)
; 281  : 			{	// report error
; 282  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 283  : 			_SCL_SECURE_OUT_OF_RANGE;
; 284  : 			}
; 285  : 
; 286  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 287  : 		--(*(_Mybase *)this);
; 288  : 		if (_Ptrsav == this->_Ptr)
; 289  : 			{	// report error
; 290  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 291  : 			_SCL_SECURE_OUT_OF_RANGE;
; 292  : 			}
; 293  : 
; 294  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 295  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 296  : 
; 297  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 298  : 		--(*(_Mybase *)this);
; 299  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 300  : 
; 301  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 302  : 		--(*(_Mybase *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >,std::_Iterator_base0>::operator--

; 303  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 304  : 
; 305  : 		return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 306  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >::operator--
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>, COMDAT
; _this$ = ecx

; 145  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > > &>
  00015	83 c4 04	 add	 esp, 4
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	89 0a		 mov	 DWORD PTR [edx], ecx
  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??$move@AA_N@std@@YA$$QA_NAA_N@Z ; std::move<bool &>
  00028	83 c4 04	 add	 esp, 4
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	8a 10		 mov	 dl, BYTE PTR [eax]
  00030	88 51 04	 mov	 BYTE PTR [ecx+4], dl

; 146  : 		}

  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>
_TEXT	ENDS
PUBLIC	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::operator--
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator--, COMDAT
; _this$ = ecx

; 277  : 		{	// predecrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 278  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 279  : 		if (this->_Getcont() == 0
; 280  : 			|| this->_Ptr == 0)
; 281  : 			{	// report error
; 282  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 283  : 			_SCL_SECURE_OUT_OF_RANGE;
; 284  : 			}
; 285  : 
; 286  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 287  : 		--(*(_Mybase *)this);
; 288  : 		if (_Ptrsav == this->_Ptr)
; 289  : 			{	// report error
; 290  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 291  : 			_SCL_SECURE_OUT_OF_RANGE;
; 292  : 			}
; 293  : 
; 294  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 295  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 296  : 
; 297  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 298  : 		--(*(_Mybase *)this);
; 299  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 300  : 
; 301  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 302  : 		--(*(_Mybase *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::operator--

; 303  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 304  : 
; 305  : 		return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 306  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >::operator--
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >,bool>, COMDAT
; _this$ = ecx

; 145  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > > &>
  00015	83 c4 04	 add	 esp, 4
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	89 0a		 mov	 DWORD PTR [edx], ecx
  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??$move@AA_N@std@@YA$$QA_NAA_N@Z ; std::move<bool &>
  00028	83 c4 04	 add	 esp, 4
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	8a 10		 mov	 dl, BYTE PTR [eax]
  00030	88 51 04	 mov	 BYTE PTR [ecx+4], dl

; 146  : 		}

  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >,bool>
_TEXT	ENDS
PUBLIC	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >,std::_Iterator_base0>::operator--
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::operator--, COMDAT
; _this$ = ecx

; 277  : 		{	// predecrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 278  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 279  : 		if (this->_Getcont() == 0
; 280  : 			|| this->_Ptr == 0)
; 281  : 			{	// report error
; 282  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 283  : 			_SCL_SECURE_OUT_OF_RANGE;
; 284  : 			}
; 285  : 
; 286  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 287  : 		--(*(_Mybase *)this);
; 288  : 		if (_Ptrsav == this->_Ptr)
; 289  : 			{	// report error
; 290  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 291  : 			_SCL_SECURE_OUT_OF_RANGE;
; 292  : 			}
; 293  : 
; 294  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 295  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 296  : 
; 297  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 298  : 		--(*(_Mybase *)this);
; 299  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 300  : 
; 301  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 302  : 		--(*(_Mybase *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >,std::_Iterator_base0>::operator--

; 303  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 304  : 
; 305  : 		return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 306  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >::operator--
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >,bool>, COMDAT
; _this$ = ecx

; 145  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > > &>
  00015	83 c4 04	 add	 esp, 4
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	89 0a		 mov	 DWORD PTR [edx], ecx
  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??$move@AA_N@std@@YA$$QA_NAA_N@Z ; std::move<bool &>
  00028	83 c4 04	 add	 esp, 4
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	8a 10		 mov	 dl, BYTE PTR [eax]
  00030	88 51 04	 mov	 BYTE PTR [ecx+4], dl

; 146  : 		}

  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >,bool>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBHH@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -76						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@U?$pair@$$CBHH@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<int const ,int> >::max_size, COMDAT
; _this$ = ecx

; 217  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  0000c	c7 45 f8 ff ff
	ff 1f		 mov	 DWORD PTR __Count$[ebp], 536870911 ; 1fffffffH

; 219  : 		return (0 < _Count ? _Count : 1);

  00013	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00017	76 08		 jbe	 SHORT $LN3@max_size@5
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0001c	89 45 b4	 mov	 DWORD PTR tv65[ebp], eax
  0001f	eb 07		 jmp	 SHORT $LN4@max_size@5
$LN3@max_size@5:
  00021	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$LN4@max_size@5:
  00028	8b 45 b4	 mov	 eax, DWORD PTR tv65[ebp]

; 220  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?max_size@?$allocator@U?$pair@$$CBHH@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<int const ,int> >::max_size
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -76						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >::max_size, COMDAT
; _this$ = ecx

; 217  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  0000c	c7 45 f8 cc cc
	cc 0c		 mov	 DWORD PTR __Count$[ebp], 214748364 ; 0cccccccH

; 219  : 		return (0 < _Count ? _Count : 1);

  00013	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00017	76 08		 jbe	 SHORT $LN3@max_size@6
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0001c	89 45 b4	 mov	 DWORD PTR tv65[ebp], eax
  0001f	eb 07		 jmp	 SHORT $LN4@max_size@6
$LN3@max_size@6:
  00021	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$LN4@max_size@6:
  00028	8b 45 b4	 mov	 eax, DWORD PTR tv65[ebp]

; 220  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?max_size@?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >::max_size
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -76						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >::max_size, COMDAT
; _this$ = ecx

; 217  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  0000c	c7 45 f8 cc cc
	cc 0c		 mov	 DWORD PTR __Count$[ebp], 214748364 ; 0cccccccH

; 219  : 		return (0 < _Count ? _Count : 1);

  00013	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00017	76 08		 jbe	 SHORT $LN3@max_size@7
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0001c	89 45 b4	 mov	 DWORD PTR tv65[ebp], eax
  0001f	eb 07		 jmp	 SHORT $LN4@max_size@7
$LN3@max_size@7:
  00021	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$LN4@max_size@7:
  00028	8b 45 b4	 mov	 eax, DWORD PTR tv65[ebp]

; 220  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?max_size@?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >::max_size
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
__Pnode$236818 = -8					; size = 4
_this$ = -4						; size = 4
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = ecx

; 83   : 		{	// predecrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 84   : 		if (_Mytree::_Isnil(_Ptr))

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Isnil
  00017	83 c4 04	 add	 esp, 4
  0001a	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0001d	85 d2		 test	 edx, edx
  0001f	74 1a		 je	 SHORT $LN8@operator@7

; 85   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b 08		 mov	 ecx, DWORD PTR [eax]
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Right
  0002c	83 c4 04	 add	 esp, 4
  0002f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 02		 mov	 DWORD PTR [edx], eax
  00036	e9 a4 00 00 00	 jmp	 $LN7@operator@7
$LN8@operator@7:

; 86   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00040	51		 push	 ecx
  00041	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Left
  00046	83 c4 04	 add	 esp, 4
  00049	8b 10		 mov	 edx, DWORD PTR [eax]
  0004b	52		 push	 edx
  0004c	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Isnil
  00051	83 c4 04	 add	 esp, 4
  00054	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00057	85 c0		 test	 eax, eax
  00059	75 20		 jne	 SHORT $LN4@operator@7

; 87   : 			_Ptr = _Mytree::_Max(
; 88   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree

  0005b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00060	51		 push	 ecx
  00061	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Left
  00066	83 c4 04	 add	 esp, 4
  00069	8b 10		 mov	 edx, DWORD PTR [eax]
  0006b	52		 push	 edx
  0006c	e8 00 00 00 00	 call	 ?_Max@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Max
  00071	83 c4 04	 add	 esp, 4
  00074	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	89 01		 mov	 DWORD PTR [ecx], eax

; 89   : 		else

  00079	eb 64		 jmp	 SHORT $LN7@operator@7
$LN4@operator@7:

; 90   : 			{	// climb looking for left subtree
; 91   : 			_Nodeptr _Pnode;
; 92   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 93   : 				&& _Ptr == _Mytree::_Left(_Pnode))

  0007b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00080	51		 push	 ecx
  00081	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  00086	83 c4 04	 add	 esp, 4
  00089	8b 10		 mov	 edx, DWORD PTR [eax]
  0008b	89 55 f8	 mov	 DWORD PTR __Pnode$236818[ebp], edx
  0008e	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236818[ebp]
  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Isnil
  00097	83 c4 04	 add	 esp, 4
  0009a	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0009d	85 c9		 test	 ecx, ecx
  0009f	75 1f		 jne	 SHORT $LN3@operator@7
  000a1	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236818[ebp]
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Left
  000aa	83 c4 04	 add	 esp, 4
  000ad	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b0	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b2	3b 10		 cmp	 edx, DWORD PTR [eax]
  000b4	75 0a		 jne	 SHORT $LN3@operator@7

; 94   : 				_Ptr = _Pnode;	// ==> parent while left subtree

  000b6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b9	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$236818[ebp]
  000bc	89 08		 mov	 DWORD PTR [eax], ecx
  000be	eb bb		 jmp	 SHORT $LN4@operator@7
$LN3@operator@7:

; 95   : 			if (_Mytree::_Isnil(_Ptr))

  000c0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c5	51		 push	 ecx
  000c6	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Isnil
  000cb	83 c4 04	 add	 esp, 4
  000ce	0f be 10	 movsx	 edx, BYTE PTR [eax]
  000d1	85 d2		 test	 edx, edx
  000d3	74 02		 je	 SHORT $LN2@operator@7

; 96   : 				;	// begin() shouldn't be decremented, don't move
; 97   : 			else

  000d5	eb 08		 jmp	 SHORT $LN7@operator@7
$LN2@operator@7:

; 98   : 				_Ptr = _Pnode;	// ==> parent if not head

  000d7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000da	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$236818[ebp]
  000dd	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@operator@7:

; 99   : 			}
; 100  : 		return (*this);

  000df	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 101  : 		}

  000e2	5f		 pop	 edi
  000e3	5e		 pop	 esi
  000e4	5b		 pop	 ebx
  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c3		 ret	 0
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >,std::_Iterator_base0>::operator--
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
__Pnode$236830 = -8					; size = 4
_this$ = -4						; size = 4
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = ecx

; 83   : 		{	// predecrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 84   : 		if (_Mytree::_Isnil(_Ptr))

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  00017	83 c4 04	 add	 esp, 4
  0001a	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0001d	85 d2		 test	 edx, edx
  0001f	74 1a		 je	 SHORT $LN8@operator@8

; 85   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b 08		 mov	 ecx, DWORD PTR [eax]
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  0002c	83 c4 04	 add	 esp, 4
  0002f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 02		 mov	 DWORD PTR [edx], eax
  00036	e9 a4 00 00 00	 jmp	 $LN7@operator@8
$LN8@operator@8:

; 86   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00040	51		 push	 ecx
  00041	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  00046	83 c4 04	 add	 esp, 4
  00049	8b 10		 mov	 edx, DWORD PTR [eax]
  0004b	52		 push	 edx
  0004c	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  00051	83 c4 04	 add	 esp, 4
  00054	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00057	85 c0		 test	 eax, eax
  00059	75 20		 jne	 SHORT $LN4@operator@8

; 87   : 			_Ptr = _Mytree::_Max(
; 88   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree

  0005b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00060	51		 push	 ecx
  00061	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  00066	83 c4 04	 add	 esp, 4
  00069	8b 10		 mov	 edx, DWORD PTR [eax]
  0006b	52		 push	 edx
  0006c	e8 00 00 00 00	 call	 ?_Max@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Max
  00071	83 c4 04	 add	 esp, 4
  00074	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	89 01		 mov	 DWORD PTR [ecx], eax

; 89   : 		else

  00079	eb 64		 jmp	 SHORT $LN7@operator@8
$LN4@operator@8:

; 90   : 			{	// climb looking for left subtree
; 91   : 			_Nodeptr _Pnode;
; 92   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 93   : 				&& _Ptr == _Mytree::_Left(_Pnode))

  0007b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00080	51		 push	 ecx
  00081	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  00086	83 c4 04	 add	 esp, 4
  00089	8b 10		 mov	 edx, DWORD PTR [eax]
  0008b	89 55 f8	 mov	 DWORD PTR __Pnode$236830[ebp], edx
  0008e	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236830[ebp]
  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  00097	83 c4 04	 add	 esp, 4
  0009a	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0009d	85 c9		 test	 ecx, ecx
  0009f	75 1f		 jne	 SHORT $LN3@operator@8
  000a1	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236830[ebp]
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  000aa	83 c4 04	 add	 esp, 4
  000ad	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b0	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b2	3b 10		 cmp	 edx, DWORD PTR [eax]
  000b4	75 0a		 jne	 SHORT $LN3@operator@8

; 94   : 				_Ptr = _Pnode;	// ==> parent while left subtree

  000b6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b9	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$236830[ebp]
  000bc	89 08		 mov	 DWORD PTR [eax], ecx
  000be	eb bb		 jmp	 SHORT $LN4@operator@8
$LN3@operator@8:

; 95   : 			if (_Mytree::_Isnil(_Ptr))

  000c0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c5	51		 push	 ecx
  000c6	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  000cb	83 c4 04	 add	 esp, 4
  000ce	0f be 10	 movsx	 edx, BYTE PTR [eax]
  000d1	85 d2		 test	 edx, edx
  000d3	74 02		 je	 SHORT $LN2@operator@8

; 96   : 				;	// begin() shouldn't be decremented, don't move
; 97   : 			else

  000d5	eb 08		 jmp	 SHORT $LN7@operator@8
$LN2@operator@8:

; 98   : 				_Ptr = _Pnode;	// ==> parent if not head

  000d7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000da	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$236830[ebp]
  000dd	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@operator@8:

; 99   : 			}
; 100  : 		return (*this);

  000df	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 101  : 		}

  000e2	5f		 pop	 edi
  000e3	5e		 pop	 esi
  000e4	5b		 pop	 ebx
  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c3		 ret	 0
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >,std::_Iterator_base0>::operator--
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
__Pnode$236842 = -8					; size = 4
_this$ = -4						; size = 4
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = ecx

; 83   : 		{	// predecrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 84   : 		if (_Mytree::_Isnil(_Ptr))

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Isnil
  00017	83 c4 04	 add	 esp, 4
  0001a	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0001d	85 d2		 test	 edx, edx
  0001f	74 1a		 je	 SHORT $LN8@operator@9

; 85   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b 08		 mov	 ecx, DWORD PTR [eax]
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Right
  0002c	83 c4 04	 add	 esp, 4
  0002f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 02		 mov	 DWORD PTR [edx], eax
  00036	e9 a4 00 00 00	 jmp	 $LN7@operator@9
$LN8@operator@9:

; 86   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00040	51		 push	 ecx
  00041	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Left
  00046	83 c4 04	 add	 esp, 4
  00049	8b 10		 mov	 edx, DWORD PTR [eax]
  0004b	52		 push	 edx
  0004c	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Isnil
  00051	83 c4 04	 add	 esp, 4
  00054	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00057	85 c0		 test	 eax, eax
  00059	75 20		 jne	 SHORT $LN4@operator@9

; 87   : 			_Ptr = _Mytree::_Max(
; 88   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree

  0005b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00060	51		 push	 ecx
  00061	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Left
  00066	83 c4 04	 add	 esp, 4
  00069	8b 10		 mov	 edx, DWORD PTR [eax]
  0006b	52		 push	 edx
  0006c	e8 00 00 00 00	 call	 ?_Max@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Max
  00071	83 c4 04	 add	 esp, 4
  00074	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	89 01		 mov	 DWORD PTR [ecx], eax

; 89   : 		else

  00079	eb 64		 jmp	 SHORT $LN7@operator@9
$LN4@operator@9:

; 90   : 			{	// climb looking for left subtree
; 91   : 			_Nodeptr _Pnode;
; 92   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 93   : 				&& _Ptr == _Mytree::_Left(_Pnode))

  0007b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00080	51		 push	 ecx
  00081	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  00086	83 c4 04	 add	 esp, 4
  00089	8b 10		 mov	 edx, DWORD PTR [eax]
  0008b	89 55 f8	 mov	 DWORD PTR __Pnode$236842[ebp], edx
  0008e	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236842[ebp]
  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Isnil
  00097	83 c4 04	 add	 esp, 4
  0009a	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0009d	85 c9		 test	 ecx, ecx
  0009f	75 1f		 jne	 SHORT $LN3@operator@9
  000a1	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$236842[ebp]
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Left
  000aa	83 c4 04	 add	 esp, 4
  000ad	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b0	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b2	3b 10		 cmp	 edx, DWORD PTR [eax]
  000b4	75 0a		 jne	 SHORT $LN3@operator@9

; 94   : 				_Ptr = _Pnode;	// ==> parent while left subtree

  000b6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b9	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$236842[ebp]
  000bc	89 08		 mov	 DWORD PTR [eax], ecx
  000be	eb bb		 jmp	 SHORT $LN4@operator@9
$LN3@operator@9:

; 95   : 			if (_Mytree::_Isnil(_Ptr))

  000c0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c5	51		 push	 ecx
  000c6	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Isnil
  000cb	83 c4 04	 add	 esp, 4
  000ce	0f be 10	 movsx	 edx, BYTE PTR [eax]
  000d1	85 d2		 test	 edx, edx
  000d3	74 02		 je	 SHORT $LN2@operator@9

; 96   : 				;	// begin() shouldn't be decremented, don't move
; 97   : 			else

  000d5	eb 08		 jmp	 SHORT $LN7@operator@9
$LN2@operator@9:

; 98   : 				_Ptr = _Pnode;	// ==> parent if not head

  000d7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000da	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$236842[ebp]
  000dd	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@operator@9:

; 99   : 			}
; 100  : 		return (*this);

  000df	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 101  : 		}

  000e2	5f		 pop	 edi
  000e3	5e		 pop	 esi
  000e4	5b		 pop	 ebx
  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c3		 ret	 0
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >,std::_Iterator_base0>::operator--
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$?0AAHAAH@?$_Pair_base@HH@std@@QAE@AAH0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAHAAH@?$_Pair_base@HH@std@@QAE@AAH0@Z PROC	; std::_Pair_base<int,int>::_Pair_base<int,int><int &,int &>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>
  00015	83 c4 04	 add	 esp, 4
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 10		 mov	 edx, DWORD PTR [eax]
  0001d	89 11		 mov	 DWORD PTR [ecx], edx
  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>
  00028	83 c4 04	 add	 esp, 4
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	8b 10		 mov	 edx, DWORD PTR [eax]
  00030	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 164  : 		}

  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
??$?0AAHAAH@?$_Pair_base@HH@std@@QAE@AAH0@Z ENDP	; std::_Pair_base<int,int>::_Pair_base<int,int><int &,int &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@AAH@std@@YAAAHAAH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAH@std@@YAAAHAAH@Z PROC			; std::forward<int &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAH@std@@YAAAHAAH@Z ENDP			; std::forward<int &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@U?$pair@HH@std@@@std@@YA$$QAU?$pair@HH@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$pair@HH@std@@@std@@YA$$QAU?$pair@HH@0@AAU10@@Z PROC ; std::forward<std::pair<int,int> >, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@U?$pair@HH@std@@@std@@YA$$QAU?$pair@HH@0@AAU10@@Z ENDP ; std::forward<std::pair<int,int> >
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@U?$pair@$$CBHH@std@@@std@@U?$pair@$$CBHH@2@U?$pair@HH@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHH@std@@@0@PAU?$pair@$$CBHH@0@$$QAU?$pair@HH@0@@Z ; std::_Cons_val<std::allocator<std::pair<int const ,int> >,std::pair<int const ,int>,std::pair<int,int> >
PUBLIC	?_Buynode@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xtree
xdata$x	SEGMENT
__catchsym$??$_Buynode@U?$pair@HH@std@@@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@$$QAU?$pair@HH@1@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Buynode@U?$pair@HH@std@@@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@$$QAU?$pair@HH@1@@Z$0
__unwindtable$??$_Buynode@U?$pair@HH@std@@@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@$$QAU?$pair@HH@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Buynode@U?$pair@HH@std@@@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@$$QAU?$pair@HH@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Buynode@U?$pair@HH@std@@@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@$$QAU?$pair@HH@1@@Z$2
__ehfuncinfo$??$_Buynode@U?$pair@HH@std@@@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@$$QAU?$pair@HH@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Buynode@U?$pair@HH@std@@@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@$$QAU?$pair@HH@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Buynode@U?$pair@HH@std@@@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@$$QAU?$pair@HH@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Buynode@U?$pair@HH@std@@@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@$$QAU?$pair@HH@1@@Z
_TEXT	SEGMENT
tv93 = -100						; size = 4
tv92 = -96						; size = 4
tv91 = -92						; size = 4
__Wherenode$ = -24					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Val$ = 8						; size = 4
??$_Buynode@U?$pair@HH@std@@@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@$$QAU?$pair@HH@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode<std::pair<int,int> >, COMDAT
; _this$ = ecx

; 586  : 		_Nodeptr _Buynode(_Valty&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Buynode@U?$pair@HH@std@@@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@$$QAU?$pair@HH@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 54	 sub	 esp, 84			; 00000054H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 587  : 		{	// allocate a node with defaults
; 588  : 		_Nodeptr _Wherenode = _Buynode();

  0002f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?_Buynode@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode
  00037	89 45 e8	 mov	 DWORD PTR __Wherenode$[ebp], eax

; 589  : 
; 590  : 		_TRY_BEGIN

  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 591  : 		_Cons_val(this->_Alval, _STD addressof(this->_Myval(_Wherenode)),
; 592  : 			_STD forward<_Valty>(_Val));

  00041	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 ??$forward@U?$pair@HH@std@@@std@@YA$$QAU?$pair@HH@0@AAU10@@Z ; std::forward<std::pair<int,int> >
  0004a	83 c4 04	 add	 esp, 4
  0004d	89 45 a4	 mov	 DWORD PTR tv91[ebp], eax
  00050	8b 4d e8	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00053	51		 push	 ecx
  00054	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Myval
  00059	83 c4 04	 add	 esp, 4
  0005c	89 45 a0	 mov	 DWORD PTR tv92[ebp], eax
  0005f	8b 55 a0	 mov	 edx, DWORD PTR tv92[ebp]
  00062	52		 push	 edx
  00063	e8 00 00 00 00	 call	 ??$addressof@U?$pair@$$CBHH@std@@@std@@YAPAU?$pair@$$CBHH@0@AAU10@@Z ; std::addressof<std::pair<int const ,int> >
  00068	83 c4 04	 add	 esp, 4
  0006b	89 45 9c	 mov	 DWORD PTR tv93[ebp], eax
  0006e	8b 45 a4	 mov	 eax, DWORD PTR tv91[ebp]
  00071	50		 push	 eax
  00072	8b 4d 9c	 mov	 ecx, DWORD PTR tv93[ebp]
  00075	51		 push	 ecx
  00076	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00079	83 c2 0d	 add	 edx, 13			; 0000000dH
  0007c	52		 push	 edx
  0007d	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@U?$pair@$$CBHH@std@@@std@@U?$pair@$$CBHH@2@U?$pair@HH@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHH@std@@@0@PAU?$pair@$$CBHH@0@$$QAU?$pair@HH@0@@Z ; std::_Cons_val<std::allocator<std::pair<int const ,int> >,std::pair<int const ,int>,std::pair<int,int> >
  00082	83 c4 0c	 add	 esp, 12			; 0000000cH
  00085	eb 27		 jmp	 SHORT $LN4@Buynode
__catch$??$_Buynode@U?$pair@HH@std@@@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@$$QAU?$pair@HH@1@@Z$0:

; 593  : 		_CATCH_ALL
; 594  : 		this->_Alnod.deallocate(_Wherenode, 1);

  00087	6a 01		 push	 1
  00089	8b 45 e8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0008c	50		 push	 eax
  0008d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00090	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00093	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::deallocate

; 595  : 		_RERAISE;

  00098	6a 00		 push	 0
  0009a	6a 00		 push	 0
  0009c	e8 00 00 00 00	 call	 __CxxThrowException@8

; 596  : 		_CATCH_END

  000a1	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000a8	b8 00 00 00 00	 mov	 eax, __tryend$??$_Buynode@U?$pair@HH@std@@@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@$$QAU?$pair@HH@1@@Z$1
  000ad	c3		 ret	 0
$LN4@Buynode:
  000ae	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Buynode@U?$pair@HH@std@@@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@$$QAU?$pair@HH@1@@Z$1:

; 597  : 
; 598  : 		return (_Wherenode);

  000b5	8b 45 e8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
$LN3@Buynode:

; 599  : 		}

  000b8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000bb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c2	59		 pop	 ecx
  000c3	5f		 pop	 edi
  000c4	5e		 pop	 esi
  000c5	5b		 pop	 ebx
  000c6	8b e5		 mov	 esp, ebp
  000c8	5d		 pop	 ebp
  000c9	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Buynode@U?$pair@HH@std@@@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@$$QAU?$pair@HH@1@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a 98	 mov	 ecx, DWORD PTR [edx-104]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Buynode@U?$pair@HH@std@@@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@$$QAU?$pair@HH@1@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Buynode@U?$pair@HH@std@@@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@1@$$QAU?$pair@HH@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode<std::pair<int,int> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@AAV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@YAAAV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@YAAAV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@0@AAV10@@Z PROC ; std::forward<std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@YAAAV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > &>
_TEXT	ENDS
PUBLIC	??0?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@ABV01@@Z ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >
; Function compile flags: /Odtp /ZI
;	COMDAT ??$?0AAHAAV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@?$_Pair_base@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@AAHAAV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAHAAV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@?$_Pair_base@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@AAHAAV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@1@@Z PROC ; std::_Pair_base<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::_Pair_base<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > ><int &,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > &>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>
  00015	83 c4 04	 add	 esp, 4
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 10		 mov	 edx, DWORD PTR [eax]
  0001d	89 11		 mov	 DWORD PTR [ecx], edx
  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??$forward@AAV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@YAAAV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@0@AAV10@@Z ; std::forward<std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > &>
  00028	83 c4 04	 add	 esp, 4
  0002b	50		 push	 eax
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	83 c1 04	 add	 ecx, 4
  00032	e8 00 00 00 00	 call	 ??0?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@ABV01@@Z ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >

; 164  : 		}

  00037	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c2 08 00	 ret	 8
??$?0AAHAAV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@?$_Pair_base@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@AAHAAV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@1@@Z ENDP ; std::_Pair_base<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::_Pair_base<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > ><int &,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@YA$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@YA$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@AAU10@@Z PROC ; std::forward<std::pair<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@YA$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@AAU10@@Z ENDP ; std::forward<std::pair<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@0@PAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@@Z ; std::_Cons_val<std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >,std::pair<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >
PUBLIC	?_Buynode@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Buynode
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xtree
xdata$x	SEGMENT
__catchsym$??$_Buynode@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Buynode@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z$0
__unwindtable$??$_Buynode@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Buynode@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Buynode@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z$2
__ehfuncinfo$??$_Buynode@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Buynode@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Buynode@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Buynode@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
tv93 = -100						; size = 4
tv92 = -96						; size = 4
tv91 = -92						; size = 4
__Wherenode$ = -24					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Val$ = 8						; size = 4
??$_Buynode@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Buynode<std::pair<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >, COMDAT
; _this$ = ecx

; 586  : 		_Nodeptr _Buynode(_Valty&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Buynode@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 54	 sub	 esp, 84			; 00000054H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 587  : 		{	// allocate a node with defaults
; 588  : 		_Nodeptr _Wherenode = _Buynode();

  0002f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?_Buynode@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Buynode
  00037	89 45 e8	 mov	 DWORD PTR __Wherenode$[ebp], eax

; 589  : 
; 590  : 		_TRY_BEGIN

  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 591  : 		_Cons_val(this->_Alval, _STD addressof(this->_Myval(_Wherenode)),
; 592  : 			_STD forward<_Valty>(_Val));

  00041	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 ??$forward@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@YA$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@AAU10@@Z ; std::forward<std::pair<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >
  0004a	83 c4 04	 add	 esp, 4
  0004d	89 45 a4	 mov	 DWORD PTR tv91[ebp], eax
  00050	8b 4d e8	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00053	51		 push	 ecx
  00054	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Myval
  00059	83 c4 04	 add	 esp, 4
  0005c	89 45 a0	 mov	 DWORD PTR tv92[ebp], eax
  0005f	8b 55 a0	 mov	 edx, DWORD PTR tv92[ebp]
  00062	52		 push	 edx
  00063	e8 00 00 00 00	 call	 ??$addressof@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@YAPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@AAU10@@Z ; std::addressof<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >
  00068	83 c4 04	 add	 esp, 4
  0006b	89 45 9c	 mov	 DWORD PTR tv93[ebp], eax
  0006e	8b 45 a4	 mov	 eax, DWORD PTR tv91[ebp]
  00071	50		 push	 eax
  00072	8b 4d 9c	 mov	 ecx, DWORD PTR tv93[ebp]
  00075	51		 push	 ecx
  00076	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00079	83 c2 0d	 add	 edx, 13			; 0000000dH
  0007c	52		 push	 edx
  0007d	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@0@PAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@@Z ; std::_Cons_val<std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >,std::pair<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >
  00082	83 c4 0c	 add	 esp, 12			; 0000000cH
  00085	eb 27		 jmp	 SHORT $LN4@Buynode@2
__catch$??$_Buynode@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z$0:

; 593  : 		_CATCH_ALL
; 594  : 		this->_Alnod.deallocate(_Wherenode, 1);

  00087	6a 01		 push	 1
  00089	8b 45 e8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0008c	50		 push	 eax
  0008d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00090	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00093	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Node>::deallocate

; 595  : 		_RERAISE;

  00098	6a 00		 push	 0
  0009a	6a 00		 push	 0
  0009c	e8 00 00 00 00	 call	 __CxxThrowException@8

; 596  : 		_CATCH_END

  000a1	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000a8	b8 00 00 00 00	 mov	 eax, __tryend$??$_Buynode@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z$1
  000ad	c3		 ret	 0
$LN4@Buynode@2:
  000ae	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Buynode@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z$1:

; 597  : 
; 598  : 		return (_Wherenode);

  000b5	8b 45 e8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
$LN3@Buynode@2:

; 599  : 		}

  000b8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000bb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c2	59		 pop	 ecx
  000c3	5f		 pop	 edi
  000c4	5e		 pop	 esi
  000c5	5b		 pop	 ebx
  000c6	8b e5		 mov	 esp, ebp
  000c8	5d		 pop	 ebp
  000c9	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Buynode@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a 98	 mov	 ecx, DWORD PTR [edx-104]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Buynode@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Buynode@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Buynode<std::pair<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@AAV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@YAAAV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@YAAAV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@0@AAV10@@Z PROC ; std::forward<std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@YAAAV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > &>
_TEXT	ENDS
PUBLIC	??0?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@ABV01@@Z ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >
; Function compile flags: /Odtp /ZI
;	COMDAT ??$?0AAHAAV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@?$_Pair_base@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@AAHAAV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAHAAV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@?$_Pair_base@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@AAHAAV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@1@@Z PROC ; std::_Pair_base<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::_Pair_base<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > ><int &,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > &>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>
  00015	83 c4 04	 add	 esp, 4
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 10		 mov	 edx, DWORD PTR [eax]
  0001d	89 11		 mov	 DWORD PTR [ecx], edx
  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??$forward@AAV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@YAAAV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@0@AAV10@@Z ; std::forward<std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > &>
  00028	83 c4 04	 add	 esp, 4
  0002b	50		 push	 eax
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	83 c1 04	 add	 ecx, 4
  00032	e8 00 00 00 00	 call	 ??0?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@ABV01@@Z ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >

; 164  : 		}

  00037	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c2 08 00	 ret	 8
??$?0AAHAAV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@?$_Pair_base@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@AAHAAV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@1@@Z ENDP ; std::_Pair_base<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::_Pair_base<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > ><int &,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@YA$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@YA$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@AAU10@@Z PROC ; std::forward<std::pair<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@YA$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@AAU10@@Z ENDP ; std::forward<std::pair<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@0@PAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@@Z ; std::_Cons_val<std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >,std::pair<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >
PUBLIC	?_Buynode@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Buynode
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xtree
xdata$x	SEGMENT
__catchsym$??$_Buynode@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Buynode@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z$0
__unwindtable$??$_Buynode@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Buynode@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Buynode@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z$2
__ehfuncinfo$??$_Buynode@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Buynode@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Buynode@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Buynode@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
tv93 = -100						; size = 4
tv92 = -96						; size = 4
tv91 = -92						; size = 4
__Wherenode$ = -24					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Val$ = 8						; size = 4
??$_Buynode@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Buynode<std::pair<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >, COMDAT
; _this$ = ecx

; 586  : 		_Nodeptr _Buynode(_Valty&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Buynode@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 54	 sub	 esp, 84			; 00000054H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 587  : 		{	// allocate a node with defaults
; 588  : 		_Nodeptr _Wherenode = _Buynode();

  0002f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?_Buynode@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Buynode
  00037	89 45 e8	 mov	 DWORD PTR __Wherenode$[ebp], eax

; 589  : 
; 590  : 		_TRY_BEGIN

  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 591  : 		_Cons_val(this->_Alval, _STD addressof(this->_Myval(_Wherenode)),
; 592  : 			_STD forward<_Valty>(_Val));

  00041	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 ??$forward@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@YA$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@AAU10@@Z ; std::forward<std::pair<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >
  0004a	83 c4 04	 add	 esp, 4
  0004d	89 45 a4	 mov	 DWORD PTR tv91[ebp], eax
  00050	8b 4d e8	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00053	51		 push	 ecx
  00054	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Myval
  00059	83 c4 04	 add	 esp, 4
  0005c	89 45 a0	 mov	 DWORD PTR tv92[ebp], eax
  0005f	8b 55 a0	 mov	 edx, DWORD PTR tv92[ebp]
  00062	52		 push	 edx
  00063	e8 00 00 00 00	 call	 ??$addressof@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@YAPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@AAU10@@Z ; std::addressof<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >
  00068	83 c4 04	 add	 esp, 4
  0006b	89 45 9c	 mov	 DWORD PTR tv93[ebp], eax
  0006e	8b 45 a4	 mov	 eax, DWORD PTR tv91[ebp]
  00071	50		 push	 eax
  00072	8b 4d 9c	 mov	 ecx, DWORD PTR tv93[ebp]
  00075	51		 push	 ecx
  00076	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00079	83 c2 0d	 add	 edx, 13			; 0000000dH
  0007c	52		 push	 edx
  0007d	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@0@PAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@@Z ; std::_Cons_val<std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >,std::pair<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >
  00082	83 c4 0c	 add	 esp, 12			; 0000000cH
  00085	eb 27		 jmp	 SHORT $LN4@Buynode@3
__catch$??$_Buynode@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z$0:

; 593  : 		_CATCH_ALL
; 594  : 		this->_Alnod.deallocate(_Wherenode, 1);

  00087	6a 01		 push	 1
  00089	8b 45 e8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0008c	50		 push	 eax
  0008d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00090	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00093	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Node>::deallocate

; 595  : 		_RERAISE;

  00098	6a 00		 push	 0
  0009a	6a 00		 push	 0
  0009c	e8 00 00 00 00	 call	 __CxxThrowException@8

; 596  : 		_CATCH_END

  000a1	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000a8	b8 00 00 00 00	 mov	 eax, __tryend$??$_Buynode@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z$1
  000ad	c3		 ret	 0
$LN4@Buynode@3:
  000ae	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Buynode@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z$1:

; 597  : 
; 598  : 		return (_Wherenode);

  000b5	8b 45 e8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
$LN3@Buynode@3:

; 599  : 		}

  000b8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000bb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c2	59		 pop	 ecx
  000c3	5f		 pop	 edi
  000c4	5e		 pop	 esi
  000c5	5b		 pop	 ebx
  000c6	8b e5		 mov	 esp, ebp
  000c8	5d		 pop	 ebp
  000c9	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Buynode@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a 98	 mov	 ecx, DWORD PTR [edx-104]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Buynode@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Buynode@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Buynode<std::pair<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$_Move@AAD@std@@YA$$QADAAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$_Move@AAD@std@@YA$$QADAAD@Z PROC			; std::_Move<char &>, COMDAT

; 94   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 95   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 96   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Move@AAD@std@@YA$$QADAAD@Z ENDP			; std::_Move<char &>
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??2@YAPAXIPAX@Z					; operator new
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$construct@AAH@?$allocator@H@std@@QAEXPAHAAH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@AAH@?$allocator@H@std@@QAEXPAHAAH@Z$0
__ehfuncinfo$??$construct@AAH@?$allocator@H@std@@QAEXPAHAAH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@AAH@?$allocator@H@std@@QAEXPAHAAH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$construct@AAH@?$allocator@H@std@@QAEXPAHAAH@Z
_TEXT	SEGMENT
tv73 = -92						; size = 4
$T240011 = -88						; size = 4
$T240012 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAH@?$allocator@H@std@@QAEXPAHAAH@Z PROC	; std::allocator<int>::construct<int &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@AAH@?$allocator@H@std@@QAEXPAHAAH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 04		 push	 4
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T240012[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T240012[ebp], 0
  00047	74 1b		 je	 SHORT $LN3@construct
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>
  00052	83 c4 04	 add	 esp, 4
  00055	8b 55 ac	 mov	 edx, DWORD PTR $T240012[ebp]
  00058	8b 00		 mov	 eax, DWORD PTR [eax]
  0005a	89 02		 mov	 DWORD PTR [edx], eax
  0005c	8b 4d ac	 mov	 ecx, DWORD PTR $T240012[ebp]
  0005f	89 4d a4	 mov	 DWORD PTR tv73[ebp], ecx
  00062	eb 07		 jmp	 SHORT $LN4@construct
$LN3@construct:
  00064	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
$LN4@construct:
  0006b	8b 55 a4	 mov	 edx, DWORD PTR tv73[ebp]
  0006e	89 55 a8	 mov	 DWORD PTR $T240011[ebp], edx
  00071	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 209  : 		}

  00078	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00082	59		 pop	 ecx
  00083	5f		 pop	 edi
  00084	5e		 pop	 esi
  00085	5b		 pop	 ebx
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@AAH@?$allocator@H@std@@QAEXPAHAAH@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T240012[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@AAH@?$allocator@H@std@@QAEXPAHAAH@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@AAH@?$allocator@H@std@@QAEXPAHAAH@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@AAH@?$allocator@H@std@@QAEXPAHAAH@Z ENDP	; std::allocator<int>::construct<int &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 81   :         {return (_Where); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 83   :         {return; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@ABH@std@@YAABHABH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABH@std@@YAABHABH@Z PROC			; std::forward<int const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@ABH@std@@YAABHABH@Z ENDP			; std::forward<int const &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@AAUCASTLEDEEP_EVENTTIME@@@std@@YAAAUCASTLEDEEP_EVENTTIME@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUCASTLEDEEP_EVENTTIME@@@std@@YAAAUCASTLEDEEP_EVENTTIME@@AAU1@@Z PROC ; std::forward<CASTLEDEEP_EVENTTIME &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAUCASTLEDEEP_EVENTTIME@@@std@@YAAAUCASTLEDEEP_EVENTTIME@@AAU1@@Z ENDP ; std::forward<CASTLEDEEP_EVENTTIME &>
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$construct@AAUCASTLEDEEP_EVENTTIME@@@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAEXPAUCASTLEDEEP_EVENTTIME@@AAU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@AAUCASTLEDEEP_EVENTTIME@@@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAEXPAUCASTLEDEEP_EVENTTIME@@AAU2@@Z$0
__ehfuncinfo$??$construct@AAUCASTLEDEEP_EVENTTIME@@@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAEXPAUCASTLEDEEP_EVENTTIME@@AAU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@AAUCASTLEDEEP_EVENTTIME@@@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAEXPAUCASTLEDEEP_EVENTTIME@@AAU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$construct@AAUCASTLEDEEP_EVENTTIME@@@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAEXPAUCASTLEDEEP_EVENTTIME@@AAU2@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T240032 = -88						; size = 4
$T240033 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAUCASTLEDEEP_EVENTTIME@@@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAEXPAUCASTLEDEEP_EVENTTIME@@AAU2@@Z PROC ; std::allocator<CASTLEDEEP_EVENTTIME>::construct<CASTLEDEEP_EVENTTIME &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@AAUCASTLEDEEP_EVENTTIME@@@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAEXPAUCASTLEDEEP_EVENTTIME@@AAU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 08		 push	 8
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T240033[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T240033[ebp], 0
  00047	74 21		 je	 SHORT $LN3@construct@2
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@AAUCASTLEDEEP_EVENTTIME@@@std@@YAAAUCASTLEDEEP_EVENTTIME@@AAU1@@Z ; std::forward<CASTLEDEEP_EVENTTIME &>
  00052	83 c4 04	 add	 esp, 4
  00055	8b 10		 mov	 edx, DWORD PTR [eax]
  00057	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005a	8b 4d ac	 mov	 ecx, DWORD PTR $T240033[ebp]
  0005d	89 11		 mov	 DWORD PTR [ecx], edx
  0005f	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00062	8b 55 ac	 mov	 edx, DWORD PTR $T240033[ebp]
  00065	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  00068	eb 07		 jmp	 SHORT $LN4@construct@2
$LN3@construct@2:
  0006a	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct@2:
  00071	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00074	89 45 a8	 mov	 DWORD PTR $T240032[ebp], eax
  00077	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 209  : 		}

  0007e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00081	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00088	59		 pop	 ecx
  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@AAUCASTLEDEEP_EVENTTIME@@@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAEXPAUCASTLEDEEP_EVENTTIME@@AAU2@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T240033[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@AAUCASTLEDEEP_EVENTTIME@@@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAEXPAUCASTLEDEEP_EVENTTIME@@AAU2@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@AAUCASTLEDEEP_EVENTTIME@@@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAEXPAUCASTLEDEEP_EVENTTIME@@AAU2@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@AAUCASTLEDEEP_EVENTTIME@@@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAEXPAUCASTLEDEEP_EVENTTIME@@AAU2@@Z ENDP ; std::allocator<CASTLEDEEP_EVENTTIME>::construct<CASTLEDEEP_EVENTTIME &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@ABUCASTLEDEEP_EVENTTIME@@@std@@YAABUCASTLEDEEP_EVENTTIME@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUCASTLEDEEP_EVENTTIME@@@std@@YAABUCASTLEDEEP_EVENTTIME@@ABU1@@Z PROC ; std::forward<CASTLEDEEP_EVENTTIME const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@ABUCASTLEDEEP_EVENTTIME@@@std@@YAABUCASTLEDEEP_EVENTTIME@@ABU1@@Z ENDP ; std::forward<CASTLEDEEP_EVENTTIME const &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@AAUCASTLEDEEP_SPAWNTIME@@@std@@YAAAUCASTLEDEEP_SPAWNTIME@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUCASTLEDEEP_SPAWNTIME@@@std@@YAAAUCASTLEDEEP_SPAWNTIME@@AAU1@@Z PROC ; std::forward<CASTLEDEEP_SPAWNTIME &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAUCASTLEDEEP_SPAWNTIME@@@std@@YAAAUCASTLEDEEP_SPAWNTIME@@AAU1@@Z ENDP ; std::forward<CASTLEDEEP_SPAWNTIME &>
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$construct@AAUCASTLEDEEP_SPAWNTIME@@@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEXPAUCASTLEDEEP_SPAWNTIME@@AAU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@AAUCASTLEDEEP_SPAWNTIME@@@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEXPAUCASTLEDEEP_SPAWNTIME@@AAU2@@Z$0
__ehfuncinfo$??$construct@AAUCASTLEDEEP_SPAWNTIME@@@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEXPAUCASTLEDEEP_SPAWNTIME@@AAU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@AAUCASTLEDEEP_SPAWNTIME@@@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEXPAUCASTLEDEEP_SPAWNTIME@@AAU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$construct@AAUCASTLEDEEP_SPAWNTIME@@@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEXPAUCASTLEDEEP_SPAWNTIME@@AAU2@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T240049 = -88						; size = 4
$T240050 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAUCASTLEDEEP_SPAWNTIME@@@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEXPAUCASTLEDEEP_SPAWNTIME@@AAU2@@Z PROC ; std::allocator<CASTLEDEEP_SPAWNTIME>::construct<CASTLEDEEP_SPAWNTIME &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@AAUCASTLEDEEP_SPAWNTIME@@@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEXPAUCASTLEDEEP_SPAWNTIME@@AAU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 08		 push	 8
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T240050[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T240050[ebp], 0
  00047	74 21		 je	 SHORT $LN3@construct@3
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@AAUCASTLEDEEP_SPAWNTIME@@@std@@YAAAUCASTLEDEEP_SPAWNTIME@@AAU1@@Z ; std::forward<CASTLEDEEP_SPAWNTIME &>
  00052	83 c4 04	 add	 esp, 4
  00055	8b 10		 mov	 edx, DWORD PTR [eax]
  00057	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005a	8b 4d ac	 mov	 ecx, DWORD PTR $T240050[ebp]
  0005d	89 11		 mov	 DWORD PTR [ecx], edx
  0005f	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00062	8b 55 ac	 mov	 edx, DWORD PTR $T240050[ebp]
  00065	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  00068	eb 07		 jmp	 SHORT $LN4@construct@3
$LN3@construct@3:
  0006a	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct@3:
  00071	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00074	89 45 a8	 mov	 DWORD PTR $T240049[ebp], eax
  00077	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 209  : 		}

  0007e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00081	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00088	59		 pop	 ecx
  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@AAUCASTLEDEEP_SPAWNTIME@@@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEXPAUCASTLEDEEP_SPAWNTIME@@AAU2@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T240050[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@AAUCASTLEDEEP_SPAWNTIME@@@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEXPAUCASTLEDEEP_SPAWNTIME@@AAU2@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@AAUCASTLEDEEP_SPAWNTIME@@@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEXPAUCASTLEDEEP_SPAWNTIME@@AAU2@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@AAUCASTLEDEEP_SPAWNTIME@@@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEXPAUCASTLEDEEP_SPAWNTIME@@AAU2@@Z ENDP ; std::allocator<CASTLEDEEP_SPAWNTIME>::construct<CASTLEDEEP_SPAWNTIME &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@ABUCASTLEDEEP_SPAWNTIME@@@std@@YAABUCASTLEDEEP_SPAWNTIME@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUCASTLEDEEP_SPAWNTIME@@@std@@YAABUCASTLEDEEP_SPAWNTIME@@ABU1@@Z PROC ; std::forward<CASTLEDEEP_SPAWNTIME const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@ABUCASTLEDEEP_SPAWNTIME@@@std@@YAABUCASTLEDEEP_SPAWNTIME@@ABU1@@Z ENDP ; std::forward<CASTLEDEEP_SPAWNTIME const &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@AAUCASTLEDEEP_MONSTERINFO@@@std@@YAAAUCASTLEDEEP_MONSTERINFO@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUCASTLEDEEP_MONSTERINFO@@@std@@YAAAUCASTLEDEEP_MONSTERINFO@@AAU1@@Z PROC ; std::forward<CASTLEDEEP_MONSTERINFO &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAUCASTLEDEEP_MONSTERINFO@@@std@@YAAAUCASTLEDEEP_MONSTERINFO@@AAU1@@Z ENDP ; std::forward<CASTLEDEEP_MONSTERINFO &>
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$construct@AAUCASTLEDEEP_MONSTERINFO@@@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEXPAUCASTLEDEEP_MONSTERINFO@@AAU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@AAUCASTLEDEEP_MONSTERINFO@@@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEXPAUCASTLEDEEP_MONSTERINFO@@AAU2@@Z$0
__ehfuncinfo$??$construct@AAUCASTLEDEEP_MONSTERINFO@@@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEXPAUCASTLEDEEP_MONSTERINFO@@AAU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@AAUCASTLEDEEP_MONSTERINFO@@@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEXPAUCASTLEDEEP_MONSTERINFO@@AAU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$construct@AAUCASTLEDEEP_MONSTERINFO@@@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEXPAUCASTLEDEEP_MONSTERINFO@@AAU2@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T240066 = -88						; size = 4
$T240067 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAUCASTLEDEEP_MONSTERINFO@@@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEXPAUCASTLEDEEP_MONSTERINFO@@AAU2@@Z PROC ; std::allocator<CASTLEDEEP_MONSTERINFO>::construct<CASTLEDEEP_MONSTERINFO &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@AAUCASTLEDEEP_MONSTERINFO@@@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEXPAUCASTLEDEEP_MONSTERINFO@@AAU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 1c		 push	 28			; 0000001cH
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T240067[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T240067[ebp], 0
  00047	74 20		 je	 SHORT $LN3@construct@4
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@AAUCASTLEDEEP_MONSTERINFO@@@std@@YAAAUCASTLEDEEP_MONSTERINFO@@AAU1@@Z ; std::forward<CASTLEDEEP_MONSTERINFO &>
  00052	83 c4 04	 add	 esp, 4
  00055	b9 07 00 00 00	 mov	 ecx, 7
  0005a	8b f0		 mov	 esi, eax
  0005c	8b 7d ac	 mov	 edi, DWORD PTR $T240067[ebp]
  0005f	f3 a5		 rep movsd
  00061	8b 55 ac	 mov	 edx, DWORD PTR $T240067[ebp]
  00064	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  00067	eb 07		 jmp	 SHORT $LN4@construct@4
$LN3@construct@4:
  00069	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct@4:
  00070	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00073	89 45 a8	 mov	 DWORD PTR $T240066[ebp], eax
  00076	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 209  : 		}

  0007d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00080	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00087	59		 pop	 ecx
  00088	5f		 pop	 edi
  00089	5e		 pop	 esi
  0008a	5b		 pop	 ebx
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@AAUCASTLEDEEP_MONSTERINFO@@@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEXPAUCASTLEDEEP_MONSTERINFO@@AAU2@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T240067[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@AAUCASTLEDEEP_MONSTERINFO@@@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEXPAUCASTLEDEEP_MONSTERINFO@@AAU2@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@AAUCASTLEDEEP_MONSTERINFO@@@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEXPAUCASTLEDEEP_MONSTERINFO@@AAU2@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@AAUCASTLEDEEP_MONSTERINFO@@@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEXPAUCASTLEDEEP_MONSTERINFO@@AAU2@@Z ENDP ; std::allocator<CASTLEDEEP_MONSTERINFO>::construct<CASTLEDEEP_MONSTERINFO &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@ABUCASTLEDEEP_MONSTERINFO@@@std@@YAABUCASTLEDEEP_MONSTERINFO@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUCASTLEDEEP_MONSTERINFO@@@std@@YAABUCASTLEDEEP_MONSTERINFO@@ABU1@@Z PROC ; std::forward<CASTLEDEEP_MONSTERINFO const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@ABUCASTLEDEEP_MONSTERINFO@@@std@@YAABUCASTLEDEEP_MONSTERINFO@@ABU1@@Z ENDP ; std::forward<CASTLEDEEP_MONSTERINFO const &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z PROC ; std::_Ptr_cat<int,int>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00009	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z ENDP ; std::_Ptr_cat<int,int>
_TEXT	ENDS
EXTRN	_memmove:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Move@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<int *,int *>, COMDAT

; 2522 : 	{	// move [_First, _Last) to [_Dest, ...), pointers to scalars

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2523 : 	ptrdiff_t _Count = _Last - _First;

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000f	c1 f8 02	 sar	 eax, 2
  00012	89 45 fc	 mov	 DWORD PTR __Count$[ebp], eax

; 2524 : 	_CSTD memmove(&*_Dest, &*_First,
; 2525 : 		_Count * sizeof (*_First));

  00015	8b 45 fc	 mov	 eax, DWORD PTR __Count$[ebp]
  00018	c1 e0 02	 shl	 eax, 2
  0001b	50		 push	 eax
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00023	52		 push	 edx
  00024	e8 00 00 00 00	 call	 _memmove
  00029	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2526 : 	return (_Dest + _Count);

  0002c	8b 45 fc	 mov	 eax, DWORD PTR __Count$[ebp]
  0002f	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00032	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 2527 : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Move@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<int *,int *>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@UCASTLEDEEP_EVENTTIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUCASTLEDEEP_EVENTTIME@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UCASTLEDEEP_EVENTTIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUCASTLEDEEP_EVENTTIME@@0@Z PROC ; std::_Ptr_cat<CASTLEDEEP_EVENTTIME,CASTLEDEEP_EVENTTIME>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00009	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Ptr_cat@UCASTLEDEEP_EVENTTIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUCASTLEDEEP_EVENTTIME@@0@Z ENDP ; std::_Ptr_cat<CASTLEDEEP_EVENTTIME,CASTLEDEEP_EVENTTIME>
_TEXT	ENDS
PUBLIC	??$move@AAUCASTLEDEEP_EVENTTIME@@@std@@YA$$QAUCASTLEDEEP_EVENTTIME@@AAU1@@Z ; std::move<CASTLEDEEP_EVENTTIME &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Move@PAUCASTLEDEEP_EVENTTIME@@PAU1@@std@@YAPAUCASTLEDEEP_EVENTTIME@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAUCASTLEDEEP_EVENTTIME@@PAU1@@std@@YAPAUCASTLEDEEP_EVENTTIME@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<CASTLEDEEP_EVENTTIME *,CASTLEDEEP_EVENTTIME *>, COMDAT

; 2512 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2513 : 	for (; _First != _Last; ++_Dest, ++_First)

  00009	eb 12		 jmp	 SHORT $LN3@Move
$LN2@Move:
  0000b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000e	83 c0 08	 add	 eax, 8
  00011	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00017	83 c1 08	 add	 ecx, 8
  0001a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN3@Move:
  0001d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00020	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00023	74 1b		 je	 SHORT $LN1@Move

; 2514 : 		*_Dest = _STD move(*_First);

  00025	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??$move@AAUCASTLEDEEP_EVENTTIME@@@std@@YA$$QAUCASTLEDEEP_EVENTTIME@@AAU1@@Z ; std::move<CASTLEDEEP_EVENTTIME &>
  0002e	83 c4 04	 add	 esp, 4
  00031	8b 08		 mov	 ecx, DWORD PTR [eax]
  00033	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00036	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00039	89 08		 mov	 DWORD PTR [eax], ecx
  0003b	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0003e	eb cb		 jmp	 SHORT $LN2@Move
$LN1@Move:

; 2515 : 	return (_Dest);

  00040	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 2516 : 	}

  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
??$_Move@PAUCASTLEDEEP_EVENTTIME@@PAU1@@std@@YAPAUCASTLEDEEP_EVENTTIME@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<CASTLEDEEP_EVENTTIME *,CASTLEDEEP_EVENTTIME *>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@HHH@std@@YAPAHPAH00AAV?$allocator@H@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<int,int,int>
PUBLIC	??$_Val_type@PAH@std@@YAPAHPAH@Z		; std::_Val_type<int *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_move@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z
_TEXT	SEGMENT
$T240089 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z PROC ; std::_Uninitialized_move<int *,int *,std::allocator<int> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z ; std::_Ptr_cat<int,int>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T240089[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T240089[ebp]
  00020	52		 push	 edx
  00021	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??$_Val_type@PAH@std@@YAPAHPAH@Z ; std::_Val_type<int *>
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00031	51		 push	 ecx
  00032	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00035	52		 push	 edx
  00036	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 ??$_Uninit_move@HHH@std@@YAPAHPAH00AAV?$allocator@H@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<int,int,int>
  00043	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
??$_Uninitialized_move@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z ENDP ; std::_Uninitialized_move<int *,int *,std::allocator<int> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 104  : 	{	// destroy [_First, _Last), scalar type (do nothing)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 105  : 	}

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUCASTLEDEEP_EVENTTIME@@PAU1@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@U1@@std@@YAPAUCASTLEDEEP_EVENTTIME@@PAU1@00AAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CASTLEDEEP_EVENTTIME *,CASTLEDEEP_EVENTTIME *,std::allocator<CASTLEDEEP_EVENTTIME>,CASTLEDEEP_EVENTTIME>
PUBLIC	??$_Val_type@PAUCASTLEDEEP_EVENTTIME@@@std@@YAPAUCASTLEDEEP_EVENTTIME@@PAU1@@Z ; std::_Val_type<CASTLEDEEP_EVENTTIME *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_move@PAUCASTLEDEEP_EVENTTIME@@PAU1@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@YAPAUCASTLEDEEP_EVENTTIME@@PAU1@00AAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@@Z
_TEXT	SEGMENT
$T240094 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUCASTLEDEEP_EVENTTIME@@PAU1@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@YAPAUCASTLEDEEP_EVENTTIME@@PAU1@00AAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@@Z PROC ; std::_Uninitialized_move<CASTLEDEEP_EVENTTIME *,CASTLEDEEP_EVENTTIME *,std::allocator<CASTLEDEEP_EVENTTIME> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UCASTLEDEEP_EVENTTIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUCASTLEDEEP_EVENTTIME@@0@Z ; std::_Ptr_cat<CASTLEDEEP_EVENTTIME,CASTLEDEEP_EVENTTIME>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T240094[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T240094[ebp]
  00020	52		 push	 edx
  00021	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??$_Val_type@PAUCASTLEDEEP_EVENTTIME@@@std@@YAPAUCASTLEDEEP_EVENTTIME@@PAU1@@Z ; std::_Val_type<CASTLEDEEP_EVENTTIME *>
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00031	51		 push	 ecx
  00032	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00035	52		 push	 edx
  00036	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUCASTLEDEEP_EVENTTIME@@PAU1@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@U1@@std@@YAPAUCASTLEDEEP_EVENTTIME@@PAU1@00AAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CASTLEDEEP_EVENTTIME *,CASTLEDEEP_EVENTTIME *,std::allocator<CASTLEDEEP_EVENTTIME>,CASTLEDEEP_EVENTTIME>
  00043	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
??$_Uninitialized_move@PAUCASTLEDEEP_EVENTTIME@@PAU1@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@YAPAUCASTLEDEEP_EVENTTIME@@PAU1@00AAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@@Z ENDP ; std::_Uninitialized_move<CASTLEDEEP_EVENTTIME *,CASTLEDEEP_EVENTTIME *,std::allocator<CASTLEDEEP_EVENTTIME> >
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@UCASTLEDEEP_EVENTTIME@@@std@@YAXAAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@PAUCASTLEDEEP_EVENTTIME@@@Z ; std::_Dest_val<std::allocator<CASTLEDEEP_EVENTTIME>,CASTLEDEEP_EVENTTIME>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@YAXPAUCASTLEDEEP_EVENTTIME@@0AAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@YAXPAUCASTLEDEEP_EVENTTIME@@0AAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CASTLEDEEP_EVENTTIME> >, COMDAT

; 95   : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 96   : 	for (; _First != _Last; ++_First)

  00009	eb 09		 jmp	 SHORT $LN3@Destroy_ra
$LN2@Destroy_ra:
  0000b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000e	83 c0 08	 add	 eax, 8
  00011	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra:
  00014	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00017	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0001a	74 12		 je	 SHORT $LN4@Destroy_ra

; 97   : 		_Dest_val(_Al, _First);

  0001c	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@UCASTLEDEEP_EVENTTIME@@@std@@YAXAAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@PAUCASTLEDEEP_EVENTTIME@@@Z ; std::_Dest_val<std::allocator<CASTLEDEEP_EVENTTIME>,CASTLEDEEP_EVENTTIME>
  00029	83 c4 08	 add	 esp, 8
  0002c	eb dd		 jmp	 SHORT $LN2@Destroy_ra
$LN4@Destroy_ra:

; 98   : 	}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$_Destroy_range@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@@std@@YAXPAUCASTLEDEEP_EVENTTIME@@0AAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CASTLEDEEP_EVENTTIME> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUCASTLEDEEP_SPAWNTIME@@PAU1@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@U1@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@PAU1@00AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CASTLEDEEP_SPAWNTIME *,CASTLEDEEP_SPAWNTIME *,std::allocator<CASTLEDEEP_SPAWNTIME>,CASTLEDEEP_SPAWNTIME>
PUBLIC	??$_Val_type@PAUCASTLEDEEP_SPAWNTIME@@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@PAU1@@Z ; std::_Val_type<CASTLEDEEP_SPAWNTIME *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_move@PAUCASTLEDEEP_SPAWNTIME@@PAU1@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@PAU1@00AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@@Z
_TEXT	SEGMENT
$T240099 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUCASTLEDEEP_SPAWNTIME@@PAU1@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@PAU1@00AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@@Z PROC ; std::_Uninitialized_move<CASTLEDEEP_SPAWNTIME *,CASTLEDEEP_SPAWNTIME *,std::allocator<CASTLEDEEP_SPAWNTIME> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UCASTLEDEEP_SPAWNTIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUCASTLEDEEP_SPAWNTIME@@0@Z ; std::_Ptr_cat<CASTLEDEEP_SPAWNTIME,CASTLEDEEP_SPAWNTIME>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T240099[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T240099[ebp]
  00020	52		 push	 edx
  00021	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??$_Val_type@PAUCASTLEDEEP_SPAWNTIME@@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@PAU1@@Z ; std::_Val_type<CASTLEDEEP_SPAWNTIME *>
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00031	51		 push	 ecx
  00032	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00035	52		 push	 edx
  00036	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUCASTLEDEEP_SPAWNTIME@@PAU1@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@U1@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@PAU1@00AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CASTLEDEEP_SPAWNTIME *,CASTLEDEEP_SPAWNTIME *,std::allocator<CASTLEDEEP_SPAWNTIME>,CASTLEDEEP_SPAWNTIME>
  00043	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
??$_Uninitialized_move@PAUCASTLEDEEP_SPAWNTIME@@PAU1@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@PAU1@00AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@@Z ENDP ; std::_Uninitialized_move<CASTLEDEEP_SPAWNTIME *,CASTLEDEEP_SPAWNTIME *,std::allocator<CASTLEDEEP_SPAWNTIME> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@UCASTLEDEEP_SPAWNTIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUCASTLEDEEP_SPAWNTIME@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UCASTLEDEEP_SPAWNTIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUCASTLEDEEP_SPAWNTIME@@0@Z PROC ; std::_Ptr_cat<CASTLEDEEP_SPAWNTIME,CASTLEDEEP_SPAWNTIME>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00009	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Ptr_cat@UCASTLEDEEP_SPAWNTIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUCASTLEDEEP_SPAWNTIME@@0@Z ENDP ; std::_Ptr_cat<CASTLEDEEP_SPAWNTIME,CASTLEDEEP_SPAWNTIME>
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@UCASTLEDEEP_SPAWNTIME@@@std@@YAXAAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@PAUCASTLEDEEP_SPAWNTIME@@@Z ; std::_Dest_val<std::allocator<CASTLEDEEP_SPAWNTIME>,CASTLEDEEP_SPAWNTIME>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@YAXPAUCASTLEDEEP_SPAWNTIME@@0AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@YAXPAUCASTLEDEEP_SPAWNTIME@@0AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CASTLEDEEP_SPAWNTIME> >, COMDAT

; 95   : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 96   : 	for (; _First != _Last; ++_First)

  00009	eb 09		 jmp	 SHORT $LN3@Destroy_ra@2
$LN2@Destroy_ra@2:
  0000b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000e	83 c0 08	 add	 eax, 8
  00011	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra@2:
  00014	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00017	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0001a	74 12		 je	 SHORT $LN4@Destroy_ra@2

; 97   : 		_Dest_val(_Al, _First);

  0001c	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@UCASTLEDEEP_SPAWNTIME@@@std@@YAXAAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@PAUCASTLEDEEP_SPAWNTIME@@@Z ; std::_Dest_val<std::allocator<CASTLEDEEP_SPAWNTIME>,CASTLEDEEP_SPAWNTIME>
  00029	83 c4 08	 add	 esp, 8
  0002c	eb dd		 jmp	 SHORT $LN2@Destroy_ra@2
$LN4@Destroy_ra@2:

; 98   : 	}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$_Destroy_range@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@YAXPAUCASTLEDEEP_SPAWNTIME@@0AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CASTLEDEEP_SPAWNTIME> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUCASTLEDEEP_MONSTERINFO@@PAU1@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@U1@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@PAU1@00AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CASTLEDEEP_MONSTERINFO *,CASTLEDEEP_MONSTERINFO *,std::allocator<CASTLEDEEP_MONSTERINFO>,CASTLEDEEP_MONSTERINFO>
PUBLIC	??$_Val_type@PAUCASTLEDEEP_MONSTERINFO@@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@PAU1@@Z ; std::_Val_type<CASTLEDEEP_MONSTERINFO *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_move@PAUCASTLEDEEP_MONSTERINFO@@PAU1@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@PAU1@00AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@@Z
_TEXT	SEGMENT
$T240106 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUCASTLEDEEP_MONSTERINFO@@PAU1@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@PAU1@00AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@@Z PROC ; std::_Uninitialized_move<CASTLEDEEP_MONSTERINFO *,CASTLEDEEP_MONSTERINFO *,std::allocator<CASTLEDEEP_MONSTERINFO> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UCASTLEDEEP_MONSTERINFO@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUCASTLEDEEP_MONSTERINFO@@0@Z ; std::_Ptr_cat<CASTLEDEEP_MONSTERINFO,CASTLEDEEP_MONSTERINFO>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T240106[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T240106[ebp]
  00020	52		 push	 edx
  00021	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??$_Val_type@PAUCASTLEDEEP_MONSTERINFO@@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@PAU1@@Z ; std::_Val_type<CASTLEDEEP_MONSTERINFO *>
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00031	51		 push	 ecx
  00032	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00035	52		 push	 edx
  00036	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUCASTLEDEEP_MONSTERINFO@@PAU1@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@U1@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@PAU1@00AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CASTLEDEEP_MONSTERINFO *,CASTLEDEEP_MONSTERINFO *,std::allocator<CASTLEDEEP_MONSTERINFO>,CASTLEDEEP_MONSTERINFO>
  00043	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
??$_Uninitialized_move@PAUCASTLEDEEP_MONSTERINFO@@PAU1@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@PAU1@00AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@@Z ENDP ; std::_Uninitialized_move<CASTLEDEEP_MONSTERINFO *,CASTLEDEEP_MONSTERINFO *,std::allocator<CASTLEDEEP_MONSTERINFO> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@UCASTLEDEEP_MONSTERINFO@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUCASTLEDEEP_MONSTERINFO@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UCASTLEDEEP_MONSTERINFO@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUCASTLEDEEP_MONSTERINFO@@0@Z PROC ; std::_Ptr_cat<CASTLEDEEP_MONSTERINFO,CASTLEDEEP_MONSTERINFO>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00009	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Ptr_cat@UCASTLEDEEP_MONSTERINFO@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUCASTLEDEEP_MONSTERINFO@@0@Z ENDP ; std::_Ptr_cat<CASTLEDEEP_MONSTERINFO,CASTLEDEEP_MONSTERINFO>
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@UCASTLEDEEP_MONSTERINFO@@@std@@YAXAAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@PAUCASTLEDEEP_MONSTERINFO@@@Z ; std::_Dest_val<std::allocator<CASTLEDEEP_MONSTERINFO>,CASTLEDEEP_MONSTERINFO>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@YAXPAUCASTLEDEEP_MONSTERINFO@@0AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@YAXPAUCASTLEDEEP_MONSTERINFO@@0AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CASTLEDEEP_MONSTERINFO> >, COMDAT

; 95   : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 96   : 	for (; _First != _Last; ++_First)

  00009	eb 09		 jmp	 SHORT $LN3@Destroy_ra@3
$LN2@Destroy_ra@3:
  0000b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000e	83 c0 1c	 add	 eax, 28			; 0000001cH
  00011	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra@3:
  00014	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00017	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0001a	74 12		 je	 SHORT $LN4@Destroy_ra@3

; 97   : 		_Dest_val(_Al, _First);

  0001c	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@UCASTLEDEEP_MONSTERINFO@@@std@@YAXAAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@PAUCASTLEDEEP_MONSTERINFO@@@Z ; std::_Dest_val<std::allocator<CASTLEDEEP_MONSTERINFO>,CASTLEDEEP_MONSTERINFO>
  00029	83 c4 08	 add	 esp, 8
  0002c	eb dd		 jmp	 SHORT $LN2@Destroy_ra@3
$LN4@Destroy_ra@3:

; 98   : 	}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$_Destroy_range@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@YAXPAUCASTLEDEEP_MONSTERINFO@@0AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CASTLEDEEP_MONSTERINFO> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\map
_TEXT	ENDS
;	COMDAT ??$_Kfn@$$CBHH@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHH@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Kfn@$$CBHH@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHH@1@@Z PROC ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Kfn<int const ,int>, COMDAT

; 66   : 		static const _Kty& _Kfn(const _STD pair<_Ty1, _Ty2>& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 67   : 		{	// extract key from element value
; 68   : 		return (_Val.first);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 69   : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Kfn@$$CBHH@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHH@1@@Z ENDP ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Kfn<int const ,int>
_TEXT	ENDS
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > > &,bool>
PUBLIC	??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > > &>
PUBLIC	??$forward@_N@std@@YA$$QA_NAA_N@Z		; std::forward<bool>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > > &,bool>, COMDAT
; _this$ = ecx

; 247  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$forward@_N@std@@YA$$QA_NAA_N@Z ; std::forward<bool>
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > > &>
  00022	83 c4 04	 add	 esp, 4
  00025	50		 push	 eax
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > > &,bool>

; 248  : 		}

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > > &,bool>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy@U?$pair@$$CBHH@std@@@std@@YAXPAU?$pair@$$CBHH@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U?$pair@$$CBHH@std@@@std@@YAXPAU?$pair@$$CBHH@0@@Z PROC ; std::_Destroy<std::pair<int const ,int> >, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Destroy@U?$pair@$$CBHH@std@@@std@@YAXPAU?$pair@$$CBHH@0@@Z ENDP ; std::_Destroy<std::pair<int const ,int> >
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Construct@HABH@std@@YAXPAHABH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@HABH@std@@YAXPAHABH@Z$0
__ehfuncinfo$??$_Construct@HABH@std@@YAXPAHABH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@HABH@std@@YAXPAHABH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Construct@HABH@std@@YAXPAHABH@Z
_TEXT	SEGMENT
tv73 = -92						; size = 4
$T240119 = -88						; size = 4
$T240120 = -84						; size = 4
__Vptr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@HABH@std@@YAXPAHABH@Z PROC		; std::_Construct<int,int const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Construct@HABH@std@@YAXPAHABH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 47   : 	void _FARQ *_Vptr = _Ptr;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002b	89 45 f0	 mov	 DWORD PTR __Vptr$[ebp], eax

; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  0002e	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00031	50		 push	 eax
  00032	6a 04		 push	 4
  00034	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00039	83 c4 08	 add	 esp, 8
  0003c	89 45 ac	 mov	 DWORD PTR $T240120[ebp], eax
  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00046	83 7d ac 00	 cmp	 DWORD PTR $T240120[ebp], 0
  0004a	74 1b		 je	 SHORT $LN3@Construct
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ??$forward@ABH@std@@YAABHABH@Z ; std::forward<int const &>
  00055	83 c4 04	 add	 esp, 4
  00058	8b 55 ac	 mov	 edx, DWORD PTR $T240120[ebp]
  0005b	8b 00		 mov	 eax, DWORD PTR [eax]
  0005d	89 02		 mov	 DWORD PTR [edx], eax
  0005f	8b 4d ac	 mov	 ecx, DWORD PTR $T240120[ebp]
  00062	89 4d a4	 mov	 DWORD PTR tv73[ebp], ecx
  00065	eb 07		 jmp	 SHORT $LN4@Construct
$LN3@Construct:
  00067	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
$LN4@Construct:
  0006e	8b 55 a4	 mov	 edx, DWORD PTR tv73[ebp]
  00071	89 55 a8	 mov	 DWORD PTR $T240119[ebp], edx
  00074	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 49   : 	}

  0007b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00085	59		 pop	 ecx
  00086	5f		 pop	 edi
  00087	5e		 pop	 esi
  00088	5b		 pop	 ebx
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@HABH@std@@YAXPAHABH@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T240120[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Construct@HABH@std@@YAXPAHABH@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Construct@HABH@std@@YAXPAHABH@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Construct@HABH@std@@YAXPAHABH@Z ENDP		; std::_Construct<int,int const &>
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > > &,bool>
PUBLIC	??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > > &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > > &,bool>, COMDAT
; _this$ = ecx

; 247  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$forward@_N@std@@YA$$QA_NAA_N@Z ; std::forward<bool>
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > > &>
  00022	83 c4 04	 add	 esp, 4
  00025	50		 push	 eax
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > > &,bool>

; 248  : 		}

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > > &,bool>
_TEXT	ENDS
PUBLIC	??_G?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAEPAXI@Z ; std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::`scalar deleting destructor'
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@YAXPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@YAXPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@@Z PROC ; std::_Destroy<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 63   : 	_Ptr->~_Ty();

  00009	6a 00		 push	 0
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000e	e8 00 00 00 00	 call	 ??_G?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAEPAXI@Z

; 64   : 	}

  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??$_Destroy@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@YAXPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@@Z ENDP ; std::_Destroy<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >
_TEXT	ENDS
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > > &,bool>
PUBLIC	??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > > &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > > &,bool>, COMDAT
; _this$ = ecx

; 247  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$forward@_N@std@@YA$$QA_NAA_N@Z ; std::forward<bool>
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > > &>
  00022	83 c4 04	 add	 esp, 4
  00025	50		 push	 eax
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > > &,bool>

; 248  : 		}

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > > &,bool>
_TEXT	ENDS
PUBLIC	??_G?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAEPAXI@Z ; std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::`scalar deleting destructor'
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@YAXPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@YAXPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@@Z PROC ; std::_Destroy<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 63   : 	_Ptr->~_Ty();

  00009	6a 00		 push	 0
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000e	e8 00 00 00 00	 call	 ??_G?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAEPAXI@Z

; 64   : 	}

  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??$_Destroy@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@YAXPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@@Z ENDP ; std::_Destroy<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Construct@UCASTLEDEEP_EVENTTIME@@ABU1@@std@@YAXPAUCASTLEDEEP_EVENTTIME@@ABU1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@UCASTLEDEEP_EVENTTIME@@ABU1@@std@@YAXPAUCASTLEDEEP_EVENTTIME@@ABU1@@Z$0
__ehfuncinfo$??$_Construct@UCASTLEDEEP_EVENTTIME@@ABU1@@std@@YAXPAUCASTLEDEEP_EVENTTIME@@ABU1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@UCASTLEDEEP_EVENTTIME@@ABU1@@std@@YAXPAUCASTLEDEEP_EVENTTIME@@ABU1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Construct@UCASTLEDEEP_EVENTTIME@@ABU1@@std@@YAXPAUCASTLEDEEP_EVENTTIME@@ABU1@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T240140 = -88						; size = 4
$T240141 = -84						; size = 4
__Vptr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UCASTLEDEEP_EVENTTIME@@ABU1@@std@@YAXPAUCASTLEDEEP_EVENTTIME@@ABU1@@Z PROC ; std::_Construct<CASTLEDEEP_EVENTTIME,CASTLEDEEP_EVENTTIME const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Construct@UCASTLEDEEP_EVENTTIME@@ABU1@@std@@YAXPAUCASTLEDEEP_EVENTTIME@@ABU1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 47   : 	void _FARQ *_Vptr = _Ptr;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002b	89 45 f0	 mov	 DWORD PTR __Vptr$[ebp], eax

; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  0002e	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00031	50		 push	 eax
  00032	6a 08		 push	 8
  00034	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00039	83 c4 08	 add	 esp, 8
  0003c	89 45 ac	 mov	 DWORD PTR $T240141[ebp], eax
  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00046	83 7d ac 00	 cmp	 DWORD PTR $T240141[ebp], 0
  0004a	74 21		 je	 SHORT $LN3@Construct@2
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ??$forward@ABUCASTLEDEEP_EVENTTIME@@@std@@YAABUCASTLEDEEP_EVENTTIME@@ABU1@@Z ; std::forward<CASTLEDEEP_EVENTTIME const &>
  00055	83 c4 04	 add	 esp, 4
  00058	8b 10		 mov	 edx, DWORD PTR [eax]
  0005a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005d	8b 4d ac	 mov	 ecx, DWORD PTR $T240141[ebp]
  00060	89 11		 mov	 DWORD PTR [ecx], edx
  00062	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00065	8b 55 ac	 mov	 edx, DWORD PTR $T240141[ebp]
  00068	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  0006b	eb 07		 jmp	 SHORT $LN4@Construct@2
$LN3@Construct@2:
  0006d	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@Construct@2:
  00074	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00077	89 45 a8	 mov	 DWORD PTR $T240140[ebp], eax
  0007a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 49   : 	}

  00081	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00084	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008b	59		 pop	 ecx
  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi
  0008e	5b		 pop	 ebx
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@UCASTLEDEEP_EVENTTIME@@ABU1@@std@@YAXPAUCASTLEDEEP_EVENTTIME@@ABU1@@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T240141[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Construct@UCASTLEDEEP_EVENTTIME@@ABU1@@std@@YAXPAUCASTLEDEEP_EVENTTIME@@ABU1@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Construct@UCASTLEDEEP_EVENTTIME@@ABU1@@std@@YAXPAUCASTLEDEEP_EVENTTIME@@ABU1@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Construct@UCASTLEDEEP_EVENTTIME@@ABU1@@std@@YAXPAUCASTLEDEEP_EVENTTIME@@ABU1@@Z ENDP ; std::_Construct<CASTLEDEEP_EVENTTIME,CASTLEDEEP_EVENTTIME const &>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Construct@UCASTLEDEEP_SPAWNTIME@@ABU1@@std@@YAXPAUCASTLEDEEP_SPAWNTIME@@ABU1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@UCASTLEDEEP_SPAWNTIME@@ABU1@@std@@YAXPAUCASTLEDEEP_SPAWNTIME@@ABU1@@Z$0
__ehfuncinfo$??$_Construct@UCASTLEDEEP_SPAWNTIME@@ABU1@@std@@YAXPAUCASTLEDEEP_SPAWNTIME@@ABU1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@UCASTLEDEEP_SPAWNTIME@@ABU1@@std@@YAXPAUCASTLEDEEP_SPAWNTIME@@ABU1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Construct@UCASTLEDEEP_SPAWNTIME@@ABU1@@std@@YAXPAUCASTLEDEEP_SPAWNTIME@@ABU1@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T240153 = -88						; size = 4
$T240154 = -84						; size = 4
__Vptr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UCASTLEDEEP_SPAWNTIME@@ABU1@@std@@YAXPAUCASTLEDEEP_SPAWNTIME@@ABU1@@Z PROC ; std::_Construct<CASTLEDEEP_SPAWNTIME,CASTLEDEEP_SPAWNTIME const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Construct@UCASTLEDEEP_SPAWNTIME@@ABU1@@std@@YAXPAUCASTLEDEEP_SPAWNTIME@@ABU1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 47   : 	void _FARQ *_Vptr = _Ptr;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002b	89 45 f0	 mov	 DWORD PTR __Vptr$[ebp], eax

; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  0002e	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00031	50		 push	 eax
  00032	6a 08		 push	 8
  00034	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00039	83 c4 08	 add	 esp, 8
  0003c	89 45 ac	 mov	 DWORD PTR $T240154[ebp], eax
  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00046	83 7d ac 00	 cmp	 DWORD PTR $T240154[ebp], 0
  0004a	74 21		 je	 SHORT $LN3@Construct@3
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ??$forward@ABUCASTLEDEEP_SPAWNTIME@@@std@@YAABUCASTLEDEEP_SPAWNTIME@@ABU1@@Z ; std::forward<CASTLEDEEP_SPAWNTIME const &>
  00055	83 c4 04	 add	 esp, 4
  00058	8b 10		 mov	 edx, DWORD PTR [eax]
  0005a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005d	8b 4d ac	 mov	 ecx, DWORD PTR $T240154[ebp]
  00060	89 11		 mov	 DWORD PTR [ecx], edx
  00062	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00065	8b 55 ac	 mov	 edx, DWORD PTR $T240154[ebp]
  00068	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  0006b	eb 07		 jmp	 SHORT $LN4@Construct@3
$LN3@Construct@3:
  0006d	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@Construct@3:
  00074	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00077	89 45 a8	 mov	 DWORD PTR $T240153[ebp], eax
  0007a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 49   : 	}

  00081	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00084	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008b	59		 pop	 ecx
  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi
  0008e	5b		 pop	 ebx
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@UCASTLEDEEP_SPAWNTIME@@ABU1@@std@@YAXPAUCASTLEDEEP_SPAWNTIME@@ABU1@@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T240154[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Construct@UCASTLEDEEP_SPAWNTIME@@ABU1@@std@@YAXPAUCASTLEDEEP_SPAWNTIME@@ABU1@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Construct@UCASTLEDEEP_SPAWNTIME@@ABU1@@std@@YAXPAUCASTLEDEEP_SPAWNTIME@@ABU1@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Construct@UCASTLEDEEP_SPAWNTIME@@ABU1@@std@@YAXPAUCASTLEDEEP_SPAWNTIME@@ABU1@@Z ENDP ; std::_Construct<CASTLEDEEP_SPAWNTIME,CASTLEDEEP_SPAWNTIME const &>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Construct@UCASTLEDEEP_MONSTERINFO@@ABU1@@std@@YAXPAUCASTLEDEEP_MONSTERINFO@@ABU1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@UCASTLEDEEP_MONSTERINFO@@ABU1@@std@@YAXPAUCASTLEDEEP_MONSTERINFO@@ABU1@@Z$0
__ehfuncinfo$??$_Construct@UCASTLEDEEP_MONSTERINFO@@ABU1@@std@@YAXPAUCASTLEDEEP_MONSTERINFO@@ABU1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@UCASTLEDEEP_MONSTERINFO@@ABU1@@std@@YAXPAUCASTLEDEEP_MONSTERINFO@@ABU1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Construct@UCASTLEDEEP_MONSTERINFO@@ABU1@@std@@YAXPAUCASTLEDEEP_MONSTERINFO@@ABU1@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T240166 = -88						; size = 4
$T240167 = -84						; size = 4
__Vptr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UCASTLEDEEP_MONSTERINFO@@ABU1@@std@@YAXPAUCASTLEDEEP_MONSTERINFO@@ABU1@@Z PROC ; std::_Construct<CASTLEDEEP_MONSTERINFO,CASTLEDEEP_MONSTERINFO const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Construct@UCASTLEDEEP_MONSTERINFO@@ABU1@@std@@YAXPAUCASTLEDEEP_MONSTERINFO@@ABU1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 47   : 	void _FARQ *_Vptr = _Ptr;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002b	89 45 f0	 mov	 DWORD PTR __Vptr$[ebp], eax

; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  0002e	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00031	50		 push	 eax
  00032	6a 1c		 push	 28			; 0000001cH
  00034	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00039	83 c4 08	 add	 esp, 8
  0003c	89 45 ac	 mov	 DWORD PTR $T240167[ebp], eax
  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00046	83 7d ac 00	 cmp	 DWORD PTR $T240167[ebp], 0
  0004a	74 20		 je	 SHORT $LN3@Construct@4
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ??$forward@ABUCASTLEDEEP_MONSTERINFO@@@std@@YAABUCASTLEDEEP_MONSTERINFO@@ABU1@@Z ; std::forward<CASTLEDEEP_MONSTERINFO const &>
  00055	83 c4 04	 add	 esp, 4
  00058	b9 07 00 00 00	 mov	 ecx, 7
  0005d	8b f0		 mov	 esi, eax
  0005f	8b 7d ac	 mov	 edi, DWORD PTR $T240167[ebp]
  00062	f3 a5		 rep movsd
  00064	8b 55 ac	 mov	 edx, DWORD PTR $T240167[ebp]
  00067	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  0006a	eb 07		 jmp	 SHORT $LN4@Construct@4
$LN3@Construct@4:
  0006c	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@Construct@4:
  00073	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00076	89 45 a8	 mov	 DWORD PTR $T240166[ebp], eax
  00079	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 49   : 	}

  00080	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00083	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008a	59		 pop	 ecx
  0008b	5f		 pop	 edi
  0008c	5e		 pop	 esi
  0008d	5b		 pop	 ebx
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@UCASTLEDEEP_MONSTERINFO@@ABU1@@std@@YAXPAUCASTLEDEEP_MONSTERINFO@@ABU1@@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T240167[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Construct@UCASTLEDEEP_MONSTERINFO@@ABU1@@std@@YAXPAUCASTLEDEEP_MONSTERINFO@@ABU1@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Construct@UCASTLEDEEP_MONSTERINFO@@ABU1@@std@@YAXPAUCASTLEDEEP_MONSTERINFO@@ABU1@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Construct@UCASTLEDEEP_MONSTERINFO@@ABU1@@std@@YAXPAUCASTLEDEEP_MONSTERINFO@@ABU1@@Z ENDP ; std::_Construct<CASTLEDEEP_MONSTERINFO,CASTLEDEEP_MONSTERINFO const &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z PROC ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > > &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z ENDP ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > > &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$move@AA_N@std@@YA$$QA_NAA_N@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AA_N@std@@YA$$QA_NAA_N@Z PROC			; std::move<bool &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$move@AA_N@std@@YA$$QA_NAA_N@Z ENDP			; std::move<bool &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z PROC ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > > &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z ENDP ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > > &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z PROC ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > > &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z ENDP ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > > &>
_TEXT	ENDS
PUBLIC	??1?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@XZ ; std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::~pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ??_G?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAEPAXI@Z PROC ; std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@XZ
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar@2
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar@2:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_G?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAEPAXI@Z ENDP ; std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@XZ ; std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::~pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ??_G?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAEPAXI@Z PROC ; std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@XZ
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar@3
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar@3:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_G?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAEPAXI@Z ENDP ; std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1?$_Pair_base@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@XZ ; std::_Pair_base<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::~_Pair_base<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ??1?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@XZ PROC ; std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::~pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1?$_Pair_base@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@XZ
  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@XZ ENDP ; std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::~pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >
_TEXT	ENDS
PUBLIC	??1?$_Pair_base@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@XZ ; std::_Pair_base<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::~_Pair_base<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ??1?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@XZ PROC ; std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::~pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1?$_Pair_base@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@XZ
  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@XZ ENDP ; std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::~pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??1?$_Pair_base@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Pair_base@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Pair_base<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::~_Pair_base<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 04	 add	 ecx, 4
  00012	e8 00 00 00 00	 call	 ??1?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@XZ ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::~vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >
  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??1?$_Pair_base@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Pair_base<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::~_Pair_base<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??1?$_Pair_base@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Pair_base@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Pair_base<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::~_Pair_base<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 04	 add	 ecx, 4
  00012	e8 00 00 00 00	 call	 ??1?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@XZ ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::~vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >
  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??1?$_Pair_base@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Pair_base<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::~_Pair_base<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
__Wherenode$ = -8					; size = 4
_this$ = -4						; size = 4
?_Buynode@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 559  : 		{	// allocate a node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 560  : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

  0000c	6a 01		 push	 1
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00014	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::allocate
  00019	89 45 f8	 mov	 DWORD PTR __Wherenode$[ebp], eax

; 561  : 
; 562  : 		this->_Left(_Wherenode) = this->_Myhead;

  0001c	8b 45 f8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Left
  00025	83 c4 04	 add	 esp, 4
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002e	89 10		 mov	 DWORD PTR [eax], edx

; 563  : 		this->_Parent(_Wherenode) = this->_Myhead;

  00030	8b 45 f8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Parent
  00039	83 c4 04	 add	 esp, 4
  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00042	89 10		 mov	 DWORD PTR [eax], edx

; 564  : 		this->_Right(_Wherenode) = this->_Myhead;

  00044	8b 45 f8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Right
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00056	89 10		 mov	 DWORD PTR [eax], edx

; 565  : 		this->_Color(_Wherenode) = this->_Red;

  00058	8b 45 f8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Color
  00061	83 c4 04	 add	 esp, 4
  00064	c6 00 00	 mov	 BYTE PTR [eax], 0

; 566  : 		this->_Isnil(_Wherenode) = false;

  00067	8b 45 f8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0006a	50		 push	 eax
  0006b	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Isnil
  00070	83 c4 04	 add	 esp, 4
  00073	c6 00 00	 mov	 BYTE PTR [eax], 0

; 567  : 		return (_Wherenode);

  00076	8b 45 f8	 mov	 eax, DWORD PTR __Wherenode$[ebp]

; 568  : 		}

  00079	5f		 pop	 edi
  0007a	5e		 pop	 esi
  0007b	5b		 pop	 ebx
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
?_Buynode@?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
__Wherenode$ = -8					; size = 4
_this$ = -4						; size = 4
?_Buynode@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 559  : 		{	// allocate a node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 560  : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

  0000c	6a 01		 push	 1
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00014	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Node>::allocate
  00019	89 45 f8	 mov	 DWORD PTR __Wherenode$[ebp], eax

; 561  : 
; 562  : 		this->_Left(_Wherenode) = this->_Myhead;

  0001c	8b 45 f8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Left
  00025	83 c4 04	 add	 esp, 4
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002e	89 10		 mov	 DWORD PTR [eax], edx

; 563  : 		this->_Parent(_Wherenode) = this->_Myhead;

  00030	8b 45 f8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Parent
  00039	83 c4 04	 add	 esp, 4
  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00042	89 10		 mov	 DWORD PTR [eax], edx

; 564  : 		this->_Right(_Wherenode) = this->_Myhead;

  00044	8b 45 f8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Right
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00056	89 10		 mov	 DWORD PTR [eax], edx

; 565  : 		this->_Color(_Wherenode) = this->_Red;

  00058	8b 45 f8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Color
  00061	83 c4 04	 add	 esp, 4
  00064	c6 00 00	 mov	 BYTE PTR [eax], 0

; 566  : 		this->_Isnil(_Wherenode) = false;

  00067	8b 45 f8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0006a	50		 push	 eax
  0006b	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Isnil
  00070	83 c4 04	 add	 esp, 4
  00073	c6 00 00	 mov	 BYTE PTR [eax], 0

; 567  : 		return (_Wherenode);

  00076	8b 45 f8	 mov	 eax, DWORD PTR __Wherenode$[ebp]

; 568  : 		}

  00079	5f		 pop	 edi
  0007a	5e		 pop	 esi
  0007b	5b		 pop	 ebx
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
?_Buynode@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> >::_Buynode
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
__Wherenode$ = -8					; size = 4
_this$ = -4						; size = 4
?_Buynode@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 559  : 		{	// allocate a node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 560  : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

  0000c	6a 01		 push	 1
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00014	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Node>::allocate
  00019	89 45 f8	 mov	 DWORD PTR __Wherenode$[ebp], eax

; 561  : 
; 562  : 		this->_Left(_Wherenode) = this->_Myhead;

  0001c	8b 45 f8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Left
  00025	83 c4 04	 add	 esp, 4
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002e	89 10		 mov	 DWORD PTR [eax], edx

; 563  : 		this->_Parent(_Wherenode) = this->_Myhead;

  00030	8b 45 f8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Parent
  00039	83 c4 04	 add	 esp, 4
  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00042	89 10		 mov	 DWORD PTR [eax], edx

; 564  : 		this->_Right(_Wherenode) = this->_Myhead;

  00044	8b 45 f8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Right
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00056	89 10		 mov	 DWORD PTR [eax], edx

; 565  : 		this->_Color(_Wherenode) = this->_Red;

  00058	8b 45 f8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Color
  00061	83 c4 04	 add	 esp, 4
  00064	c6 00 00	 mov	 BYTE PTR [eax], 0

; 566  : 		this->_Isnil(_Wherenode) = false;

  00067	8b 45 f8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0006a	50		 push	 eax
  0006b	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Isnil
  00070	83 c4 04	 add	 esp, 4
  00073	c6 00 00	 mov	 BYTE PTR [eax], 0

; 567  : 		return (_Wherenode);

  00076	8b 45 f8	 mov	 eax, DWORD PTR __Wherenode$[ebp]

; 568  : 		}

  00079	5f		 pop	 edi
  0007a	5e		 pop	 esi
  0007b	5b		 pop	 ebx
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
?_Buynode@?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> >::_Buynode
_TEXT	ENDS
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IAEPAUCASTLEDEEP_SPAWNTIME@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@0PAU2@@Z ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >
PUBLIC	?begin@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@XZ ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::begin
PUBLIC	?end@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@XZ ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::end
PUBLIC	?_Buy@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IAE_NI@Z ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Buy
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\vector
xdata$x	SEGMENT
__catchsym$??0?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@ABV01@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??0?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv157 = -108						; size = 4
tv156 = -104						; size = 4
tv69 = -100						; size = 4
$T240209 = -96						; size = 4
$T240210 = -92						; size = 4
$T240211 = -88						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >, COMDAT
; _this$ = ecx

; 535  : 		{	// construct by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  0002f	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00032	83 c0 0c	 add	 eax, 12			; 0000000cH
  00035	51		 push	 ecx
  00036	8b cc		 mov	 ecx, esp
  00038	89 65 a0	 mov	 DWORD PTR $T240209[ebp], esp
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ??0?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAE@ABV01@@Z ; std::allocator<CASTLEDEEP_SPAWNTIME>::allocator<CASTLEDEEP_SPAWNTIME>
  00041	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??0?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@1@@Z ; std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >
  00049	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 536  : 		if (_Buy(_Right.size()))

  00050	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00053	e8 00 00 00 00	 call	 ?size@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QBEIXZ ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::size
  00058	50		 push	 eax
  00059	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	e8 00 00 00 00	 call	 ?_Buy@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IAE_NI@Z ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Buy
  00061	0f b6 c0	 movzx	 eax, al
  00064	85 c0		 test	 eax, eax
  00066	74 6f		 je	 SHORT $LN3@vector@2

; 537  : 			_TRY_BEGIN

  00068	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 538  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 539  : 				this->_Myfirst);

  0006c	8d 45 a4	 lea	 eax, DWORD PTR $T240210[ebp]
  0006f	50		 push	 eax
  00070	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00073	e8 00 00 00 00	 call	 ?end@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@XZ ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::end
  00078	89 45 9c	 mov	 DWORD PTR tv69[ebp], eax
  0007b	8d 4d a8	 lea	 ecx, DWORD PTR $T240211[ebp]
  0007e	51		 push	 ecx
  0007f	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00082	e8 00 00 00 00	 call	 ?begin@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@XZ ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::begin
  00087	89 45 98	 mov	 DWORD PTR tv156[ebp], eax
  0008a	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0008d	8b 02		 mov	 eax, DWORD PTR [edx]
  0008f	50		 push	 eax
  00090	8b 4d 9c	 mov	 ecx, DWORD PTR tv69[ebp]
  00093	8b 11		 mov	 edx, DWORD PTR [ecx]
  00095	52		 push	 edx
  00096	8b 45 98	 mov	 eax, DWORD PTR tv156[ebp]
  00099	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009b	51		 push	 ecx
  0009c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0009f	e8 00 00 00 00	 call	 ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IAEPAUCASTLEDEEP_SPAWNTIME@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@0PAU2@@Z ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >
  000a4	89 45 94	 mov	 DWORD PTR tv157[ebp], eax
  000a7	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000aa	8b 45 94	 mov	 eax, DWORD PTR tv157[ebp]
  000ad	89 42 04	 mov	 DWORD PTR [edx+4], eax
  000b0	eb 1e		 jmp	 SHORT $LN5@vector@2
__catch$??0?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@ABV01@@Z$0:

; 540  : 			_CATCH_ALL
; 541  : 			_Tidy();

  000b2	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000b5	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IAEXXZ ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Tidy

; 542  : 			_RERAISE;

  000ba	6a 00		 push	 0
  000bc	6a 00		 push	 0
  000be	e8 00 00 00 00	 call	 __CxxThrowException@8

; 543  : 			_CATCH_END

  000c3	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  000ca	b8 00 00 00 00	 mov	 eax, $LN3@vector@2
  000cf	c3		 ret	 0
$LN5@vector@2:
  000d0	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@2:

; 544  : 		}

  000d7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000de	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
$LN4@vector@2:
  000e1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000e4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000eb	59		 pop	 ecx
  000ec	5f		 pop	 edi
  000ed	5e		 pop	 esi
  000ee	5b		 pop	 ebx
  000ef	8b e5		 mov	 esp, ebp
  000f1	5d		 pop	 ebp
  000f2	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@ABV01@@Z$2:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@XZ ; std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::~_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >
__ehhandler$??0?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@ABV01@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a 90	 mov	 ecx, DWORD PTR [edx-112]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@ABV01@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IAEPAUCASTLEDEEP_MONSTERINFO@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@0PAU2@@Z ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >
PUBLIC	?begin@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@XZ ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::begin
PUBLIC	?end@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@XZ ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::end
PUBLIC	?_Buy@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IAE_NI@Z ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Buy
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@ABV01@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??0?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv157 = -108						; size = 4
tv156 = -104						; size = 4
tv69 = -100						; size = 4
$T240228 = -96						; size = 4
$T240229 = -92						; size = 4
$T240230 = -88						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >, COMDAT
; _this$ = ecx

; 535  : 		{	// construct by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  0002f	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00032	83 c0 0c	 add	 eax, 12			; 0000000cH
  00035	51		 push	 ecx
  00036	8b cc		 mov	 ecx, esp
  00038	89 65 a0	 mov	 DWORD PTR $T240228[ebp], esp
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ??0?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAE@ABV01@@Z ; std::allocator<CASTLEDEEP_MONSTERINFO>::allocator<CASTLEDEEP_MONSTERINFO>
  00041	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??0?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@1@@Z ; std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >
  00049	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 536  : 		if (_Buy(_Right.size()))

  00050	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00053	e8 00 00 00 00	 call	 ?size@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QBEIXZ ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::size
  00058	50		 push	 eax
  00059	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	e8 00 00 00 00	 call	 ?_Buy@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IAE_NI@Z ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Buy
  00061	0f b6 c0	 movzx	 eax, al
  00064	85 c0		 test	 eax, eax
  00066	74 6f		 je	 SHORT $LN3@vector@3

; 537  : 			_TRY_BEGIN

  00068	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 538  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 539  : 				this->_Myfirst);

  0006c	8d 45 a4	 lea	 eax, DWORD PTR $T240229[ebp]
  0006f	50		 push	 eax
  00070	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00073	e8 00 00 00 00	 call	 ?end@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@XZ ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::end
  00078	89 45 9c	 mov	 DWORD PTR tv69[ebp], eax
  0007b	8d 4d a8	 lea	 ecx, DWORD PTR $T240230[ebp]
  0007e	51		 push	 ecx
  0007f	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00082	e8 00 00 00 00	 call	 ?begin@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@XZ ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::begin
  00087	89 45 98	 mov	 DWORD PTR tv156[ebp], eax
  0008a	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0008d	8b 02		 mov	 eax, DWORD PTR [edx]
  0008f	50		 push	 eax
  00090	8b 4d 9c	 mov	 ecx, DWORD PTR tv69[ebp]
  00093	8b 11		 mov	 edx, DWORD PTR [ecx]
  00095	52		 push	 edx
  00096	8b 45 98	 mov	 eax, DWORD PTR tv156[ebp]
  00099	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009b	51		 push	 ecx
  0009c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0009f	e8 00 00 00 00	 call	 ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IAEPAUCASTLEDEEP_MONSTERINFO@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@0PAU2@@Z ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >
  000a4	89 45 94	 mov	 DWORD PTR tv157[ebp], eax
  000a7	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000aa	8b 45 94	 mov	 eax, DWORD PTR tv157[ebp]
  000ad	89 42 04	 mov	 DWORD PTR [edx+4], eax
  000b0	eb 1e		 jmp	 SHORT $LN5@vector@3
__catch$??0?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@ABV01@@Z$0:

; 540  : 			_CATCH_ALL
; 541  : 			_Tidy();

  000b2	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000b5	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IAEXXZ ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Tidy

; 542  : 			_RERAISE;

  000ba	6a 00		 push	 0
  000bc	6a 00		 push	 0
  000be	e8 00 00 00 00	 call	 __CxxThrowException@8

; 543  : 			_CATCH_END

  000c3	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  000ca	b8 00 00 00 00	 mov	 eax, $LN3@vector@3
  000cf	c3		 ret	 0
$LN5@vector@3:
  000d0	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@3:

; 544  : 		}

  000d7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000de	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
$LN4@vector@3:
  000e1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000e4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000eb	59		 pop	 ecx
  000ec	5f		 pop	 edi
  000ed	5e		 pop	 esi
  000ee	5b		 pop	 ebx
  000ef	8b e5		 mov	 esp, ebp
  000f1	5d		 pop	 ebp
  000f2	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@ABV01@@Z$2:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@XZ ; std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::~_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >
__ehhandler$??0?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@ABV01@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a 90	 mov	 ecx, DWORD PTR [edx-112]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@ABV01@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >
; Function compile flags: /Odtp /ZI
;	COMDAT ?begin@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@XZ PROC ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::begin, COMDAT
; _this$ = ecx

; 786  : 		{	// return iterator for beginning of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 787  : 		return (const_iterator(this->_Myfirst, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	52		 push	 edx
  00016	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00019	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@PAUCASTLEDEEP_SPAWNTIME@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >
  0001e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 788  : 		}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?begin@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@XZ ENDP ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::begin
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?end@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@XZ PROC ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::end, COMDAT
; _this$ = ecx

; 796  : 		{	// return iterator for end of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 797  : 		return (const_iterator(this->_Mylast, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	52		 push	 edx
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@PAUCASTLEDEEP_SPAWNTIME@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >
  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 798  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?end@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@XZ ENDP ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::end
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Buy, COMDAT
; _this$ = ecx

; 1250 : 		{	// allocate array with _Capacity elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1251 : 		this->_Myfirst = 0;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1252 : 		this->_Mylast = 0;

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1253 : 		this->_Myend = 0;

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 1254 : 
; 1255 : 		if (_Capacity == 0)

  00029	83 7d 08 00	 cmp	 DWORD PTR __Capacity$[ebp], 0
  0002d	75 06		 jne	 SHORT $LN4@Buy

; 1256 : 			return (false);

  0002f	32 c0		 xor	 al, al
  00031	eb 4b		 jmp	 SHORT $LN6@Buy
  00033	eb 47		 jmp	 SHORT $LN3@Buy
$LN4@Buy:

; 1257 : 		else if (max_size() < _Capacity)

  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ?max_size@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QBEIXZ ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::max_size
  0003d	3b 45 08	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  00040	73 0a		 jae	 SHORT $LN2@Buy

; 1258 : 			_Xlen();	// result too long

  00042	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IBEXXZ ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Xlen

; 1259 : 		else

  0004a	eb 30		 jmp	 SHORT $LN3@Buy
$LN2@Buy:

; 1260 : 			{	// nonempty array, allocate storage
; 1261 : 			this->_Myfirst = this->_Alval.allocate(_Capacity);

  0004c	8b 45 08	 mov	 eax, DWORD PTR __Capacity$[ebp]
  0004f	50		 push	 eax
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00056	e8 00 00 00 00	 call	 ?allocate@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEPAUCASTLEDEEP_SPAWNTIME@@I@Z ; std::allocator<CASTLEDEEP_SPAWNTIME>::allocate
  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	89 01		 mov	 DWORD PTR [ecx], eax

; 1262 : 			this->_Mylast = this->_Myfirst;

  00060	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00063	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	8b 11		 mov	 edx, DWORD PTR [ecx]
  00068	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1263 : 			this->_Myend = this->_Myfirst + _Capacity;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00070	8b 55 08	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00073	8d 04 d1	 lea	 eax, DWORD PTR [ecx+edx*8]
  00076	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00079	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN3@Buy:

; 1264 : 			}
; 1265 : 		return (true);

  0007c	b0 01		 mov	 al, 1
$LN6@Buy:

; 1266 : 		}

  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c2 04 00	 ret	 4
?_Buy@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Buy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?begin@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@XZ PROC ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::begin, COMDAT
; _this$ = ecx

; 786  : 		{	// return iterator for beginning of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 787  : 		return (const_iterator(this->_Myfirst, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	52		 push	 edx
  00016	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00019	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@PAUCASTLEDEEP_MONSTERINFO@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >
  0001e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 788  : 		}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?begin@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@XZ ENDP ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::begin
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?end@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@XZ PROC ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::end, COMDAT
; _this$ = ecx

; 796  : 		{	// return iterator for end of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 797  : 		return (const_iterator(this->_Mylast, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	52		 push	 edx
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@PAUCASTLEDEEP_MONSTERINFO@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >
  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 798  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?end@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@XZ ENDP ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::end
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Buy, COMDAT
; _this$ = ecx

; 1250 : 		{	// allocate array with _Capacity elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1251 : 		this->_Myfirst = 0;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1252 : 		this->_Mylast = 0;

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1253 : 		this->_Myend = 0;

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 1254 : 
; 1255 : 		if (_Capacity == 0)

  00029	83 7d 08 00	 cmp	 DWORD PTR __Capacity$[ebp], 0
  0002d	75 06		 jne	 SHORT $LN4@Buy@2

; 1256 : 			return (false);

  0002f	32 c0		 xor	 al, al
  00031	eb 4b		 jmp	 SHORT $LN6@Buy@2
  00033	eb 47		 jmp	 SHORT $LN3@Buy@2
$LN4@Buy@2:

; 1257 : 		else if (max_size() < _Capacity)

  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ?max_size@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QBEIXZ ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::max_size
  0003d	3b 45 08	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  00040	73 0a		 jae	 SHORT $LN2@Buy@2

; 1258 : 			_Xlen();	// result too long

  00042	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IBEXXZ ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Xlen

; 1259 : 		else

  0004a	eb 30		 jmp	 SHORT $LN3@Buy@2
$LN2@Buy@2:

; 1260 : 			{	// nonempty array, allocate storage
; 1261 : 			this->_Myfirst = this->_Alval.allocate(_Capacity);

  0004c	8b 45 08	 mov	 eax, DWORD PTR __Capacity$[ebp]
  0004f	50		 push	 eax
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00056	e8 00 00 00 00	 call	 ?allocate@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEPAUCASTLEDEEP_MONSTERINFO@@I@Z ; std::allocator<CASTLEDEEP_MONSTERINFO>::allocate
  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	89 01		 mov	 DWORD PTR [ecx], eax

; 1262 : 			this->_Mylast = this->_Myfirst;

  00060	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00063	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	8b 11		 mov	 edx, DWORD PTR [ecx]
  00068	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1263 : 			this->_Myend = this->_Myfirst + _Capacity;

  0006b	8b 45 08	 mov	 eax, DWORD PTR __Capacity$[ebp]
  0006e	6b c0 1c	 imul	 eax, 28			; 0000001cH
  00071	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	03 01		 add	 eax, DWORD PTR [ecx]
  00076	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00079	89 42 08	 mov	 DWORD PTR [edx+8], eax
$LN3@Buy@2:

; 1264 : 			}
; 1265 : 		return (true);

  0007c	b0 01		 mov	 al, 1
$LN6@Buy@2:

; 1266 : 		}

  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c2 04 00	 ret	 4
?_Buy@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Buy
_TEXT	ENDS
PUBLIC	??$construct@U?$pair@HH@std@@@?$allocator@U?$pair@$$CBHH@std@@@std@@QAEXPAU?$pair@$$CBHH@1@$$QAU?$pair@HH@1@@Z ; std::allocator<std::pair<int const ,int> >::construct<std::pair<int,int> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Cons_val@V?$allocator@U?$pair@$$CBHH@std@@@std@@U?$pair@$$CBHH@2@U?$pair@HH@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHH@std@@@0@PAU?$pair@$$CBHH@0@$$QAU?$pair@HH@0@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@U?$pair@$$CBHH@std@@@std@@U?$pair@$$CBHH@2@U?$pair@HH@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHH@std@@@0@PAU?$pair@$$CBHH@0@$$QAU?$pair@HH@0@@Z PROC ; std::_Cons_val<std::allocator<std::pair<int const ,int> >,std::pair<int const ,int>,std::pair<int,int> >, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@U?$pair@HH@std@@@std@@YA$$QAU?$pair@HH@0@AAU10@@Z ; std::forward<std::pair<int,int> >
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ??$construct@U?$pair@HH@std@@@?$allocator@U?$pair@$$CBHH@std@@@std@@QAEXPAU?$pair@$$CBHH@1@$$QAU?$pair@HH@1@@Z ; std::allocator<std::pair<int const ,int> >::construct<std::pair<int,int> >

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@U?$pair@$$CBHH@std@@@std@@U?$pair@$$CBHH@2@U?$pair@HH@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHH@std@@@0@PAU?$pair@$$CBHH@0@$$QAU?$pair@HH@0@@Z ENDP ; std::_Cons_val<std::allocator<std::pair<int const ,int> >,std::pair<int const ,int>,std::pair<int,int> >
_TEXT	ENDS
PUBLIC	??$construct@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@QAEXPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z ; std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >::construct<std::pair<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@0@PAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@0@PAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@@Z PROC ; std::_Cons_val<std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >,std::pair<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@YA$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@AAU10@@Z ; std::forward<std::pair<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ??$construct@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@QAEXPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z ; std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >::construct<std::pair<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@0@PAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@@Z ENDP ; std::_Cons_val<std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >,std::pair<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >
_TEXT	ENDS
PUBLIC	??$construct@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@QAEXPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z ; std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >::construct<std::pair<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@0@PAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@0@PAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@@Z PROC ; std::_Cons_val<std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >,std::pair<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@YA$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@AAU10@@Z ; std::forward<std::pair<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ??$construct@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@QAEXPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z ; std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >::construct<std::pair<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@0@PAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@@Z ENDP ; std::_Cons_val<std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >,std::pair<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$move@AAUCASTLEDEEP_EVENTTIME@@@std@@YA$$QAUCASTLEDEEP_EVENTTIME@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAUCASTLEDEEP_EVENTTIME@@@std@@YA$$QAUCASTLEDEEP_EVENTTIME@@AAU1@@Z PROC ; std::move<CASTLEDEEP_EVENTTIME &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$move@AAUCASTLEDEEP_EVENTTIME@@@std@@YA$$QAUCASTLEDEEP_EVENTTIME@@AAU1@@Z ENDP ; std::move<CASTLEDEEP_EVENTTIME &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Val_type@PAH@std@@YAPAHPAH@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAH@std@@YAPAHPAH@Z PROC			; std::_Val_type<int *>, COMDAT

; 789  : 	{	// return value type from arbitrary argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 790  : 	return (0);

  00009	33 c0		 xor	 eax, eax

; 791  : 	}

  0000b	5f		 pop	 edi
  0000c	5e		 pop	 esi
  0000d	5b		 pop	 ebx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Val_type@PAH@std@@YAPAHPAH@Z ENDP			; std::_Val_type<int *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_move@HHH@std@@YAPAHPAH00AAV?$allocator@H@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@HHH@std@@YAPAHPAH00AAV?$allocator@H@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<int,int,int>, COMDAT

; 456  : 	{	// move [_First, _Last) to raw _Dest, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 457  : 	_DEBUG_RANGE(_First, _Last);
; 458  : 	_DEBUG_POINTER(_Dest);
; 459  : 	size_t _Count = (size_t)(_Last - _First);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000f	c1 f8 02	 sar	 eax, 2
  00012	89 45 fc	 mov	 DWORD PTR __Count$[ebp], eax

; 460  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 461  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00015	8b 45 fc	 mov	 eax, DWORD PTR __Count$[ebp]
  00018	c1 e0 02	 shl	 eax, 2
  0001b	50		 push	 eax
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00023	52		 push	 edx
  00024	e8 00 00 00 00	 call	 _memmove
  00029	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR __Count$[ebp]
  0002f	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 462  : 	}

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$_Uninit_move@HHH@std@@YAPAHPAH00AAV?$allocator@H@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<int,int,int>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Val_type@PAUCASTLEDEEP_EVENTTIME@@@std@@YAPAUCASTLEDEEP_EVENTTIME@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUCASTLEDEEP_EVENTTIME@@@std@@YAPAUCASTLEDEEP_EVENTTIME@@PAU1@@Z PROC ; std::_Val_type<CASTLEDEEP_EVENTTIME *>, COMDAT

; 789  : 	{	// return value type from arbitrary argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 790  : 	return (0);

  00009	33 c0		 xor	 eax, eax

; 791  : 	}

  0000b	5f		 pop	 edi
  0000c	5e		 pop	 esi
  0000d	5b		 pop	 ebx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Val_type@PAUCASTLEDEEP_EVENTTIME@@@std@@YAPAUCASTLEDEEP_EVENTTIME@@PAU1@@Z ENDP ; std::_Val_type<CASTLEDEEP_EVENTTIME *>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@UCASTLEDEEP_EVENTTIME@@U3@@std@@YAXAAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@PAUCASTLEDEEP_EVENTTIME@@$$QAU2@@Z ; std::_Cons_val<std::allocator<CASTLEDEEP_EVENTTIME>,CASTLEDEEP_EVENTTIME,CASTLEDEEP_EVENTTIME>
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_move@PAUCASTLEDEEP_EVENTTIME@@PAU1@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@U1@@std@@YAPAUCASTLEDEEP_EVENTTIME@@PAU1@00AAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_move@PAUCASTLEDEEP_EVENTTIME@@PAU1@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@U1@@std@@YAPAUCASTLEDEEP_EVENTTIME@@PAU1@00AAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_move@PAUCASTLEDEEP_EVENTTIME@@PAU1@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@U1@@std@@YAPAUCASTLEDEEP_EVENTTIME@@PAU1@00AAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_move@PAUCASTLEDEEP_EVENTTIME@@PAU1@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@U1@@std@@YAPAUCASTLEDEEP_EVENTTIME@@PAU1@00AAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_move@PAUCASTLEDEEP_EVENTTIME@@PAU1@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@U1@@std@@YAPAUCASTLEDEEP_EVENTTIME@@PAU1@00AAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_move@PAUCASTLEDEEP_EVENTTIME@@PAU1@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@U1@@std@@YAPAUCASTLEDEEP_EVENTTIME@@PAU1@00AAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_move@PAUCASTLEDEEP_EVENTTIME@@PAU1@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@U1@@std@@YAPAUCASTLEDEEP_EVENTTIME@@PAU1@00AAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_move@PAUCASTLEDEEP_EVENTTIME@@PAU1@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@U1@@std@@YAPAUCASTLEDEEP_EVENTTIME@@PAU1@00AAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Uninit_move@PAUCASTLEDEEP_EVENTTIME@@PAU1@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@U1@@std@@YAPAUCASTLEDEEP_EVENTTIME@@PAU1@00AAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUCASTLEDEEP_EVENTTIME@@PAU1@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@U1@@std@@YAPAUCASTLEDEEP_EVENTTIME@@PAU1@00AAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<CASTLEDEEP_EVENTTIME *,CASTLEDEEP_EVENTTIME *,std::allocator<CASTLEDEEP_EVENTTIME>,CASTLEDEEP_EVENTTIME>, COMDAT

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_move@PAUCASTLEDEEP_EVENTTIME@@PAU1@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@U1@@std@@YAPAUCASTLEDEEP_EVENTTIME@@PAU1@00AAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 44	 sub	 esp, 68			; 00000044H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;

  0002c	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0002f	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 428  : 
; 429  : 	_TRY_BEGIN

  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00039	eb 12		 jmp	 SHORT $LN6@Uninit_mov
$LN5@Uninit_mov:

; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  0003b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0003e	83 c0 08	 add	 eax, 8
  00041	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00044	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00047	83 c1 08	 add	 ecx, 8
  0004a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN6@Uninit_mov:
  0004d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00050	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00053	74 16		 je	 SHORT $LN4@Uninit_mov

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

  00055	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00058	50		 push	 eax
  00059	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0005c	51		 push	 ecx
  0005d	8b 55 14	 mov	 edx, DWORD PTR __Al$[ebp]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@UCASTLEDEEP_EVENTTIME@@U3@@std@@YAXAAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@PAUCASTLEDEEP_EVENTTIME@@$$QAU2@@Z ; std::_Cons_val<std::allocator<CASTLEDEEP_EVENTTIME>,CASTLEDEEP_EVENTTIME,CASTLEDEEP_EVENTTIME>
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
  00069	eb d0		 jmp	 SHORT $LN5@Uninit_mov
$LN4@Uninit_mov:
  0006b	eb 3b		 jmp	 SHORT $LN10@Uninit_mov
__catch$??$_Uninit_move@PAUCASTLEDEEP_EVENTTIME@@PAU1@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@U1@@std@@YAPAUCASTLEDEEP_EVENTTIME@@PAU1@00AAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 432  : 	_CATCH_ALL

  0006d	eb 09		 jmp	 SHORT $LN3@Uninit_mov
$LN2@Uninit_mov:

; 433  : 	for (; _Next != _Dest; ++_Next)

  0006f	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00072	83 c0 08	 add	 eax, 8
  00075	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax
$LN3@Uninit_mov:
  00078	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  0007b	3b 45 10	 cmp	 eax, DWORD PTR __Dest$[ebp]
  0007e	74 12		 je	 SHORT $LN1@Uninit_mov

; 434  : 		_Dest_val(_Al, _Next);

  00080	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00083	50		 push	 eax
  00084	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@UCASTLEDEEP_EVENTTIME@@@std@@YAXAAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@PAUCASTLEDEEP_EVENTTIME@@@Z ; std::_Dest_val<std::allocator<CASTLEDEEP_EVENTTIME>,CASTLEDEEP_EVENTTIME>
  0008d	83 c4 08	 add	 esp, 8
  00090	eb dd		 jmp	 SHORT $LN2@Uninit_mov
$LN1@Uninit_mov:

; 435  : 	_RERAISE;

  00092	6a 00		 push	 0
  00094	6a 00		 push	 0
  00096	e8 00 00 00 00	 call	 __CxxThrowException@8

; 436  : 	_CATCH_END

  0009b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000a2	b8 00 00 00 00	 mov	 eax, __tryend$??$_Uninit_move@PAUCASTLEDEEP_EVENTTIME@@PAU1@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@U1@@std@@YAPAUCASTLEDEEP_EVENTTIME@@PAU1@00AAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1
  000a7	c3		 ret	 0
$LN10@Uninit_mov:
  000a8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_move@PAUCASTLEDEEP_EVENTTIME@@PAU1@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@U1@@std@@YAPAUCASTLEDEEP_EVENTTIME@@PAU1@00AAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1:

; 437  : 	return (_Dest);

  000af	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_mov:

; 438  : 	}

  000b2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000b5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000bc	59		 pop	 ecx
  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_move@PAUCASTLEDEEP_EVENTTIME@@PAU1@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@U1@@std@@YAPAUCASTLEDEEP_EVENTTIME@@PAU1@00AAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninit_move@PAUCASTLEDEEP_EVENTTIME@@PAU1@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@U1@@std@@YAPAUCASTLEDEEP_EVENTTIME@@PAU1@00AAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninit_move@PAUCASTLEDEEP_EVENTTIME@@PAU1@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@U1@@std@@YAPAUCASTLEDEEP_EVENTTIME@@PAU1@00AAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CASTLEDEEP_EVENTTIME *,CASTLEDEEP_EVENTTIME *,std::allocator<CASTLEDEEP_EVENTTIME>,CASTLEDEEP_EVENTTIME>
PUBLIC	?destroy@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAEXPAUCASTLEDEEP_EVENTTIME@@@Z ; std::allocator<CASTLEDEEP_EVENTTIME>::destroy
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Dest_val@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@UCASTLEDEEP_EVENTTIME@@@std@@YAXAAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@PAUCASTLEDEEP_EVENTTIME@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@UCASTLEDEEP_EVENTTIME@@@std@@YAXAAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@PAUCASTLEDEEP_EVENTTIME@@@Z PROC ; std::_Dest_val<std::allocator<CASTLEDEEP_EVENTTIME>,CASTLEDEEP_EVENTTIME>, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 287  : 	_Alval.destroy(_Pdest);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  00010	e8 00 00 00 00	 call	 ?destroy@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAEXPAUCASTLEDEEP_EVENTTIME@@@Z ; std::allocator<CASTLEDEEP_EVENTTIME>::destroy

; 288  : 	}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Dest_val@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@UCASTLEDEEP_EVENTTIME@@@std@@YAXAAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@PAUCASTLEDEEP_EVENTTIME@@@Z ENDP ; std::_Dest_val<std::allocator<CASTLEDEEP_EVENTTIME>,CASTLEDEEP_EVENTTIME>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Val_type@PAUCASTLEDEEP_SPAWNTIME@@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUCASTLEDEEP_SPAWNTIME@@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@PAU1@@Z PROC ; std::_Val_type<CASTLEDEEP_SPAWNTIME *>, COMDAT

; 789  : 	{	// return value type from arbitrary argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 790  : 	return (0);

  00009	33 c0		 xor	 eax, eax

; 791  : 	}

  0000b	5f		 pop	 edi
  0000c	5e		 pop	 esi
  0000d	5b		 pop	 ebx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Val_type@PAUCASTLEDEEP_SPAWNTIME@@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@PAU1@@Z ENDP ; std::_Val_type<CASTLEDEEP_SPAWNTIME *>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@UCASTLEDEEP_SPAWNTIME@@U3@@std@@YAXAAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@PAUCASTLEDEEP_SPAWNTIME@@$$QAU2@@Z ; std::_Cons_val<std::allocator<CASTLEDEEP_SPAWNTIME>,CASTLEDEEP_SPAWNTIME,CASTLEDEEP_SPAWNTIME>
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_move@PAUCASTLEDEEP_SPAWNTIME@@PAU1@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@U1@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@PAU1@00AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_move@PAUCASTLEDEEP_SPAWNTIME@@PAU1@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@U1@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@PAU1@00AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_move@PAUCASTLEDEEP_SPAWNTIME@@PAU1@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@U1@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@PAU1@00AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_move@PAUCASTLEDEEP_SPAWNTIME@@PAU1@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@U1@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@PAU1@00AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_move@PAUCASTLEDEEP_SPAWNTIME@@PAU1@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@U1@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@PAU1@00AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_move@PAUCASTLEDEEP_SPAWNTIME@@PAU1@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@U1@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@PAU1@00AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_move@PAUCASTLEDEEP_SPAWNTIME@@PAU1@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@U1@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@PAU1@00AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_move@PAUCASTLEDEEP_SPAWNTIME@@PAU1@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@U1@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@PAU1@00AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Uninit_move@PAUCASTLEDEEP_SPAWNTIME@@PAU1@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@U1@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@PAU1@00AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUCASTLEDEEP_SPAWNTIME@@PAU1@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@U1@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@PAU1@00AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<CASTLEDEEP_SPAWNTIME *,CASTLEDEEP_SPAWNTIME *,std::allocator<CASTLEDEEP_SPAWNTIME>,CASTLEDEEP_SPAWNTIME>, COMDAT

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_move@PAUCASTLEDEEP_SPAWNTIME@@PAU1@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@U1@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@PAU1@00AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 44	 sub	 esp, 68			; 00000044H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;

  0002c	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0002f	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 428  : 
; 429  : 	_TRY_BEGIN

  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00039	eb 12		 jmp	 SHORT $LN6@Uninit_mov@2
$LN5@Uninit_mov@2:

; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  0003b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0003e	83 c0 08	 add	 eax, 8
  00041	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00044	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00047	83 c1 08	 add	 ecx, 8
  0004a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN6@Uninit_mov@2:
  0004d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00050	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00053	74 16		 je	 SHORT $LN4@Uninit_mov@2

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

  00055	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00058	50		 push	 eax
  00059	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0005c	51		 push	 ecx
  0005d	8b 55 14	 mov	 edx, DWORD PTR __Al$[ebp]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@UCASTLEDEEP_SPAWNTIME@@U3@@std@@YAXAAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@PAUCASTLEDEEP_SPAWNTIME@@$$QAU2@@Z ; std::_Cons_val<std::allocator<CASTLEDEEP_SPAWNTIME>,CASTLEDEEP_SPAWNTIME,CASTLEDEEP_SPAWNTIME>
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
  00069	eb d0		 jmp	 SHORT $LN5@Uninit_mov@2
$LN4@Uninit_mov@2:
  0006b	eb 3b		 jmp	 SHORT $LN10@Uninit_mov@2
__catch$??$_Uninit_move@PAUCASTLEDEEP_SPAWNTIME@@PAU1@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@U1@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@PAU1@00AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 432  : 	_CATCH_ALL

  0006d	eb 09		 jmp	 SHORT $LN3@Uninit_mov@2
$LN2@Uninit_mov@2:

; 433  : 	for (; _Next != _Dest; ++_Next)

  0006f	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00072	83 c0 08	 add	 eax, 8
  00075	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax
$LN3@Uninit_mov@2:
  00078	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  0007b	3b 45 10	 cmp	 eax, DWORD PTR __Dest$[ebp]
  0007e	74 12		 je	 SHORT $LN1@Uninit_mov@2

; 434  : 		_Dest_val(_Al, _Next);

  00080	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00083	50		 push	 eax
  00084	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@UCASTLEDEEP_SPAWNTIME@@@std@@YAXAAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@PAUCASTLEDEEP_SPAWNTIME@@@Z ; std::_Dest_val<std::allocator<CASTLEDEEP_SPAWNTIME>,CASTLEDEEP_SPAWNTIME>
  0008d	83 c4 08	 add	 esp, 8
  00090	eb dd		 jmp	 SHORT $LN2@Uninit_mov@2
$LN1@Uninit_mov@2:

; 435  : 	_RERAISE;

  00092	6a 00		 push	 0
  00094	6a 00		 push	 0
  00096	e8 00 00 00 00	 call	 __CxxThrowException@8

; 436  : 	_CATCH_END

  0009b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000a2	b8 00 00 00 00	 mov	 eax, __tryend$??$_Uninit_move@PAUCASTLEDEEP_SPAWNTIME@@PAU1@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@U1@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@PAU1@00AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1
  000a7	c3		 ret	 0
$LN10@Uninit_mov@2:
  000a8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_move@PAUCASTLEDEEP_SPAWNTIME@@PAU1@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@U1@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@PAU1@00AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1:

; 437  : 	return (_Dest);

  000af	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_mov@2:

; 438  : 	}

  000b2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000b5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000bc	59		 pop	 ecx
  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_move@PAUCASTLEDEEP_SPAWNTIME@@PAU1@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@U1@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@PAU1@00AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninit_move@PAUCASTLEDEEP_SPAWNTIME@@PAU1@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@U1@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@PAU1@00AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninit_move@PAUCASTLEDEEP_SPAWNTIME@@PAU1@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@U1@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@PAU1@00AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CASTLEDEEP_SPAWNTIME *,CASTLEDEEP_SPAWNTIME *,std::allocator<CASTLEDEEP_SPAWNTIME>,CASTLEDEEP_SPAWNTIME>
PUBLIC	?destroy@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEXPAUCASTLEDEEP_SPAWNTIME@@@Z ; std::allocator<CASTLEDEEP_SPAWNTIME>::destroy
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Dest_val@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@UCASTLEDEEP_SPAWNTIME@@@std@@YAXAAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@PAUCASTLEDEEP_SPAWNTIME@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@UCASTLEDEEP_SPAWNTIME@@@std@@YAXAAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@PAUCASTLEDEEP_SPAWNTIME@@@Z PROC ; std::_Dest_val<std::allocator<CASTLEDEEP_SPAWNTIME>,CASTLEDEEP_SPAWNTIME>, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 287  : 	_Alval.destroy(_Pdest);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  00010	e8 00 00 00 00	 call	 ?destroy@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEXPAUCASTLEDEEP_SPAWNTIME@@@Z ; std::allocator<CASTLEDEEP_SPAWNTIME>::destroy

; 288  : 	}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Dest_val@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@UCASTLEDEEP_SPAWNTIME@@@std@@YAXAAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@PAUCASTLEDEEP_SPAWNTIME@@@Z ENDP ; std::_Dest_val<std::allocator<CASTLEDEEP_SPAWNTIME>,CASTLEDEEP_SPAWNTIME>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Val_type@PAUCASTLEDEEP_MONSTERINFO@@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUCASTLEDEEP_MONSTERINFO@@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@PAU1@@Z PROC ; std::_Val_type<CASTLEDEEP_MONSTERINFO *>, COMDAT

; 789  : 	{	// return value type from arbitrary argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 790  : 	return (0);

  00009	33 c0		 xor	 eax, eax

; 791  : 	}

  0000b	5f		 pop	 edi
  0000c	5e		 pop	 esi
  0000d	5b		 pop	 ebx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Val_type@PAUCASTLEDEEP_MONSTERINFO@@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@PAU1@@Z ENDP ; std::_Val_type<CASTLEDEEP_MONSTERINFO *>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@UCASTLEDEEP_MONSTERINFO@@U3@@std@@YAXAAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@PAUCASTLEDEEP_MONSTERINFO@@$$QAU2@@Z ; std::_Cons_val<std::allocator<CASTLEDEEP_MONSTERINFO>,CASTLEDEEP_MONSTERINFO,CASTLEDEEP_MONSTERINFO>
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_move@PAUCASTLEDEEP_MONSTERINFO@@PAU1@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@U1@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@PAU1@00AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_move@PAUCASTLEDEEP_MONSTERINFO@@PAU1@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@U1@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@PAU1@00AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_move@PAUCASTLEDEEP_MONSTERINFO@@PAU1@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@U1@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@PAU1@00AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_move@PAUCASTLEDEEP_MONSTERINFO@@PAU1@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@U1@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@PAU1@00AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_move@PAUCASTLEDEEP_MONSTERINFO@@PAU1@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@U1@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@PAU1@00AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_move@PAUCASTLEDEEP_MONSTERINFO@@PAU1@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@U1@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@PAU1@00AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_move@PAUCASTLEDEEP_MONSTERINFO@@PAU1@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@U1@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@PAU1@00AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_move@PAUCASTLEDEEP_MONSTERINFO@@PAU1@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@U1@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@PAU1@00AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Uninit_move@PAUCASTLEDEEP_MONSTERINFO@@PAU1@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@U1@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@PAU1@00AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUCASTLEDEEP_MONSTERINFO@@PAU1@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@U1@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@PAU1@00AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<CASTLEDEEP_MONSTERINFO *,CASTLEDEEP_MONSTERINFO *,std::allocator<CASTLEDEEP_MONSTERINFO>,CASTLEDEEP_MONSTERINFO>, COMDAT

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_move@PAUCASTLEDEEP_MONSTERINFO@@PAU1@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@U1@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@PAU1@00AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 44	 sub	 esp, 68			; 00000044H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;

  0002c	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0002f	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 428  : 
; 429  : 	_TRY_BEGIN

  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00039	eb 12		 jmp	 SHORT $LN6@Uninit_mov@3
$LN5@Uninit_mov@3:

; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  0003b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0003e	83 c0 1c	 add	 eax, 28			; 0000001cH
  00041	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00044	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00047	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0004a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN6@Uninit_mov@3:
  0004d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00050	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00053	74 16		 je	 SHORT $LN4@Uninit_mov@3

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

  00055	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00058	50		 push	 eax
  00059	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0005c	51		 push	 ecx
  0005d	8b 55 14	 mov	 edx, DWORD PTR __Al$[ebp]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@UCASTLEDEEP_MONSTERINFO@@U3@@std@@YAXAAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@PAUCASTLEDEEP_MONSTERINFO@@$$QAU2@@Z ; std::_Cons_val<std::allocator<CASTLEDEEP_MONSTERINFO>,CASTLEDEEP_MONSTERINFO,CASTLEDEEP_MONSTERINFO>
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
  00069	eb d0		 jmp	 SHORT $LN5@Uninit_mov@3
$LN4@Uninit_mov@3:
  0006b	eb 3b		 jmp	 SHORT $LN10@Uninit_mov@3
__catch$??$_Uninit_move@PAUCASTLEDEEP_MONSTERINFO@@PAU1@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@U1@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@PAU1@00AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 432  : 	_CATCH_ALL

  0006d	eb 09		 jmp	 SHORT $LN3@Uninit_mov@3
$LN2@Uninit_mov@3:

; 433  : 	for (; _Next != _Dest; ++_Next)

  0006f	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00072	83 c0 1c	 add	 eax, 28			; 0000001cH
  00075	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax
$LN3@Uninit_mov@3:
  00078	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  0007b	3b 45 10	 cmp	 eax, DWORD PTR __Dest$[ebp]
  0007e	74 12		 je	 SHORT $LN1@Uninit_mov@3

; 434  : 		_Dest_val(_Al, _Next);

  00080	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00083	50		 push	 eax
  00084	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@UCASTLEDEEP_MONSTERINFO@@@std@@YAXAAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@PAUCASTLEDEEP_MONSTERINFO@@@Z ; std::_Dest_val<std::allocator<CASTLEDEEP_MONSTERINFO>,CASTLEDEEP_MONSTERINFO>
  0008d	83 c4 08	 add	 esp, 8
  00090	eb dd		 jmp	 SHORT $LN2@Uninit_mov@3
$LN1@Uninit_mov@3:

; 435  : 	_RERAISE;

  00092	6a 00		 push	 0
  00094	6a 00		 push	 0
  00096	e8 00 00 00 00	 call	 __CxxThrowException@8

; 436  : 	_CATCH_END

  0009b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000a2	b8 00 00 00 00	 mov	 eax, __tryend$??$_Uninit_move@PAUCASTLEDEEP_MONSTERINFO@@PAU1@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@U1@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@PAU1@00AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1
  000a7	c3		 ret	 0
$LN10@Uninit_mov@3:
  000a8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_move@PAUCASTLEDEEP_MONSTERINFO@@PAU1@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@U1@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@PAU1@00AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1:

; 437  : 	return (_Dest);

  000af	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_mov@3:

; 438  : 	}

  000b2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000b5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000bc	59		 pop	 ecx
  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_move@PAUCASTLEDEEP_MONSTERINFO@@PAU1@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@U1@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@PAU1@00AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninit_move@PAUCASTLEDEEP_MONSTERINFO@@PAU1@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@U1@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@PAU1@00AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninit_move@PAUCASTLEDEEP_MONSTERINFO@@PAU1@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@U1@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@PAU1@00AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CASTLEDEEP_MONSTERINFO *,CASTLEDEEP_MONSTERINFO *,std::allocator<CASTLEDEEP_MONSTERINFO>,CASTLEDEEP_MONSTERINFO>
PUBLIC	?destroy@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEXPAUCASTLEDEEP_MONSTERINFO@@@Z ; std::allocator<CASTLEDEEP_MONSTERINFO>::destroy
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Dest_val@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@UCASTLEDEEP_MONSTERINFO@@@std@@YAXAAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@PAUCASTLEDEEP_MONSTERINFO@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@UCASTLEDEEP_MONSTERINFO@@@std@@YAXAAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@PAUCASTLEDEEP_MONSTERINFO@@@Z PROC ; std::_Dest_val<std::allocator<CASTLEDEEP_MONSTERINFO>,CASTLEDEEP_MONSTERINFO>, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 287  : 	_Alval.destroy(_Pdest);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  00010	e8 00 00 00 00	 call	 ?destroy@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEXPAUCASTLEDEEP_MONSTERINFO@@@Z ; std::allocator<CASTLEDEEP_MONSTERINFO>::destroy

; 288  : 	}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Dest_val@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@UCASTLEDEEP_MONSTERINFO@@@std@@YAXAAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@PAUCASTLEDEEP_MONSTERINFO@@@Z ENDP ; std::_Dest_val<std::allocator<CASTLEDEEP_MONSTERINFO>,CASTLEDEEP_MONSTERINFO>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > > &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > > &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@_N@std@@YA$$QA_NAA_N@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@_N@std@@YA$$QA_NAA_N@Z PROC			; std::forward<bool>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@_N@std@@YA$$QA_NAA_N@Z ENDP			; std::forward<bool>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > > &,bool>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > > &>
  00015	83 c4 04	 add	 esp, 4
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	89 0a		 mov	 DWORD PTR [edx], ecx
  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??$forward@_N@std@@YA$$QA_NAA_N@Z ; std::forward<bool>
  00028	83 c4 04	 add	 esp, 4
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	8a 10		 mov	 dl, BYTE PTR [eax]
  00030	88 51 04	 mov	 BYTE PTR [ecx+4], dl

; 164  : 		}

  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> > > &,bool>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > > &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > > &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > > &,bool>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > > &>
  00015	83 c4 04	 add	 esp, 4
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	89 0a		 mov	 DWORD PTR [edx], ecx
  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??$forward@_N@std@@YA$$QA_NAA_N@Z ; std::forward<bool>
  00028	83 c4 04	 add	 esp, 4
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	8a 10		 mov	 dl, BYTE PTR [eax]
  00030	88 51 04	 mov	 BYTE PTR [ecx+4], dl

; 164  : 		}

  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >,0> > > &,bool>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > > &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > > &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > > &,bool>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > > &>
  00015	83 c4 04	 add	 esp, 4
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	89 0a		 mov	 DWORD PTR [edx], ecx
  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??$forward@_N@std@@YA$$QA_NAA_N@Z ; std::forward<bool>
  00028	83 c4 04	 add	 esp, 4
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	8a 10		 mov	 dl, BYTE PTR [eax]
  00030	88 51 04	 mov	 BYTE PTR [ecx+4], dl

; 164  : 		}

  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >,0> > > &,bool>
_TEXT	ENDS
PUBLIC	??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@PAUCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@2@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@0PAU1@AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@@Z ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >,CASTLEDEEP_SPAWNTIME *,std::allocator<CASTLEDEEP_SPAWNTIME> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IAEPAUCASTLEDEEP_SPAWNTIME@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@0PAU2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IAEPAUCASTLEDEEP_SPAWNTIME@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@0PAU2@@Z PROC ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >, COMDAT
; _this$ = ecx

; 1315 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1316 : 		{	// copy initializing [_First, _Last), using allocator
; 1317 : 		return (_Uninitialized_copy(_First, _Last,
; 1318 : 			_Ptr, this->_Alval));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@PAUCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@2@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@0PAU1@AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@@Z ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >,CASTLEDEEP_SPAWNTIME *,std::allocator<CASTLEDEEP_SPAWNTIME> >
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 1319 : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IAEPAUCASTLEDEEP_SPAWNTIME@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@0PAU2@@Z ENDP ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@PAUCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@2@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@0PAU1@AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@@Z ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >,CASTLEDEEP_MONSTERINFO *,std::allocator<CASTLEDEEP_MONSTERINFO> >
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IAEPAUCASTLEDEEP_MONSTERINFO@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@0PAU2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IAEPAUCASTLEDEEP_MONSTERINFO@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@0PAU2@@Z PROC ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >, COMDAT
; _this$ = ecx

; 1315 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1316 : 		{	// copy initializing [_First, _Last), using allocator
; 1317 : 		return (_Uninitialized_copy(_First, _Last,
; 1318 : 			_Ptr, this->_Alval));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@PAUCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@2@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@0PAU1@AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@@Z ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >,CASTLEDEEP_MONSTERINFO *,std::allocator<CASTLEDEEP_MONSTERINFO> >
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 1319 : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IAEPAUCASTLEDEEP_MONSTERINFO@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@0PAU2@@Z ENDP ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >
_TEXT	ENDS
PUBLIC	??$_Destroy@UCASTLEDEEP_EVENTTIME@@@std@@YAXPAUCASTLEDEEP_EVENTTIME@@@Z ; std::_Destroy<CASTLEDEEP_EVENTTIME>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAEXPAUCASTLEDEEP_EVENTTIME@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAEXPAUCASTLEDEEP_EVENTTIME@@@Z PROC ; std::allocator<CASTLEDEEP_EVENTTIME>::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 213  : 		_Destroy(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Destroy@UCASTLEDEEP_EVENTTIME@@@std@@YAXPAUCASTLEDEEP_EVENTTIME@@@Z ; std::_Destroy<CASTLEDEEP_EVENTTIME>
  00015	83 c4 04	 add	 esp, 4

; 214  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?destroy@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAEXPAUCASTLEDEEP_EVENTTIME@@@Z ENDP ; std::allocator<CASTLEDEEP_EVENTTIME>::destroy
_TEXT	ENDS
PUBLIC	??$_Destroy@UCASTLEDEEP_SPAWNTIME@@@std@@YAXPAUCASTLEDEEP_SPAWNTIME@@@Z ; std::_Destroy<CASTLEDEEP_SPAWNTIME>
; Function compile flags: /Odtp /ZI
;	COMDAT ?destroy@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEXPAUCASTLEDEEP_SPAWNTIME@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEXPAUCASTLEDEEP_SPAWNTIME@@@Z PROC ; std::allocator<CASTLEDEEP_SPAWNTIME>::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 213  : 		_Destroy(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Destroy@UCASTLEDEEP_SPAWNTIME@@@std@@YAXPAUCASTLEDEEP_SPAWNTIME@@@Z ; std::_Destroy<CASTLEDEEP_SPAWNTIME>
  00015	83 c4 04	 add	 esp, 4

; 214  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?destroy@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEXPAUCASTLEDEEP_SPAWNTIME@@@Z ENDP ; std::allocator<CASTLEDEEP_SPAWNTIME>::destroy
_TEXT	ENDS
PUBLIC	??$_Destroy@UCASTLEDEEP_MONSTERINFO@@@std@@YAXPAUCASTLEDEEP_MONSTERINFO@@@Z ; std::_Destroy<CASTLEDEEP_MONSTERINFO>
; Function compile flags: /Odtp /ZI
;	COMDAT ?destroy@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEXPAUCASTLEDEEP_MONSTERINFO@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEXPAUCASTLEDEEP_MONSTERINFO@@@Z PROC ; std::allocator<CASTLEDEEP_MONSTERINFO>::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 213  : 		_Destroy(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Destroy@UCASTLEDEEP_MONSTERINFO@@@std@@YAXPAUCASTLEDEEP_MONSTERINFO@@@Z ; std::_Destroy<CASTLEDEEP_MONSTERINFO>
  00015	83 c4 04	 add	 esp, 4

; 214  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?destroy@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEXPAUCASTLEDEEP_MONSTERINFO@@@Z ENDP ; std::allocator<CASTLEDEEP_MONSTERINFO>::destroy
_TEXT	ENDS
PUBLIC	??$?0HH@?$pair@$$CBHH@std@@QAE@$$QAU?$pair@HH@1@@Z ; std::pair<int const ,int>::pair<int const ,int><int,int>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@U?$pair@HH@std@@@?$allocator@U?$pair@$$CBHH@std@@@std@@QAEXPAU?$pair@$$CBHH@1@$$QAU?$pair@HH@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@U?$pair@HH@std@@@?$allocator@U?$pair@$$CBHH@std@@@std@@QAEXPAU?$pair@$$CBHH@1@$$QAU?$pair@HH@1@@Z$0
__ehfuncinfo$??$construct@U?$pair@HH@std@@@?$allocator@U?$pair@$$CBHH@std@@@std@@QAEXPAU?$pair@$$CBHH@1@$$QAU?$pair@HH@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@U?$pair@HH@std@@@?$allocator@U?$pair@$$CBHH@std@@@std@@QAEXPAU?$pair@$$CBHH@1@$$QAU?$pair@HH@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$construct@U?$pair@HH@std@@@?$allocator@U?$pair@$$CBHH@std@@@std@@QAEXPAU?$pair@$$CBHH@1@$$QAU?$pair@HH@1@@Z
_TEXT	SEGMENT
tv76 = -92						; size = 4
$T240352 = -88						; size = 4
$T240353 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@U?$pair@HH@std@@@?$allocator@U?$pair@$$CBHH@std@@@std@@QAEXPAU?$pair@$$CBHH@1@$$QAU?$pair@HH@1@@Z PROC ; std::allocator<std::pair<int const ,int> >::construct<std::pair<int,int> >, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@U?$pair@HH@std@@@?$allocator@U?$pair@$$CBHH@std@@@std@@QAEXPAU?$pair@$$CBHH@1@$$QAU?$pair@HH@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 08		 push	 8
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T240353[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T240353[ebp], 0
  00047	74 1a		 je	 SHORT $LN3@construct@5
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@U?$pair@HH@std@@@std@@YA$$QAU?$pair@HH@0@AAU10@@Z ; std::forward<std::pair<int,int> >
  00052	83 c4 04	 add	 esp, 4
  00055	50		 push	 eax
  00056	8b 4d ac	 mov	 ecx, DWORD PTR $T240353[ebp]
  00059	e8 00 00 00 00	 call	 ??$?0HH@?$pair@$$CBHH@std@@QAE@$$QAU?$pair@HH@1@@Z ; std::pair<int const ,int>::pair<int const ,int><int,int>
  0005e	89 45 a4	 mov	 DWORD PTR tv76[ebp], eax
  00061	eb 07		 jmp	 SHORT $LN4@construct@5
$LN3@construct@5:
  00063	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN4@construct@5:
  0006a	8b 55 a4	 mov	 edx, DWORD PTR tv76[ebp]
  0006d	89 55 a8	 mov	 DWORD PTR $T240352[ebp], edx
  00070	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 209  : 		}

  00077	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00081	59		 pop	 ecx
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@U?$pair@HH@std@@@?$allocator@U?$pair@$$CBHH@std@@@std@@QAEXPAU?$pair@$$CBHH@1@$$QAU?$pair@HH@1@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T240353[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@U?$pair@HH@std@@@?$allocator@U?$pair@$$CBHH@std@@@std@@QAEXPAU?$pair@$$CBHH@1@$$QAU?$pair@HH@1@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@U?$pair@HH@std@@@?$allocator@U?$pair@$$CBHH@std@@@std@@QAEXPAU?$pair@$$CBHH@1@$$QAU?$pair@HH@1@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@U?$pair@HH@std@@@?$allocator@U?$pair@$$CBHH@std@@@std@@QAEXPAU?$pair@$$CBHH@1@$$QAU?$pair@HH@1@@Z ENDP ; std::allocator<std::pair<int const ,int> >::construct<std::pair<int,int> >
PUBLIC	??$?0HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z ; std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > ><int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@QAEXPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@QAEXPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z$0
__ehfuncinfo$??$construct@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@QAEXPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@QAEXPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$construct@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@QAEXPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
tv76 = -92						; size = 4
$T240365 = -88						; size = 4
$T240366 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@QAEXPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z PROC ; std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >::construct<std::pair<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@QAEXPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 14		 push	 20			; 00000014H
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T240366[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T240366[ebp], 0
  00047	74 1a		 je	 SHORT $LN3@construct@6
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@YA$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@AAU10@@Z ; std::forward<std::pair<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >
  00052	83 c4 04	 add	 esp, 4
  00055	50		 push	 eax
  00056	8b 4d ac	 mov	 ecx, DWORD PTR $T240366[ebp]
  00059	e8 00 00 00 00	 call	 ??$?0HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z ; std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > ><int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >
  0005e	89 45 a4	 mov	 DWORD PTR tv76[ebp], eax
  00061	eb 07		 jmp	 SHORT $LN4@construct@6
$LN3@construct@6:
  00063	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN4@construct@6:
  0006a	8b 55 a4	 mov	 edx, DWORD PTR tv76[ebp]
  0006d	89 55 a8	 mov	 DWORD PTR $T240365[ebp], edx
  00070	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 209  : 		}

  00077	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00081	59		 pop	 ecx
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@QAEXPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T240366[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@QAEXPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@QAEXPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@U?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@@std@@QAEXPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z ENDP ; std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >::construct<std::pair<int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > > >
PUBLIC	??$?0HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z ; std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > ><int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@QAEXPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@QAEXPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z$0
__ehfuncinfo$??$construct@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@QAEXPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@QAEXPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$construct@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@QAEXPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
tv76 = -92						; size = 4
$T240378 = -88						; size = 4
$T240379 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@QAEXPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z PROC ; std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >::construct<std::pair<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@QAEXPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 14		 push	 20			; 00000014H
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T240379[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T240379[ebp], 0
  00047	74 1a		 je	 SHORT $LN3@construct@7
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@YA$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@AAU10@@Z ; std::forward<std::pair<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >
  00052	83 c4 04	 add	 esp, 4
  00055	50		 push	 eax
  00056	8b 4d ac	 mov	 ecx, DWORD PTR $T240379[ebp]
  00059	e8 00 00 00 00	 call	 ??$?0HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z ; std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > ><int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >
  0005e	89 45 a4	 mov	 DWORD PTR tv76[ebp], eax
  00061	eb 07		 jmp	 SHORT $LN4@construct@7
$LN3@construct@7:
  00063	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN4@construct@7:
  0006a	8b 55 a4	 mov	 edx, DWORD PTR tv76[ebp]
  0006d	89 55 a8	 mov	 DWORD PTR $T240378[ebp], edx
  00070	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 209  : 		}

  00077	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00081	59		 pop	 ecx
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@QAEXPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T240379[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@QAEXPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@QAEXPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@U?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@?$allocator@U?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@@std@@QAEXPAU?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z ENDP ; std::allocator<std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >::construct<std::pair<int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > > >
PUBLIC	?construct@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAEXPAUCASTLEDEEP_EVENTTIME@@$$QAU3@@Z ; std::allocator<CASTLEDEEP_EVENTTIME>::construct
PUBLIC	??$forward@UCASTLEDEEP_EVENTTIME@@@std@@YA$$QAUCASTLEDEEP_EVENTTIME@@AAU1@@Z ; std::forward<CASTLEDEEP_EVENTTIME>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@UCASTLEDEEP_EVENTTIME@@U3@@std@@YAXAAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@PAUCASTLEDEEP_EVENTTIME@@$$QAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@UCASTLEDEEP_EVENTTIME@@U3@@std@@YAXAAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@PAUCASTLEDEEP_EVENTTIME@@$$QAU2@@Z PROC ; std::_Cons_val<std::allocator<CASTLEDEEP_EVENTTIME>,CASTLEDEEP_EVENTTIME,CASTLEDEEP_EVENTTIME>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@UCASTLEDEEP_EVENTTIME@@@std@@YA$$QAUCASTLEDEEP_EVENTTIME@@AAU1@@Z ; std::forward<CASTLEDEEP_EVENTTIME>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAEXPAUCASTLEDEEP_EVENTTIME@@$$QAU3@@Z ; std::allocator<CASTLEDEEP_EVENTTIME>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@UCASTLEDEEP_EVENTTIME@@U3@@std@@YAXAAV?$allocator@UCASTLEDEEP_EVENTTIME@@@0@PAUCASTLEDEEP_EVENTTIME@@$$QAU2@@Z ENDP ; std::_Cons_val<std::allocator<CASTLEDEEP_EVENTTIME>,CASTLEDEEP_EVENTTIME,CASTLEDEEP_EVENTTIME>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEXPAUCASTLEDEEP_SPAWNTIME@@$$QAU3@@Z ; std::allocator<CASTLEDEEP_SPAWNTIME>::construct
PUBLIC	??$forward@UCASTLEDEEP_SPAWNTIME@@@std@@YA$$QAUCASTLEDEEP_SPAWNTIME@@AAU1@@Z ; std::forward<CASTLEDEEP_SPAWNTIME>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@UCASTLEDEEP_SPAWNTIME@@U3@@std@@YAXAAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@PAUCASTLEDEEP_SPAWNTIME@@$$QAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@UCASTLEDEEP_SPAWNTIME@@U3@@std@@YAXAAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@PAUCASTLEDEEP_SPAWNTIME@@$$QAU2@@Z PROC ; std::_Cons_val<std::allocator<CASTLEDEEP_SPAWNTIME>,CASTLEDEEP_SPAWNTIME,CASTLEDEEP_SPAWNTIME>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@UCASTLEDEEP_SPAWNTIME@@@std@@YA$$QAUCASTLEDEEP_SPAWNTIME@@AAU1@@Z ; std::forward<CASTLEDEEP_SPAWNTIME>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEXPAUCASTLEDEEP_SPAWNTIME@@$$QAU3@@Z ; std::allocator<CASTLEDEEP_SPAWNTIME>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@UCASTLEDEEP_SPAWNTIME@@U3@@std@@YAXAAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@PAUCASTLEDEEP_SPAWNTIME@@$$QAU2@@Z ENDP ; std::_Cons_val<std::allocator<CASTLEDEEP_SPAWNTIME>,CASTLEDEEP_SPAWNTIME,CASTLEDEEP_SPAWNTIME>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEXPAUCASTLEDEEP_MONSTERINFO@@$$QAU3@@Z ; std::allocator<CASTLEDEEP_MONSTERINFO>::construct
PUBLIC	??$forward@UCASTLEDEEP_MONSTERINFO@@@std@@YA$$QAUCASTLEDEEP_MONSTERINFO@@AAU1@@Z ; std::forward<CASTLEDEEP_MONSTERINFO>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@UCASTLEDEEP_MONSTERINFO@@U3@@std@@YAXAAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@PAUCASTLEDEEP_MONSTERINFO@@$$QAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@UCASTLEDEEP_MONSTERINFO@@U3@@std@@YAXAAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@PAUCASTLEDEEP_MONSTERINFO@@$$QAU2@@Z PROC ; std::_Cons_val<std::allocator<CASTLEDEEP_MONSTERINFO>,CASTLEDEEP_MONSTERINFO,CASTLEDEEP_MONSTERINFO>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@UCASTLEDEEP_MONSTERINFO@@@std@@YA$$QAUCASTLEDEEP_MONSTERINFO@@AAU1@@Z ; std::forward<CASTLEDEEP_MONSTERINFO>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEXPAUCASTLEDEEP_MONSTERINFO@@$$QAU3@@Z ; std::allocator<CASTLEDEEP_MONSTERINFO>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@UCASTLEDEEP_MONSTERINFO@@U3@@std@@YAXAAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@PAUCASTLEDEEP_MONSTERINFO@@$$QAU2@@Z ENDP ; std::_Cons_val<std::allocator<CASTLEDEEP_MONSTERINFO>,CASTLEDEEP_MONSTERINFO,CASTLEDEEP_MONSTERINFO>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@PAUCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@2@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@0PAU1@AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >,CASTLEDEEP_SPAWNTIME *,std::allocator<CASTLEDEEP_SPAWNTIME> >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@PAUCASTLEDEEP_SPAWNTIME@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@AAPAUCASTLEDEEP_SPAWNTIME@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >,CASTLEDEEP_SPAWNTIME *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@PAUCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@2@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@0PAU1@AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@@Z
_TEXT	SEGMENT
$T240397 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@PAUCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@2@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@0PAU1@AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@@Z PROC ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >,CASTLEDEEP_SPAWNTIME *,std::allocator<CASTLEDEEP_SPAWNTIME> >, COMDAT

; 412  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 413  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 414  : 		_Ptr_cat(_First, _Dest)));

  00009	8d 45 10	 lea	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@PAUCASTLEDEEP_SPAWNTIME@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@AAPAUCASTLEDEEP_SPAWNTIME@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >,CASTLEDEEP_SPAWNTIME *>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T240397[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T240397[ebp]
  00020	52		 push	 edx
  00021	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0002c	52		 push	 edx
  0002d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@PAUCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@2@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@0PAU1@AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >,CASTLEDEEP_SPAWNTIME *,std::allocator<CASTLEDEEP_SPAWNTIME> >
  00036	83 c4 14	 add	 esp, 20			; 00000014H

; 415  : 	}

  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@PAUCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@2@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@0PAU1@AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@@Z ENDP ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >,CASTLEDEEP_SPAWNTIME *,std::allocator<CASTLEDEEP_SPAWNTIME> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@PAUCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@2@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@0PAU1@AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >,CASTLEDEEP_MONSTERINFO *,std::allocator<CASTLEDEEP_MONSTERINFO> >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@PAUCASTLEDEEP_MONSTERINFO@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@AAPAUCASTLEDEEP_MONSTERINFO@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >,CASTLEDEEP_MONSTERINFO *>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@PAUCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@2@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@0PAU1@AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@@Z
_TEXT	SEGMENT
$T240400 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@PAUCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@2@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@0PAU1@AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@@Z PROC ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >,CASTLEDEEP_MONSTERINFO *,std::allocator<CASTLEDEEP_MONSTERINFO> >, COMDAT

; 412  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 413  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 414  : 		_Ptr_cat(_First, _Dest)));

  00009	8d 45 10	 lea	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@PAUCASTLEDEEP_MONSTERINFO@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@AAPAUCASTLEDEEP_MONSTERINFO@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >,CASTLEDEEP_MONSTERINFO *>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T240400[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T240400[ebp]
  00020	52		 push	 edx
  00021	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0002c	52		 push	 edx
  0002d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@PAUCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@2@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@0PAU1@AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >,CASTLEDEEP_MONSTERINFO *,std::allocator<CASTLEDEEP_MONSTERINFO> >
  00036	83 c4 14	 add	 esp, 20			; 00000014H

; 415  : 	}

  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@PAUCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@2@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@0PAU1@AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@@Z ENDP ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >,CASTLEDEEP_MONSTERINFO *,std::allocator<CASTLEDEEP_MONSTERINFO> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy@UCASTLEDEEP_EVENTTIME@@@std@@YAXPAUCASTLEDEEP_EVENTTIME@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UCASTLEDEEP_EVENTTIME@@@std@@YAXPAUCASTLEDEEP_EVENTTIME@@@Z PROC ; std::_Destroy<CASTLEDEEP_EVENTTIME>, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Destroy@UCASTLEDEEP_EVENTTIME@@@std@@YAXPAUCASTLEDEEP_EVENTTIME@@@Z ENDP ; std::_Destroy<CASTLEDEEP_EVENTTIME>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Destroy@UCASTLEDEEP_SPAWNTIME@@@std@@YAXPAUCASTLEDEEP_SPAWNTIME@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UCASTLEDEEP_SPAWNTIME@@@std@@YAXPAUCASTLEDEEP_SPAWNTIME@@@Z PROC ; std::_Destroy<CASTLEDEEP_SPAWNTIME>, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Destroy@UCASTLEDEEP_SPAWNTIME@@@std@@YAXPAUCASTLEDEEP_SPAWNTIME@@@Z ENDP ; std::_Destroy<CASTLEDEEP_SPAWNTIME>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Destroy@UCASTLEDEEP_MONSTERINFO@@@std@@YAXPAUCASTLEDEEP_MONSTERINFO@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UCASTLEDEEP_MONSTERINFO@@@std@@YAXPAUCASTLEDEEP_MONSTERINFO@@@Z PROC ; std::_Destroy<CASTLEDEEP_MONSTERINFO>, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Destroy@UCASTLEDEEP_MONSTERINFO@@@std@@YAXPAUCASTLEDEEP_MONSTERINFO@@@Z ENDP ; std::_Destroy<CASTLEDEEP_MONSTERINFO>
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAEXPAUCASTLEDEEP_EVENTTIME@@$$QAU3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAEXPAUCASTLEDEEP_EVENTTIME@@$$QAU3@@Z$0
__ehfuncinfo$?construct@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAEXPAUCASTLEDEEP_EVENTTIME@@$$QAU3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAEXPAUCASTLEDEEP_EVENTTIME@@$$QAU3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAEXPAUCASTLEDEEP_EVENTTIME@@$$QAU3@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T240409 = -88						; size = 4
$T240410 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAEXPAUCASTLEDEEP_EVENTTIME@@$$QAU3@@Z PROC ; std::allocator<CASTLEDEEP_EVENTTIME>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?construct@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAEXPAUCASTLEDEEP_EVENTTIME@@$$QAU3@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 08		 push	 8
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T240410[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T240410[ebp], 0
  00047	74 21		 je	 SHORT $LN3@construct@8
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@UCASTLEDEEP_EVENTTIME@@@std@@YA$$QAUCASTLEDEEP_EVENTTIME@@AAU1@@Z ; std::forward<CASTLEDEEP_EVENTTIME>
  00052	83 c4 04	 add	 esp, 4
  00055	8b 10		 mov	 edx, DWORD PTR [eax]
  00057	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005a	8b 4d ac	 mov	 ecx, DWORD PTR $T240410[ebp]
  0005d	89 11		 mov	 DWORD PTR [ecx], edx
  0005f	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00062	8b 55 ac	 mov	 edx, DWORD PTR $T240410[ebp]
  00065	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  00068	eb 07		 jmp	 SHORT $LN4@construct@8
$LN3@construct@8:
  0006a	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct@8:
  00071	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00074	89 45 a8	 mov	 DWORD PTR $T240409[ebp], eax
  00077	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 203  : 		}

  0007e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00081	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00088	59		 pop	 ecx
  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAEXPAUCASTLEDEEP_EVENTTIME@@$$QAU3@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T240410[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$?construct@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAEXPAUCASTLEDEEP_EVENTTIME@@$$QAU3@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?construct@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAEXPAUCASTLEDEEP_EVENTTIME@@$$QAU3@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@UCASTLEDEEP_EVENTTIME@@@std@@QAEXPAUCASTLEDEEP_EVENTTIME@@$$QAU3@@Z ENDP ; std::allocator<CASTLEDEEP_EVENTTIME>::construct
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEXPAUCASTLEDEEP_SPAWNTIME@@$$QAU3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEXPAUCASTLEDEEP_SPAWNTIME@@$$QAU3@@Z$0
__ehfuncinfo$?construct@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEXPAUCASTLEDEEP_SPAWNTIME@@$$QAU3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEXPAUCASTLEDEEP_SPAWNTIME@@$$QAU3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEXPAUCASTLEDEEP_SPAWNTIME@@$$QAU3@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T240422 = -88						; size = 4
$T240423 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEXPAUCASTLEDEEP_SPAWNTIME@@$$QAU3@@Z PROC ; std::allocator<CASTLEDEEP_SPAWNTIME>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?construct@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEXPAUCASTLEDEEP_SPAWNTIME@@$$QAU3@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 08		 push	 8
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T240423[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T240423[ebp], 0
  00047	74 21		 je	 SHORT $LN3@construct@9
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@UCASTLEDEEP_SPAWNTIME@@@std@@YA$$QAUCASTLEDEEP_SPAWNTIME@@AAU1@@Z ; std::forward<CASTLEDEEP_SPAWNTIME>
  00052	83 c4 04	 add	 esp, 4
  00055	8b 10		 mov	 edx, DWORD PTR [eax]
  00057	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005a	8b 4d ac	 mov	 ecx, DWORD PTR $T240423[ebp]
  0005d	89 11		 mov	 DWORD PTR [ecx], edx
  0005f	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00062	8b 55 ac	 mov	 edx, DWORD PTR $T240423[ebp]
  00065	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  00068	eb 07		 jmp	 SHORT $LN4@construct@9
$LN3@construct@9:
  0006a	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct@9:
  00071	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00074	89 45 a8	 mov	 DWORD PTR $T240422[ebp], eax
  00077	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 203  : 		}

  0007e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00081	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00088	59		 pop	 ecx
  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEXPAUCASTLEDEEP_SPAWNTIME@@$$QAU3@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T240423[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$?construct@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEXPAUCASTLEDEEP_SPAWNTIME@@$$QAU3@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?construct@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEXPAUCASTLEDEEP_SPAWNTIME@@$$QAU3@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAEXPAUCASTLEDEEP_SPAWNTIME@@$$QAU3@@Z ENDP ; std::allocator<CASTLEDEEP_SPAWNTIME>::construct
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEXPAUCASTLEDEEP_MONSTERINFO@@$$QAU3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEXPAUCASTLEDEEP_MONSTERINFO@@$$QAU3@@Z$0
__ehfuncinfo$?construct@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEXPAUCASTLEDEEP_MONSTERINFO@@$$QAU3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEXPAUCASTLEDEEP_MONSTERINFO@@$$QAU3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEXPAUCASTLEDEEP_MONSTERINFO@@$$QAU3@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T240435 = -88						; size = 4
$T240436 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEXPAUCASTLEDEEP_MONSTERINFO@@$$QAU3@@Z PROC ; std::allocator<CASTLEDEEP_MONSTERINFO>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?construct@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEXPAUCASTLEDEEP_MONSTERINFO@@$$QAU3@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 1c		 push	 28			; 0000001cH
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T240436[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T240436[ebp], 0
  00047	74 20		 je	 SHORT $LN3@construct@10
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@UCASTLEDEEP_MONSTERINFO@@@std@@YA$$QAUCASTLEDEEP_MONSTERINFO@@AAU1@@Z ; std::forward<CASTLEDEEP_MONSTERINFO>
  00052	83 c4 04	 add	 esp, 4
  00055	b9 07 00 00 00	 mov	 ecx, 7
  0005a	8b f0		 mov	 esi, eax
  0005c	8b 7d ac	 mov	 edi, DWORD PTR $T240436[ebp]
  0005f	f3 a5		 rep movsd
  00061	8b 55 ac	 mov	 edx, DWORD PTR $T240436[ebp]
  00064	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  00067	eb 07		 jmp	 SHORT $LN4@construct@10
$LN3@construct@10:
  00069	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct@10:
  00070	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00073	89 45 a8	 mov	 DWORD PTR $T240435[ebp], eax
  00076	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 203  : 		}

  0007d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00080	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00087	59		 pop	 ecx
  00088	5f		 pop	 edi
  00089	5e		 pop	 esi
  0008a	5b		 pop	 ebx
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEXPAUCASTLEDEEP_MONSTERINFO@@$$QAU3@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T240436[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$?construct@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEXPAUCASTLEDEEP_MONSTERINFO@@$$QAU3@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?construct@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEXPAUCASTLEDEEP_MONSTERINFO@@$$QAU3@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAEXPAUCASTLEDEEP_MONSTERINFO@@$$QAU3@@Z ENDP ; std::allocator<CASTLEDEEP_MONSTERINFO>::construct
PUBLIC	??$?0HH@?$_Pair_base@$$CBHH@std@@QAE@$$QAH0@Z	; std::_Pair_base<int const ,int>::_Pair_base<int const ,int><int,int>
PUBLIC	??$forward@H@std@@YA$$QAHAAH@Z			; std::forward<int>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$?0HH@?$pair@$$CBHH@std@@QAE@$$QAU?$pair@HH@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??$?0HH@?$pair@$$CBHH@std@@QAE@$$QAU?$pair@HH@1@@Z PROC	; std::pair<int const ,int>::pair<int const ,int><int,int>, COMDAT
; _this$ = ecx

; 255  : 		{	// construct from moved compatible pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	83 c0 04	 add	 eax, 4
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??$forward@H@std@@YA$$QAHAAH@Z ; std::forward<int>
  00018	83 c4 04	 add	 esp, 4
  0001b	50		 push	 eax
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ??$forward@H@std@@YA$$QAHAAH@Z ; std::forward<int>
  00025	83 c4 04	 add	 esp, 4
  00028	50		 push	 eax
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ??$?0HH@?$_Pair_base@$$CBHH@std@@QAE@$$QAH0@Z ; std::_Pair_base<int const ,int>::_Pair_base<int const ,int><int,int>

; 256  : 		}

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
??$?0HH@?$pair@$$CBHH@std@@QAE@$$QAU?$pair@HH@1@@Z ENDP	; std::pair<int const ,int>::pair<int const ,int><int,int>
_TEXT	ENDS
PUBLIC	??$?0HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@?$_Pair_base@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@$$QAH$$QAV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@1@@Z ; std::_Pair_base<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::_Pair_base<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > ><int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >
PUBLIC	??$forward@V?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@YA$$QAV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@0@AAV10@@Z ; std::forward<std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ??$?0HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??$?0HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z PROC ; std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > ><int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >, COMDAT
; _this$ = ecx

; 255  : 		{	// construct from moved compatible pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	83 c0 04	 add	 eax, 4
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??$forward@V?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@YA$$QAV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@0@AAV10@@Z ; std::forward<std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >
  00018	83 c4 04	 add	 esp, 4
  0001b	50		 push	 eax
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ??$forward@H@std@@YA$$QAHAAH@Z ; std::forward<int>
  00025	83 c4 04	 add	 esp, 4
  00028	50		 push	 eax
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ??$?0HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@?$_Pair_base@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@$$QAH$$QAV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@1@@Z ; std::_Pair_base<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::_Pair_base<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > ><int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >

; 256  : 		}

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
??$?0HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@?$pair@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@$$QAU?$pair@HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@1@@Z ENDP ; std::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::pair<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > ><int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >
_TEXT	ENDS
PUBLIC	??$?0HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@?$_Pair_base@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@$$QAH$$QAV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@1@@Z ; std::_Pair_base<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::_Pair_base<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > ><int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >
PUBLIC	??$forward@V?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@YA$$QAV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@0@AAV10@@Z ; std::forward<std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ??$?0HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??$?0HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z PROC ; std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > ><int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >, COMDAT
; _this$ = ecx

; 255  : 		{	// construct from moved compatible pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	83 c0 04	 add	 eax, 4
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??$forward@V?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@YA$$QAV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@0@AAV10@@Z ; std::forward<std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >
  00018	83 c4 04	 add	 esp, 4
  0001b	50		 push	 eax
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ??$forward@H@std@@YA$$QAHAAH@Z ; std::forward<int>
  00025	83 c4 04	 add	 esp, 4
  00028	50		 push	 eax
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ??$?0HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@?$_Pair_base@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@$$QAH$$QAV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@1@@Z ; std::_Pair_base<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::_Pair_base<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > ><int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >

; 256  : 		}

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
??$?0HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@?$pair@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@$$QAU?$pair@HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@1@@Z ENDP ; std::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::pair<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > ><int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@UCASTLEDEEP_EVENTTIME@@@std@@YA$$QAUCASTLEDEEP_EVENTTIME@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UCASTLEDEEP_EVENTTIME@@@std@@YA$$QAUCASTLEDEEP_EVENTTIME@@AAU1@@Z PROC ; std::forward<CASTLEDEEP_EVENTTIME>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@UCASTLEDEEP_EVENTTIME@@@std@@YA$$QAUCASTLEDEEP_EVENTTIME@@AAU1@@Z ENDP ; std::forward<CASTLEDEEP_EVENTTIME>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@UCASTLEDEEP_SPAWNTIME@@@std@@YA$$QAUCASTLEDEEP_SPAWNTIME@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UCASTLEDEEP_SPAWNTIME@@@std@@YA$$QAUCASTLEDEEP_SPAWNTIME@@AAU1@@Z PROC ; std::forward<CASTLEDEEP_SPAWNTIME>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@UCASTLEDEEP_SPAWNTIME@@@std@@YA$$QAUCASTLEDEEP_SPAWNTIME@@AAU1@@Z ENDP ; std::forward<CASTLEDEEP_SPAWNTIME>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@UCASTLEDEEP_MONSTERINFO@@@std@@YA$$QAUCASTLEDEEP_MONSTERINFO@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UCASTLEDEEP_MONSTERINFO@@@std@@YA$$QAUCASTLEDEEP_MONSTERINFO@@AAU1@@Z PROC ; std::forward<CASTLEDEEP_MONSTERINFO>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@UCASTLEDEEP_MONSTERINFO@@@std@@YA$$QAUCASTLEDEEP_MONSTERINFO@@AAU1@@Z ENDP ; std::forward<CASTLEDEEP_MONSTERINFO>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@PAUCASTLEDEEP_SPAWNTIME@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@AAPAUCASTLEDEEP_SPAWNTIME@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@PAUCASTLEDEEP_SPAWNTIME@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@AAPAUCASTLEDEEP_SPAWNTIME@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >,CASTLEDEEP_SPAWNTIME *>, COMDAT

; 485  : 	{	// return pointer category from arbitrary arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 486  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 487  : 	return (_Cat);

  00009	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 488  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@PAUCASTLEDEEP_SPAWNTIME@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@AAPAUCASTLEDEEP_SPAWNTIME@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >,CASTLEDEEP_SPAWNTIME *>
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@PAUCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@2@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@0PAU1@AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@PAUCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@2@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@0PAU1@AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@PAUCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@2@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@0PAU1@AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@PAUCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@2@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@0PAU1@AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@PAUCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@2@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@0PAU1@AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@PAUCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@2@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@0PAU1@AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@PAUCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@2@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@0PAU1@AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@PAUCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@2@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@0PAU1@AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@PAUCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@2@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@0PAU1@AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
tv84 = -88						; size = 4
tv83 = -85						; size = 1
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@PAUCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@2@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@0PAU1@AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >,CASTLEDEEP_SPAWNTIME *,std::allocator<CASTLEDEEP_SPAWNTIME> >, COMDAT

; 369  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@PAUCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@2@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@0PAU1@AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 48	 sub	 esp, 72			; 00000048H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 370  : 	_DEBUG_RANGE(_First, _Last);
; 371  : 	_DEBUG_POINTER(_Dest);
; 372  : 	_FwdIt _Next = _Dest;

  0002c	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0002f	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 373  : 
; 374  : 	_TRY_BEGIN

  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00039	eb 11		 jmp	 SHORT $LN6@Uninit_cop
$LN5@Uninit_cop:

; 375  : 	for (; _First != _Last; ++_Dest, ++_First)

  0003b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0003e	83 c0 08	 add	 eax, 8
  00041	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00044	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  00047	e8 00 00 00 00	 call	 ??E?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::operator++
$LN6@Uninit_cop:
  0004c	8d 45 0c	 lea	 eax, DWORD PTR __Last$[ebp]
  0004f	50		 push	 eax
  00050	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  00053	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::operator!=
  00058	88 45 ab	 mov	 BYTE PTR tv83[ebp], al
  0005b	0f b6 4d ab	 movzx	 ecx, BYTE PTR tv83[ebp]
  0005f	85 c9		 test	 ecx, ecx
  00061	74 21		 je	 SHORT $LN4@Uninit_cop

; 376  : 		_Cons_val(_Al, _Dest, *_First);

  00063	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  00066	e8 00 00 00 00	 call	 ??D?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QBEABUCASTLEDEEP_SPAWNTIME@@XZ ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::operator*
  0006b	89 45 a8	 mov	 DWORD PTR tv84[ebp], eax
  0006e	8b 45 a8	 mov	 eax, DWORD PTR tv84[ebp]
  00071	50		 push	 eax
  00072	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00075	51		 push	 ecx
  00076	8b 55 14	 mov	 edx, DWORD PTR __Al$[ebp]
  00079	52		 push	 edx
  0007a	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@UCASTLEDEEP_SPAWNTIME@@ABU3@@std@@YAXAAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@PAUCASTLEDEEP_SPAWNTIME@@ABU2@@Z ; std::_Cons_val<std::allocator<CASTLEDEEP_SPAWNTIME>,CASTLEDEEP_SPAWNTIME,CASTLEDEEP_SPAWNTIME const &>
  0007f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00082	eb b7		 jmp	 SHORT $LN5@Uninit_cop
$LN4@Uninit_cop:
  00084	eb 3b		 jmp	 SHORT $LN10@Uninit_cop
__catch$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@PAUCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@2@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@0PAU1@AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 377  : 	_CATCH_ALL

  00086	eb 09		 jmp	 SHORT $LN3@Uninit_cop
$LN2@Uninit_cop:

; 378  : 	for (; _Next != _Dest; ++_Next)

  00088	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  0008b	83 c0 08	 add	 eax, 8
  0008e	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop:
  00091	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00094	3b 45 10	 cmp	 eax, DWORD PTR __Dest$[ebp]
  00097	74 12		 je	 SHORT $LN1@Uninit_cop

; 379  : 		_Dest_val(_Al, _Next);

  00099	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  0009c	50		 push	 eax
  0009d	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  000a0	51		 push	 ecx
  000a1	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@UCASTLEDEEP_SPAWNTIME@@@std@@YAXAAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@PAUCASTLEDEEP_SPAWNTIME@@@Z ; std::_Dest_val<std::allocator<CASTLEDEEP_SPAWNTIME>,CASTLEDEEP_SPAWNTIME>
  000a6	83 c4 08	 add	 esp, 8
  000a9	eb dd		 jmp	 SHORT $LN2@Uninit_cop
$LN1@Uninit_cop:

; 380  : 	_RERAISE;

  000ab	6a 00		 push	 0
  000ad	6a 00		 push	 0
  000af	e8 00 00 00 00	 call	 __CxxThrowException@8

; 381  : 	_CATCH_END

  000b4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000bb	b8 00 00 00 00	 mov	 eax, __tryend$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@PAUCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@2@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@0PAU1@AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$1
  000c0	c3		 ret	 0
$LN10@Uninit_cop:
  000c1	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@PAUCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@2@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@0PAU1@AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$1:

; 382  : 	return (_Dest);

  000c8	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop:

; 383  : 	}

  000cb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000ce	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d5	59		 pop	 ecx
  000d6	5f		 pop	 edi
  000d7	5e		 pop	 esi
  000d8	5b		 pop	 ebx
  000d9	8b e5		 mov	 esp, ebp
  000db	5d		 pop	 ebp
  000dc	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@PAUCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@2@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@0PAU1@AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a4	 mov	 ecx, DWORD PTR [edx-92]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@PAUCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@2@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@0PAU1@AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@PAUCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@2@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@0@0PAU1@AAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >,CASTLEDEEP_SPAWNTIME *,std::allocator<CASTLEDEEP_SPAWNTIME> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@PAUCASTLEDEEP_MONSTERINFO@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@AAPAUCASTLEDEEP_MONSTERINFO@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@PAUCASTLEDEEP_MONSTERINFO@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@AAPAUCASTLEDEEP_MONSTERINFO@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >,CASTLEDEEP_MONSTERINFO *>, COMDAT

; 485  : 	{	// return pointer category from arbitrary arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 486  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 487  : 	return (_Cat);

  00009	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 488  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@PAUCASTLEDEEP_MONSTERINFO@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@AAPAUCASTLEDEEP_MONSTERINFO@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >,CASTLEDEEP_MONSTERINFO *>
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@PAUCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@2@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@0PAU1@AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@PAUCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@2@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@0PAU1@AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@PAUCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@2@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@0PAU1@AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@PAUCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@2@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@0PAU1@AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@PAUCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@2@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@0PAU1@AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@PAUCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@2@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@0PAU1@AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@PAUCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@2@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@0PAU1@AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@PAUCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@2@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@0PAU1@AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@PAUCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@2@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@0PAU1@AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
tv84 = -88						; size = 4
tv83 = -85						; size = 1
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@PAUCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@2@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@0PAU1@AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >,CASTLEDEEP_MONSTERINFO *,std::allocator<CASTLEDEEP_MONSTERINFO> >, COMDAT

; 369  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@PAUCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@2@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@0PAU1@AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 48	 sub	 esp, 72			; 00000048H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 370  : 	_DEBUG_RANGE(_First, _Last);
; 371  : 	_DEBUG_POINTER(_Dest);
; 372  : 	_FwdIt _Next = _Dest;

  0002c	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0002f	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 373  : 
; 374  : 	_TRY_BEGIN

  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00039	eb 11		 jmp	 SHORT $LN6@Uninit_cop@2
$LN5@Uninit_cop@2:

; 375  : 	for (; _First != _Last; ++_Dest, ++_First)

  0003b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0003e	83 c0 1c	 add	 eax, 28			; 0000001cH
  00041	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00044	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  00047	e8 00 00 00 00	 call	 ??E?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::operator++
$LN6@Uninit_cop@2:
  0004c	8d 45 0c	 lea	 eax, DWORD PTR __Last$[ebp]
  0004f	50		 push	 eax
  00050	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  00053	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::operator!=
  00058	88 45 ab	 mov	 BYTE PTR tv83[ebp], al
  0005b	0f b6 4d ab	 movzx	 ecx, BYTE PTR tv83[ebp]
  0005f	85 c9		 test	 ecx, ecx
  00061	74 21		 je	 SHORT $LN4@Uninit_cop@2

; 376  : 		_Cons_val(_Al, _Dest, *_First);

  00063	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  00066	e8 00 00 00 00	 call	 ??D?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QBEABUCASTLEDEEP_MONSTERINFO@@XZ ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::operator*
  0006b	89 45 a8	 mov	 DWORD PTR tv84[ebp], eax
  0006e	8b 45 a8	 mov	 eax, DWORD PTR tv84[ebp]
  00071	50		 push	 eax
  00072	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00075	51		 push	 ecx
  00076	8b 55 14	 mov	 edx, DWORD PTR __Al$[ebp]
  00079	52		 push	 edx
  0007a	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@UCASTLEDEEP_MONSTERINFO@@ABU3@@std@@YAXAAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@PAUCASTLEDEEP_MONSTERINFO@@ABU2@@Z ; std::_Cons_val<std::allocator<CASTLEDEEP_MONSTERINFO>,CASTLEDEEP_MONSTERINFO,CASTLEDEEP_MONSTERINFO const &>
  0007f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00082	eb b7		 jmp	 SHORT $LN5@Uninit_cop@2
$LN4@Uninit_cop@2:
  00084	eb 3b		 jmp	 SHORT $LN10@Uninit_cop@2
__catch$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@PAUCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@2@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@0PAU1@AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 377  : 	_CATCH_ALL

  00086	eb 09		 jmp	 SHORT $LN3@Uninit_cop@2
$LN2@Uninit_cop@2:

; 378  : 	for (; _Next != _Dest; ++_Next)

  00088	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  0008b	83 c0 1c	 add	 eax, 28			; 0000001cH
  0008e	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@2:
  00091	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00094	3b 45 10	 cmp	 eax, DWORD PTR __Dest$[ebp]
  00097	74 12		 je	 SHORT $LN1@Uninit_cop@2

; 379  : 		_Dest_val(_Al, _Next);

  00099	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  0009c	50		 push	 eax
  0009d	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  000a0	51		 push	 ecx
  000a1	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@UCASTLEDEEP_MONSTERINFO@@@std@@YAXAAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@PAUCASTLEDEEP_MONSTERINFO@@@Z ; std::_Dest_val<std::allocator<CASTLEDEEP_MONSTERINFO>,CASTLEDEEP_MONSTERINFO>
  000a6	83 c4 08	 add	 esp, 8
  000a9	eb dd		 jmp	 SHORT $LN2@Uninit_cop@2
$LN1@Uninit_cop@2:

; 380  : 	_RERAISE;

  000ab	6a 00		 push	 0
  000ad	6a 00		 push	 0
  000af	e8 00 00 00 00	 call	 __CxxThrowException@8

; 381  : 	_CATCH_END

  000b4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000bb	b8 00 00 00 00	 mov	 eax, __tryend$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@PAUCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@2@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@0PAU1@AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$1
  000c0	c3		 ret	 0
$LN10@Uninit_cop@2:
  000c1	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@PAUCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@2@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@0PAU1@AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$1:

; 382  : 	return (_Dest);

  000c8	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@2:

; 383  : 	}

  000cb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000ce	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d5	59		 pop	 ecx
  000d6	5f		 pop	 edi
  000d7	5e		 pop	 esi
  000d8	5b		 pop	 ebx
  000d9	8b e5		 mov	 esp, ebp
  000db	5d		 pop	 ebp
  000dc	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@PAUCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@2@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@0PAU1@AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a4	 mov	 ecx, DWORD PTR [edx-92]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@PAUCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@2@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@0PAU1@AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@PAUCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@2@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@0@0PAU1@AAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >,CASTLEDEEP_MONSTERINFO *,std::allocator<CASTLEDEEP_MONSTERINFO> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@H@std@@YA$$QAHAAH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@H@std@@YA$$QAHAAH@Z PROC			; std::forward<int>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@H@std@@YA$$QAHAAH@Z ENDP			; std::forward<int>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$?0HH@?$_Pair_base@$$CBHH@std@@QAE@$$QAH0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0HH@?$_Pair_base@$$CBHH@std@@QAE@$$QAH0@Z PROC	; std::_Pair_base<int const ,int>::_Pair_base<int const ,int><int,int>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$forward@H@std@@YA$$QAHAAH@Z ; std::forward<int>
  00015	83 c4 04	 add	 esp, 4
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 10		 mov	 edx, DWORD PTR [eax]
  0001d	89 11		 mov	 DWORD PTR [ecx], edx
  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??$forward@H@std@@YA$$QAHAAH@Z ; std::forward<int>
  00028	83 c4 04	 add	 esp, 4
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	8b 10		 mov	 edx, DWORD PTR [eax]
  00030	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 164  : 		}

  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
??$?0HH@?$_Pair_base@$$CBHH@std@@QAE@$$QAH0@Z ENDP	; std::_Pair_base<int const ,int>::_Pair_base<int const ,int><int,int>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@V?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@YA$$QAV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@YA$$QAV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@0@AAV10@@Z PROC ; std::forward<std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@V?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@YA$$QAV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >
_TEXT	ENDS
PUBLIC	??0?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@$$QAV01@@Z ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >
; Function compile flags: /Odtp /ZI
;	COMDAT ??$?0HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@?$_Pair_base@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@$$QAH$$QAV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@?$_Pair_base@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@$$QAH$$QAV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@1@@Z PROC ; std::_Pair_base<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::_Pair_base<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > ><int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$forward@H@std@@YA$$QAHAAH@Z ; std::forward<int>
  00015	83 c4 04	 add	 esp, 4
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 10		 mov	 edx, DWORD PTR [eax]
  0001d	89 11		 mov	 DWORD PTR [ecx], edx
  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??$forward@V?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@YA$$QAV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@0@AAV10@@Z ; std::forward<std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >
  00028	83 c4 04	 add	 esp, 4
  0002b	50		 push	 eax
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	83 c1 04	 add	 ecx, 4
  00032	e8 00 00 00 00	 call	 ??0?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@$$QAV01@@Z ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >

; 164  : 		}

  00037	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c2 08 00	 ret	 8
??$?0HV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@?$_Pair_base@$$CBHV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@$$QAH$$QAV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@1@@Z ENDP ; std::_Pair_base<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::_Pair_base<int const ,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > ><int,std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@V?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@YA$$QAV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@YA$$QAV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@0@AAV10@@Z PROC ; std::forward<std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@V?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@YA$$QAV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >
_TEXT	ENDS
PUBLIC	??0?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@$$QAV01@@Z ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >
; Function compile flags: /Odtp /ZI
;	COMDAT ??$?0HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@?$_Pair_base@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@$$QAH$$QAV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@?$_Pair_base@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@$$QAH$$QAV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@1@@Z PROC ; std::_Pair_base<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::_Pair_base<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > ><int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$forward@H@std@@YA$$QAHAAH@Z ; std::forward<int>
  00015	83 c4 04	 add	 esp, 4
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 10		 mov	 edx, DWORD PTR [eax]
  0001d	89 11		 mov	 DWORD PTR [ecx], edx
  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??$forward@V?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@YA$$QAV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@0@AAV10@@Z ; std::forward<std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >
  00028	83 c4 04	 add	 esp, 4
  0002b	50		 push	 eax
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	83 c1 04	 add	 ecx, 4
  00032	e8 00 00 00 00	 call	 ??0?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@$$QAV01@@Z ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >

; 164  : 		}

  00037	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c2 08 00	 ret	 8
??$?0HV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@?$_Pair_base@$$CBHV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@$$QAH$$QAV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@1@@Z ENDP ; std::_Pair_base<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::_Pair_base<int const ,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > ><int,std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >
_TEXT	ENDS
PUBLIC	?_Assign_rv@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAEX$$QAV12@@Z ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Assign_rv
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$??0?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@$$QAV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@$$QAV01@@Z$0
__ehfuncinfo$??0?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@$$QAV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@$$QAV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??0?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
$T240510 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@$$QAV01@@Z PROC ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >, COMDAT
; _this$ = ecx

; 595  : 		{	// construct by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@$$QAV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 48	 sub	 esp, 72			; 00000048H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0002e	83 c0 0c	 add	 eax, 12			; 0000000cH
  00031	51		 push	 ecx
  00032	8b cc		 mov	 ecx, esp
  00034	89 65 ac	 mov	 DWORD PTR $T240510[ebp], esp
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ??0?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAE@ABV01@@Z ; std::allocator<CASTLEDEEP_SPAWNTIME>::allocator<CASTLEDEEP_SPAWNTIME>
  0003d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	e8 00 00 00 00	 call	 ??0?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@1@@Z ; std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >
  00045	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 596  : 		_Assign_rv(_STD forward<_Myt>(_Right));

  0004c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 ??$forward@V?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@YA$$QAV?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@0@AAV10@@Z ; std::forward<std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >
  00055	83 c4 04	 add	 esp, 4
  00058	50		 push	 eax
  00059	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	e8 00 00 00 00	 call	 ?_Assign_rv@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAEX$$QAV12@@Z ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Assign_rv

; 597  : 		}

  00061	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00068	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0006b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00075	59		 pop	 ecx
  00076	5f		 pop	 edi
  00077	5e		 pop	 esi
  00078	5b		 pop	 ebx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@$$QAV01@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@XZ ; std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::~_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >
__ehhandler$??0?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@$$QAV01@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@$$QAV01@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE@$$QAV01@@Z ENDP ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >
PUBLIC	?_Assign_rv@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAEX$$QAV12@@Z ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Assign_rv
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@$$QAV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@$$QAV01@@Z$0
__ehfuncinfo$??0?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@$$QAV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@$$QAV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??0?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
$T240520 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@$$QAV01@@Z PROC ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >, COMDAT
; _this$ = ecx

; 595  : 		{	// construct by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@$$QAV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 48	 sub	 esp, 72			; 00000048H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0002e	83 c0 0c	 add	 eax, 12			; 0000000cH
  00031	51		 push	 ecx
  00032	8b cc		 mov	 ecx, esp
  00034	89 65 ac	 mov	 DWORD PTR $T240520[ebp], esp
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ??0?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAE@ABV01@@Z ; std::allocator<CASTLEDEEP_MONSTERINFO>::allocator<CASTLEDEEP_MONSTERINFO>
  0003d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	e8 00 00 00 00	 call	 ??0?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@1@@Z ; std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >
  00045	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 596  : 		_Assign_rv(_STD forward<_Myt>(_Right));

  0004c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 ??$forward@V?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@YA$$QAV?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@0@AAV10@@Z ; std::forward<std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >
  00055	83 c4 04	 add	 esp, 4
  00058	50		 push	 eax
  00059	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	e8 00 00 00 00	 call	 ?_Assign_rv@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAEX$$QAV12@@Z ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Assign_rv

; 597  : 		}

  00061	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00068	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0006b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00075	59		 pop	 ecx
  00076	5f		 pop	 edi
  00077	5e		 pop	 esi
  00078	5b		 pop	 ebx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@$$QAV01@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@XZ ; std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::~_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >
__ehhandler$??0?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@$$QAV01@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@$$QAV01@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE@$$QAV01@@Z ENDP ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >
PUBLIC	?_Swap_all@_Container_base0@std@@QAEXAAU12@@Z	; std::_Container_base0::_Swap_all
PUBLIC	?push_back@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAEX$$QAUCASTLEDEEP_SPAWNTIME@@@Z ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::push_back
PUBLIC	?clear@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAEXXZ ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::clear
PUBLIC	??$?9UCASTLEDEEP_SPAWNTIME@@U0@@std@@YA_NABV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@0@Z ; std::operator!=<CASTLEDEEP_SPAWNTIME,CASTLEDEEP_SPAWNTIME>
PUBLIC	?get_allocator@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QBE?AV?$allocator@UCASTLEDEEP_SPAWNTIME@@@2@XZ ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::get_allocator
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Assign_rv@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAEX$$QAV12@@Z
_TEXT	SEGMENT
$T240530 = -78						; size = 1
$T240531 = -77						; size = 1
$T240532 = -76						; size = 4
__Next$237961 = -8					; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?_Assign_rv@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAEX$$QAV12@@Z PROC ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Assign_rv, COMDAT
; _this$ = ecx

; 606  : 		{	// assign by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 607  : 		if (this == &_Right)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	3b 45 08	 cmp	 eax, DWORD PTR __Right$[ebp]
  00012	75 05		 jne	 SHORT $LN7@Assign_rv
  00014	e9 d4 00 00 00	 jmp	 $LN8@Assign_rv
$LN7@Assign_rv:

; 608  : 			;
; 609  : 		else if (get_allocator() != _Right.get_allocator())

  00019	8d 45 b2	 lea	 eax, DWORD PTR $T240530[ebp]
  0001c	50		 push	 eax
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00020	e8 00 00 00 00	 call	 ?get_allocator@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QBE?AV?$allocator@UCASTLEDEEP_SPAWNTIME@@@2@XZ ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::get_allocator
  00025	50		 push	 eax
  00026	8d 4d b3	 lea	 ecx, DWORD PTR $T240531[ebp]
  00029	51		 push	 ecx
  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ?get_allocator@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QBE?AV?$allocator@UCASTLEDEEP_SPAWNTIME@@@2@XZ ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::get_allocator
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ??$?9UCASTLEDEEP_SPAWNTIME@@U0@@std@@YA_NABV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@0@Z ; std::operator!=<CASTLEDEEP_SPAWNTIME,CASTLEDEEP_SPAWNTIME>
  00038	83 c4 08	 add	 esp, 8
  0003b	0f b6 d0	 movzx	 edx, al
  0003e	85 d2		 test	 edx, edx
  00040	74 58		 je	 SHORT $LN5@Assign_rv

; 610  : 			{	// move construct a copy
; 611  : 			clear();

  00042	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ?clear@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAEXXZ ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::clear

; 612  : 			for (iterator _Next = _Right.begin(); _Next != _Right.end();

  0004a	8d 45 f8	 lea	 eax, DWORD PTR __Next$237961[ebp]
  0004d	50		 push	 eax
  0004e	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00051	e8 00 00 00 00	 call	 ?begin@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@XZ ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::begin
  00056	eb 08		 jmp	 SHORT $LN4@Assign_rv
$LN3@Assign_rv:

; 613  : 				++_Next)

  00058	8d 4d f8	 lea	 ecx, DWORD PTR __Next$237961[ebp]
  0005b	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::operator++
$LN4@Assign_rv:
  00060	8d 45 b4	 lea	 eax, DWORD PTR $T240532[ebp]
  00063	50		 push	 eax
  00064	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00067	e8 00 00 00 00	 call	 ?end@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@XZ ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::end
  0006c	50		 push	 eax
  0006d	8d 4d f8	 lea	 ecx, DWORD PTR __Next$237961[ebp]
  00070	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::operator!=
  00075	0f b6 c8	 movzx	 ecx, al
  00078	85 c9		 test	 ecx, ecx
  0007a	74 1c		 je	 SHORT $LN2@Assign_rv

; 614  : 				push_back(_STD forward<_Ty>(*_Next));

  0007c	8d 4d f8	 lea	 ecx, DWORD PTR __Next$237961[ebp]
  0007f	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QBEAAUCASTLEDEEP_SPAWNTIME@@XZ ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::operator*
  00084	50		 push	 eax
  00085	e8 00 00 00 00	 call	 ??$forward@UCASTLEDEEP_SPAWNTIME@@@std@@YA$$QAUCASTLEDEEP_SPAWNTIME@@AAU1@@Z ; std::forward<CASTLEDEEP_SPAWNTIME>
  0008a	83 c4 04	 add	 esp, 4
  0008d	50		 push	 eax
  0008e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00091	e8 00 00 00 00	 call	 ?push_back@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAEX$$QAUCASTLEDEEP_SPAWNTIME@@@Z ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::push_back
  00096	eb c0		 jmp	 SHORT $LN3@Assign_rv
$LN2@Assign_rv:

; 615  : 			}
; 616  : 		else

  00098	eb 53		 jmp	 SHORT $LN8@Assign_rv
$LN5@Assign_rv:

; 617  : 			{	// clear this and steal from _Right
; 618  : 			_Tidy();

  0009a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IAEXXZ ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Tidy

; 619  : 			this->_Swap_all((_Myt&)_Right);

  000a2	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  000a5	50		 push	 eax
  000a6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a9	e8 00 00 00 00	 call	 ?_Swap_all@_Container_base0@std@@QAEXAAU12@@Z ; std::_Container_base0::_Swap_all

; 620  : 			this->_Myfirst = _Right._Myfirst;

  000ae	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b1	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  000b4	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b6	89 10		 mov	 DWORD PTR [eax], edx

; 621  : 			this->_Mylast = _Right._Mylast;

  000b8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000bb	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  000be	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000c1	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 622  : 			this->_Myend = _Right._Myend;

  000c4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c7	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  000ca	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000cd	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 623  : 
; 624  : 			_Right._Myfirst = 0;

  000d0	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  000d3	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 625  : 			_Right._Mylast = 0;

  000d9	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  000dc	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 626  : 			_Right._Myend = 0;

  000e3	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  000e6	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
$LN8@Assign_rv:

; 627  : 			}
; 628  : 		}

  000ed	5f		 pop	 edi
  000ee	5e		 pop	 esi
  000ef	5b		 pop	 ebx
  000f0	8b e5		 mov	 esp, ebp
  000f2	5d		 pop	 ebp
  000f3	c2 04 00	 ret	 4
?_Assign_rv@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAEX$$QAV12@@Z ENDP ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Assign_rv
_TEXT	ENDS
PUBLIC	?push_back@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAEX$$QAUCASTLEDEEP_MONSTERINFO@@@Z ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::push_back
PUBLIC	?clear@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAEXXZ ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::clear
PUBLIC	??$?9UCASTLEDEEP_MONSTERINFO@@U0@@std@@YA_NABV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@0@Z ; std::operator!=<CASTLEDEEP_MONSTERINFO,CASTLEDEEP_MONSTERINFO>
PUBLIC	?get_allocator@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QBE?AV?$allocator@UCASTLEDEEP_MONSTERINFO@@@2@XZ ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::get_allocator
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Assign_rv@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAEX$$QAV12@@Z
_TEXT	SEGMENT
$T240535 = -78						; size = 1
$T240536 = -77						; size = 1
$T240537 = -76						; size = 4
__Next$238001 = -8					; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?_Assign_rv@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAEX$$QAV12@@Z PROC ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Assign_rv, COMDAT
; _this$ = ecx

; 606  : 		{	// assign by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 607  : 		if (this == &_Right)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	3b 45 08	 cmp	 eax, DWORD PTR __Right$[ebp]
  00012	75 05		 jne	 SHORT $LN7@Assign_rv@2
  00014	e9 d4 00 00 00	 jmp	 $LN8@Assign_rv@2
$LN7@Assign_rv@2:

; 608  : 			;
; 609  : 		else if (get_allocator() != _Right.get_allocator())

  00019	8d 45 b2	 lea	 eax, DWORD PTR $T240535[ebp]
  0001c	50		 push	 eax
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00020	e8 00 00 00 00	 call	 ?get_allocator@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QBE?AV?$allocator@UCASTLEDEEP_MONSTERINFO@@@2@XZ ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::get_allocator
  00025	50		 push	 eax
  00026	8d 4d b3	 lea	 ecx, DWORD PTR $T240536[ebp]
  00029	51		 push	 ecx
  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ?get_allocator@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QBE?AV?$allocator@UCASTLEDEEP_MONSTERINFO@@@2@XZ ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::get_allocator
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ??$?9UCASTLEDEEP_MONSTERINFO@@U0@@std@@YA_NABV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@0@Z ; std::operator!=<CASTLEDEEP_MONSTERINFO,CASTLEDEEP_MONSTERINFO>
  00038	83 c4 08	 add	 esp, 8
  0003b	0f b6 d0	 movzx	 edx, al
  0003e	85 d2		 test	 edx, edx
  00040	74 58		 je	 SHORT $LN5@Assign_rv@2

; 610  : 			{	// move construct a copy
; 611  : 			clear();

  00042	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ?clear@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAEXXZ ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::clear

; 612  : 			for (iterator _Next = _Right.begin(); _Next != _Right.end();

  0004a	8d 45 f8	 lea	 eax, DWORD PTR __Next$238001[ebp]
  0004d	50		 push	 eax
  0004e	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00051	e8 00 00 00 00	 call	 ?begin@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@XZ ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::begin
  00056	eb 08		 jmp	 SHORT $LN4@Assign_rv@2
$LN3@Assign_rv@2:

; 613  : 				++_Next)

  00058	8d 4d f8	 lea	 ecx, DWORD PTR __Next$238001[ebp]
  0005b	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::operator++
$LN4@Assign_rv@2:
  00060	8d 45 b4	 lea	 eax, DWORD PTR $T240537[ebp]
  00063	50		 push	 eax
  00064	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00067	e8 00 00 00 00	 call	 ?end@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@XZ ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::end
  0006c	50		 push	 eax
  0006d	8d 4d f8	 lea	 ecx, DWORD PTR __Next$238001[ebp]
  00070	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::operator!=
  00075	0f b6 c8	 movzx	 ecx, al
  00078	85 c9		 test	 ecx, ecx
  0007a	74 1c		 je	 SHORT $LN2@Assign_rv@2

; 614  : 				push_back(_STD forward<_Ty>(*_Next));

  0007c	8d 4d f8	 lea	 ecx, DWORD PTR __Next$238001[ebp]
  0007f	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QBEAAUCASTLEDEEP_MONSTERINFO@@XZ ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::operator*
  00084	50		 push	 eax
  00085	e8 00 00 00 00	 call	 ??$forward@UCASTLEDEEP_MONSTERINFO@@@std@@YA$$QAUCASTLEDEEP_MONSTERINFO@@AAU1@@Z ; std::forward<CASTLEDEEP_MONSTERINFO>
  0008a	83 c4 04	 add	 esp, 4
  0008d	50		 push	 eax
  0008e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00091	e8 00 00 00 00	 call	 ?push_back@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAEX$$QAUCASTLEDEEP_MONSTERINFO@@@Z ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::push_back
  00096	eb c0		 jmp	 SHORT $LN3@Assign_rv@2
$LN2@Assign_rv@2:

; 615  : 			}
; 616  : 		else

  00098	eb 53		 jmp	 SHORT $LN8@Assign_rv@2
$LN5@Assign_rv@2:

; 617  : 			{	// clear this and steal from _Right
; 618  : 			_Tidy();

  0009a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IAEXXZ ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Tidy

; 619  : 			this->_Swap_all((_Myt&)_Right);

  000a2	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  000a5	50		 push	 eax
  000a6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a9	e8 00 00 00 00	 call	 ?_Swap_all@_Container_base0@std@@QAEXAAU12@@Z ; std::_Container_base0::_Swap_all

; 620  : 			this->_Myfirst = _Right._Myfirst;

  000ae	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b1	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  000b4	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b6	89 10		 mov	 DWORD PTR [eax], edx

; 621  : 			this->_Mylast = _Right._Mylast;

  000b8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000bb	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  000be	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000c1	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 622  : 			this->_Myend = _Right._Myend;

  000c4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c7	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  000ca	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000cd	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 623  : 
; 624  : 			_Right._Myfirst = 0;

  000d0	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  000d3	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 625  : 			_Right._Mylast = 0;

  000d9	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  000dc	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 626  : 			_Right._Myend = 0;

  000e3	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  000e6	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
$LN8@Assign_rv@2:

; 627  : 			}
; 628  : 		}

  000ed	5f		 pop	 edi
  000ee	5e		 pop	 esi
  000ef	5b		 pop	 ebx
  000f0	8b e5		 mov	 esp, ebp
  000f2	5d		 pop	 ebp
  000f3	c2 04 00	 ret	 4
?_Assign_rv@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAEX$$QAV12@@Z ENDP ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Assign_rv
_TEXT	ENDS
PUBLIC	??$addressof@UCASTLEDEEP_SPAWNTIME@@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@AAU1@@Z ; std::addressof<CASTLEDEEP_SPAWNTIME>
; Function compile flags: /Odtp /ZI
;	COMDAT ?push_back@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAEX$$QAUCASTLEDEEP_SPAWNTIME@@@Z
_TEXT	SEGMENT
__Idx$238017 = -8					; size = 4
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAEX$$QAUCASTLEDEEP_SPAWNTIME@@@Z PROC ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::push_back, COMDAT
; _this$ = ecx

; 631  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 632  : 		if (_Inside(_STD addressof(_Val)))

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$addressof@UCASTLEDEEP_SPAWNTIME@@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@AAU1@@Z ; std::addressof<CASTLEDEEP_SPAWNTIME>
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Inside@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IBE_NPBUCASTLEDEEP_SPAWNTIME@@@Z ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Inside
  00021	0f b6 c8	 movzx	 ecx, al
  00024	85 c9		 test	 ecx, ecx
  00026	0f 84 81 00 00
	00		 je	 $LN4@push_back@5

; 633  : 			{	// push back an element
; 634  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  0002c	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ??$addressof@UCASTLEDEEP_SPAWNTIME@@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@AAU1@@Z ; std::addressof<CASTLEDEEP_SPAWNTIME>
  00035	83 c4 04	 add	 esp, 4
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0003d	c1 f8 03	 sar	 eax, 3
  00040	89 45 f8	 mov	 DWORD PTR __Idx$238017[ebp], eax

; 635  : 			if (this->_Mylast == this->_Myend)

  00043	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0004c	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0004f	75 0a		 jne	 SHORT $LN3@push_back@5

; 636  : 				_Reserve(1);

  00051	6a 01		 push	 1
  00053	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IAEXI@Z ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Reserve
$LN3@push_back@5:

; 637  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  0005b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00061	51		 push	 ecx
  00062	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00065	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00068	50		 push	 eax
  00069	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IBEXPAUCASTLEDEEP_SPAWNTIME@@0@Z ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Orphan_range

; 638  : 			_Cons_val(this->_Alval,
; 639  : 				this->_Mylast,
; 640  : 				_STD forward<_Ty>(this->_Myfirst[_Idx]));

  00071	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00074	8b 08		 mov	 ecx, DWORD PTR [eax]
  00076	8b 55 f8	 mov	 edx, DWORD PTR __Idx$238017[ebp]
  00079	8d 04 d1	 lea	 eax, DWORD PTR [ecx+edx*8]
  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 ??$forward@UCASTLEDEEP_SPAWNTIME@@@std@@YA$$QAUCASTLEDEEP_SPAWNTIME@@AAU1@@Z ; std::forward<CASTLEDEEP_SPAWNTIME>
  00082	83 c4 04	 add	 esp, 4
  00085	50		 push	 eax
  00086	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00089	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0008c	52		 push	 edx
  0008d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00090	83 c0 0c	 add	 eax, 12			; 0000000cH
  00093	50		 push	 eax
  00094	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@UCASTLEDEEP_SPAWNTIME@@U3@@std@@YAXAAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@PAUCASTLEDEEP_SPAWNTIME@@$$QAU2@@Z ; std::_Cons_val<std::allocator<CASTLEDEEP_SPAWNTIME>,CASTLEDEEP_SPAWNTIME,CASTLEDEEP_SPAWNTIME>
  00099	83 c4 0c	 add	 esp, 12			; 0000000cH

; 641  : 			++this->_Mylast;

  0009c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000a2	83 c1 08	 add	 ecx, 8
  000a5	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000a8	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 642  : 			}
; 643  : 		else

  000ab	eb 60		 jmp	 SHORT $LN5@push_back@5
$LN4@push_back@5:

; 644  : 			{	// push back a non-element
; 645  : 			if (this->_Mylast == this->_Myend)

  000ad	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000b6	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  000b9	75 0a		 jne	 SHORT $LN1@push_back@5

; 646  : 				_Reserve(1);

  000bb	6a 01		 push	 1
  000bd	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c0	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IAEXI@Z ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Reserve
$LN1@push_back@5:

; 647  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  000c5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c8	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000cb	51		 push	 ecx
  000cc	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000cf	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000d2	50		 push	 eax
  000d3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d6	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IBEXPAUCASTLEDEEP_SPAWNTIME@@0@Z ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Orphan_range

; 648  : 			_Cons_val(this->_Alval,
; 649  : 				this->_Mylast,
; 650  : 				_STD forward<_Ty>(_Val));

  000db	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  000de	50		 push	 eax
  000df	e8 00 00 00 00	 call	 ??$forward@UCASTLEDEEP_SPAWNTIME@@@std@@YA$$QAUCASTLEDEEP_SPAWNTIME@@AAU1@@Z ; std::forward<CASTLEDEEP_SPAWNTIME>
  000e4	83 c4 04	 add	 esp, 4
  000e7	50		 push	 eax
  000e8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000eb	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000ee	52		 push	 edx
  000ef	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000f2	83 c0 0c	 add	 eax, 12			; 0000000cH
  000f5	50		 push	 eax
  000f6	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@UCASTLEDEEP_SPAWNTIME@@U3@@std@@YAXAAV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@PAUCASTLEDEEP_SPAWNTIME@@$$QAU2@@Z ; std::_Cons_val<std::allocator<CASTLEDEEP_SPAWNTIME>,CASTLEDEEP_SPAWNTIME,CASTLEDEEP_SPAWNTIME>
  000fb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 651  : 			++this->_Mylast;

  000fe	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00101	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00104	83 c1 08	 add	 ecx, 8
  00107	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0010a	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN5@push_back@5:

; 652  : 			}
; 653  : 		}

  0010d	5f		 pop	 edi
  0010e	5e		 pop	 esi
  0010f	5b		 pop	 ebx
  00110	8b e5		 mov	 esp, ebp
  00112	5d		 pop	 ebp
  00113	c2 04 00	 ret	 4
?push_back@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAEX$$QAUCASTLEDEEP_SPAWNTIME@@@Z ENDP ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::push_back
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?get_allocator@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QBE?AV?$allocator@UCASTLEDEEP_SPAWNTIME@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?get_allocator@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QBE?AV?$allocator@UCASTLEDEEP_SPAWNTIME@@@2@XZ PROC ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::get_allocator, COMDAT
; _this$ = ecx

; 893  : 		{	// return allocator object for values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 894  : 		return (this->_Alval);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00016	e8 00 00 00 00	 call	 ??0?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@QAE@ABV01@@Z ; std::allocator<CASTLEDEEP_SPAWNTIME>::allocator<CASTLEDEEP_SPAWNTIME>
  0001b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 895  : 		}

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
?get_allocator@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QBE?AV?$allocator@UCASTLEDEEP_SPAWNTIME@@@2@XZ ENDP ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::get_allocator
_TEXT	ENDS
PUBLIC	?erase@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@0@Z ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::erase
; Function compile flags: /Odtp /ZI
;	COMDAT ?clear@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T240544 = -88						; size = 4
$T240545 = -84						; size = 4
$T240546 = -80						; size = 4
$T240547 = -76						; size = 4
$T240548 = -72						; size = 4
_this$ = -4						; size = 4
?clear@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAEXXZ PROC ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::clear, COMDAT
; _this$ = ecx

; 1217 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1218 : 		erase(begin(), end());

  0000c	8d 45 ac	 lea	 eax, DWORD PTR $T240545[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?end@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@XZ ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::end
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d a8	 mov	 DWORD PTR $T240544[ebp], ecx
  0001d	8d 55 b4	 lea	 edx, DWORD PTR $T240547[ebp]
  00020	52		 push	 edx
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?begin@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@XZ ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::begin
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 b0	 mov	 DWORD PTR $T240546[ebp], eax
  0002e	8b 4d a8	 mov	 ecx, DWORD PTR $T240544[ebp]
  00031	51		 push	 ecx
  00032	8b 55 b0	 mov	 edx, DWORD PTR $T240546[ebp]
  00035	52		 push	 edx
  00036	8d 45 b8	 lea	 eax, DWORD PTR $T240548[ebp]
  00039	50		 push	 eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?erase@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@0@Z ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::erase

; 1219 : 		}

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?clear@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAEXXZ ENDP ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::clear
_TEXT	ENDS
PUBLIC	??$addressof@UCASTLEDEEP_MONSTERINFO@@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@AAU1@@Z ; std::addressof<CASTLEDEEP_MONSTERINFO>
; Function compile flags: /Odtp /ZI
;	COMDAT ?push_back@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAEX$$QAUCASTLEDEEP_MONSTERINFO@@@Z
_TEXT	SEGMENT
__Idx$238040 = -8					; size = 4
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAEX$$QAUCASTLEDEEP_MONSTERINFO@@@Z PROC ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::push_back, COMDAT
; _this$ = ecx

; 631  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 632  : 		if (_Inside(_STD addressof(_Val)))

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$addressof@UCASTLEDEEP_MONSTERINFO@@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@AAU1@@Z ; std::addressof<CASTLEDEEP_MONSTERINFO>
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Inside@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IBE_NPBUCASTLEDEEP_MONSTERINFO@@@Z ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Inside
  00021	0f b6 c8	 movzx	 ecx, al
  00024	85 c9		 test	 ecx, ecx
  00026	0f 84 86 00 00
	00		 je	 $LN4@push_back@6

; 633  : 			{	// push back an element
; 634  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  0002c	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ??$addressof@UCASTLEDEEP_MONSTERINFO@@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@AAU1@@Z ; std::addressof<CASTLEDEEP_MONSTERINFO>
  00035	83 c4 04	 add	 esp, 4
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0003d	99		 cdq
  0003e	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  00043	f7 f9		 idiv	 ecx
  00045	89 45 f8	 mov	 DWORD PTR __Idx$238040[ebp], eax

; 635  : 			if (this->_Mylast == this->_Myend)

  00048	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00051	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00054	75 0a		 jne	 SHORT $LN3@push_back@6

; 636  : 				_Reserve(1);

  00056	6a 01		 push	 1
  00058	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IAEXI@Z ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Reserve
$LN3@push_back@6:

; 637  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  00060	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00063	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00066	51		 push	 ecx
  00067	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0006a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0006d	50		 push	 eax
  0006e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00071	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IBEXPAUCASTLEDEEP_MONSTERINFO@@0@Z ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Orphan_range

; 638  : 			_Cons_val(this->_Alval,
; 639  : 				this->_Mylast,
; 640  : 				_STD forward<_Ty>(this->_Myfirst[_Idx]));

  00076	8b 45 f8	 mov	 eax, DWORD PTR __Idx$238040[ebp]
  00079	6b c0 1c	 imul	 eax, 28			; 0000001cH
  0007c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	03 01		 add	 eax, DWORD PTR [ecx]
  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 ??$forward@UCASTLEDEEP_MONSTERINFO@@@std@@YA$$QAUCASTLEDEEP_MONSTERINFO@@AAU1@@Z ; std::forward<CASTLEDEEP_MONSTERINFO>
  00087	83 c4 04	 add	 esp, 4
  0008a	50		 push	 eax
  0008b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0008e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00091	50		 push	 eax
  00092	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00095	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00098	51		 push	 ecx
  00099	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@UCASTLEDEEP_MONSTERINFO@@U3@@std@@YAXAAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@PAUCASTLEDEEP_MONSTERINFO@@$$QAU2@@Z ; std::_Cons_val<std::allocator<CASTLEDEEP_MONSTERINFO>,CASTLEDEEP_MONSTERINFO,CASTLEDEEP_MONSTERINFO>
  0009e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 641  : 			++this->_Mylast;

  000a1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000a7	83 c1 1c	 add	 ecx, 28			; 0000001cH
  000aa	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000ad	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 642  : 			}
; 643  : 		else

  000b0	eb 60		 jmp	 SHORT $LN5@push_back@6
$LN4@push_back@6:

; 644  : 			{	// push back a non-element
; 645  : 			if (this->_Mylast == this->_Myend)

  000b2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b8	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000bb	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  000be	75 0a		 jne	 SHORT $LN1@push_back@6

; 646  : 				_Reserve(1);

  000c0	6a 01		 push	 1
  000c2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c5	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IAEXI@Z ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Reserve
$LN1@push_back@6:

; 647  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  000ca	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000cd	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d0	51		 push	 ecx
  000d1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000d4	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000d7	50		 push	 eax
  000d8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000db	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IBEXPAUCASTLEDEEP_MONSTERINFO@@0@Z ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Orphan_range

; 648  : 			_Cons_val(this->_Alval,
; 649  : 				this->_Mylast,
; 650  : 				_STD forward<_Ty>(_Val));

  000e0	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  000e3	50		 push	 eax
  000e4	e8 00 00 00 00	 call	 ??$forward@UCASTLEDEEP_MONSTERINFO@@@std@@YA$$QAUCASTLEDEEP_MONSTERINFO@@AAU1@@Z ; std::forward<CASTLEDEEP_MONSTERINFO>
  000e9	83 c4 04	 add	 esp, 4
  000ec	50		 push	 eax
  000ed	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f0	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000f3	52		 push	 edx
  000f4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000f7	83 c0 0c	 add	 eax, 12			; 0000000cH
  000fa	50		 push	 eax
  000fb	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@UCASTLEDEEP_MONSTERINFO@@U3@@std@@YAXAAV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@PAUCASTLEDEEP_MONSTERINFO@@$$QAU2@@Z ; std::_Cons_val<std::allocator<CASTLEDEEP_MONSTERINFO>,CASTLEDEEP_MONSTERINFO,CASTLEDEEP_MONSTERINFO>
  00100	83 c4 0c	 add	 esp, 12			; 0000000cH

; 651  : 			++this->_Mylast;

  00103	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00106	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00109	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0010c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0010f	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN5@push_back@6:

; 652  : 			}
; 653  : 		}

  00112	5f		 pop	 edi
  00113	5e		 pop	 esi
  00114	5b		 pop	 ebx
  00115	8b e5		 mov	 esp, ebp
  00117	5d		 pop	 ebp
  00118	c2 04 00	 ret	 4
?push_back@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAEX$$QAUCASTLEDEEP_MONSTERINFO@@@Z ENDP ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::push_back
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?get_allocator@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QBE?AV?$allocator@UCASTLEDEEP_MONSTERINFO@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?get_allocator@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QBE?AV?$allocator@UCASTLEDEEP_MONSTERINFO@@@2@XZ PROC ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::get_allocator, COMDAT
; _this$ = ecx

; 893  : 		{	// return allocator object for values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 894  : 		return (this->_Alval);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00016	e8 00 00 00 00	 call	 ??0?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@QAE@ABV01@@Z ; std::allocator<CASTLEDEEP_MONSTERINFO>::allocator<CASTLEDEEP_MONSTERINFO>
  0001b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 895  : 		}

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
?get_allocator@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QBE?AV?$allocator@UCASTLEDEEP_MONSTERINFO@@@2@XZ ENDP ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::get_allocator
_TEXT	ENDS
PUBLIC	?erase@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@0@Z ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::erase
; Function compile flags: /Odtp /ZI
;	COMDAT ?clear@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T240555 = -88						; size = 4
$T240556 = -84						; size = 4
$T240557 = -80						; size = 4
$T240558 = -76						; size = 4
$T240559 = -72						; size = 4
_this$ = -4						; size = 4
?clear@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAEXXZ PROC ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::clear, COMDAT
; _this$ = ecx

; 1217 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1218 : 		erase(begin(), end());

  0000c	8d 45 ac	 lea	 eax, DWORD PTR $T240556[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?end@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@XZ ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::end
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d a8	 mov	 DWORD PTR $T240555[ebp], ecx
  0001d	8d 55 b4	 lea	 edx, DWORD PTR $T240558[ebp]
  00020	52		 push	 edx
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?begin@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@XZ ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::begin
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 b0	 mov	 DWORD PTR $T240557[ebp], eax
  0002e	8b 4d a8	 mov	 ecx, DWORD PTR $T240555[ebp]
  00031	51		 push	 ecx
  00032	8b 55 b0	 mov	 edx, DWORD PTR $T240557[ebp]
  00035	52		 push	 edx
  00036	8d 45 b8	 lea	 eax, DWORD PTR $T240559[ebp]
  00039	50		 push	 eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?erase@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@0@Z ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::erase

; 1219 : 		}

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?clear@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAEXXZ ENDP ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::clear
_TEXT	ENDS
PUBLIC	??$_Move@PAUCASTLEDEEP_SPAWNTIME@@PAU1@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@PAU1@00@Z ; std::_Move<CASTLEDEEP_SPAWNTIME *,CASTLEDEEP_SPAWNTIME *>
PUBLIC	?_Make_iter@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@@Z ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Make_iter
; Function compile flags: /Odtp /ZI
;	COMDAT ?erase@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T240562 = -84						; size = 4
__Ptr$238064 = -16					; size = 4
__Last$ = -12						; size = 4
__First$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@0@Z PROC ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::erase, COMDAT
; _this$ = ecx

; 1190 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1191 : 		iterator _First = _Make_iter(_First_arg);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __First_arg$[ebp]
  0000f	50		 push	 eax
  00010	8d 4d f8	 lea	 ecx, DWORD PTR __First$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@@Z ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Make_iter

; 1192 : 		iterator _Last = _Make_iter(_Last_arg);

  0001c	8b 45 10	 mov	 eax, DWORD PTR __Last_arg$[ebp]
  0001f	50		 push	 eax
  00020	8d 4d f4	 lea	 ecx, DWORD PTR __Last$[ebp]
  00023	51		 push	 ecx
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@@Z ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Make_iter

; 1193 : 
; 1194 : 		if (_First != _Last)

  0002c	8d 45 f4	 lea	 eax, DWORD PTR __Last$[ebp]
  0002f	50		 push	 eax
  00030	8d 4d f8	 lea	 ecx, DWORD PTR __First$[ebp]
  00033	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::operator!=
  00038	0f b6 c8	 movzx	 ecx, al
  0003b	85 c9		 test	 ecx, ecx
  0003d	74 36		 je	 SHORT $LN1@erase@9

; 1195 : 			{	// worth doing, copy down over hole
; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 			if (_Last < _First || _VICONT(_First) != this
; 1198 : 				|| _VIPTR(_First) < this->_Myfirst
; 1199 : 				|| this->_Mylast < _VIPTR(_Last))
; 1200 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1201 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1202 : 				_VIPTR(_First));
; 1203 : 			_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1204 : 
; 1205 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1206 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1207 : 				_VIPTR(_First));

  0003f	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00042	50		 push	 eax
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00049	52		 push	 edx
  0004a	8b 45 f4	 mov	 eax, DWORD PTR __Last$[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ??$_Move@PAUCASTLEDEEP_SPAWNTIME@@PAU1@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@PAU1@00@Z ; std::_Move<CASTLEDEEP_SPAWNTIME *,CASTLEDEEP_SPAWNTIME *>
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH
  00056	89 45 f0	 mov	 DWORD PTR __Ptr$238064[ebp], eax

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 			_Destroy(_Ptr, this->_Mylast);

  00059	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005f	51		 push	 ecx
  00060	8b 55 f0	 mov	 edx, DWORD PTR __Ptr$238064[ebp]
  00063	52		 push	 edx
  00064	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@IAEXPAUCASTLEDEEP_SPAWNTIME@@0@Z ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Destroy

; 1211 : 			this->_Mylast = _Ptr;

  0006c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006f	8b 4d f0	 mov	 ecx, DWORD PTR __Ptr$238064[ebp]
  00072	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@erase@9:

; 1212 : 			}
; 1213 : 		return (_Make_iter(_First));

  00075	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00078	89 45 ac	 mov	 DWORD PTR $T240562[ebp], eax
  0007b	8b 4d ac	 mov	 ecx, DWORD PTR $T240562[ebp]
  0007e	51		 push	 ecx
  0007f	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00082	52		 push	 edx
  00083	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@@Z ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Make_iter
  0008b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1214 : 		}

  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@0@Z ENDP ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::erase
_TEXT	ENDS
PUBLIC	??$_Move@PAUCASTLEDEEP_MONSTERINFO@@PAU1@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@PAU1@00@Z ; std::_Move<CASTLEDEEP_MONSTERINFO *,CASTLEDEEP_MONSTERINFO *>
PUBLIC	?_Make_iter@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@@Z ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Make_iter
; Function compile flags: /Odtp /ZI
;	COMDAT ?erase@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T240565 = -84						; size = 4
__Ptr$238082 = -16					; size = 4
__Last$ = -12						; size = 4
__First$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@0@Z PROC ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::erase, COMDAT
; _this$ = ecx

; 1190 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1191 : 		iterator _First = _Make_iter(_First_arg);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __First_arg$[ebp]
  0000f	50		 push	 eax
  00010	8d 4d f8	 lea	 ecx, DWORD PTR __First$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@@Z ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Make_iter

; 1192 : 		iterator _Last = _Make_iter(_Last_arg);

  0001c	8b 45 10	 mov	 eax, DWORD PTR __Last_arg$[ebp]
  0001f	50		 push	 eax
  00020	8d 4d f4	 lea	 ecx, DWORD PTR __Last$[ebp]
  00023	51		 push	 ecx
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@@Z ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Make_iter

; 1193 : 
; 1194 : 		if (_First != _Last)

  0002c	8d 45 f4	 lea	 eax, DWORD PTR __Last$[ebp]
  0002f	50		 push	 eax
  00030	8d 4d f8	 lea	 ecx, DWORD PTR __First$[ebp]
  00033	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::operator!=
  00038	0f b6 c8	 movzx	 ecx, al
  0003b	85 c9		 test	 ecx, ecx
  0003d	74 36		 je	 SHORT $LN1@erase@10

; 1195 : 			{	// worth doing, copy down over hole
; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 			if (_Last < _First || _VICONT(_First) != this
; 1198 : 				|| _VIPTR(_First) < this->_Myfirst
; 1199 : 				|| this->_Mylast < _VIPTR(_Last))
; 1200 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1201 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1202 : 				_VIPTR(_First));
; 1203 : 			_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1204 : 
; 1205 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1206 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1207 : 				_VIPTR(_First));

  0003f	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00042	50		 push	 eax
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00049	52		 push	 edx
  0004a	8b 45 f4	 mov	 eax, DWORD PTR __Last$[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ??$_Move@PAUCASTLEDEEP_MONSTERINFO@@PAU1@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@PAU1@00@Z ; std::_Move<CASTLEDEEP_MONSTERINFO *,CASTLEDEEP_MONSTERINFO *>
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH
  00056	89 45 f0	 mov	 DWORD PTR __Ptr$238082[ebp], eax

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 			_Destroy(_Ptr, this->_Mylast);

  00059	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005f	51		 push	 ecx
  00060	8b 55 f0	 mov	 edx, DWORD PTR __Ptr$238082[ebp]
  00063	52		 push	 edx
  00064	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@IAEXPAUCASTLEDEEP_MONSTERINFO@@0@Z ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Destroy

; 1211 : 			this->_Mylast = _Ptr;

  0006c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006f	8b 4d f0	 mov	 ecx, DWORD PTR __Ptr$238082[ebp]
  00072	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@erase@10:

; 1212 : 			}
; 1213 : 		return (_Make_iter(_First));

  00075	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00078	89 45 ac	 mov	 DWORD PTR $T240565[ebp], eax
  0007b	8b 4d ac	 mov	 ecx, DWORD PTR $T240565[ebp]
  0007e	51		 push	 ecx
  0007f	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00082	52		 push	 edx
  00083	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@@Z ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Make_iter
  0008b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1214 : 		}

  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@0@Z ENDP ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::erase
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@@Z PROC ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Make_iter, COMDAT
; _this$ = ecx

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  : 		return (iterator(_Where._Ptr, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@std@@QAE@PAUCASTLEDEEP_SPAWNTIME@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >::_Vector_iterator<std::_Vector_val<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> > >
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 803  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
?_Make_iter@?$vector@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_SPAWNTIME@@V?$allocator@UCASTLEDEEP_SPAWNTIME@@@std@@@std@@@2@@Z ENDP ; std::vector<CASTLEDEEP_SPAWNTIME,std::allocator<CASTLEDEEP_SPAWNTIME> >::_Make_iter
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@@Z PROC ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Make_iter, COMDAT
; _this$ = ecx

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  : 		return (iterator(_Where._Ptr, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@std@@QAE@PAUCASTLEDEEP_MONSTERINFO@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >::_Vector_iterator<std::_Vector_val<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> > >
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 803  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
?_Make_iter@?$vector@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCASTLEDEEP_MONSTERINFO@@V?$allocator@UCASTLEDEEP_MONSTERINFO@@@std@@@std@@@2@@Z ENDP ; std::vector<CASTLEDEEP_MONSTERINFO,std::allocator<CASTLEDEEP_MONSTERINFO> >::_Make_iter
_TEXT	ENDS
PUBLIC	??$?8UCASTLEDEEP_SPAWNTIME@@U0@@std@@YA_NABV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@0@Z ; std::operator==<CASTLEDEEP_SPAWNTIME,CASTLEDEEP_SPAWNTIME>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$?9UCASTLEDEEP_SPAWNTIME@@U0@@std@@YA_NABV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9UCASTLEDEEP_SPAWNTIME@@U0@@std@@YA_NABV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@0@Z PROC ; std::operator!=<CASTLEDEEP_SPAWNTIME,CASTLEDEEP_SPAWNTIME>, COMDAT

; 270  : 	{	// test for allocator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 271  : 	return (!(_Left == _Right));

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$?8UCASTLEDEEP_SPAWNTIME@@U0@@std@@YA_NABV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@0@Z ; std::operator==<CASTLEDEEP_SPAWNTIME,CASTLEDEEP_SPAWNTIME>
  00016	83 c4 08	 add	 esp, 8
  00019	0f b6 c0	 movzx	 eax, al
  0001c	f7 d8		 neg	 eax
  0001e	1b c0		 sbb	 eax, eax
  00020	83 c0 01	 add	 eax, 1

; 272  : 	}

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
??$?9UCASTLEDEEP_SPAWNTIME@@U0@@std@@YA_NABV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@0@Z ENDP ; std::operator!=<CASTLEDEEP_SPAWNTIME,CASTLEDEEP_SPAWNTIME>
_TEXT	ENDS
PUBLIC	??$?8UCASTLEDEEP_MONSTERINFO@@U0@@std@@YA_NABV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@0@Z ; std::operator==<CASTLEDEEP_MONSTERINFO,CASTLEDEEP_MONSTERINFO>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$?9UCASTLEDEEP_MONSTERINFO@@U0@@std@@YA_NABV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9UCASTLEDEEP_MONSTERINFO@@U0@@std@@YA_NABV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@0@Z PROC ; std::operator!=<CASTLEDEEP_MONSTERINFO,CASTLEDEEP_MONSTERINFO>, COMDAT

; 270  : 	{	// test for allocator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 271  : 	return (!(_Left == _Right));

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$?8UCASTLEDEEP_MONSTERINFO@@U0@@std@@YA_NABV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@0@Z ; std::operator==<CASTLEDEEP_MONSTERINFO,CASTLEDEEP_MONSTERINFO>
  00016	83 c4 08	 add	 esp, 8
  00019	0f b6 c0	 movzx	 eax, al
  0001c	f7 d8		 neg	 eax
  0001e	1b c0		 sbb	 eax, eax
  00020	83 c0 01	 add	 eax, 1

; 272  : 	}

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
??$?9UCASTLEDEEP_MONSTERINFO@@U0@@std@@YA_NABV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@0@Z ENDP ; std::operator!=<CASTLEDEEP_MONSTERINFO,CASTLEDEEP_MONSTERINFO>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$addressof@UCASTLEDEEP_SPAWNTIME@@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@AAU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@UCASTLEDEEP_SPAWNTIME@@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@AAU1@@Z PROC ; std::addressof<CASTLEDEEP_SPAWNTIME>, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 111  : 	return ((_Ty *) &(char&)_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@UCASTLEDEEP_SPAWNTIME@@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@AAU1@@Z ENDP ; std::addressof<CASTLEDEEP_SPAWNTIME>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$addressof@UCASTLEDEEP_MONSTERINFO@@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@AAU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@UCASTLEDEEP_MONSTERINFO@@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@AAU1@@Z PROC ; std::addressof<CASTLEDEEP_MONSTERINFO>, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 111  : 	return ((_Ty *) &(char&)_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@UCASTLEDEEP_MONSTERINFO@@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@AAU1@@Z ENDP ; std::addressof<CASTLEDEEP_MONSTERINFO>
_TEXT	ENDS
PUBLIC	??$_Move@PAUCASTLEDEEP_SPAWNTIME@@PAU1@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<CASTLEDEEP_SPAWNTIME *,CASTLEDEEP_SPAWNTIME *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAUCASTLEDEEP_SPAWNTIME@@PAU1@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@PAU1@00@Z
_TEXT	SEGMENT
$T240580 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAUCASTLEDEEP_SPAWNTIME@@PAU1@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@PAU1@00@Z PROC ; std::_Move<CASTLEDEEP_SPAWNTIME *,CASTLEDEEP_SPAWNTIME *>, COMDAT

; 2533 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2534 : 	return (_Move(_First, _Last,
; 2535 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UCASTLEDEEP_SPAWNTIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUCASTLEDEEP_SPAWNTIME@@0@Z ; std::_Ptr_cat<CASTLEDEEP_SPAWNTIME,CASTLEDEEP_SPAWNTIME>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T240580[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T240580[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Move@PAUCASTLEDEEP_SPAWNTIME@@PAU1@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<CASTLEDEEP_SPAWNTIME *,CASTLEDEEP_SPAWNTIME *>
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 2536 : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Move@PAUCASTLEDEEP_SPAWNTIME@@PAU1@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@PAU1@00@Z ENDP ; std::_Move<CASTLEDEEP_SPAWNTIME *,CASTLEDEEP_SPAWNTIME *>
_TEXT	ENDS
PUBLIC	??$_Move@PAUCASTLEDEEP_MONSTERINFO@@PAU1@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<CASTLEDEEP_MONSTERINFO *,CASTLEDEEP_MONSTERINFO *>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Move@PAUCASTLEDEEP_MONSTERINFO@@PAU1@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@PAU1@00@Z
_TEXT	SEGMENT
$T240583 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAUCASTLEDEEP_MONSTERINFO@@PAU1@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@PAU1@00@Z PROC ; std::_Move<CASTLEDEEP_MONSTERINFO *,CASTLEDEEP_MONSTERINFO *>, COMDAT

; 2533 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2534 : 	return (_Move(_First, _Last,
; 2535 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UCASTLEDEEP_MONSTERINFO@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUCASTLEDEEP_MONSTERINFO@@0@Z ; std::_Ptr_cat<CASTLEDEEP_MONSTERINFO,CASTLEDEEP_MONSTERINFO>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T240583[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T240583[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Move@PAUCASTLEDEEP_MONSTERINFO@@PAU1@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<CASTLEDEEP_MONSTERINFO *,CASTLEDEEP_MONSTERINFO *>
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 2536 : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Move@PAUCASTLEDEEP_MONSTERINFO@@PAU1@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@PAU1@00@Z ENDP ; std::_Move<CASTLEDEEP_MONSTERINFO *,CASTLEDEEP_MONSTERINFO *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?8UCASTLEDEEP_SPAWNTIME@@U0@@std@@YA_NABV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?8UCASTLEDEEP_SPAWNTIME@@U0@@std@@YA_NABV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@0@Z PROC ; std::operator==<CASTLEDEEP_SPAWNTIME,CASTLEDEEP_SPAWNTIME>, COMDAT

; 262  : 	{	// test for allocator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 263  : 	return (true);

  00009	b0 01		 mov	 al, 1

; 264  : 	}

  0000b	5f		 pop	 edi
  0000c	5e		 pop	 esi
  0000d	5b		 pop	 ebx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$?8UCASTLEDEEP_SPAWNTIME@@U0@@std@@YA_NABV?$allocator@UCASTLEDEEP_SPAWNTIME@@@0@0@Z ENDP ; std::operator==<CASTLEDEEP_SPAWNTIME,CASTLEDEEP_SPAWNTIME>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$?8UCASTLEDEEP_MONSTERINFO@@U0@@std@@YA_NABV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?8UCASTLEDEEP_MONSTERINFO@@U0@@std@@YA_NABV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@0@Z PROC ; std::operator==<CASTLEDEEP_MONSTERINFO,CASTLEDEEP_MONSTERINFO>, COMDAT

; 262  : 	{	// test for allocator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 263  : 	return (true);

  00009	b0 01		 mov	 al, 1

; 264  : 	}

  0000b	5f		 pop	 edi
  0000c	5e		 pop	 esi
  0000d	5b		 pop	 ebx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$?8UCASTLEDEEP_MONSTERINFO@@U0@@std@@YA_NABV?$allocator@UCASTLEDEEP_MONSTERINFO@@@0@0@Z ENDP ; std::operator==<CASTLEDEEP_MONSTERINFO,CASTLEDEEP_MONSTERINFO>
_TEXT	ENDS
PUBLIC	??$move@AAUCASTLEDEEP_SPAWNTIME@@@std@@YA$$QAUCASTLEDEEP_SPAWNTIME@@AAU1@@Z ; std::move<CASTLEDEEP_SPAWNTIME &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAUCASTLEDEEP_SPAWNTIME@@PAU1@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAUCASTLEDEEP_SPAWNTIME@@PAU1@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<CASTLEDEEP_SPAWNTIME *,CASTLEDEEP_SPAWNTIME *>, COMDAT

; 2512 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2513 : 	for (; _First != _Last; ++_Dest, ++_First)

  00009	eb 12		 jmp	 SHORT $LN3@Move@2
$LN2@Move@2:
  0000b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000e	83 c0 08	 add	 eax, 8
  00011	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00017	83 c1 08	 add	 ecx, 8
  0001a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN3@Move@2:
  0001d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00020	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00023	74 1b		 je	 SHORT $LN1@Move@2

; 2514 : 		*_Dest = _STD move(*_First);

  00025	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??$move@AAUCASTLEDEEP_SPAWNTIME@@@std@@YA$$QAUCASTLEDEEP_SPAWNTIME@@AAU1@@Z ; std::move<CASTLEDEEP_SPAWNTIME &>
  0002e	83 c4 04	 add	 esp, 4
  00031	8b 08		 mov	 ecx, DWORD PTR [eax]
  00033	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00036	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00039	89 08		 mov	 DWORD PTR [eax], ecx
  0003b	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0003e	eb cb		 jmp	 SHORT $LN2@Move@2
$LN1@Move@2:

; 2515 : 	return (_Dest);

  00040	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 2516 : 	}

  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
??$_Move@PAUCASTLEDEEP_SPAWNTIME@@PAU1@@std@@YAPAUCASTLEDEEP_SPAWNTIME@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<CASTLEDEEP_SPAWNTIME *,CASTLEDEEP_SPAWNTIME *>
_TEXT	ENDS
PUBLIC	??$move@AAUCASTLEDEEP_MONSTERINFO@@@std@@YA$$QAUCASTLEDEEP_MONSTERINFO@@AAU1@@Z ; std::move<CASTLEDEEP_MONSTERINFO &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Move@PAUCASTLEDEEP_MONSTERINFO@@PAU1@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAUCASTLEDEEP_MONSTERINFO@@PAU1@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<CASTLEDEEP_MONSTERINFO *,CASTLEDEEP_MONSTERINFO *>, COMDAT

; 2512 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2513 : 	for (; _First != _Last; ++_Dest, ++_First)

  00009	eb 12		 jmp	 SHORT $LN3@Move@3
$LN2@Move@3:
  0000b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000e	83 c0 1c	 add	 eax, 28			; 0000001cH
  00011	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00017	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0001a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN3@Move@3:
  0001d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00020	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00023	74 1a		 je	 SHORT $LN1@Move@3

; 2514 : 		*_Dest = _STD move(*_First);

  00025	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??$move@AAUCASTLEDEEP_MONSTERINFO@@@std@@YA$$QAUCASTLEDEEP_MONSTERINFO@@AAU1@@Z ; std::move<CASTLEDEEP_MONSTERINFO &>
  0002e	83 c4 04	 add	 esp, 4
  00031	b9 07 00 00 00	 mov	 ecx, 7
  00036	8b f0		 mov	 esi, eax
  00038	8b 7d 10	 mov	 edi, DWORD PTR __Dest$[ebp]
  0003b	f3 a5		 rep movsd
  0003d	eb cc		 jmp	 SHORT $LN2@Move@3
$LN1@Move@3:

; 2515 : 	return (_Dest);

  0003f	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 2516 : 	}

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
??$_Move@PAUCASTLEDEEP_MONSTERINFO@@PAU1@@std@@YAPAUCASTLEDEEP_MONSTERINFO@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<CASTLEDEEP_MONSTERINFO *,CASTLEDEEP_MONSTERINFO *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$move@AAUCASTLEDEEP_SPAWNTIME@@@std@@YA$$QAUCASTLEDEEP_SPAWNTIME@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAUCASTLEDEEP_SPAWNTIME@@@std@@YA$$QAUCASTLEDEEP_SPAWNTIME@@AAU1@@Z PROC ; std::move<CASTLEDEEP_SPAWNTIME &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$move@AAUCASTLEDEEP_SPAWNTIME@@@std@@YA$$QAUCASTLEDEEP_SPAWNTIME@@AAU1@@Z ENDP ; std::move<CASTLEDEEP_SPAWNTIME &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$move@AAUCASTLEDEEP_MONSTERINFO@@@std@@YA$$QAUCASTLEDEEP_MONSTERINFO@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAUCASTLEDEEP_MONSTERINFO@@@std@@YA$$QAUCASTLEDEEP_MONSTERINFO@@AAU1@@Z PROC ; std::move<CASTLEDEEP_MONSTERINFO &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$move@AAUCASTLEDEEP_MONSTERINFO@@@std@@YA$$QAUCASTLEDEEP_MONSTERINFO@@AAU1@@Z ENDP ; std::move<CASTLEDEEP_MONSTERINFO &>
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File d:\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
; Function compile flags: /Odtp /ZI
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ ; std::bad_alloc::~bad_alloc
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar@4
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar@4:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 37   : 		{	// orphan all iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 38   : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Swap_all@_Container_base0@std@@QAEXAAU12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Swap_all@_Container_base0@std@@QAEXAAU12@@Z PROC	; std::_Container_base0::_Swap_all, COMDAT
; _this$ = ecx

; 41   : 		{	// swap all iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 42   : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Swap_all@_Container_base0@std@@QAEXAAU12@@Z ENDP	; std::_Container_base0::_Swap_all
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 48   : 		{	// adopt this iterator by parent

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 49   : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\castledeepevent.cpp
;	COMDAT ??__Eg_CastleDeepEvent@@YAXXZ
text$yc	SEGMENT
??__Eg_CastleDeepEvent@@YAXXZ PROC			; `dynamic initializer for 'g_CastleDeepEvent'', COMDAT

; 18   : CCastleDeepEvent g_CastleDeepEvent;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleDeepEvent@@3VCCastleDeepEvent@@A ; g_CastleDeepEvent
  0000e	e8 00 00 00 00	 call	 ??0CCastleDeepEvent@@QAE@XZ ; CCastleDeepEvent::CCastleDeepEvent
  00013	68 00 00 00 00	 push	 OFFSET ??__Fg_CastleDeepEvent@@YAXXZ ; `dynamic atexit destructor for 'g_CastleDeepEvent''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??__Eg_CastleDeepEvent@@YAXXZ ENDP			; `dynamic initializer for 'g_CastleDeepEvent''
; Function compile flags: /Odtp /ZI
text$yc	ENDS
;	COMDAT ??__Fg_CastleDeepEvent@@YAXXZ
text$yd	SEGMENT
??__Fg_CastleDeepEvent@@YAXXZ PROC			; `dynamic atexit destructor for 'g_CastleDeepEvent'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleDeepEvent@@3VCCastleDeepEvent@@A ; g_CastleDeepEvent
  0000e	e8 00 00 00 00	 call	 ??1CCastleDeepEvent@@UAE@XZ ; CCastleDeepEvent::~CCastleDeepEvent
  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__Fg_CastleDeepEvent@@YAXXZ ENDP			; `dynamic atexit destructor for 'g_CastleDeepEvent''
text$yd	ENDS
PUBLIC	?g_CastleDeepEvent@@3VCCastleDeepEvent@@A	; g_CastleDeepEvent
_BSS	SEGMENT
?g_CastleDeepEvent@@3VCCastleDeepEvent@@A DB 0a8H DUP (?) ; g_CastleDeepEvent
_BSS	ENDS
CRT$XCU	SEGMENT
_g_CastleDeepEvent$initializer$ DD FLAT:??__Eg_CastleDeepEvent@@YAXXZ
CRT$XCU	ENDS
END
