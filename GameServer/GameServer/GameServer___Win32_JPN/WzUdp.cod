; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	D:\Projects\ExTeam6.3\Source\GameServer\GameServer\WzUdp.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?Init@WzUdp@@QAEHXZ				; WzUdp::Init
PUBLIC	??_7WzUdp@@6B@					; WzUdp::`vftable'
PUBLIC	??0WzUdp@@QAE@XZ				; WzUdp::WzUdp
PUBLIC	??_R4WzUdp@@6B@					; WzUdp::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVWzUdp@@@8				; WzUdp `RTTI Type Descriptor'
PUBLIC	??_R3WzUdp@@8					; WzUdp::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2WzUdp@@8					; WzUdp::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@WzUdp@@8				; WzUdp::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_EWzUdp@@UAEPAXI@Z:PROC			; WzUdp::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@WzUdp@@8
; File d:\projects\exteam6.3\source\gameserver\gameserver\wzudp.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@WzUdp@@8 DD FLAT:??_R0?AVWzUdp@@@8	; WzUdp::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3WzUdp@@8
rdata$r	ENDS
;	COMDAT ??_R2WzUdp@@8
rdata$r	SEGMENT
??_R2WzUdp@@8 DD FLAT:??_R1A@?0A@EA@WzUdp@@8		; WzUdp::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3WzUdp@@8
rdata$r	SEGMENT
??_R3WzUdp@@8 DD 00H					; WzUdp::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2WzUdp@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVWzUdp@@@8
_DATA	SEGMENT
??_R0?AVWzUdp@@@8 DD FLAT:??_7type_info@@6B@		; WzUdp `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVWzUdp@@', 00H
_DATA	ENDS
;	COMDAT ??_R4WzUdp@@6B@
rdata$r	SEGMENT
??_R4WzUdp@@6B@ DD 00H					; WzUdp::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVWzUdp@@@8
	DD	FLAT:??_R3WzUdp@@8
rdata$r	ENDS
;	COMDAT ??_7WzUdp@@6B@
CONST	SEGMENT
??_7WzUdp@@6B@ DD FLAT:??_R4WzUdp@@6B@			; WzUdp::`vftable'
	DD	FLAT:??_EWzUdp@@UAEPAXI@Z
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0WzUdp@@QAE@XZ PROC					; WzUdp::WzUdp
; _this$ = ecx

; 18   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7WzUdp@@6B@

; 19   : 	Init();

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?Init@WzUdp@@QAEHXZ	; WzUdp::Init

; 20   : }

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??0WzUdp@@QAE@XZ ENDP					; WzUdp::WzUdp
_TEXT	ENDS
PUBLIC	??1WzUdp@@UAE@XZ				; WzUdp::~WzUdp
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp /ZI
;	COMDAT ??_GWzUdp@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GWzUdp@@UAEPAXI@Z PROC				; WzUdp::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1WzUdp@@UAE@XZ	; WzUdp::~WzUdp
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_GWzUdp@@UAEPAXI@Z ENDP				; WzUdp::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?Close@WzUdp@@QAEHXZ				; WzUdp::Close
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1WzUdp@@UAE@XZ PROC					; WzUdp::~WzUdp
; _this$ = ecx

; 23   : {

  00030	55		 push	 ebp
  00031	8b ec		 mov	 ebp, esp
  00033	83 ec 44	 sub	 esp, 68			; 00000044H
  00036	53		 push	 ebx
  00037	56		 push	 esi
  00038	57		 push	 edi
  00039	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0003c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7WzUdp@@6B@

; 24   : 	Close();

  00045	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?Close@WzUdp@@QAEHXZ	; WzUdp::Close

; 25   : }

  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5b		 pop	 ebx
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
??1WzUdp@@UAE@XZ ENDP					; WzUdp::~WzUdp
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	__imp__WSAStartup@8:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_wsd$ = -408						; size = 400
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?Init@WzUdp@@QAEHXZ PROC				; WzUdp::Init
; _this$ = ecx

; 28   : {

  00060	55		 push	 ebp
  00061	8b ec		 mov	 ebp, esp
  00063	81 ec d8 01 00
	00		 sub	 esp, 472		; 000001d8H
  00069	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0006e	33 c5		 xor	 eax, ebp
  00070	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00073	53		 push	 ebx
  00074	56		 push	 esi
  00075	57		 push	 edi
  00076	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 29   : 	WSADATA			wsd;
; 30   : 
; 31   : 	if (WSAStartup(MAKEWORD(2,2), &wsd) != 0)

  00079	8d 85 68 fe ff
	ff		 lea	 eax, DWORD PTR _wsd$[ebp]
  0007f	50		 push	 eax
  00080	68 02 02 00 00	 push	 514			; 00000202H
  00085	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAStartup@8
  0008b	85 c0		 test	 eax, eax
  0008d	74 04		 je	 SHORT $LN1@Init

; 32   :     {        
; 33   :         return FALSE;

  0008f	33 c0		 xor	 eax, eax
  00091	eb 3a		 jmp	 SHORT $LN2@Init
$LN1@Init:

; 34   :     }
; 35   : 	m_Socket = -1;//Season 4.5 changed

  00093	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00096	c7 40 10 ff ff
	ff ff		 mov	 DWORD PTR [eax+16], -1

; 36   : 	m_dwLength  = DEFAULT_BUFFER_LENGTH;

  0009d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000a0	c7 40 1c 00 10
	00 00		 mov	 DWORD PTR [eax+28], 4096 ; 00001000H

; 37   : 	m_dwRecvOfs = 0;

  000a7	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000aa	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 38   : 	m_ThreadHandle = NULL;

  000b1	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000b4	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 39   : 	ProtocolCore   = NULL;

  000bb	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000be	c7 80 5c 08 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+2140], 0

; 40   : 	return TRUE;

  000c8	b8 01 00 00 00	 mov	 eax, 1
$LN2@Init:

; 41   : }

  000cd	5f		 pop	 edi
  000ce	5e		 pop	 esi
  000cf	5b		 pop	 ebx
  000d0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d3	33 cd		 xor	 ecx, ebp
  000d5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000da	8b e5		 mov	 esp, ebp
  000dc	5d		 pop	 ebp
  000dd	c3		 ret	 0
?Init@WzUdp@@QAEHXZ ENDP				; WzUdp::Init
_TEXT	ENDS
EXTRN	__imp__HeapFree@12:PROC
EXTRN	__imp__GetProcessHeap@0:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp__TerminateThread@8:PROC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Close@WzUdp@@QAEHXZ PROC				; WzUdp::Close
; _this$ = ecx

; 44   : {

  000e0	55		 push	 ebp
  000e1	8b ec		 mov	 ebp, esp
  000e3	83 ec 44	 sub	 esp, 68			; 00000044H
  000e6	53		 push	 ebx
  000e7	56		 push	 esi
  000e8	57		 push	 edi
  000e9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 45   : 	TerminateThread(m_ThreadHandle, 0);

  000ec	6a 00		 push	 0
  000ee	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000f1	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000f4	51		 push	 ecx
  000f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TerminateThread@8

; 46   : 	if( m_ThreadHandle != NULL )

  000fb	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000fe	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00102	74 26		 je	 SHORT $LN1@Close

; 47   : 	{
; 48   : 		WaitForSingleObject( m_ThreadHandle, INFINITE );

  00104	6a ff		 push	 -1
  00106	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00109	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0010c	51		 push	 ecx
  0010d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 49   : 		CloseHandle(m_ThreadHandle);

  00113	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00116	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00119	51		 push	 ecx
  0011a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 50   : 		m_ThreadHandle = NULL;

  00120	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00123	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
$LN1@Close:

; 51   : 	}
; 52   : 	HeapFree(GetProcessHeap(), 0, m_Recvbuf);

  0012a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0012d	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00130	51		 push	 ecx
  00131	6a 00		 push	 0
  00133	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessHeap@0
  00139	50		 push	 eax
  0013a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapFree@12

; 53   : 	return TRUE;

  00140	b8 01 00 00 00	 mov	 eax, 1

; 54   : }	

  00145	5f		 pop	 edi
  00146	5e		 pop	 esi
  00147	5b		 pop	 ebx
  00148	8b e5		 mov	 esp, ebp
  0014a	5d		 pop	 ebp
  0014b	c3		 ret	 0
?Close@WzUdp@@QAEHXZ ENDP				; WzUdp::Close
_TEXT	ENDS
PUBLIC	?CreateSocket@WzUdp@@QAEHXZ			; WzUdp::CreateSocket
EXTRN	__imp__WSASocketA@24:PROC
EXTRN	__imp__closesocket@4:PROC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CreateSocket@WzUdp@@QAEHXZ PROC			; WzUdp::CreateSocket
; _this$ = ecx

; 57   : {

  00150	55		 push	 ebp
  00151	8b ec		 mov	 ebp, esp
  00153	83 ec 44	 sub	 esp, 68			; 00000044H
  00156	53		 push	 ebx
  00157	56		 push	 esi
  00158	57		 push	 edi
  00159	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 58   : 	if( m_Socket != INVALID_SOCKET)//Season 4.5 addon

  0015c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0015f	83 78 10 ff	 cmp	 DWORD PTR [eax+16], -1
  00163	74 17		 je	 SHORT $LN2@CreateSock

; 59   : 	{
; 60   : 		closesocket(m_Socket);

  00165	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00168	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0016b	51		 push	 ecx
  0016c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4

; 61   : 		m_Socket = -1;

  00172	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00175	c7 40 10 ff ff
	ff ff		 mov	 DWORD PTR [eax+16], -1
$LN2@CreateSock:

; 62   : 	}
; 63   : 
; 64   : 	m_Socket = WSASocket(AF_INET, SOCK_DGRAM, 0, NULL, 0, NULL);

  0017c	6a 00		 push	 0
  0017e	6a 00		 push	 0
  00180	6a 00		 push	 0
  00182	6a 00		 push	 0
  00184	6a 02		 push	 2
  00186	6a 02		 push	 2
  00188	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSASocketA@24
  0018e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00191	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 65   :     
; 66   : 	if( m_Socket == INVALID_SOCKET )

  00194	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00197	83 78 10 ff	 cmp	 DWORD PTR [eax+16], -1
  0019b	75 04		 jne	 SHORT $LN1@CreateSock

; 67   :     {        
; 68   :         return FALSE;

  0019d	33 c0		 xor	 eax, eax
  0019f	eb 05		 jmp	 SHORT $LN3@CreateSock
$LN1@CreateSock:

; 69   :     }
; 70   : 	return TRUE;

  001a1	b8 01 00 00 00	 mov	 eax, 1
$LN3@CreateSock:

; 71   : }

  001a6	5f		 pop	 edi
  001a7	5e		 pop	 esi
  001a8	5b		 pop	 ebx
  001a9	8b e5		 mov	 esp, ebp
  001ab	5d		 pop	 ebp
  001ac	c3		 ret	 0
?CreateSocket@WzUdp@@QAEHXZ ENDP			; WzUdp::CreateSocket
_TEXT	ENDS
PUBLIC	?SendSet@WzUdp@@QAEHPADH@Z			; WzUdp::SendSet
EXTRN	_memcpy:PROC
EXTRN	__imp__gethostbyname@4:PROC
EXTRN	__imp__inet_addr@4:PROC
EXTRN	__imp__htons@4:PROC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv75 = -76						; size = 4
_host$204579 = -8					; size = 4
_this$ = -4						; size = 4
_ip$ = 8						; size = 4
_port$ = 12						; size = 4
?SendSet@WzUdp@@QAEHPADH@Z PROC				; WzUdp::SendSet
; _this$ = ecx

; 74   : {

  001b0	55		 push	 ebp
  001b1	8b ec		 mov	 ebp, esp
  001b3	83 ec 4c	 sub	 esp, 76			; 0000004cH
  001b6	53		 push	 ebx
  001b7	56		 push	 esi
  001b8	57		 push	 edi
  001b9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 75   : 	m_Port					= port;

  001bc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001bf	8b 4d 0c	 mov	 ecx, DWORD PTR _port$[ebp]
  001c2	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 76   :     m_SockAddr.sin_family	= AF_INET;

  001c5	b8 02 00 00 00	 mov	 eax, 2
  001ca	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001cd	66 89 81 4c 08
	00 00		 mov	 WORD PTR [ecx+2124], ax

; 77   :     m_SockAddr.sin_port		= htons(port);

  001d4	0f b7 45 0c	 movzx	 eax, WORD PTR _port$[ebp]
  001d8	50		 push	 eax
  001d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__htons@4
  001df	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001e2	66 89 81 4e 08
	00 00		 mov	 WORD PTR [ecx+2126], ax

; 78   : 	if( (m_SockAddr.sin_addr.s_addr	= inet_addr(ip)) == INADDR_NONE )

  001e9	8b 45 08	 mov	 eax, DWORD PTR _ip$[ebp]
  001ec	50		 push	 eax
  001ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__inet_addr@4
  001f3	89 45 b4	 mov	 DWORD PTR tv75[ebp], eax
  001f6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001f9	8b 55 b4	 mov	 edx, DWORD PTR tv75[ebp]
  001fc	89 91 50 08 00
	00		 mov	 DWORD PTR [ecx+2128], edx
  00202	83 7d b4 ff	 cmp	 DWORD PTR tv75[ebp], -1
  00206	75 43		 jne	 SHORT $LN3@SendSet

; 79   : 	{
; 80   : 		struct hostent *host=NULL;

  00208	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _host$204579[ebp], 0

; 81   : 		host = gethostbyname(ip);

  0020f	8b 45 08	 mov	 eax, DWORD PTR _ip$[ebp]
  00212	50		 push	 eax
  00213	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__gethostbyname@4
  00219	89 45 f8	 mov	 DWORD PTR _host$204579[ebp], eax

; 82   : 		if( host )

  0021c	83 7d f8 00	 cmp	 DWORD PTR _host$204579[ebp], 0
  00220	74 25		 je	 SHORT $LN2@SendSet

; 83   : 		{
; 84   : 			CopyMemory(&m_SockAddr.sin_addr, host->h_addr_list[0], host->h_length);

  00222	8b 45 f8	 mov	 eax, DWORD PTR _host$204579[ebp]
  00225	0f bf 48 0a	 movsx	 ecx, WORD PTR [eax+10]
  00229	51		 push	 ecx
  0022a	8b 55 f8	 mov	 edx, DWORD PTR _host$204579[ebp]
  0022d	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00230	8b 08		 mov	 ecx, DWORD PTR [eax]
  00232	51		 push	 ecx
  00233	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00236	81 c2 50 08 00
	00		 add	 edx, 2128		; 00000850H
  0023c	52		 push	 edx
  0023d	e8 00 00 00 00	 call	 _memcpy
  00242	83 c4 0c	 add	 esp, 12			; 0000000cH

; 85   : 		}
; 86   : 		else

  00245	eb 04		 jmp	 SHORT $LN3@SendSet
$LN2@SendSet:

; 87   : 		{		
; 88   : 			return FALSE;

  00247	33 c0		 xor	 eax, eax
  00249	eb 05		 jmp	 SHORT $LN4@SendSet
$LN3@SendSet:

; 89   : 		}
; 90   : 	}
; 91   : 	return TRUE;

  0024b	b8 01 00 00 00	 mov	 eax, 1
$LN4@SendSet:

; 92   : }

  00250	5f		 pop	 edi
  00251	5e		 pop	 esi
  00252	5b		 pop	 ebx
  00253	8b e5		 mov	 esp, ebp
  00255	5d		 pop	 ebp
  00256	c2 08 00	 ret	 8
?SendSet@WzUdp@@QAEHPADH@Z ENDP				; WzUdp::SendSet
_TEXT	ENDS
PUBLIC	?SetProtocolCore@WzUdp@@QAEHP6AXEPAEH@Z@Z	; WzUdp::SetProtocolCore
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pc$ = 8						; size = 4
?SetProtocolCore@WzUdp@@QAEHP6AXEPAEH@Z@Z PROC		; WzUdp::SetProtocolCore
; _this$ = ecx

; 95   : {

  00260	55		 push	 ebp
  00261	8b ec		 mov	 ebp, esp
  00263	83 ec 44	 sub	 esp, 68			; 00000044H
  00266	53		 push	 ebx
  00267	56		 push	 esi
  00268	57		 push	 edi
  00269	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 96   : 	ProtocolCore = pc;

  0026c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0026f	8b 4d 08	 mov	 ecx, DWORD PTR _pc$[ebp]
  00272	89 88 5c 08 00
	00		 mov	 DWORD PTR [eax+2140], ecx

; 97   : 	return TRUE;

  00278	b8 01 00 00 00	 mov	 eax, 1

; 98   : }

  0027d	5f		 pop	 edi
  0027e	5e		 pop	 esi
  0027f	5b		 pop	 ebx
  00280	8b e5		 mov	 esp, ebp
  00282	5d		 pop	 ebp
  00283	c2 04 00	 ret	 4
?SetProtocolCore@WzUdp@@QAEHP6AXEPAEH@Z@Z ENDP		; WzUdp::SetProtocolCore
_TEXT	ENDS
PUBLIC	?RecvSet@WzUdp@@QAEHH@Z				; WzUdp::RecvSet
EXTRN	__imp__HeapAlloc@12:PROC
EXTRN	__imp__bind@12:PROC
EXTRN	__imp__htonl@4:PROC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
_port$ = 8						; size = 4
?RecvSet@WzUdp@@QAEHH@Z PROC				; WzUdp::RecvSet
; _this$ = ecx

; 102  : {

  00290	55		 push	 ebp
  00291	8b ec		 mov	 ebp, esp
  00293	83 ec 44	 sub	 esp, 68			; 00000044H
  00296	53		 push	 ebx
  00297	56		 push	 esi
  00298	57		 push	 edi
  00299	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 103  : 	m_Port						= port;

  0029c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0029f	8b 4d 08	 mov	 ecx, DWORD PTR _port$[ebp]
  002a2	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 104  :     m_SockAddr.sin_port			= htons(port);

  002a5	0f b7 45 08	 movzx	 eax, WORD PTR _port$[ebp]
  002a9	50		 push	 eax
  002aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__htons@4
  002b0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002b3	66 89 81 4e 08
	00 00		 mov	 WORD PTR [ecx+2126], ax

; 105  : 	m_SockAddr.sin_family		= AF_INET;

  002ba	b8 02 00 00 00	 mov	 eax, 2
  002bf	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002c2	66 89 81 4c 08
	00 00		 mov	 WORD PTR [ecx+2124], ax

; 106  :     m_SockAddr.sin_addr.s_addr	= htonl(INADDR_ANY);

  002c9	6a 00		 push	 0
  002cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__htonl@4
  002d1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002d4	89 81 50 08 00
	00		 mov	 DWORD PTR [ecx+2128], eax

; 107  : 	
; 108  : 	if( bind(m_Socket, (SOCKADDR *)&m_SockAddr, sizeof(m_SockAddr)) == SOCKET_ERROR )

  002da	6a 10		 push	 16			; 00000010H
  002dc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002df	05 4c 08 00 00	 add	 eax, 2124		; 0000084cH
  002e4	50		 push	 eax
  002e5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002e8	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  002eb	52		 push	 edx
  002ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__bind@12
  002f2	83 f8 ff	 cmp	 eax, -1
  002f5	75 04		 jne	 SHORT $LN2@RecvSet

; 109  :     {		
; 110  : 		return FALSE;

  002f7	33 c0		 xor	 eax, eax
  002f9	eb 2e		 jmp	 SHORT $LN3@RecvSet
$LN2@RecvSet:

; 111  :     }
; 112  : 	
; 113  : 	m_Recvbuf = (LPBYTE)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, m_dwLength);

  002fb	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002fe	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00301	51		 push	 ecx
  00302	6a 08		 push	 8
  00304	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessHeap@0
  0030a	50		 push	 eax
  0030b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapAlloc@12
  00311	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00314	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 114  :     if (!m_Recvbuf)

  00317	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0031a	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  0031e	75 04		 jne	 SHORT $LN1@RecvSet

; 115  :     {        
; 116  :         return FALSE;

  00320	33 c0		 xor	 eax, eax
  00322	eb 05		 jmp	 SHORT $LN3@RecvSet
$LN1@RecvSet:

; 117  :     }
; 118  : 	return TRUE;

  00324	b8 01 00 00 00	 mov	 eax, 1
$LN3@RecvSet:

; 119  : }

  00329	5f		 pop	 edi
  0032a	5e		 pop	 esi
  0032b	5b		 pop	 ebx
  0032c	8b e5		 mov	 esp, ebp
  0032e	5d		 pop	 ebp
  0032f	c2 04 00	 ret	 4
?RecvSet@WzUdp@@QAEHH@Z ENDP				; WzUdp::RecvSet
_TEXT	ENDS
PUBLIC	?SendData@WzUdp@@QAEHPAEK@Z			; WzUdp::SendData
EXTRN	__imp__WSAGetLastError@0:PROC
EXTRN	__imp__WSASendTo@36:PROC
EXTRN	_memset:PROC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_Ret$ = -8						; size = 4
_this$ = -4						; size = 4
_SendData$ = 8						; size = 4
_nSendDataLen$ = 12					; size = 4
?SendData@WzUdp@@QAEHPAEK@Z PROC			; WzUdp::SendData
; _this$ = ecx

; 124  : {

  00340	55		 push	 ebp
  00341	8b ec		 mov	 ebp, esp
  00343	83 ec 48	 sub	 esp, 72			; 00000048H
  00346	53		 push	 ebx
  00347	56		 push	 esi
  00348	57		 push	 edi
  00349	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 125  : 	DWORD Ret;
; 126  : 
; 127  : 	ZeroMemory(&(m_PerIoSendData.Overlapped), sizeof(OVERLAPPED));

  0034c	6a 14		 push	 20			; 00000014H
  0034e	6a 00		 push	 0
  00350	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00353	83 c0 28	 add	 eax, 40			; 00000028H
  00356	50		 push	 eax
  00357	e8 00 00 00 00	 call	 _memset
  0035c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 128  : 	
; 129  : 	memcpy(m_PerIoSendData.Buffer, SendData, nSendDataLen);

  0035f	8b 45 0c	 mov	 eax, DWORD PTR _nSendDataLen$[ebp]
  00362	50		 push	 eax
  00363	8b 4d 08	 mov	 ecx, DWORD PTR _SendData$[ebp]
  00366	51		 push	 ecx
  00367	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0036a	83 c2 44	 add	 edx, 68			; 00000044H
  0036d	52		 push	 edx
  0036e	e8 00 00 00 00	 call	 _memcpy
  00373	83 c4 0c	 add	 esp, 12			; 0000000cH

; 130  : 	
; 131  : 	m_PerIoSendData.lOfs		= nSendDataLen;

  00376	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00379	8b 4d 0c	 mov	 ecx, DWORD PTR _nSendDataLen$[ebp]
  0037c	89 88 48 08 00
	00		 mov	 DWORD PTR [eax+2120], ecx

; 132  : 	m_PerIoSendData.DataBuf.buf = m_PerIoSendData.Buffer;

  00382	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00385	83 c0 44	 add	 eax, 68			; 00000044H
  00388	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0038b	89 41 40	 mov	 DWORD PTR [ecx+64], eax

; 133  : 	m_PerIoSendData.DataBuf.len = m_PerIoSendData.lOfs;

  0038e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00391	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00394	8b 91 48 08 00
	00		 mov	 edx, DWORD PTR [ecx+2120]
  0039a	89 50 3c	 mov	 DWORD PTR [eax+60], edx

; 134  : 		
; 135  : 	Ret = WSASendTo(m_Socket, &(m_PerIoSendData.DataBuf), 1, &nSendDataLen, 
; 136  : 		0, (SOCKADDR*)&m_SockAddr, sizeof(m_SockAddr), &(m_PerIoSendData.Overlapped), NULL);

  0039d	6a 00		 push	 0
  0039f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  003a2	83 c0 28	 add	 eax, 40			; 00000028H
  003a5	50		 push	 eax
  003a6	6a 10		 push	 16			; 00000010H
  003a8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003ab	81 c1 4c 08 00
	00		 add	 ecx, 2124		; 0000084cH
  003b1	51		 push	 ecx
  003b2	6a 00		 push	 0
  003b4	8d 55 0c	 lea	 edx, DWORD PTR _nSendDataLen$[ebp]
  003b7	52		 push	 edx
  003b8	6a 01		 push	 1
  003ba	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  003bd	83 c0 3c	 add	 eax, 60			; 0000003cH
  003c0	50		 push	 eax
  003c1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003c4	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  003c7	52		 push	 edx
  003c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSASendTo@36
  003ce	89 45 f8	 mov	 DWORD PTR _Ret$[ebp], eax

; 137  : 	if( Ret == SOCKET_ERROR )

  003d1	83 7d f8 ff	 cmp	 DWORD PTR _Ret$[ebp], -1
  003d5	75 12		 jne	 SHORT $LN2@SendData

; 138  : 	{
; 139  : 		if (WSAGetLastError() != ERROR_IO_PENDING)

  003d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  003dd	3d e5 03 00 00	 cmp	 eax, 997		; 000003e5H
  003e2	74 05		 je	 SHORT $LN2@SendData

; 140  : 		{
; 141  : 			//printf("WSASend() failed with error %d\n", WSAGetLastError());
; 142  : 			return -1;

  003e4	83 c8 ff	 or	 eax, -1
  003e7	eb 05		 jmp	 SHORT $LN3@SendData
$LN2@SendData:

; 143  : 		}
; 144  : 	}
; 145  : 	return TRUE;

  003e9	b8 01 00 00 00	 mov	 eax, 1
$LN3@SendData:

; 146  : }

  003ee	5f		 pop	 edi
  003ef	5e		 pop	 esi
  003f0	5b		 pop	 ebx
  003f1	8b e5		 mov	 esp, ebp
  003f3	5d		 pop	 ebp
  003f4	c2 08 00	 ret	 8
?SendData@WzUdp@@QAEHPAEK@Z ENDP			; WzUdp::SendData
_TEXT	ENDS
PUBLIC	?MuProtocolParse@WzUdp@@QAEHPAEAAH@Z		; WzUdp::MuProtocolParse
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_headcode$ = -13					; size = 1
_size$ = -12						; size = 4
_lOfs$ = -8						; size = 4
_this$ = -4						; size = 4
_RecvData$ = 8						; size = 4
_nRecvDataLen$ = 12					; size = 4
?MuProtocolParse@WzUdp@@QAEHPAEAAH@Z PROC		; WzUdp::MuProtocolParse
; _this$ = ecx

; 149  : {	

  00400	55		 push	 ebp
  00401	8b ec		 mov	 ebp, esp
  00403	83 ec 50	 sub	 esp, 80			; 00000050H
  00406	53		 push	 ebx
  00407	56		 push	 esi
  00408	57		 push	 edi
  00409	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 150  : 	int		lOfs = 0;

  0040c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _lOfs$[ebp], 0

; 151  : 	int		size = 0;

  00413	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _size$[ebp], 0

; 152  : 	BYTE	headcode;
; 153  : 
; 154  : 	if( ProtocolCore == NULL ) return FALSE;

  0041a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0041d	83 b8 5c 08 00
	00 00		 cmp	 DWORD PTR [eax+2140], 0
  00424	75 07		 jne	 SHORT $LN14@MuProtocol
  00426	33 c0		 xor	 eax, eax
  00428	e9 30 01 00 00	 jmp	 $LN16@MuProtocol
$LN14@MuProtocol:

; 155  : 
; 156  : 	while( TRUE )

  0042d	b8 01 00 00 00	 mov	 eax, 1
  00432	85 c0		 test	 eax, eax
  00434	0f 84 1e 01 00
	00		 je	 $LN13@MuProtocol

; 157  : 	{
; 158  : 		if( RecvData[lOfs] == 0xC1 )

  0043a	8b 45 08	 mov	 eax, DWORD PTR _RecvData$[ebp]
  0043d	03 45 f8	 add	 eax, DWORD PTR _lOfs$[ebp]
  00440	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00443	81 f9 c1 00 00
	00		 cmp	 ecx, 193		; 000000c1H
  00449	75 1b		 jne	 SHORT $LN12@MuProtocol

; 159  : 		{
; 160  : 			size		= *(RecvData+lOfs+1);

  0044b	8b 45 08	 mov	 eax, DWORD PTR _RecvData$[ebp]
  0044e	03 45 f8	 add	 eax, DWORD PTR _lOfs$[ebp]
  00451	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00455	89 4d f4	 mov	 DWORD PTR _size$[ebp], ecx

; 161  : 			headcode	= *(RecvData+lOfs+2);

  00458	8b 45 08	 mov	 eax, DWORD PTR _RecvData$[ebp]
  0045b	03 45 f8	 add	 eax, DWORD PTR _lOfs$[ebp]
  0045e	8a 48 02	 mov	 cl, BYTE PTR [eax+2]
  00461	88 4d f3	 mov	 BYTE PTR _headcode$[ebp], cl
  00464	eb 56		 jmp	 SHORT $LN11@MuProtocol
$LN12@MuProtocol:

; 162  : 		}
; 163  : 		else if( RecvData[lOfs] == 0xC2 )

  00466	8b 45 08	 mov	 eax, DWORD PTR _RecvData$[ebp]
  00469	03 45 f8	 add	 eax, DWORD PTR _lOfs$[ebp]
  0046c	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0046f	81 f9 c2 00 00
	00		 cmp	 ecx, 194		; 000000c2H
  00475	75 34		 jne	 SHORT $LN10@MuProtocol

; 164  : 		{
; 165  : 			size		 = (WORD)(*(RecvData+lOfs+1));

  00477	8b 45 08	 mov	 eax, DWORD PTR _RecvData$[ebp]
  0047a	03 45 f8	 add	 eax, DWORD PTR _lOfs$[ebp]
  0047d	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00481	89 4d f4	 mov	 DWORD PTR _size$[ebp], ecx

; 166  : 			size	   <<= 8;

  00484	8b 45 f4	 mov	 eax, DWORD PTR _size$[ebp]
  00487	c1 e0 08	 shl	 eax, 8
  0048a	89 45 f4	 mov	 DWORD PTR _size$[ebp], eax

; 167  : 			size		|= (WORD)(*(RecvData+lOfs+2));

  0048d	8b 45 08	 mov	 eax, DWORD PTR _RecvData$[ebp]
  00490	03 45 f8	 add	 eax, DWORD PTR _lOfs$[ebp]
  00493	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  00497	0b 4d f4	 or	 ecx, DWORD PTR _size$[ebp]
  0049a	89 4d f4	 mov	 DWORD PTR _size$[ebp], ecx

; 168  : 			headcode	 = *(RecvData+lOfs+3);

  0049d	8b 45 08	 mov	 eax, DWORD PTR _RecvData$[ebp]
  004a0	03 45 f8	 add	 eax, DWORD PTR _lOfs$[ebp]
  004a3	8a 48 03	 mov	 cl, BYTE PTR [eax+3]
  004a6	88 4d f3	 mov	 BYTE PTR _headcode$[ebp], cl

; 169  : 		}
; 170  : 		else  // 헤더가 맞지 않다면..

  004a9	eb 11		 jmp	 SHORT $LN11@MuProtocol
$LN10@MuProtocol:

; 171  : 		{
; 172  : 			m_dwRecvOfs = 0;

  004ab	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  004ae	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 173  : 			return FALSE;

  004b5	33 c0		 xor	 eax, eax
  004b7	e9 a1 00 00 00	 jmp	 $LN16@MuProtocol
$LN11@MuProtocol:

; 174  : 		}
; 175  : 		if( size <= 0 )	// size 가 0일때는 에러..

  004bc	83 7d f4 00	 cmp	 DWORD PTR _size$[ebp], 0
  004c0	7f 0c		 jg	 SHORT $LN8@MuProtocol

; 176  : 		{
; 177  : 			return FALSE;

  004c2	33 c0		 xor	 eax, eax
  004c4	e9 94 00 00 00	 jmp	 $LN16@MuProtocol
  004c9	e9 85 00 00 00	 jmp	 $LN7@MuProtocol
$LN8@MuProtocol:

; 178  : 		}		
; 179  : 		else if( size <= nRecvDataLen )	// 하나의 패킷이 완전하다면..

  004ce	8b 45 0c	 mov	 eax, DWORD PTR _nRecvDataLen$[ebp]
  004d1	8b 4d f4	 mov	 ecx, DWORD PTR _size$[ebp]
  004d4	3b 08		 cmp	 ecx, DWORD PTR [eax]
  004d6	7f 43		 jg	 SHORT $LN6@MuProtocol

; 180  : 		{
; 181  : 			(*ProtocolCore)(headcode, RecvData+lOfs, size);

  004d8	8b 45 f4	 mov	 eax, DWORD PTR _size$[ebp]
  004db	50		 push	 eax
  004dc	8b 4d 08	 mov	 ecx, DWORD PTR _RecvData$[ebp]
  004df	03 4d f8	 add	 ecx, DWORD PTR _lOfs$[ebp]
  004e2	51		 push	 ecx
  004e3	0f b6 55 f3	 movzx	 edx, BYTE PTR _headcode$[ebp]
  004e7	52		 push	 edx
  004e8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  004eb	8b 88 5c 08 00
	00		 mov	 ecx, DWORD PTR [eax+2140]
  004f1	ff d1		 call	 ecx
  004f3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 182  : 			lOfs		 += size;

  004f6	8b 45 f8	 mov	 eax, DWORD PTR _lOfs$[ebp]
  004f9	03 45 f4	 add	 eax, DWORD PTR _size$[ebp]
  004fc	89 45 f8	 mov	 DWORD PTR _lOfs$[ebp], eax

; 183  : 			m_dwRecvOfs  -= size;

  004ff	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00502	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00505	2b 4d f4	 sub	 ecx, DWORD PTR _size$[ebp]
  00508	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0050b	89 4a 20	 mov	 DWORD PTR [edx+32], ecx

; 184  : 			if( m_dwRecvOfs <= 0 ) break;

  0050e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00511	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  00515	7f 02		 jg	 SHORT $LN5@MuProtocol
  00517	eb 3f		 jmp	 SHORT $LN13@MuProtocol
$LN5@MuProtocol:

; 185  : 		}		
; 186  : 		else												// 데이터가 더 남았다면

  00519	eb 38		 jmp	 SHORT $LN7@MuProtocol
$LN6@MuProtocol:

; 187  : 		{	
; 188  : 			if( lOfs > 0 )									// 하나이상 데이터를 처리한 후 라면..

  0051b	83 7d f8 00	 cmp	 DWORD PTR _lOfs$[ebp], 0
  0051f	7e 30		 jle	 SHORT $LN3@MuProtocol

; 189  : 			{
; 190  : 				if( m_dwRecvOfs < 1 )

  00521	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00524	83 78 20 01	 cmp	 DWORD PTR [eax+32], 1
  00528	7d 06		 jge	 SHORT $LN2@MuProtocol

; 191  : 				{
; 192  : 					return FALSE;

  0052a	33 c0		 xor	 eax, eax
  0052c	eb 2f		 jmp	 SHORT $LN16@MuProtocol

; 193  : 				}
; 194  : 				else 

  0052e	eb 21		 jmp	 SHORT $LN3@MuProtocol
$LN2@MuProtocol:

; 195  : 				{
; 196  : 					memcpy(RecvData, (RecvData+lOfs), m_dwRecvOfs); // 남은만큼 복사한다.

  00530	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00533	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00536	51		 push	 ecx
  00537	8b 55 08	 mov	 edx, DWORD PTR _RecvData$[ebp]
  0053a	03 55 f8	 add	 edx, DWORD PTR _lOfs$[ebp]
  0053d	52		 push	 edx
  0053e	8b 45 08	 mov	 eax, DWORD PTR _RecvData$[ebp]
  00541	50		 push	 eax
  00542	e8 00 00 00 00	 call	 _memcpy
  00547	83 c4 0c	 add	 esp, 12			; 0000000cH

; 197  : 					return TRUE;

  0054a	b8 01 00 00 00	 mov	 eax, 1
  0054f	eb 0c		 jmp	 SHORT $LN16@MuProtocol
$LN3@MuProtocol:

; 198  : 				}
; 199  : 			}
; 200  : 			break;

  00551	eb 05		 jmp	 SHORT $LN13@MuProtocol
$LN7@MuProtocol:

; 201  : 		}
; 202  : 	}

  00553	e9 d5 fe ff ff	 jmp	 $LN14@MuProtocol
$LN13@MuProtocol:

; 203  : 	return TRUE;

  00558	b8 01 00 00 00	 mov	 eax, 1
$LN16@MuProtocol:

; 204  : }

  0055d	5f		 pop	 edi
  0055e	5e		 pop	 esi
  0055f	5b		 pop	 ebx
  00560	8b e5		 mov	 esp, ebp
  00562	5d		 pop	 ebp
  00563	c2 08 00	 ret	 8
?MuProtocolParse@WzUdp@@QAEHPAEAAH@Z ENDP		; WzUdp::MuProtocolParse
_TEXT	ENDS
PUBLIC	?WzUdpRecvThread@@YGKPAVWzUdp@@@Z		; WzUdpRecvThread
PUBLIC	?Run@WzUdp@@QAEHXZ				; WzUdp::Run
EXTRN	__imp__CreateThread@24:PROC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv65 = -72						; size = 4
_this$ = -4						; size = 4
?Run@WzUdp@@QAEHXZ PROC					; WzUdp::Run
; _this$ = ecx

; 208  : {

  00570	55		 push	 ebp
  00571	8b ec		 mov	 ebp, esp
  00573	83 ec 48	 sub	 esp, 72			; 00000048H
  00576	53		 push	 ebx
  00577	56		 push	 esi
  00578	57		 push	 edi
  00579	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 209  : 	if( (m_ThreadHandle = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)WzUdpRecvThread, (void*)this, 0, &m_ThreadID) ) == NULL)

  0057c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0057f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00582	50		 push	 eax
  00583	6a 00		 push	 0
  00585	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00588	51		 push	 ecx
  00589	68 00 00 00 00	 push	 OFFSET ?WzUdpRecvThread@@YGKPAVWzUdp@@@Z ; WzUdpRecvThread
  0058e	6a 00		 push	 0
  00590	6a 00		 push	 0
  00592	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateThread@24
  00598	89 45 b8	 mov	 DWORD PTR tv65[ebp], eax
  0059b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0059e	8b 45 b8	 mov	 eax, DWORD PTR tv65[ebp]
  005a1	89 42 08	 mov	 DWORD PTR [edx+8], eax
  005a4	83 7d b8 00	 cmp	 DWORD PTR tv65[ebp], 0
  005a8	75 04		 jne	 SHORT $LN1@Run

; 210  : 	{		
; 211  : 		return FALSE;

  005aa	33 c0		 xor	 eax, eax
  005ac	eb 05		 jmp	 SHORT $LN2@Run
$LN1@Run:

; 212  : 	}
; 213  : 	return TRUE;

  005ae	b8 01 00 00 00	 mov	 eax, 1
$LN2@Run:

; 214  : }

  005b3	5f		 pop	 edi
  005b4	5e		 pop	 esi
  005b5	5b		 pop	 ebx
  005b6	8b e5		 mov	 esp, ebp
  005b8	5d		 pop	 ebp
  005b9	c3		 ret	 0
?Run@WzUdp@@QAEHXZ ENDP					; WzUdp::Run
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?RecvThread@WzUdp@@QAEHXZ			; WzUdp::RecvThread
EXTRN	__imp__recvfrom@24:PROC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_sender$ = -32						; size = 16
_dwSenderSize$ = -16					; size = 4
_ret$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?RecvThread@WzUdp@@QAEHXZ PROC				; WzUdp::RecvThread
; _this$ = ecx

; 217  : {

  005c0	55		 push	 ebp
  005c1	8b ec		 mov	 ebp, esp
  005c3	83 ec 60	 sub	 esp, 96			; 00000060H
  005c6	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  005cb	33 c5		 xor	 eax, ebp
  005cd	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  005d0	53		 push	 ebx
  005d1	56		 push	 esi
  005d2	57		 push	 edi
  005d3	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 218  : 	int			ret;
; 219  :     DWORD		dwSenderSize;
; 220  :     SOCKADDR_IN	sender;	
; 221  : 	
; 222  : 	dwSenderSize = sizeof(sender);

  005d6	c7 45 f0 10 00
	00 00		 mov	 DWORD PTR _dwSenderSize$[ebp], 16 ; 00000010H
$LN6@RecvThread:

; 223  : 	while(1)

  005dd	b8 01 00 00 00	 mov	 eax, 1
  005e2	85 c0		 test	 eax, eax
  005e4	74 73		 je	 SHORT $LN7@RecvThread

; 224  : 	{		
; 225  : 		ret = recvfrom(m_Socket, (char*)m_Recvbuf+m_dwRecvOfs,
; 226  : 			DEFAULT_BUFFER_LENGTH-m_dwRecvOfs, 0, (SOCKADDR *)&sender, (int*)&dwSenderSize);

  005e6	8d 45 f0	 lea	 eax, DWORD PTR _dwSenderSize$[ebp]
  005e9	50		 push	 eax
  005ea	8d 4d e0	 lea	 ecx, DWORD PTR _sender$[ebp]
  005ed	51		 push	 ecx
  005ee	6a 00		 push	 0
  005f0	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  005f3	b8 00 10 00 00	 mov	 eax, 4096		; 00001000H
  005f8	2b 42 20	 sub	 eax, DWORD PTR [edx+32]
  005fb	50		 push	 eax
  005fc	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  005ff	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00602	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00605	03 50 20	 add	 edx, DWORD PTR [eax+32]
  00608	52		 push	 edx
  00609	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0060c	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0060f	52		 push	 edx
  00610	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__recvfrom@24
  00616	89 45 f4	 mov	 DWORD PTR _ret$[ebp], eax

; 227  : 
; 228  : 		if (ret == SOCKET_ERROR)

  00619	83 7d f4 ff	 cmp	 DWORD PTR _ret$[ebp], -1
  0061d	75 02		 jne	 SHORT $LN4@RecvThread
  0061f	eb 36		 jmp	 SHORT $LN3@RecvThread
$LN4@RecvThread:

; 229  : 		{
; 230  : 			//printf("recvfrom() failed; %d\n", WSAGetLastError());
; 231  : 		}
; 232  : 		else if (ret == 0)

  00621	83 7d f4 00	 cmp	 DWORD PTR _ret$[ebp], 0
  00625	75 02		 jne	 SHORT $LN2@RecvThread

; 233  : 		{
; 234  : 		}
; 235  : 		else

  00627	eb 2e		 jmp	 SHORT $LN3@RecvThread
$LN2@RecvThread:

; 236  : 		{
; 237  : 			m_dwLength  = ret;

  00629	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0062c	8b 4d f4	 mov	 ecx, DWORD PTR _ret$[ebp]
  0062f	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 238  : 			m_dwRecvOfs += ret;

  00632	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00635	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00638	03 4d f4	 add	 ecx, DWORD PTR _ret$[ebp]
  0063b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0063e	89 4a 20	 mov	 DWORD PTR [edx+32], ecx

; 239  : 			MuProtocolParse(m_Recvbuf, m_dwLength);

  00641	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00644	83 c0 1c	 add	 eax, 28			; 0000001cH
  00647	50		 push	 eax
  00648	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0064b	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0064e	52		 push	 edx
  0064f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00652	e8 00 00 00 00	 call	 ?MuProtocolParse@WzUdp@@QAEHPAEAAH@Z ; WzUdp::MuProtocolParse
$LN3@RecvThread:

; 240  : 		}
; 241  : 	}

  00657	eb 84		 jmp	 SHORT $LN6@RecvThread
$LN7@RecvThread:

; 242  : }

  00659	5f		 pop	 edi
  0065a	5e		 pop	 esi
  0065b	5b		 pop	 ebx
  0065c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0065f	33 cd		 xor	 ecx, ebp
  00661	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00666	8b e5		 mov	 esp, ebp
  00668	5d		 pop	 ebp
  00669	c3		 ret	 0
?RecvThread@WzUdp@@QAEHXZ ENDP				; WzUdp::RecvThread
; Function compile flags: /Odtp /ZI
_lpWzUdp$ = 8						; size = 4
?WzUdpRecvThread@@YGKPAVWzUdp@@@Z PROC			; WzUdpRecvThread

; 245  : {

  00670	55		 push	 ebp
  00671	8b ec		 mov	 ebp, esp
  00673	83 ec 40	 sub	 esp, 64			; 00000040H
  00676	53		 push	 ebx
  00677	56		 push	 esi
  00678	57		 push	 edi

; 246  :     lpWzUdp->RecvThread();

  00679	8b 4d 08	 mov	 ecx, DWORD PTR _lpWzUdp$[ebp]
  0067c	e8 00 00 00 00	 call	 ?RecvThread@WzUdp@@QAEHXZ ; WzUdp::RecvThread

; 247  : 	return TRUE;

  00681	b8 01 00 00 00	 mov	 eax, 1

; 248  : }

  00686	5f		 pop	 edi
  00687	5e		 pop	 esi
  00688	5b		 pop	 ebx
  00689	8b e5		 mov	 esp, ebp
  0068b	5d		 pop	 ebp
  0068c	c2 04 00	 ret	 4
?WzUdpRecvThread@@YGKPAVWzUdp@@@Z ENDP			; WzUdpRecvThread
_TEXT	ENDS
END
