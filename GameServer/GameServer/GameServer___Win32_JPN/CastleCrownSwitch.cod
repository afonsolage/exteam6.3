; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	D:\Projects\ExTeam6.3\Source\GameServer\GameServer\CastleCrownSwitch.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
_DATA	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Odtp /ZI
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@vector:
  00009	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000c	83 e8 01	 sub	 eax, 1
  0000f	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00012	78 11		 js	 SHORT $LN3@vector
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00017	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  0001d	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00020	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00023	eb e4		 jmp	 SHORT $LN2@vector
$LN3@vector:
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??_7CCastleCrownSwitch@@6B@			; CCastleCrownSwitch::`vftable'
PUBLIC	??0CCastleCrownSwitch@@QAE@XZ			; CCastleCrownSwitch::CCastleCrownSwitch
PUBLIC	??_R4CCastleCrownSwitch@@6B@			; CCastleCrownSwitch::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCCastleCrownSwitch@@@8			; CCastleCrownSwitch `RTTI Type Descriptor'
PUBLIC	??_R3CCastleCrownSwitch@@8			; CCastleCrownSwitch::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CCastleCrownSwitch@@8			; CCastleCrownSwitch::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CCastleCrownSwitch@@8		; CCastleCrownSwitch::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ECCastleCrownSwitch@@UAEPAXI@Z:PROC		; CCastleCrownSwitch::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CCastleCrownSwitch@@8
; File d:\projects\exteam6.3\source\gameserver\gameserver\castlecrownswitch.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@CCastleCrownSwitch@@8 DD FLAT:??_R0?AVCCastleCrownSwitch@@@8 ; CCastleCrownSwitch::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CCastleCrownSwitch@@8
rdata$r	ENDS
;	COMDAT ??_R2CCastleCrownSwitch@@8
rdata$r	SEGMENT
??_R2CCastleCrownSwitch@@8 DD FLAT:??_R1A@?0A@EA@CCastleCrownSwitch@@8 ; CCastleCrownSwitch::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CCastleCrownSwitch@@8
rdata$r	SEGMENT
??_R3CCastleCrownSwitch@@8 DD 00H			; CCastleCrownSwitch::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CCastleCrownSwitch@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCCastleCrownSwitch@@@8
_DATA	SEGMENT
??_R0?AVCCastleCrownSwitch@@@8 DD FLAT:??_7type_info@@6B@ ; CCastleCrownSwitch `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCCastleCrownSwitch@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CCastleCrownSwitch@@6B@
rdata$r	SEGMENT
??_R4CCastleCrownSwitch@@6B@ DD 00H			; CCastleCrownSwitch::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCCastleCrownSwitch@@@8
	DD	FLAT:??_R3CCastleCrownSwitch@@8
rdata$r	ENDS
;	COMDAT ??_7CCastleCrownSwitch@@6B@
CONST	SEGMENT
??_7CCastleCrownSwitch@@6B@ DD FLAT:??_R4CCastleCrownSwitch@@6B@ ; CCastleCrownSwitch::`vftable'
	DD	FLAT:??_ECCastleCrownSwitch@@UAEPAXI@Z
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CCastleCrownSwitch@@QAE@XZ PROC			; CCastleCrownSwitch::CCastleCrownSwitch
; _this$ = ecx

; 19   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CCastleCrownSwitch@@6B@

; 20   : 	return;
; 21   : }

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0CCastleCrownSwitch@@QAE@XZ ENDP			; CCastleCrownSwitch::CCastleCrownSwitch
_TEXT	ENDS
PUBLIC	??1CCastleCrownSwitch@@UAE@XZ			; CCastleCrownSwitch::~CCastleCrownSwitch
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp /ZI
;	COMDAT ??_GCCastleCrownSwitch@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCCastleCrownSwitch@@UAEPAXI@Z PROC			; CCastleCrownSwitch::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1CCastleCrownSwitch@@UAE@XZ ; CCastleCrownSwitch::~CCastleCrownSwitch
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_GCCastleCrownSwitch@@UAEPAXI@Z ENDP			; CCastleCrownSwitch::`scalar deleting destructor'
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CCastleCrownSwitch@@UAE@XZ PROC			; CCastleCrownSwitch::~CCastleCrownSwitch
; _this$ = ecx

; 24   : {

  00020	55		 push	 ebp
  00021	8b ec		 mov	 ebp, esp
  00023	83 ec 44	 sub	 esp, 68			; 00000044H
  00026	53		 push	 ebx
  00027	56		 push	 esi
  00028	57		 push	 edi
  00029	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CCastleCrownSwitch@@6B@

; 25   : 	return;
; 26   : }

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??1CCastleCrownSwitch@@UAE@XZ ENDP			; CCastleCrownSwitch::~CCastleCrownSwitch
_TEXT	ENDS
PUBLIC	??_C@_0FD@POFOJJJE@?$FLCastleSiege?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Push?5Cast@ ; `string'
PUBLIC	?SetRegCrownAvailable@CCastleSiege@@QAEXH@Z	; CCastleSiege::SetRegCrownAvailable
PUBLIC	?GetRegCrownAvailable@CCastleSiege@@QAEHXZ	; CCastleSiege::GetRegCrownAvailable
PUBLIC	?CastleCrownSwitchAct@CCastleCrownSwitch@@QAEXH@Z ; CCastleCrownSwitch::CastleCrownSwitchAct
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?GCAnsCsAccessSwitchState@@YAXHHHE@Z:PROC	; GCAnsCsAccessSwitchState
EXTRN	_abs:PROC
EXTRN	?NotifyCrownSwitchInfo@CCastleSiege@@QAEXH@Z:PROC ; CCastleSiege::NotifyCrownSwitchInfo
EXTRN	?NotifyCrownState@CCastleSiege@@QAEXE@Z:PROC	; CCastleSiege::NotifyCrownState
EXTRN	?ResetCrownSwitchUserIndex@CCastleSiege@@QAEXH@Z:PROC ; CCastleSiege::ResetCrownSwitchUserIndex
EXTRN	?GetCrownSwitchUserIndex@CCastleSiege@@QAEHH@Z:PROC ; CCastleSiege::GetCrownSwitchUserIndex
EXTRN	?g_CastleSiege@@3VCCastleSiege@@A:BYTE		; g_CastleSiege
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?gObjIsConnected@@YAHH@Z:PROC			; gObjIsConnected
;	COMDAT ??_C@_0FD@POFOJJJE@?$FLCastleSiege?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Push?5Cast@
CONST	SEGMENT
??_C@_0FD@POFOJJJE@?$FLCastleSiege?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Push?5Cast@ DB '['
	DB	'CastleSiege] [%s][%s] Push Castle Crown Switch Canceled (GUIL'
	DB	'D:%s) - CS X:%d/Y:%d', 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv83 = -88						; size = 4
_iCrownIndex2$221983 = -20				; size = 4
_iCrownIndex1$221982 = -16				; size = 4
_lpUserObj$ = -12					; size = 4
_lpObj$ = -8						; size = 4
_this$ = -4						; size = 4
_iIndex$ = 8						; size = 4
?CastleCrownSwitchAct@CCastleCrownSwitch@@QAEXH@Z PROC	; CCastleCrownSwitch::CastleCrownSwitchAct
; _this$ = ecx

; 29   : {

  00040	55		 push	 ebp
  00041	8b ec		 mov	 ebp, esp
  00043	83 ec 58	 sub	 esp, 88			; 00000058H
  00046	53		 push	 ebx
  00047	56		 push	 esi
  00048	57		 push	 edi
  00049	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 30   : 	if ( !gObjIsConnected(iIndex))

  0004c	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00055	83 c4 04	 add	 esp, 4
  00058	85 c0		 test	 eax, eax
  0005a	75 05		 jne	 SHORT $LN14@CastleCrow

; 31   : 		return;

  0005c	e9 56 03 00 00	 jmp	 $LN15@CastleCrow
$LN14@CastleCrow:

; 32   : 
; 33   : 	if ( gObj[iIndex].Type != OBJ_NPC ||
; 34   : 		((gObj[iIndex].Class < 217 )?FALSE:(gObj[iIndex].Class > 219-1 )?FALSE:TRUE)==FALSE )

  00061	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00064	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0006a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00070	0f b7 54 01 68	 movzx	 edx, WORD PTR [ecx+eax+104]
  00075	83 fa 03	 cmp	 edx, 3
  00078	75 53		 jne	 SHORT $LN12@CastleCrow
  0007a	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0007d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00083	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00089	0f b7 94 01 b8
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+184]
  00091	81 fa d9 00 00
	00		 cmp	 edx, 217		; 000000d9H
  00097	7d 09		 jge	 SHORT $LN17@CastleCrow
  00099	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv83[ebp], 0
  000a0	eb 25		 jmp	 SHORT $LN18@CastleCrow
$LN17@CastleCrow:
  000a2	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  000a5	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  000ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000b1	0f b7 94 01 b8
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+184]
  000b9	33 c0		 xor	 eax, eax
  000bb	81 fa da 00 00
	00		 cmp	 edx, 218		; 000000daH
  000c1	0f 9e c0	 setle	 al
  000c4	89 45 a8	 mov	 DWORD PTR tv83[ebp], eax
$LN18@CastleCrow:
  000c7	83 7d a8 00	 cmp	 DWORD PTR tv83[ebp], 0
  000cb	75 05		 jne	 SHORT $LN13@CastleCrow
$LN12@CastleCrow:

; 35   : 		return;

  000cd	e9 e5 02 00 00	 jmp	 $LN15@CastleCrow
$LN13@CastleCrow:

; 36   : 
; 37   : 	if ( !gObjIsConnected(g_CastleSiege.GetCrownSwitchUserIndex(gObj[iIndex].Class)) )

  000d2	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  000d5	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  000db	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000e1	0f b7 94 01 b8
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+184]
  000e9	52		 push	 edx
  000ea	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000ef	e8 00 00 00 00	 call	 ?GetCrownSwitchUserIndex@CCastleSiege@@QAEHH@Z ; CCastleSiege::GetCrownSwitchUserIndex
  000f4	50		 push	 eax
  000f5	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  000fa	83 c4 04	 add	 esp, 4
  000fd	85 c0		 test	 eax, eax
  000ff	75 4e		 jne	 SHORT $LN11@CastleCrow

; 38   : 	{
; 39   : 		g_CastleSiege.ResetCrownSwitchUserIndex(gObj[iIndex].Class);

  00101	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00104	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0010a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00110	0f b7 94 01 b8
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+184]
  00118	52		 push	 edx
  00119	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0011e	e8 00 00 00 00	 call	 ?ResetCrownSwitchUserIndex@CCastleSiege@@QAEXH@Z ; CCastleSiege::ResetCrownSwitchUserIndex

; 40   : 
; 41   : 		if ( g_CastleSiege.GetRegCrownAvailable() == 1 )

  00123	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00128	e8 00 00 00 00	 call	 ?GetRegCrownAvailable@CCastleSiege@@QAEHXZ ; CCastleSiege::GetRegCrownAvailable
  0012d	83 f8 01	 cmp	 eax, 1
  00130	75 18		 jne	 SHORT $LN10@CastleCrow

; 42   : 		{
; 43   : 			g_CastleSiege.SetRegCrownAvailable(FALSE);

  00132	6a 00		 push	 0
  00134	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00139	e8 00 00 00 00	 call	 ?SetRegCrownAvailable@CCastleSiege@@QAEXH@Z ; CCastleSiege::SetRegCrownAvailable

; 44   : 			g_CastleSiege.NotifyCrownState(1);

  0013e	6a 01		 push	 1
  00140	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00145	e8 00 00 00 00	 call	 ?NotifyCrownState@CCastleSiege@@QAEXE@Z ; CCastleSiege::NotifyCrownState
$LN10@CastleCrow:

; 45   : 		}
; 46   : 
; 47   : 		return;

  0014a	e9 68 02 00 00	 jmp	 $LN15@CastleCrow
$LN11@CastleCrow:

; 48   : 	}
; 49   : 	
; 50   : 	LPOBJ lpObj= &gObj[iIndex];

  0014f	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00152	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00158	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0015e	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 51   : 	LPOBJ lpUserObj = &gObj[g_CastleSiege.GetCrownSwitchUserIndex(gObj[iIndex].Class)];

  00161	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00164	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0016a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00170	0f b7 94 01 b8
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+184]
  00178	52		 push	 edx
  00179	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0017e	e8 00 00 00 00	 call	 ?GetCrownSwitchUserIndex@CCastleSiege@@QAEHH@Z ; CCastleSiege::GetCrownSwitchUserIndex
  00183	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00189	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0018f	89 45 f4	 mov	 DWORD PTR _lpUserObj$[ebp], eax

; 52   : 	g_CastleSiege.NotifyCrownSwitchInfo(iIndex);

  00192	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00195	50		 push	 eax
  00196	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0019b	e8 00 00 00 00	 call	 ?NotifyCrownSwitchInfo@CCastleSiege@@QAEXH@Z ; CCastleSiege::NotifyCrownSwitchInfo

; 53   : 
; 54   : 	if ( lpUserObj->MapNumber == MAP_INDEX_CASTLESIEGE &&
; 55   : 		 lpUserObj->m_btCsJoinSide >= 2 )

  001a0	8b 45 f4	 mov	 eax, DWORD PTR _lpUserObj$[ebp]
  001a3	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  001aa	83 f9 1e	 cmp	 ecx, 30			; 0000001eH
  001ad	0f 85 a3 01 00
	00		 jne	 $LN9@CastleCrow
  001b3	8b 45 f4	 mov	 eax, DWORD PTR _lpUserObj$[ebp]
  001b6	0f b6 88 02 1c
	00 00		 movzx	 ecx, BYTE PTR [eax+7170]
  001bd	83 f9 02	 cmp	 ecx, 2
  001c0	0f 8c 90 01 00
	00		 jl	 $LN9@CastleCrow

; 56   : 	{
; 57   : 		if ( abs(lpObj->Y - lpUserObj->Y) <= 3 &&
; 58   : 			 abs(lpObj->X - lpUserObj->X) <= 3 )

  001c6	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001c9	0f bf 88 46 01
	00 00		 movsx	 ecx, WORD PTR [eax+326]
  001d0	8b 55 f4	 mov	 edx, DWORD PTR _lpUserObj$[ebp]
  001d3	0f bf 82 46 01
	00 00		 movsx	 eax, WORD PTR [edx+326]
  001da	2b c8		 sub	 ecx, eax
  001dc	51		 push	 ecx
  001dd	e8 00 00 00 00	 call	 _abs
  001e2	83 c4 04	 add	 esp, 4
  001e5	83 f8 03	 cmp	 eax, 3
  001e8	0f 8f c9 00 00
	00		 jg	 $LN8@CastleCrow
  001ee	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001f1	0f bf 88 44 01
	00 00		 movsx	 ecx, WORD PTR [eax+324]
  001f8	8b 55 f4	 mov	 edx, DWORD PTR _lpUserObj$[ebp]
  001fb	0f bf 82 44 01
	00 00		 movsx	 eax, WORD PTR [edx+324]
  00202	2b c8		 sub	 ecx, eax
  00204	51		 push	 ecx
  00205	e8 00 00 00 00	 call	 _abs
  0020a	83 c4 04	 add	 esp, 4
  0020d	83 f8 03	 cmp	 eax, 3
  00210	0f 8f a1 00 00
	00		 jg	 $LN8@CastleCrow

; 59   : 		{
; 60   : 			int iCrownIndex1 = g_CastleSiege.GetCrownSwitchUserIndex(217);

  00216	68 d9 00 00 00	 push	 217			; 000000d9H
  0021b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00220	e8 00 00 00 00	 call	 ?GetCrownSwitchUserIndex@CCastleSiege@@QAEHH@Z ; CCastleSiege::GetCrownSwitchUserIndex
  00225	89 45 f0	 mov	 DWORD PTR _iCrownIndex1$221982[ebp], eax

; 61   : 			int iCrownIndex2 = g_CastleSiege.GetCrownSwitchUserIndex(218);

  00228	68 da 00 00 00	 push	 218			; 000000daH
  0022d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00232	e8 00 00 00 00	 call	 ?GetCrownSwitchUserIndex@CCastleSiege@@QAEHH@Z ; CCastleSiege::GetCrownSwitchUserIndex
  00237	89 45 ec	 mov	 DWORD PTR _iCrownIndex2$221983[ebp], eax

; 62   : 
; 63   : 			if (gObjIsConnected(iCrownIndex1) && gObjIsConnected(iCrownIndex2) )

  0023a	8b 45 f0	 mov	 eax, DWORD PTR _iCrownIndex1$221982[ebp]
  0023d	50		 push	 eax
  0023e	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00243	83 c4 04	 add	 esp, 4
  00246	85 c0		 test	 eax, eax
  00248	74 68		 je	 SHORT $LN7@CastleCrow
  0024a	8b 45 ec	 mov	 eax, DWORD PTR _iCrownIndex2$221983[ebp]
  0024d	50		 push	 eax
  0024e	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00253	83 c4 04	 add	 esp, 4
  00256	85 c0		 test	 eax, eax
  00258	74 58		 je	 SHORT $LN7@CastleCrow

; 64   : 			{
; 65   : 				if ( gObj[iCrownIndex1].m_btCsJoinSide == gObj[iCrownIndex2].m_btCsJoinSide )

  0025a	8b 45 f0	 mov	 eax, DWORD PTR _iCrownIndex1$221982[ebp]
  0025d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00263	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00269	0f b6 94 01 02
	1c 00 00	 movzx	 edx, BYTE PTR [ecx+eax+7170]
  00271	8b 45 ec	 mov	 eax, DWORD PTR _iCrownIndex2$221983[ebp]
  00274	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0027a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00280	0f b6 84 01 02
	1c 00 00	 movzx	 eax, BYTE PTR [ecx+eax+7170]
  00288	3b d0		 cmp	 edx, eax
  0028a	75 26		 jne	 SHORT $LN7@CastleCrow

; 66   : 				{
; 67   : 					if ( g_CastleSiege.GetRegCrownAvailable() == 0 )

  0028c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00291	e8 00 00 00 00	 call	 ?GetRegCrownAvailable@CCastleSiege@@QAEHXZ ; CCastleSiege::GetRegCrownAvailable
  00296	85 c0		 test	 eax, eax
  00298	75 18		 jne	 SHORT $LN7@CastleCrow

; 68   : 					{
; 69   : 						g_CastleSiege.SetRegCrownAvailable(TRUE);

  0029a	6a 01		 push	 1
  0029c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  002a1	e8 00 00 00 00	 call	 ?SetRegCrownAvailable@CCastleSiege@@QAEXH@Z ; CCastleSiege::SetRegCrownAvailable

; 70   : 						g_CastleSiege.NotifyCrownState(0);

  002a6	6a 00		 push	 0
  002a8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  002ad	e8 00 00 00 00	 call	 ?NotifyCrownState@CCastleSiege@@QAEXE@Z ; CCastleSiege::NotifyCrownState
$LN7@CastleCrow:

; 71   : 					}
; 72   : 				}
; 73   : 			}
; 74   : 		}
; 75   : 		else

  002b2	e9 9d 00 00 00	 jmp	 $LN4@CastleCrow
$LN8@CastleCrow:

; 76   : 		{
; 77   : 			GCAnsCsAccessSwitchState(lpUserObj->m_Index, lpObj->m_Index, -1, 0);

  002b7	6a 00		 push	 0
  002b9	6a ff		 push	 -1
  002bb	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002be	8b 08		 mov	 ecx, DWORD PTR [eax]
  002c0	51		 push	 ecx
  002c1	8b 55 f4	 mov	 edx, DWORD PTR _lpUserObj$[ebp]
  002c4	8b 02		 mov	 eax, DWORD PTR [edx]
  002c6	50		 push	 eax
  002c7	e8 00 00 00 00	 call	 ?GCAnsCsAccessSwitchState@@YAXHHHE@Z ; GCAnsCsAccessSwitchState
  002cc	83 c4 10	 add	 esp, 16			; 00000010H

; 78   : 			g_CastleSiege.ResetCrownSwitchUserIndex(gObj[iIndex].Class);

  002cf	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  002d2	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  002d8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002de	0f b7 94 01 b8
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+184]
  002e6	52		 push	 edx
  002e7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  002ec	e8 00 00 00 00	 call	 ?ResetCrownSwitchUserIndex@CCastleSiege@@QAEXH@Z ; CCastleSiege::ResetCrownSwitchUserIndex

; 79   : 
; 80   : 			if ( g_CastleSiege.GetRegCrownAvailable() == 1 )

  002f1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  002f6	e8 00 00 00 00	 call	 ?GetRegCrownAvailable@CCastleSiege@@QAEHXZ ; CCastleSiege::GetRegCrownAvailable
  002fb	83 f8 01	 cmp	 eax, 1
  002fe	75 18		 jne	 SHORT $LN3@CastleCrow

; 81   : 			{
; 82   : 				g_CastleSiege.SetRegCrownAvailable(FALSE);

  00300	6a 00		 push	 0
  00302	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00307	e8 00 00 00 00	 call	 ?SetRegCrownAvailable@CCastleSiege@@QAEXH@Z ; CCastleSiege::SetRegCrownAvailable

; 83   : 				g_CastleSiege.NotifyCrownState(1);

  0030c	6a 01		 push	 1
  0030e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00313	e8 00 00 00 00	 call	 ?NotifyCrownState@CCastleSiege@@QAEXE@Z ; CCastleSiege::NotifyCrownState
$LN3@CastleCrow:

; 84   : 			}
; 85   : 
; 86   : 			LogAddTD("[CastleSiege] [%s][%s] Push Castle Crown Switch Canceled (GUILD:%s) - CS X:%d/Y:%d",
; 87   : 				lpUserObj->AccountID, lpUserObj->Name, lpUserObj->GuildName, lpObj->X, lpObj->Y);

  00318	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0031b	0f bf 88 46 01
	00 00		 movsx	 ecx, WORD PTR [eax+326]
  00322	51		 push	 ecx
  00323	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00326	0f bf 82 44 01
	00 00		 movsx	 eax, WORD PTR [edx+324]
  0032d	50		 push	 eax
  0032e	8b 4d f4	 mov	 ecx, DWORD PTR _lpUserObj$[ebp]
  00331	81 c1 3c 04 00
	00		 add	 ecx, 1084		; 0000043cH
  00337	51		 push	 ecx
  00338	8b 55 f4	 mov	 edx, DWORD PTR _lpUserObj$[ebp]
  0033b	83 c2 77	 add	 edx, 119		; 00000077H
  0033e	52		 push	 edx
  0033f	8b 45 f4	 mov	 eax, DWORD PTR _lpUserObj$[ebp]
  00342	83 c0 6c	 add	 eax, 108		; 0000006cH
  00345	50		 push	 eax
  00346	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@POFOJJJE@?$FLCastleSiege?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Push?5Cast@
  0034b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00351	83 c4 18	 add	 esp, 24			; 00000018H
$LN4@CastleCrow:

; 88   : 		}
; 89   : 	}
; 90   : 	else

  00354	eb 61		 jmp	 SHORT $LN15@CastleCrow
$LN9@CastleCrow:

; 91   : 	{
; 92   : 		GCAnsCsAccessSwitchState(lpUserObj->m_Index, lpObj->m_Index, -1, 0);

  00356	6a 00		 push	 0
  00358	6a ff		 push	 -1
  0035a	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0035d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0035f	51		 push	 ecx
  00360	8b 55 f4	 mov	 edx, DWORD PTR _lpUserObj$[ebp]
  00363	8b 02		 mov	 eax, DWORD PTR [edx]
  00365	50		 push	 eax
  00366	e8 00 00 00 00	 call	 ?GCAnsCsAccessSwitchState@@YAXHHHE@Z ; GCAnsCsAccessSwitchState
  0036b	83 c4 10	 add	 esp, 16			; 00000010H

; 93   : 
; 94   : 		g_CastleSiege.ResetCrownSwitchUserIndex(gObj[iIndex].Class);

  0036e	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00371	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00377	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0037d	0f b7 94 01 b8
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+184]
  00385	52		 push	 edx
  00386	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0038b	e8 00 00 00 00	 call	 ?ResetCrownSwitchUserIndex@CCastleSiege@@QAEXH@Z ; CCastleSiege::ResetCrownSwitchUserIndex

; 95   : 
; 96   : 		if ( g_CastleSiege.GetRegCrownAvailable() == 1 )

  00390	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00395	e8 00 00 00 00	 call	 ?GetRegCrownAvailable@CCastleSiege@@QAEHXZ ; CCastleSiege::GetRegCrownAvailable
  0039a	83 f8 01	 cmp	 eax, 1
  0039d	75 18		 jne	 SHORT $LN15@CastleCrow

; 97   : 		{
; 98   : 			g_CastleSiege.SetRegCrownAvailable(FALSE);

  0039f	6a 00		 push	 0
  003a1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  003a6	e8 00 00 00 00	 call	 ?SetRegCrownAvailable@CCastleSiege@@QAEXH@Z ; CCastleSiege::SetRegCrownAvailable

; 99   : 			g_CastleSiege.NotifyCrownState(1);

  003ab	6a 01		 push	 1
  003ad	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  003b2	e8 00 00 00 00	 call	 ?NotifyCrownState@CCastleSiege@@QAEXE@Z ; CCastleSiege::NotifyCrownState
$LN15@CastleCrow:

; 100  : 		}
; 101  : 	}
; 102  : }

  003b7	5f		 pop	 edi
  003b8	5e		 pop	 esi
  003b9	5b		 pop	 ebx
  003ba	8b e5		 mov	 esp, ebp
  003bc	5d		 pop	 ebp
  003bd	c2 04 00	 ret	 4
?CastleCrownSwitchAct@CCastleCrownSwitch@@QAEXH@Z ENDP	; CCastleCrownSwitch::CastleCrownSwitchAct
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\castlesiege.h
_TEXT	ENDS
;	COMDAT ?GetRegCrownAvailable@CCastleSiege@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRegCrownAvailable@CCastleSiege@@QAEHXZ PROC		; CCastleSiege::GetRegCrownAvailable, COMDAT
; _this$ = ecx

; 347  : 	BOOL GetRegCrownAvailable(){return m_bRegCrownAvailable;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 80 e8 01 00
	00		 mov	 eax, DWORD PTR [eax+488]
  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?GetRegCrownAvailable@CCastleSiege@@QAEHXZ ENDP		; CCastleSiege::GetRegCrownAvailable
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?SetRegCrownAvailable@CCastleSiege@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bRegCrownAvailable$ = 8				; size = 4
?SetRegCrownAvailable@CCastleSiege@@QAEXH@Z PROC	; CCastleSiege::SetRegCrownAvailable, COMDAT
; _this$ = ecx

; 348  : 	void SetRegCrownAvailable(BOOL bRegCrownAvailable){m_bRegCrownAvailable = bRegCrownAvailable;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _bRegCrownAvailable$[ebp]
  00012	89 88 e8 01 00
	00		 mov	 DWORD PTR [eax+488], ecx
  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?SetRegCrownAvailable@CCastleSiege@@QAEXH@Z ENDP	; CCastleSiege::SetRegCrownAvailable
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\castlecrownswitch.cpp
;	COMDAT ??__Eg_CsNPC_CastleCrownSwitch@@YAXXZ
text$yc	SEGMENT
??__Eg_CsNPC_CastleCrownSwitch@@YAXXZ PROC		; `dynamic initializer for 'g_CsNPC_CastleCrownSwitch'', COMDAT

; 13   : CCastleCrownSwitch g_CsNPC_CastleCrownSwitch;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CsNPC_CastleCrownSwitch@@3VCCastleCrownSwitch@@A ; g_CsNPC_CastleCrownSwitch
  0000e	e8 00 00 00 00	 call	 ??0CCastleCrownSwitch@@QAE@XZ ; CCastleCrownSwitch::CCastleCrownSwitch
  00013	68 00 00 00 00	 push	 OFFSET ??__Fg_CsNPC_CastleCrownSwitch@@YAXXZ ; `dynamic atexit destructor for 'g_CsNPC_CastleCrownSwitch''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??__Eg_CsNPC_CastleCrownSwitch@@YAXXZ ENDP		; `dynamic initializer for 'g_CsNPC_CastleCrownSwitch''
; Function compile flags: /Odtp /ZI
text$yc	ENDS
;	COMDAT ??__Fg_CsNPC_CastleCrownSwitch@@YAXXZ
text$yd	SEGMENT
??__Fg_CsNPC_CastleCrownSwitch@@YAXXZ PROC		; `dynamic atexit destructor for 'g_CsNPC_CastleCrownSwitch'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CsNPC_CastleCrownSwitch@@3VCCastleCrownSwitch@@A ; g_CsNPC_CastleCrownSwitch
  0000e	e8 00 00 00 00	 call	 ??1CCastleCrownSwitch@@UAE@XZ ; CCastleCrownSwitch::~CCastleCrownSwitch
  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__Fg_CsNPC_CastleCrownSwitch@@YAXXZ ENDP		; `dynamic atexit destructor for 'g_CsNPC_CastleCrownSwitch''
text$yd	ENDS
PUBLIC	?g_CsNPC_CastleCrownSwitch@@3VCCastleCrownSwitch@@A ; g_CsNPC_CastleCrownSwitch
_BSS	SEGMENT
?g_CsNPC_CastleCrownSwitch@@3VCCastleCrownSwitch@@A DD 01H DUP (?) ; g_CsNPC_CastleCrownSwitch
_BSS	ENDS
CRT$XCU	SEGMENT
_g_CsNPC_CastleCrownSwitch$initializer$ DD FLAT:??__Eg_CsNPC_CastleCrownSwitch@@YAXXZ
CRT$XCU	ENDS
END
