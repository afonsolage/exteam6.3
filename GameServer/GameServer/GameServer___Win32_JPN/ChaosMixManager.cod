; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	D:\Projects\ExTeam6.3\Source\GameServer\GameServer\ChaosMixManager.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?ChaosMixManager@@3VcChaosMixManager@@A		; ChaosMixManager
_BSS	SEGMENT
?ChaosMixManager@@3VcChaosMixManager@@A DB 0a7e0904H DUP (?) ; ChaosMixManager
_BSS	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Odtp /ZI
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@vector:
  00009	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000c	83 e8 01	 sub	 eax, 1
  0000f	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00012	78 11		 js	 SHORT $LN3@vector
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00017	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  0001d	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00020	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00023	eb e4		 jmp	 SHORT $LN2@vector
$LN3@vector:
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	??_C@_0BA@PIOFNAIM@LOAD?5FILE?5ERROR?$AA@	; `string'
PUBLIC	??_C@_0CD@NHBILJPK@?4?4?2Data?2ExData?2ChaosMixManager?4i@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	?Init@cChaosMixManager@@QAEXXZ			; cChaosMixManager::Init
EXTRN	_fclose:PROC
EXTRN	?CheckUser@CExLicense@@QAE_NH@Z:PROC		; CExLicense::CheckUser
EXTRN	?g_ExLicense@@3VCExLicense@@A:BYTE		; g_ExLicense
EXTRN	_strcmp:PROC
EXTRN	__imp__ExitProcess@4:PROC
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	_fopen:PROC
EXTRN	__ftol2_sse:PROC
_BSS	SEGMENT
_TokenString DB	064H DUP (?)
_TokenNumber DD	01H DUP (?)
_SMDFile DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
; File d:\projects\exteam6.3\source\gameserver\gameserver\chaosmixmanager.cpp
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PIOFNAIM@LOAD?5FILE?5ERROR?$AA@
CONST	SEGMENT
??_C@_0BA@PIOFNAIM@LOAD?5FILE?5ERROR?$AA@ DB 'LOAD FILE ERROR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@NHBILJPK@?4?4?2Data?2ExData?2ChaosMixManager?4i@
CONST	SEGMENT
??_C@_0CD@NHBILJPK@?4?4?2Data?2ExData?2ChaosMixManager?4i@ DB '..\Data\Ex'
	DB	'Data\ChaosMixManager.ini', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_type$ = -12						; size = 4
_Token$ = -8						; size = 4
_this$ = -4						; size = 4
?Init@cChaosMixManager@@QAEXXZ PROC			; cChaosMixManager::Init
; _this$ = ecx

; 13   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 14   : 	SMDFile = fopen(MIX_DIR, "r");

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  00011	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@NHBILJPK@?4?4?2Data?2ExData?2ChaosMixManager?4i@
  00016	e8 00 00 00 00	 call	 _fopen
  0001b	83 c4 08	 add	 esp, 8
  0001e	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax

; 15   : 	if ( SMDFile == NULL )

  00023	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SMDFile, 0
  0002a	75 1c		 jne	 SHORT $LN9@Init

; 16   : 	{
; 17   : 		MessageBoxA(0,MIX_DIR,"LOAD FILE ERROR",0);

  0002c	6a 00		 push	 0
  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@PIOFNAIM@LOAD?5FILE?5ERROR?$AA@
  00033	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@NHBILJPK@?4?4?2Data?2ExData?2ChaosMixManager?4i@
  00038	6a 00		 push	 0
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 18   : 		ExitProcess(0);

  00040	6a 00		 push	 0
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExitProcess@4
$LN9@Init:

; 19   : 	}
; 20   : 	int Token;
; 21   : 	int type = -1;

  00048	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _type$[ebp], -1

; 22   : 	this->MixCount = 0;

  0004f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00052	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN8@Init:

; 23   : 	while ( true )

  00058	b8 01 00 00 00	 mov	 eax, 1
  0005d	85 c0		 test	 eax, eax
  0005f	0f 84 b0 03 00
	00		 je	 $LN7@Init

; 24   : 	{
; 25   : 	    Token = GetToken();

  00065	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0006a	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 26   :         if( Token == END) break;

  0006d	83 7d f8 02	 cmp	 DWORD PTR _Token$[ebp], 2
  00071	75 05		 jne	 SHORT $LN6@Init
  00073	e9 9d 03 00 00	 jmp	 $LN7@Init
$LN6@Init:

; 27   : 		this->MixID[this->MixCount] = (int)TokenNumber;			//MixID

  00078	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0007e	e8 00 00 00 00	 call	 __ftol2_sse
  00083	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	8b 11		 mov	 edx, DWORD PTR [ecx]
  00088	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008b	89 44 91 04	 mov	 DWORD PTR [ecx+edx*4+4], eax

; 28   : 
; 29   : 		Token = GetToken();

  0008f	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00094	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 30   : 		this->MixPercent[this->MixCount] = (int)TokenNumber;	//MixPercent

  00097	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0009d	e8 00 00 00 00	 call	 __ftol2_sse
  000a2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	8b 11		 mov	 edx, DWORD PTR [ecx]
  000a7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000aa	89 84 91 44 1f
	00 00		 mov	 DWORD PTR [ecx+edx*4+8004], eax

; 31   : 
; 32   : 		Token = GetToken();

  000b1	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  000b6	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 33   : 		this->MixZen[this->MixCount] = (int)TokenNumber;		//MixZen

  000b9	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  000bf	e8 00 00 00 00	 call	 __ftol2_sse
  000c4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c7	8b 11		 mov	 edx, DWORD PTR [ecx]
  000c9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000cc	89 84 91 c4 5d
	00 00		 mov	 DWORD PTR [ecx+edx*4+24004], eax

; 34   : 
; 35   : 		this->ItemCount[this->MixCount] = 0;

  000d3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000d6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d8	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000db	c7 84 8a 84 3e
	00 00 00 00 00
	00		 mov	 DWORD PTR [edx+ecx*4+16004], 0
$LN5@Init:

; 36   : 
; 37   : 		while ( true )

  000e6	b8 01 00 00 00	 mov	 eax, 1
  000eb	85 c0		 test	 eax, eax
  000ed	0f 84 10 03 00
	00		 je	 $LN4@Init

; 38   : 		{
; 39   : 		    Token = GetToken();

  000f3	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  000f8	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 40   : 			if (!strcmp("end",TokenString))	break;

  000fb	68 00 00 00 00	 push	 OFFSET _TokenString
  00100	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  00105	e8 00 00 00 00	 call	 _strcmp
  0010a	83 c4 08	 add	 esp, 8
  0010d	85 c0		 test	 eax, eax
  0010f	75 05		 jne	 SHORT $LN3@Init
  00111	e9 ed 02 00 00	 jmp	 $LN4@Init
$LN3@Init:

; 41   : 
; 42   : 			this->Mix[this->MixCount][this->ItemCount[this->MixCount]].MixType = TokenNumber;

  00116	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0011c	e8 00 00 00 00	 call	 __ftol2_sse
  00121	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00124	8b 11		 mov	 edx, DWORD PTR [ecx]
  00126	69 d2 c0 57 01
	00		 imul	 edx, 88000		; 000157c0H
  0012c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0012f	8d 94 11 04 7d
	00 00		 lea	 edx, DWORD PTR [ecx+edx+32004]
  00136	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00139	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0013b	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  0013e	8b 8c 8e 84 3e
	00 00		 mov	 ecx, DWORD PTR [esi+ecx*4+16004]
  00145	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  00148	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 43   : 
; 44   : 			Token = GetToken();	

  0014b	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00150	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 45   : 			this->Mix[this->MixCount][this->ItemCount[this->MixCount]].Type = TokenNumber;

  00153	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00159	e8 00 00 00 00	 call	 __ftol2_sse
  0015e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00161	8b 11		 mov	 edx, DWORD PTR [ecx]
  00163	69 d2 c0 57 01
	00		 imul	 edx, 88000		; 000157c0H
  00169	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0016c	8d 94 11 04 7d
	00 00		 lea	 edx, DWORD PTR [ecx+edx+32004]
  00173	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00176	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00178	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  0017b	8b 8c 8e 84 3e
	00 00		 mov	 ecx, DWORD PTR [esi+ecx*4+16004]
  00182	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  00185	89 44 0a 04	 mov	 DWORD PTR [edx+ecx+4], eax

; 46   : 
; 47   : 			Token = GetToken();

  00189	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0018e	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 48   : 			this->Mix[this->MixCount][this->ItemCount[this->MixCount]].Index = TokenNumber;

  00191	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00197	e8 00 00 00 00	 call	 __ftol2_sse
  0019c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0019f	8b 11		 mov	 edx, DWORD PTR [ecx]
  001a1	69 d2 c0 57 01
	00		 imul	 edx, 88000		; 000157c0H
  001a7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001aa	8d 94 11 04 7d
	00 00		 lea	 edx, DWORD PTR [ecx+edx+32004]
  001b1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001b4	8b 09		 mov	 ecx, DWORD PTR [ecx]
  001b6	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  001b9	8b 8c 8e 84 3e
	00 00		 mov	 ecx, DWORD PTR [esi+ecx*4+16004]
  001c0	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  001c3	89 44 0a 08	 mov	 DWORD PTR [edx+ecx+8], eax

; 49   : 
; 50   : 			Token = GetToken();

  001c7	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  001cc	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 51   : 			this->Mix[this->MixCount][this->ItemCount[this->MixCount]].Lvl = TokenNumber;

  001cf	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001d5	e8 00 00 00 00	 call	 __ftol2_sse
  001da	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001dd	8b 11		 mov	 edx, DWORD PTR [ecx]
  001df	69 d2 c0 57 01
	00		 imul	 edx, 88000		; 000157c0H
  001e5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001e8	8d 94 11 04 7d
	00 00		 lea	 edx, DWORD PTR [ecx+edx+32004]
  001ef	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001f2	8b 09		 mov	 ecx, DWORD PTR [ecx]
  001f4	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  001f7	8b 8c 8e 84 3e
	00 00		 mov	 ecx, DWORD PTR [esi+ecx*4+16004]
  001fe	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  00201	89 44 0a 0c	 mov	 DWORD PTR [edx+ecx+12], eax

; 52   : 
; 53   : 			Token = GetToken();

  00205	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0020a	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 54   : 			this->Mix[this->MixCount][this->ItemCount[this->MixCount]].Skill = TokenNumber;

  0020d	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00213	e8 00 00 00 00	 call	 __ftol2_sse
  00218	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0021b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0021d	69 d2 c0 57 01
	00		 imul	 edx, 88000		; 000157c0H
  00223	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00226	8d 94 11 04 7d
	00 00		 lea	 edx, DWORD PTR [ecx+edx+32004]
  0022d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00230	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00232	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  00235	8b 8c 8e 84 3e
	00 00		 mov	 ecx, DWORD PTR [esi+ecx*4+16004]
  0023c	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  0023f	89 44 0a 10	 mov	 DWORD PTR [edx+ecx+16], eax

; 55   : 
; 56   : 			Token = GetToken();

  00243	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00248	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 57   : 			this->Mix[this->MixCount][this->ItemCount[this->MixCount]].Luck = TokenNumber;

  0024b	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00251	e8 00 00 00 00	 call	 __ftol2_sse
  00256	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00259	8b 11		 mov	 edx, DWORD PTR [ecx]
  0025b	69 d2 c0 57 01
	00		 imul	 edx, 88000		; 000157c0H
  00261	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00264	8d 94 11 04 7d
	00 00		 lea	 edx, DWORD PTR [ecx+edx+32004]
  0026b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0026e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00270	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  00273	8b 8c 8e 84 3e
	00 00		 mov	 ecx, DWORD PTR [esi+ecx*4+16004]
  0027a	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  0027d	89 44 0a 14	 mov	 DWORD PTR [edx+ecx+20], eax

; 58   : 
; 59   : 			Token = GetToken();

  00281	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00286	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 60   : 			this->Mix[this->MixCount][this->ItemCount[this->MixCount]].Opt = TokenNumber;

  00289	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0028f	e8 00 00 00 00	 call	 __ftol2_sse
  00294	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00297	8b 11		 mov	 edx, DWORD PTR [ecx]
  00299	69 d2 c0 57 01
	00		 imul	 edx, 88000		; 000157c0H
  0029f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002a2	8d 94 11 04 7d
	00 00		 lea	 edx, DWORD PTR [ecx+edx+32004]
  002a9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002ac	8b 09		 mov	 ecx, DWORD PTR [ecx]
  002ae	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  002b1	8b 8c 8e 84 3e
	00 00		 mov	 ecx, DWORD PTR [esi+ecx*4+16004]
  002b8	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  002bb	89 44 0a 18	 mov	 DWORD PTR [edx+ecx+24], eax

; 61   : 
; 62   : 			Token = GetToken();

  002bf	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  002c4	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 63   : 			this->Mix[this->MixCount][this->ItemCount[this->MixCount]].Exl = TokenNumber;

  002c7	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  002cd	e8 00 00 00 00	 call	 __ftol2_sse
  002d2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002d5	8b 11		 mov	 edx, DWORD PTR [ecx]
  002d7	69 d2 c0 57 01
	00		 imul	 edx, 88000		; 000157c0H
  002dd	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002e0	8d 94 11 04 7d
	00 00		 lea	 edx, DWORD PTR [ecx+edx+32004]
  002e7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002ea	8b 09		 mov	 ecx, DWORD PTR [ecx]
  002ec	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  002ef	8b 8c 8e 84 3e
	00 00		 mov	 ecx, DWORD PTR [esi+ecx*4+16004]
  002f6	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  002f9	89 44 0a 1c	 mov	 DWORD PTR [edx+ecx+28], eax

; 64   : 
; 65   : 			Token = GetToken();

  002fd	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00302	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 66   : 			this->Mix[this->MixCount][this->ItemCount[this->MixCount]].Anc = TokenNumber;

  00305	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0030b	e8 00 00 00 00	 call	 __ftol2_sse
  00310	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00313	8b 11		 mov	 edx, DWORD PTR [ecx]
  00315	69 d2 c0 57 01
	00		 imul	 edx, 88000		; 000157c0H
  0031b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0031e	8d 94 11 04 7d
	00 00		 lea	 edx, DWORD PTR [ecx+edx+32004]
  00325	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00328	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0032a	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  0032d	8b 8c 8e 84 3e
	00 00		 mov	 ecx, DWORD PTR [esi+ecx*4+16004]
  00334	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  00337	89 44 0a 20	 mov	 DWORD PTR [edx+ecx+32], eax

; 67   : 
; 68   : #ifdef PRIVATE_MODULE
; 69   : 			if(g_ExLicense.CheckUser(eExUB::drynea) || g_ExLicense.CheckUser(eExUB::MedoniAndrei))

  0033b	6a 01		 push	 1
  0033d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00342	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00347	0f b6 c0	 movzx	 eax, al
  0034a	85 c0		 test	 eax, eax
  0034c	75 13		 jne	 SHORT $LN1@Init
  0034e	6a 32		 push	 50			; 00000032H
  00350	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00355	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  0035a	0f b6 c0	 movzx	 eax, al
  0035d	85 c0		 test	 eax, eax
  0035f	74 7c		 je	 SHORT $LN2@Init
$LN1@Init:

; 70   : 			{
; 71   : 				Token = GetToken();

  00361	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00366	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 72   : 				this->Mix[this->MixCount][this->ItemCount[this->MixCount]].MinSocket = TokenNumber;

  00369	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0036f	e8 00 00 00 00	 call	 __ftol2_sse
  00374	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00377	8b 11		 mov	 edx, DWORD PTR [ecx]
  00379	69 d2 c0 57 01
	00		 imul	 edx, 88000		; 000157c0H
  0037f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00382	8d 94 11 04 7d
	00 00		 lea	 edx, DWORD PTR [ecx+edx+32004]
  00389	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0038c	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0038e	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  00391	8b 8c 8e 84 3e
	00 00		 mov	 ecx, DWORD PTR [esi+ecx*4+16004]
  00398	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  0039b	89 44 0a 24	 mov	 DWORD PTR [edx+ecx+36], eax

; 73   : 
; 74   : 				Token = GetToken();

  0039f	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  003a4	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 75   : 				this->Mix[this->MixCount][this->ItemCount[this->MixCount]].MaxSocket = TokenNumber;

  003a7	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  003ad	e8 00 00 00 00	 call	 __ftol2_sse
  003b2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003b5	8b 11		 mov	 edx, DWORD PTR [ecx]
  003b7	69 d2 c0 57 01
	00		 imul	 edx, 88000		; 000157c0H
  003bd	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003c0	8d 94 11 04 7d
	00 00		 lea	 edx, DWORD PTR [ecx+edx+32004]
  003c7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003ca	8b 09		 mov	 ecx, DWORD PTR [ecx]
  003cc	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  003cf	8b 8c 8e 84 3e
	00 00		 mov	 ecx, DWORD PTR [esi+ecx*4+16004]
  003d6	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  003d9	89 44 0a 28	 mov	 DWORD PTR [edx+ecx+40], eax
$LN2@Init:

; 76   : 			}
; 77   : #endif
; 78   : 
; 79   : 			this->ItemCount[this->MixCount]++;

  003dd	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  003e0	8b 08		 mov	 ecx, DWORD PTR [eax]
  003e2	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  003e5	8b 84 8a 84 3e
	00 00		 mov	 eax, DWORD PTR [edx+ecx*4+16004]
  003ec	83 c0 01	 add	 eax, 1
  003ef	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003f2	8b 11		 mov	 edx, DWORD PTR [ecx]
  003f4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003f7	89 84 91 84 3e
	00 00		 mov	 DWORD PTR [ecx+edx*4+16004], eax

; 80   : 		}

  003fe	e9 e3 fc ff ff	 jmp	 $LN5@Init
$LN4@Init:

; 81   : 		this->MixCount++;

  00403	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00406	8b 08		 mov	 ecx, DWORD PTR [eax]
  00408	83 c1 01	 add	 ecx, 1
  0040b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0040e	89 0a		 mov	 DWORD PTR [edx], ecx

; 82   :     }

  00410	e9 43 fc ff ff	 jmp	 $LN8@Init
$LN7@Init:

; 83   : 	fclose(SMDFile);

  00415	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0041a	50		 push	 eax
  0041b	e8 00 00 00 00	 call	 _fclose
  00420	83 c4 04	 add	 esp, 4
$LN10@Init:

; 84   : }

  00423	5f		 pop	 edi
  00424	5e		 pop	 esi
  00425	5b		 pop	 ebx
  00426	8b e5		 mov	 esp, ebp
  00428	5d		 pop	 ebp
  00429	c3		 ret	 0
?Init@cChaosMixManager@@QAEXXZ ENDP			; cChaosMixManager::Init
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_isalnum:PROC
EXTRN	_isalpha:PROC
EXTRN	_atof:PROC
EXTRN	_isdigit:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_isspace:PROC
EXTRN	_fgetc:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	@__security_check_cookie@4:PROC
_BSS	SEGMENT
_CurrentToken DD 01H DUP (?)
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\include\readscript.h
_BSS	ENDS
_TEXT	SEGMENT
tv90 = -180						; size = 4
_TempString$ = -112					; size = 100
_p$ = -12						; size = 4
_ch$ = -5						; size = 1
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken

; 24   : {

  00430	55		 push	 ebp
  00431	8b ec		 mov	 ebp, esp
  00433	81 ec b4 00 00
	00		 sub	 esp, 180		; 000000b4H
  00439	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0043e	33 c5		 xor	 eax, ebp
  00440	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00443	53		 push	 ebx
  00444	56		 push	 esi
  00445	57		 push	 edi

; 25   : 	char ch;
; 26   : 	char* p;
; 27   : 	char TempString[100];
; 28   : 
; 29   : 	TokenString[0]=0;

  00446	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _TokenString, 0
$LN31@GetToken:

; 30   : 
; 31   : 	do
; 32   : 	{
; 33   : 		if ((ch=fgetc(SMDFile)) == -1)

  0044d	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00452	50		 push	 eax
  00453	e8 00 00 00 00	 call	 _fgetc
  00458	83 c4 04	 add	 esp, 4
  0045b	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0045e	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00462	83 f9 ff	 cmp	 ecx, -1
  00465	75 0c		 jne	 SHORT $LN28@GetToken

; 34   : 		{
; 35   : 			return END;	// End of FILE (EOF)

  00467	b8 02 00 00 00	 mov	 eax, 2
  0046c	e9 f7 02 00 00	 jmp	 $LN32@GetToken

; 36   : 		}
; 37   : 		else

  00471	eb 5b		 jmp	 SHORT $LN22@GetToken
$LN28@GetToken:

; 38   : 		{	
; 39   : 			if (ch=='/')		// this is /

  00473	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00477	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  0047a	75 52		 jne	 SHORT $LN22@GetToken

; 40   : 			{
; 41   : 				if((ch=fgetc(SMDFile)) == '/')

  0047c	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00481	50		 push	 eax
  00482	e8 00 00 00 00	 call	 _fgetc
  00487	83 c4 04	 add	 esp, 4
  0048a	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0048d	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00491	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  00494	75 38		 jne	 SHORT $LN22@GetToken
$LN24@GetToken:

; 42   : 				{
; 43   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  00496	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  0049a	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0049d	74 1c		 je	 SHORT $LN23@GetToken
  0049f	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  004a3	83 f8 ff	 cmp	 eax, -1
  004a6	74 13		 je	 SHORT $LN23@GetToken

; 44   : 					{
; 45   : 						ch=fgetc(SMDFile);

  004a8	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  004ad	50		 push	 eax
  004ae	e8 00 00 00 00	 call	 _fgetc
  004b3	83 c4 04	 add	 esp, 4
  004b6	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al

; 46   : 					}

  004b9	eb db		 jmp	 SHORT $LN24@GetToken
$LN23@GetToken:

; 47   : 	
; 48   : 					if (ch == -1)

  004bb	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  004bf	83 f8 ff	 cmp	 eax, -1
  004c2	75 0a		 jne	 SHORT $LN22@GetToken

; 49   : 					{
; 50   : 						return END;	// End of FILE

  004c4	b8 02 00 00 00	 mov	 eax, 2
  004c9	e9 9a 02 00 00	 jmp	 $LN32@GetToken
$LN22@GetToken:

; 51   : 					}
; 52   : 				}
; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : 	while (isspace(ch) != 0);

  004ce	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  004d2	50		 push	 eax
  004d3	e8 00 00 00 00	 call	 _isspace
  004d8	83 c4 04	 add	 esp, 4
  004db	85 c0		 test	 eax, eax
  004dd	0f 85 6a ff ff
	ff		 jne	 $LN31@GetToken

; 57   : 
; 58   : 	
; 59   : 	switch(ch)

  004e3	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  004e7	89 85 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], eax
  004ed	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR tv90[ebp]
  004f3	83 e9 22	 sub	 ecx, 34			; 00000022H
  004f6	89 8d 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], ecx
  004fc	83 bd 4c ff ff
	ff 5b		 cmp	 DWORD PTR tv90[ebp], 91	; 0000005bH
  00503	0f 87 a3 01 00
	00		 ja	 $LN6@GetToken
  00509	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR tv90[ebp]
  0050f	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN34@GetToken[edx]
  00516	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN35@GetToken[eax*4]
$LN19@GetToken:

; 60   : 	{
; 61   : 
; 62   : 	case 0x23:	// #
; 63   : 		return CurrentToken=COMMAND;

  0051d	c7 05 00 00 00
	00 23 00 00 00	 mov	 DWORD PTR _CurrentToken, 35 ; 00000023H
  00527	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  0052c	e9 37 02 00 00	 jmp	 $LN32@GetToken

; 64   : 		break;

  00531	e9 30 02 00 00	 jmp	 $LN20@GetToken
$LN18@GetToken:

; 65   : 	
; 66   : 	case 0x3B:	// ;
; 67   : 		return CurrentToken=SEMICOLON;

  00536	c7 05 00 00 00
	00 3b 00 00 00	 mov	 DWORD PTR _CurrentToken, 59 ; 0000003bH
  00540	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00545	e9 1e 02 00 00	 jmp	 $LN32@GetToken

; 68   : 		break;

  0054a	e9 17 02 00 00	 jmp	 $LN20@GetToken
$LN17@GetToken:

; 69   : 	
; 70   : 	case 0x2C:	// ,
; 71   : 
; 72   : 		return CurrentToken=COMMA;

  0054f	c7 05 00 00 00
	00 2c 00 00 00	 mov	 DWORD PTR _CurrentToken, 44 ; 0000002cH
  00559	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  0055e	e9 05 02 00 00	 jmp	 $LN32@GetToken

; 73   : 		break;

  00563	e9 fe 01 00 00	 jmp	 $LN20@GetToken
$LN16@GetToken:

; 74   : 	
; 75   : 	case 0x7B:	// {
; 76   : 		return CurrentToken = LP;

  00568	c7 05 00 00 00
	00 7b 00 00 00	 mov	 DWORD PTR _CurrentToken, 123 ; 0000007bH
  00572	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00577	e9 ec 01 00 00	 jmp	 $LN32@GetToken

; 77   : 		break;

  0057c	e9 e5 01 00 00	 jmp	 $LN20@GetToken
$LN15@GetToken:

; 78   : 
; 79   : 	case 0x7D:	// }
; 80   : 		return CurrentToken = RP;

  00581	c7 05 00 00 00
	00 7d 00 00 00	 mov	 DWORD PTR _CurrentToken, 125 ; 0000007dH
  0058b	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00590	e9 d3 01 00 00	 jmp	 $LN32@GetToken

; 81   : 		break;

  00595	e9 cc 01 00 00	 jmp	 $LN20@GetToken
$LN14@GetToken:

; 82   : 	// Nice Index Table :)	by Deathway
; 83   : 	// Numbers Case
; 84   : 	case 0x2D:	//-
; 85   : 	case 0x2E:	//.
; 86   : 	case '0':	//0
; 87   : 	case '1':	//1
; 88   : 	case '2':	//2
; 89   : 	case '3':	//3
; 90   : 	case '4':	//4		
; 91   : 	case '5':	//5
; 92   : 	case '6':	//6
; 93   : 	case '7':	//7
; 94   : 	case '8':	//8
; 95   : 	case '9':	//9
; 96   : 		ungetc(ch, SMDFile);

  0059a	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0059f	50		 push	 eax
  005a0	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  005a4	51		 push	 ecx
  005a5	e8 00 00 00 00	 call	 _ungetc
  005aa	83 c4 08	 add	 esp, 8

; 97   : 		p = TempString;

  005ad	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  005b0	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN13@GetToken:

; 98   : 		
; 99   : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  005b3	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  005b8	50		 push	 eax
  005b9	e8 00 00 00 00	 call	 _getc
  005be	83 c4 04	 add	 esp, 4
  005c1	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  005c4	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  005c8	83 f9 ff	 cmp	 ecx, -1
  005cb	74 36		 je	 SHORT $LN12@GetToken
  005cd	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  005d1	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  005d4	74 1a		 je	 SHORT $LN11@GetToken
  005d6	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  005da	50		 push	 eax
  005db	e8 00 00 00 00	 call	 _isdigit
  005e0	83 c4 04	 add	 esp, 4
  005e3	85 c0		 test	 eax, eax
  005e5	75 09		 jne	 SHORT $LN11@GetToken
  005e7	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  005eb	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  005ee	75 13		 jne	 SHORT $LN12@GetToken
$LN11@GetToken:

; 100  : 		{
; 101  : 			*p = ch;	// Construct a String

  005f0	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  005f3	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  005f6	88 08		 mov	 BYTE PTR [eax], cl

; 102  : 			p++;

  005f8	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  005fb	83 c0 01	 add	 eax, 1
  005fe	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 103  : 		}		

  00601	eb b0		 jmp	 SHORT $LN13@GetToken
$LN12@GetToken:

; 104  : 		*p = 0;

  00603	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00606	c6 00 00	 mov	 BYTE PTR [eax], 0

; 105  : 		TokenNumber = atof( TempString);	// Select the first Byte as Main ID

  00609	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  0060c	50		 push	 eax
  0060d	e8 00 00 00 00	 call	 _atof
  00612	83 c4 04	 add	 esp, 4
  00615	d9 1d 00 00 00
	00		 fstp	 DWORD PTR _TokenNumber

; 106  : 		return CurrentToken  = NUMBER ;

  0061b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CurrentToken, 1
  00625	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  0062a	e9 39 01 00 00	 jmp	 $LN32@GetToken

; 107  : 		break;

  0062f	e9 32 01 00 00	 jmp	 $LN20@GetToken
$LN10@GetToken:

; 108  : 
; 109  : 	case '\"':	// "	String Case
; 110  : 		p=&TokenString[0];

  00634	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString
$LN9@GetToken:

; 111  : 		
; 112  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  0063b	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00640	50		 push	 eax
  00641	e8 00 00 00 00	 call	 _getc
  00646	83 c4 04	 add	 esp, 4
  00649	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0064c	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00650	83 f9 ff	 cmp	 ecx, -1
  00653	74 1c		 je	 SHORT $LN8@GetToken
  00655	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00659	83 f8 22	 cmp	 eax, 34			; 00000022H
  0065c	74 13		 je	 SHORT $LN8@GetToken

; 113  : 		{
; 114  : 			*p = ch;

  0065e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00661	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00664	88 08		 mov	 BYTE PTR [eax], cl

; 115  : 			p++;

  00666	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00669	83 c0 01	 add	 eax, 1
  0066c	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 116  : 		}

  0066f	eb ca		 jmp	 SHORT $LN9@GetToken
$LN8@GetToken:

; 117  : 		if (ch != 0x22 )

  00671	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00675	83 f8 22	 cmp	 eax, 34			; 00000022H
  00678	74 13		 je	 SHORT $LN7@GetToken

; 118  : 		{
; 119  : 			ungetc(ch, SMDFile);

  0067a	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0067f	50		 push	 eax
  00680	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00684	51		 push	 ecx
  00685	e8 00 00 00 00	 call	 _ungetc
  0068a	83 c4 08	 add	 esp, 8
$LN7@GetToken:

; 120  : 		}
; 121  : 		*p = 0;

  0068d	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00690	c6 00 00	 mov	 BYTE PTR [eax], 0

; 122  : 		return CurrentToken = NAME;

  00693	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0
  0069d	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  006a2	e9 c1 00 00 00	 jmp	 $LN32@GetToken

; 123  : 		break;

  006a7	e9 ba 00 00 00	 jmp	 $LN20@GetToken
$LN6@GetToken:

; 124  : 
; 125  : 	default:	// Others
; 126  : 		if (isalpha(ch))

  006ac	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  006b0	50		 push	 eax
  006b1	e8 00 00 00 00	 call	 _isalpha
  006b6	83 c4 04	 add	 esp, 4
  006b9	85 c0		 test	 eax, eax
  006bb	0f 84 94 00 00
	00		 je	 $LN5@GetToken

; 127  : 		{
; 128  : 			p=&TokenString[0];

  006c1	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString

; 129  : 			*p=ch;

  006c8	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  006cb	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  006ce	88 08		 mov	 BYTE PTR [eax], cl

; 130  : 			p++;

  006d0	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  006d3	83 c0 01	 add	 eax, 1
  006d6	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN4@GetToken:

; 131  : 
; 132  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  006d9	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  006de	50		 push	 eax
  006df	e8 00 00 00 00	 call	 _getc
  006e4	83 c4 04	 add	 esp, 4
  006e7	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  006ea	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  006ee	83 f9 ff	 cmp	 ecx, -1
  006f1	74 36		 je	 SHORT $LN3@GetToken
  006f3	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  006f7	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  006fa	74 1a		 je	 SHORT $LN2@GetToken
  006fc	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00700	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  00703	74 11		 je	 SHORT $LN2@GetToken
  00705	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00709	50		 push	 eax
  0070a	e8 00 00 00 00	 call	 _isalnum
  0070f	83 c4 04	 add	 esp, 4
  00712	85 c0		 test	 eax, eax
  00714	74 13		 je	 SHORT $LN3@GetToken
$LN2@GetToken:

; 133  : 			{
; 134  : 				*p=ch;

  00716	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00719	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  0071c	88 08		 mov	 BYTE PTR [eax], cl

; 135  : 				p++;

  0071e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00721	83 c0 01	 add	 eax, 1
  00724	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 136  : 				
; 137  : 			}

  00727	eb b0		 jmp	 SHORT $LN4@GetToken
$LN3@GetToken:

; 138  : 
; 139  : 			ungetc(ch, SMDFile);

  00729	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0072e	50		 push	 eax
  0072f	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00733	51		 push	 ecx
  00734	e8 00 00 00 00	 call	 _ungetc
  00739	83 c4 08	 add	 esp, 8

; 140  : 			*p=0;

  0073c	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0073f	c6 00 00	 mov	 BYTE PTR [eax], 0

; 141  : 			CurrentToken=NAME;

  00742	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0

; 142  : 			return CurrentToken;

  0074c	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00751	eb 15		 jmp	 SHORT $LN32@GetToken

; 143  : 		}
; 144  : 		else

  00753	eb 11		 jmp	 SHORT $LN1@GetToken
$LN5@GetToken:

; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'

  00755	c7 05 00 00 00
	00 3c 00 00 00	 mov	 DWORD PTR _CurrentToken, 60 ; 0000003cH
  0075f	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00764	eb 02		 jmp	 SHORT $LN32@GetToken
$LN1@GetToken:
$LN20@GetToken:

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;

  00766	33 c0		 xor	 eax, eax
$LN32@GetToken:

; 153  : }

  00768	5f		 pop	 edi
  00769	5e		 pop	 esi
  0076a	5b		 pop	 ebx
  0076b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0076e	33 cd		 xor	 ecx, ebp
  00770	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00775	8b e5		 mov	 esp, ebp
  00777	5d		 pop	 ebp
  00778	c3		 ret	 0
  00779	8d 49 00	 npad	 3
$LN35@GetToken:
  0077c	00 00 00 00	 DD	 $LN10@GetToken
  00780	00 00 00 00	 DD	 $LN19@GetToken
  00784	00 00 00 00	 DD	 $LN17@GetToken
  00788	00 00 00 00	 DD	 $LN14@GetToken
  0078c	00 00 00 00	 DD	 $LN18@GetToken
  00790	00 00 00 00	 DD	 $LN16@GetToken
  00794	00 00 00 00	 DD	 $LN15@GetToken
  00798	00 00 00 00	 DD	 $LN6@GetToken
$LN34@GetToken:
  0079c	00		 DB	 0
  0079d	01		 DB	 1
  0079e	07		 DB	 7
  0079f	07		 DB	 7
  007a0	07		 DB	 7
  007a1	07		 DB	 7
  007a2	07		 DB	 7
  007a3	07		 DB	 7
  007a4	07		 DB	 7
  007a5	07		 DB	 7
  007a6	02		 DB	 2
  007a7	03		 DB	 3
  007a8	03		 DB	 3
  007a9	07		 DB	 7
  007aa	03		 DB	 3
  007ab	03		 DB	 3
  007ac	03		 DB	 3
  007ad	03		 DB	 3
  007ae	03		 DB	 3
  007af	03		 DB	 3
  007b0	03		 DB	 3
  007b1	03		 DB	 3
  007b2	03		 DB	 3
  007b3	03		 DB	 3
  007b4	07		 DB	 7
  007b5	04		 DB	 4
  007b6	07		 DB	 7
  007b7	07		 DB	 7
  007b8	07		 DB	 7
  007b9	07		 DB	 7
  007ba	07		 DB	 7
  007bb	07		 DB	 7
  007bc	07		 DB	 7
  007bd	07		 DB	 7
  007be	07		 DB	 7
  007bf	07		 DB	 7
  007c0	07		 DB	 7
  007c1	07		 DB	 7
  007c2	07		 DB	 7
  007c3	07		 DB	 7
  007c4	07		 DB	 7
  007c5	07		 DB	 7
  007c6	07		 DB	 7
  007c7	07		 DB	 7
  007c8	07		 DB	 7
  007c9	07		 DB	 7
  007ca	07		 DB	 7
  007cb	07		 DB	 7
  007cc	07		 DB	 7
  007cd	07		 DB	 7
  007ce	07		 DB	 7
  007cf	07		 DB	 7
  007d0	07		 DB	 7
  007d1	07		 DB	 7
  007d2	07		 DB	 7
  007d3	07		 DB	 7
  007d4	07		 DB	 7
  007d5	07		 DB	 7
  007d6	07		 DB	 7
  007d7	07		 DB	 7
  007d8	07		 DB	 7
  007d9	07		 DB	 7
  007da	07		 DB	 7
  007db	07		 DB	 7
  007dc	07		 DB	 7
  007dd	07		 DB	 7
  007de	07		 DB	 7
  007df	07		 DB	 7
  007e0	07		 DB	 7
  007e1	07		 DB	 7
  007e2	07		 DB	 7
  007e3	07		 DB	 7
  007e4	07		 DB	 7
  007e5	07		 DB	 7
  007e6	07		 DB	 7
  007e7	07		 DB	 7
  007e8	07		 DB	 7
  007e9	07		 DB	 7
  007ea	07		 DB	 7
  007eb	07		 DB	 7
  007ec	07		 DB	 7
  007ed	07		 DB	 7
  007ee	07		 DB	 7
  007ef	07		 DB	 7
  007f0	07		 DB	 7
  007f1	07		 DB	 7
  007f2	07		 DB	 7
  007f3	07		 DB	 7
  007f4	07		 DB	 7
  007f5	05		 DB	 5
  007f6	07		 DB	 7
  007f7	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
PUBLIC	?nIBox@cChaosMixManager@@AAE_NHHHHHHHH@Z	; cChaosMixManager::nIBox
PUBLIC	__$ArrayPad$
PUBLIC	?Box@cChaosMixManager@@AAEXHHH@Z		; cChaosMixManager::Box
EXTRN	?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z:PROC ; GCUserChaosBoxSend
EXTRN	?ChaosBoxInit@CMixSystem@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CMixSystem::ChaosBoxInit
EXTRN	?g_MixSystem@@3VCMixSystem@@A:BYTE		; g_MixSystem
EXTRN	?gObjInventoryCommit@@YAHH@Z:PROC		; gObjInventoryCommit
EXTRN	?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z:PROC	; ItemSerialCreateSend
EXTRN	?GenExcOpt@@YAHH@Z:PROC				; GenExcOpt
EXTRN	?GCMoneySend@@YAXHK@Z:PROC			; GCMoneySend
EXTRN	_rand:PROC
EXTRN	_srand:PROC
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	__chkstk:PROC
EXTRN	_memset:PROC
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\chaosmixmanager.cpp
_TEXT	SEGMENT
tv734 = -8168						; size = 4
_randomExcelentDrynea$220304 = -8100			; size = 4
_randomSkillDrynea$220303 = -8096			; size = 4
_randomLuckDrynea$220302 = -8092			; size = 4
_RandomSocketSlotInMixManager$220298 = -8088		; size = 4
_ExcellentOpt$220293 = -8084				; size = 24
_cAnc$220289 = -8060					; size = 4
_cExl$220288 = -8056					; size = 4
_i$220275 = -8052					; size = 4
_rNumCount$ = -8048					; size = 4
_arrNum$ = -8044					; size = 8000
_rNum$ = -44						; size = 4
_Error$ = -37						; size = 1
_Zen$ = -36						; size = 4
_Percent$ = -32						; size = 4
_pMsg$ = -28						; size = 16
_lpObj$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_IMix$ = 12						; size = 4
_Num$ = 16						; size = 4
?Box@cChaosMixManager@@AAEXHHH@Z PROC			; cChaosMixManager::Box
; _this$ = ecx

; 87   : {

  00800	55		 push	 ebp
  00801	8b ec		 mov	 ebp, esp
  00803	b8 e8 1f 00 00	 mov	 eax, 8168		; 00001fe8H
  00808	e8 00 00 00 00	 call	 __chkstk
  0080d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00812	33 c5		 xor	 eax, ebp
  00814	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00817	53		 push	 ebx
  00818	56		 push	 esi
  00819	57		 push	 edi
  0081a	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 88   : 	LPOBJ lpObj = &gObj[aIndex];

  0081d	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00820	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00826	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0082c	89 45 f4	 mov	 DWORD PTR _lpObj$[ebp], eax

; 89   : 
; 90   : 	PMSG_CHAOSMIXRESULT pMsg;
; 91   : 
; 92   : 	pMsg.Result = CB_ERROR;

  0082f	c6 45 e7 00	 mov	 BYTE PTR _pMsg$[ebp+3], 0

; 93   : 
; 94   : 	int Percent = this->MixPercent[Num];

  00833	8b 45 10	 mov	 eax, DWORD PTR _Num$[ebp]
  00836	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00839	8b 94 81 44 1f
	00 00		 mov	 edx, DWORD PTR [ecx+eax*4+8004]
  00840	89 55 e0	 mov	 DWORD PTR _Percent$[ebp], edx

; 95   : 	int Zen = this->MixZen[Num];

  00843	8b 45 10	 mov	 eax, DWORD PTR _Num$[ebp]
  00846	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00849	8b 94 81 c4 5d
	00 00		 mov	 edx, DWORD PTR [ecx+eax*4+24004]
  00850	89 55 dc	 mov	 DWORD PTR _Zen$[ebp], edx

; 96   : 	bool Error = false;

  00853	c6 45 db 00	 mov	 BYTE PTR _Error$[ebp], 0

; 97   : 	int rNum = 0;

  00857	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _rNum$[ebp], 0

; 98   : 	int arrNum[CHAOS_ITEM] = { 0 };

  0085e	c7 85 94 e0 ff
	ff 00 00 00 00	 mov	 DWORD PTR _arrNum$[ebp], 0
  00868	68 3c 1f 00 00	 push	 7996			; 00001f3cH
  0086d	6a 00		 push	 0
  0086f	8d 85 98 e0 ff
	ff		 lea	 eax, DWORD PTR _arrNum$[ebp+4]
  00875	50		 push	 eax
  00876	e8 00 00 00 00	 call	 _memset
  0087b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 99   : 
; 100  : 	int rNumCount = 0;

  0087e	c7 85 90 e0 ff
	ff 00 00 00 00	 mov	 DWORD PTR _rNumCount$[ebp], 0

; 101  : 
; 102  : 	for(int i=0;i<this->ItemCount[Num];i++)

  00888	c7 85 8c e0 ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$220275[ebp], 0
  00892	eb 0f		 jmp	 SHORT $LN24@Box
$LN23@Box:
  00894	8b 85 8c e0 ff
	ff		 mov	 eax, DWORD PTR _i$220275[ebp]
  0089a	83 c0 01	 add	 eax, 1
  0089d	89 85 8c e0 ff
	ff		 mov	 DWORD PTR _i$220275[ebp], eax
$LN24@Box:
  008a3	8b 45 10	 mov	 eax, DWORD PTR _Num$[ebp]
  008a6	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  008a9	8b 95 8c e0 ff
	ff		 mov	 edx, DWORD PTR _i$220275[ebp]
  008af	3b 94 81 84 3e
	00 00		 cmp	 edx, DWORD PTR [ecx+eax*4+16004]
  008b6	0f 8d 87 01 00
	00		 jge	 $LN22@Box

; 103  : 	{
; 104  : 		if(this->Mix[Num][i].MixType == 1)

  008bc	8b 45 10	 mov	 eax, DWORD PTR _Num$[ebp]
  008bf	69 c0 c0 57 01
	00		 imul	 eax, 88000		; 000157c0H
  008c5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  008c8	8d 94 01 04 7d
	00 00		 lea	 edx, DWORD PTR [ecx+eax+32004]
  008cf	8b 85 8c e0 ff
	ff		 mov	 eax, DWORD PTR _i$220275[ebp]
  008d5	6b c0 2c	 imul	 eax, 44			; 0000002cH
  008d8	83 3c 02 01	 cmp	 DWORD PTR [edx+eax], 1
  008dc	0f 85 18 01 00
	00		 jne	 $LN21@Box

; 105  : 		{
; 106  : 			if(!this->nIBox(aIndex,ITEMGET(this->Mix[Num][i].Type,this->Mix[Num][i].Index),this->Mix[Num][i].Lvl,this->Mix[Num][i].Skill,
; 107  : 			this->Mix[Num][i].Luck,this->Mix[Num][i].Opt,this->Mix[Num][i].Exl,this->Mix[Num][i].Anc))

  008e2	8b 45 10	 mov	 eax, DWORD PTR _Num$[ebp]
  008e5	69 c0 c0 57 01
	00		 imul	 eax, 88000		; 000157c0H
  008eb	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  008ee	8d 94 01 04 7d
	00 00		 lea	 edx, DWORD PTR [ecx+eax+32004]
  008f5	8b 85 8c e0 ff
	ff		 mov	 eax, DWORD PTR _i$220275[ebp]
  008fb	6b c0 2c	 imul	 eax, 44			; 0000002cH
  008fe	8b 4c 02 20	 mov	 ecx, DWORD PTR [edx+eax+32]
  00902	51		 push	 ecx
  00903	8b 55 10	 mov	 edx, DWORD PTR _Num$[ebp]
  00906	69 d2 c0 57 01
	00		 imul	 edx, 88000		; 000157c0H
  0090c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0090f	8d 8c 10 04 7d
	00 00		 lea	 ecx, DWORD PTR [eax+edx+32004]
  00916	8b 95 8c e0 ff
	ff		 mov	 edx, DWORD PTR _i$220275[ebp]
  0091c	6b d2 2c	 imul	 edx, 44			; 0000002cH
  0091f	8b 44 11 1c	 mov	 eax, DWORD PTR [ecx+edx+28]
  00923	50		 push	 eax
  00924	8b 4d 10	 mov	 ecx, DWORD PTR _Num$[ebp]
  00927	69 c9 c0 57 01
	00		 imul	 ecx, 88000		; 000157c0H
  0092d	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00930	8d 84 0a 04 7d
	00 00		 lea	 eax, DWORD PTR [edx+ecx+32004]
  00937	8b 8d 8c e0 ff
	ff		 mov	 ecx, DWORD PTR _i$220275[ebp]
  0093d	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  00940	8b 54 08 18	 mov	 edx, DWORD PTR [eax+ecx+24]
  00944	52		 push	 edx
  00945	8b 45 10	 mov	 eax, DWORD PTR _Num$[ebp]
  00948	69 c0 c0 57 01
	00		 imul	 eax, 88000		; 000157c0H
  0094e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00951	8d 94 01 04 7d
	00 00		 lea	 edx, DWORD PTR [ecx+eax+32004]
  00958	8b 85 8c e0 ff
	ff		 mov	 eax, DWORD PTR _i$220275[ebp]
  0095e	6b c0 2c	 imul	 eax, 44			; 0000002cH
  00961	8b 4c 02 14	 mov	 ecx, DWORD PTR [edx+eax+20]
  00965	51		 push	 ecx
  00966	8b 55 10	 mov	 edx, DWORD PTR _Num$[ebp]
  00969	69 d2 c0 57 01
	00		 imul	 edx, 88000		; 000157c0H
  0096f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00972	8d 8c 10 04 7d
	00 00		 lea	 ecx, DWORD PTR [eax+edx+32004]
  00979	8b 95 8c e0 ff
	ff		 mov	 edx, DWORD PTR _i$220275[ebp]
  0097f	6b d2 2c	 imul	 edx, 44			; 0000002cH
  00982	8b 44 11 10	 mov	 eax, DWORD PTR [ecx+edx+16]
  00986	50		 push	 eax
  00987	8b 4d 10	 mov	 ecx, DWORD PTR _Num$[ebp]
  0098a	69 c9 c0 57 01
	00		 imul	 ecx, 88000		; 000157c0H
  00990	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00993	8d 84 0a 04 7d
	00 00		 lea	 eax, DWORD PTR [edx+ecx+32004]
  0099a	8b 8d 8c e0 ff
	ff		 mov	 ecx, DWORD PTR _i$220275[ebp]
  009a0	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  009a3	8b 54 08 0c	 mov	 edx, DWORD PTR [eax+ecx+12]
  009a7	52		 push	 edx
  009a8	8b 45 10	 mov	 eax, DWORD PTR _Num$[ebp]
  009ab	69 c0 c0 57 01
	00		 imul	 eax, 88000		; 000157c0H
  009b1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  009b4	8d 94 01 04 7d
	00 00		 lea	 edx, DWORD PTR [ecx+eax+32004]
  009bb	8b 85 8c e0 ff
	ff		 mov	 eax, DWORD PTR _i$220275[ebp]
  009c1	6b c0 2c	 imul	 eax, 44			; 0000002cH
  009c4	8b 4c 02 04	 mov	 ecx, DWORD PTR [edx+eax+4]
  009c8	c1 e1 09	 shl	 ecx, 9
  009cb	8b 55 10	 mov	 edx, DWORD PTR _Num$[ebp]
  009ce	69 d2 c0 57 01
	00		 imul	 edx, 88000		; 000157c0H
  009d4	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  009d7	8d 94 10 04 7d
	00 00		 lea	 edx, DWORD PTR [eax+edx+32004]
  009de	8b 85 8c e0 ff
	ff		 mov	 eax, DWORD PTR _i$220275[ebp]
  009e4	6b c0 2c	 imul	 eax, 44			; 0000002cH
  009e7	03 4c 02 08	 add	 ecx, DWORD PTR [edx+eax+8]
  009eb	51		 push	 ecx
  009ec	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  009ef	51		 push	 ecx
  009f0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  009f3	e8 00 00 00 00	 call	 ?nIBox@cChaosMixManager@@AAE_NHHHHHHHH@Z ; cChaosMixManager::nIBox

; 108  : 			{
; 109  : 				Error == true;
; 110  : 			}
; 111  : 		}

  009f8	eb 44		 jmp	 SHORT $LN19@Box
$LN21@Box:

; 112  : 		else if(this->Mix[Num][i].MixType == 2)

  009fa	8b 45 10	 mov	 eax, DWORD PTR _Num$[ebp]
  009fd	69 c0 c0 57 01
	00		 imul	 eax, 88000		; 000157c0H
  00a03	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00a06	8d 94 01 04 7d
	00 00		 lea	 edx, DWORD PTR [ecx+eax+32004]
  00a0d	8b 85 8c e0 ff
	ff		 mov	 eax, DWORD PTR _i$220275[ebp]
  00a13	6b c0 2c	 imul	 eax, 44			; 0000002cH
  00a16	83 3c 02 02	 cmp	 DWORD PTR [edx+eax], 2
  00a1a	75 22		 jne	 SHORT $LN19@Box

; 113  : 		{
; 114  : 			arrNum[rNumCount] = i;

  00a1c	8b 85 90 e0 ff
	ff		 mov	 eax, DWORD PTR _rNumCount$[ebp]
  00a22	8b 8d 8c e0 ff
	ff		 mov	 ecx, DWORD PTR _i$220275[ebp]
  00a28	89 8c 85 94 e0
	ff ff		 mov	 DWORD PTR _arrNum$[ebp+eax*4], ecx

; 115  : 			rNumCount++;

  00a2f	8b 85 90 e0 ff
	ff		 mov	 eax, DWORD PTR _rNumCount$[ebp]
  00a35	83 c0 01	 add	 eax, 1
  00a38	89 85 90 e0 ff
	ff		 mov	 DWORD PTR _rNumCount$[ebp], eax
$LN19@Box:

; 116  : 		}
; 117  : 	}

  00a3e	e9 51 fe ff ff	 jmp	 $LN23@Box
$LN22@Box:

; 118  : 
; 119  : 
; 120  : 	if(Error == true)

  00a43	0f b6 45 db	 movzx	 eax, BYTE PTR _Error$[ebp]
  00a47	83 f8 01	 cmp	 eax, 1
  00a4a	75 20		 jne	 SHORT $LN17@Box

; 121  : 	{
; 122  : 		pMsg.Result = CB_INCORRECT_MIX_ITEMS;

  00a4c	c6 45 e7 07	 mov	 BYTE PTR _pMsg$[ebp+3], 7

; 123  : 		DataSend(lpObj->m_Index, (LPBYTE)&pMsg, pMsg.h.size);

  00a50	0f b6 45 e5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00a54	50		 push	 eax
  00a55	8d 4d e4	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00a58	51		 push	 ecx
  00a59	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00a5c	8b 02		 mov	 eax, DWORD PTR [edx]
  00a5e	50		 push	 eax
  00a5f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00a64	83 c4 0c	 add	 esp, 12			; 0000000cH

; 124  : 		return;

  00a67	e9 c6 05 00 00	 jmp	 $LN25@Box
$LN17@Box:

; 125  : 	}
; 126  : 
; 127  : 	if(lpObj->Money < Zen)

  00a6c	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a6f	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  00a75	3b 4d dc	 cmp	 ecx, DWORD PTR _Zen$[ebp]
  00a78	7d 20		 jge	 SHORT $LN16@Box

; 128  : 	{
; 129  : 		pMsg.Result = CB_NOT_ENOUGH_ZEN;

  00a7a	c6 45 e7 02	 mov	 BYTE PTR _pMsg$[ebp+3], 2

; 130  : 		DataSend(lpObj->m_Index, (LPBYTE)&pMsg, pMsg.h.size);

  00a7e	0f b6 45 e5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00a82	50		 push	 eax
  00a83	8d 4d e4	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00a86	51		 push	 ecx
  00a87	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00a8a	8b 02		 mov	 eax, DWORD PTR [edx]
  00a8c	50		 push	 eax
  00a8d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00a92	83 c4 0c	 add	 esp, 12			; 0000000cH

; 131  : 		return;

  00a95	e9 98 05 00 00	 jmp	 $LN25@Box
$LN16@Box:

; 132  : 	}
; 133  : 
; 134  : 	srand(time(NULL));

  00a9a	6a 00		 push	 0
  00a9c	e8 00 00 00 00	 call	 _time
  00aa1	83 c4 04	 add	 esp, 4
  00aa4	50		 push	 eax
  00aa5	e8 00 00 00 00	 call	 _srand
  00aaa	83 c4 04	 add	 esp, 4

; 135  : 	rNum = arrNum[rand()%rNumCount];

  00aad	e8 00 00 00 00	 call	 _rand
  00ab2	99		 cdq
  00ab3	f7 bd 90 e0 ff
	ff		 idiv	 DWORD PTR _rNumCount$[ebp]
  00ab9	8b 84 95 94 e0
	ff ff		 mov	 eax, DWORD PTR _arrNum$[ebp+edx*4]
  00ac0	89 45 d4	 mov	 DWORD PTR _rNum$[ebp], eax

; 136  : 
; 137  : 	lpObj->Money-=(Zen);

  00ac3	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ac6	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  00acc	2b 4d dc	 sub	 ecx, DWORD PTR _Zen$[ebp]
  00acf	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00ad2	89 8a f0 00 00
	00		 mov	 DWORD PTR [edx+240], ecx

; 138  : 
; 139  : 	GCMoneySend(aIndex, lpObj->Money);

  00ad8	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00adb	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  00ae1	51		 push	 ecx
  00ae2	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00ae5	52		 push	 edx
  00ae6	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  00aeb	83 c4 08	 add	 esp, 8

; 140  : 
; 141  : 
; 142  : 	if(Percent > (rand()%100))

  00aee	e8 00 00 00 00	 call	 _rand
  00af3	99		 cdq
  00af4	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00af9	f7 f9		 idiv	 ecx
  00afb	39 55 e0	 cmp	 DWORD PTR _Percent$[ebp], edx
  00afe	0f 8e fb 04 00
	00		 jle	 $LN15@Box

; 143  : 	{
; 144  : 		int cExl = 0;

  00b04	c7 85 88 e0 ff
	ff 00 00 00 00	 mov	 DWORD PTR _cExl$220288[ebp], 0

; 145  : 		int cAnc = 0;

  00b0e	c7 85 84 e0 ff
	ff 00 00 00 00	 mov	 DWORD PTR _cAnc$220289[ebp], 0

; 146  : 
; 147  : 		if(this->Mix[Num][rNum].Exl > 0)

  00b18	8b 45 10	 mov	 eax, DWORD PTR _Num$[ebp]
  00b1b	69 c0 c0 57 01
	00		 imul	 eax, 88000		; 000157c0H
  00b21	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00b24	8d 94 01 04 7d
	00 00		 lea	 edx, DWORD PTR [ecx+eax+32004]
  00b2b	8b 45 d4	 mov	 eax, DWORD PTR _rNum$[ebp]
  00b2e	6b c0 2c	 imul	 eax, 44			; 0000002cH
  00b31	83 7c 02 1c 00	 cmp	 DWORD PTR [edx+eax+28], 0
  00b36	0f 8e aa 00 00
	00		 jle	 $LN14@Box

; 148  : 		{
; 149  : 
; 150  : #ifdef PRIVATE_MODULE
; 151  : 			if(g_ExLicense.CheckUser(eExUB::drynea))

  00b3c	6a 01		 push	 1
  00b3e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00b43	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00b48	0f b6 c0	 movzx	 eax, al
  00b4b	85 c0		 test	 eax, eax
  00b4d	74 2e		 je	 SHORT $LN13@Box

; 152  : 			{
; 153  : 				cExl = GenExcOpt(this->Mix[Num][rNum].Exl);

  00b4f	8b 45 10	 mov	 eax, DWORD PTR _Num$[ebp]
  00b52	69 c0 c0 57 01
	00		 imul	 eax, 88000		; 000157c0H
  00b58	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00b5b	8d 94 01 04 7d
	00 00		 lea	 edx, DWORD PTR [ecx+eax+32004]
  00b62	8b 45 d4	 mov	 eax, DWORD PTR _rNum$[ebp]
  00b65	6b c0 2c	 imul	 eax, 44			; 0000002cH
  00b68	8b 4c 02 1c	 mov	 ecx, DWORD PTR [edx+eax+28]
  00b6c	51		 push	 ecx
  00b6d	e8 00 00 00 00	 call	 ?GenExcOpt@@YAHH@Z	; GenExcOpt
  00b72	83 c4 04	 add	 esp, 4
  00b75	89 85 88 e0 ff
	ff		 mov	 DWORD PTR _cExl$220288[ebp], eax

; 154  : 			}
; 155  : 			else

  00b7b	eb 69		 jmp	 SHORT $LN14@Box
$LN13@Box:

; 156  : 			{
; 157  : 				int ExcellentOpt[6] = { 1, 2, 4, 8, 16, 32 };

  00b7d	c7 85 6c e0 ff
	ff 01 00 00 00	 mov	 DWORD PTR _ExcellentOpt$220293[ebp], 1
  00b87	c7 85 70 e0 ff
	ff 02 00 00 00	 mov	 DWORD PTR _ExcellentOpt$220293[ebp+4], 2
  00b91	c7 85 74 e0 ff
	ff 04 00 00 00	 mov	 DWORD PTR _ExcellentOpt$220293[ebp+8], 4
  00b9b	c7 85 78 e0 ff
	ff 08 00 00 00	 mov	 DWORD PTR _ExcellentOpt$220293[ebp+12], 8
  00ba5	c7 85 7c e0 ff
	ff 10 00 00 00	 mov	 DWORD PTR _ExcellentOpt$220293[ebp+16], 16 ; 00000010H
  00baf	c7 85 80 e0 ff
	ff 20 00 00 00	 mov	 DWORD PTR _ExcellentOpt$220293[ebp+20], 32 ; 00000020H

; 158  : 				srand(time(NULL));

  00bb9	6a 00		 push	 0
  00bbb	e8 00 00 00 00	 call	 _time
  00bc0	83 c4 04	 add	 esp, 4
  00bc3	50		 push	 eax
  00bc4	e8 00 00 00 00	 call	 _srand
  00bc9	83 c4 04	 add	 esp, 4

; 159  : 				cExl = ExcellentOpt[rand()%6];

  00bcc	e8 00 00 00 00	 call	 _rand
  00bd1	99		 cdq
  00bd2	b9 06 00 00 00	 mov	 ecx, 6
  00bd7	f7 f9		 idiv	 ecx
  00bd9	8b 94 95 6c e0
	ff ff		 mov	 edx, DWORD PTR _ExcellentOpt$220293[ebp+edx*4]
  00be0	89 95 88 e0 ff
	ff		 mov	 DWORD PTR _cExl$220288[ebp], edx
$LN14@Box:

; 160  : 			}	
; 161  : #else
; 162  : 			int ExcellentOpt[6] = { 1, 2, 4, 8, 16, 32 };
; 163  : 			srand(time(NULL));
; 164  : 			cExl = ExcellentOpt[rand()%6];
; 165  : #endif
; 166  : 		}
; 167  : 
; 168  : 		if(this->Mix[Num][rNum].Anc == 5 || this->Mix[Num][rNum].Anc == 10)

  00be6	8b 45 10	 mov	 eax, DWORD PTR _Num$[ebp]
  00be9	69 c0 c0 57 01
	00		 imul	 eax, 88000		; 000157c0H
  00bef	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00bf2	8d 94 01 04 7d
	00 00		 lea	 edx, DWORD PTR [ecx+eax+32004]
  00bf9	8b 45 d4	 mov	 eax, DWORD PTR _rNum$[ebp]
  00bfc	6b c0 2c	 imul	 eax, 44			; 0000002cH
  00bff	83 7c 02 20 05	 cmp	 DWORD PTR [edx+eax+32], 5
  00c04	74 20		 je	 SHORT $LN10@Box
  00c06	8b 45 10	 mov	 eax, DWORD PTR _Num$[ebp]
  00c09	69 c0 c0 57 01
	00		 imul	 eax, 88000		; 000157c0H
  00c0f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00c12	8d 94 01 04 7d
	00 00		 lea	 edx, DWORD PTR [ecx+eax+32004]
  00c19	8b 45 d4	 mov	 eax, DWORD PTR _rNum$[ebp]
  00c1c	6b c0 2c	 imul	 eax, 44			; 0000002cH
  00c1f	83 7c 02 20 0a	 cmp	 DWORD PTR [edx+eax+32], 10 ; 0000000aH
  00c24	75 23		 jne	 SHORT $LN11@Box
$LN10@Box:

; 169  : 		{
; 170  : 			cAnc = this->Mix[Num][rNum].Anc;

  00c26	8b 45 10	 mov	 eax, DWORD PTR _Num$[ebp]
  00c29	69 c0 c0 57 01
	00		 imul	 eax, 88000		; 000157c0H
  00c2f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00c32	8d 94 01 04 7d
	00 00		 lea	 edx, DWORD PTR [ecx+eax+32004]
  00c39	8b 45 d4	 mov	 eax, DWORD PTR _rNum$[ebp]
  00c3c	6b c0 2c	 imul	 eax, 44			; 0000002cH
  00c3f	8b 4c 02 20	 mov	 ecx, DWORD PTR [edx+eax+32]
  00c43	89 8d 84 e0 ff
	ff		 mov	 DWORD PTR _cAnc$220289[ebp], ecx
$LN11@Box:

; 171  : 		}
; 172  : 
; 173  : #ifdef PRIVATE_MODULE
; 174  : 			if(g_ExLicense.CheckUser(eExUB::drynea) || g_ExLicense.CheckUser(eExUB::MedoniAndrei))

  00c49	6a 01		 push	 1
  00c4b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00c50	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00c55	0f b6 c0	 movzx	 eax, al
  00c58	85 c0		 test	 eax, eax
  00c5a	75 17		 jne	 SHORT $LN8@Box
  00c5c	6a 32		 push	 50			; 00000032H
  00c5e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00c63	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00c68	0f b6 c0	 movzx	 eax, al
  00c6b	85 c0		 test	 eax, eax
  00c6d	0f 84 e4 00 00
	00		 je	 $LN9@Box
$LN8@Box:

; 175  : 			{
; 176  : #ifdef DRYNEA_LIST_CUSTOM
; 177  : 				int RandomSocketSlotInMixManager;
; 178  : 				//srand(time(0));
; 179  : 				//RandomSocketSlotInMixManager = (rand() % 5) + 1;
; 180  : 				if( this->Mix[Num][rNum].MaxSocket == this->Mix[Num][rNum].MinSocket )

  00c73	8b 45 10	 mov	 eax, DWORD PTR _Num$[ebp]
  00c76	69 c0 c0 57 01
	00		 imul	 eax, 88000		; 000157c0H
  00c7c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00c7f	8d 94 01 04 7d
	00 00		 lea	 edx, DWORD PTR [ecx+eax+32004]
  00c86	8b 45 d4	 mov	 eax, DWORD PTR _rNum$[ebp]
  00c89	6b c0 2c	 imul	 eax, 44			; 0000002cH
  00c8c	8b 4d 10	 mov	 ecx, DWORD PTR _Num$[ebp]
  00c8f	69 c9 c0 57 01
	00		 imul	 ecx, 88000		; 000157c0H
  00c95	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  00c98	8d 8c 0e 04 7d
	00 00		 lea	 ecx, DWORD PTR [esi+ecx+32004]
  00c9f	8b 75 d4	 mov	 esi, DWORD PTR _rNum$[ebp]
  00ca2	6b f6 2c	 imul	 esi, 44			; 0000002cH
  00ca5	8b 54 02 28	 mov	 edx, DWORD PTR [edx+eax+40]
  00ca9	3b 54 31 24	 cmp	 edx, DWORD PTR [ecx+esi+36]
  00cad	75 25		 jne	 SHORT $LN7@Box

; 181  : 				{
; 182  : 					RandomSocketSlotInMixManager = this->Mix[Num][rNum].MinSocket;

  00caf	8b 45 10	 mov	 eax, DWORD PTR _Num$[ebp]
  00cb2	69 c0 c0 57 01
	00		 imul	 eax, 88000		; 000157c0H
  00cb8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00cbb	8d 94 01 04 7d
	00 00		 lea	 edx, DWORD PTR [ecx+eax+32004]
  00cc2	8b 45 d4	 mov	 eax, DWORD PTR _rNum$[ebp]
  00cc5	6b c0 2c	 imul	 eax, 44			; 0000002cH
  00cc8	8b 4c 02 24	 mov	 ecx, DWORD PTR [edx+eax+36]
  00ccc	89 8d 68 e0 ff
	ff		 mov	 DWORD PTR _RandomSocketSlotInMixManager$220298[ebp], ecx

; 183  : 				}
; 184  : 				else

  00cd2	eb 74		 jmp	 SHORT $LN6@Box
$LN7@Box:

; 185  : 				{
; 186  : 					RandomSocketSlotInMixManager = this->Mix[Num][rNum].MinSocket + (rand() % (this->Mix[Num][rNum].MaxSocket - this->Mix[Num][rNum].MinSocket + 1));

  00cd4	8b 45 10	 mov	 eax, DWORD PTR _Num$[ebp]
  00cd7	69 c0 c0 57 01
	00		 imul	 eax, 88000		; 000157c0H
  00cdd	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00ce0	8d b4 01 04 7d
	00 00		 lea	 esi, DWORD PTR [ecx+eax+32004]
  00ce7	8b 7d d4	 mov	 edi, DWORD PTR _rNum$[ebp]
  00cea	6b ff 2c	 imul	 edi, 44			; 0000002cH
  00ced	e8 00 00 00 00	 call	 _rand
  00cf2	8b 55 10	 mov	 edx, DWORD PTR _Num$[ebp]
  00cf5	69 d2 c0 57 01
	00		 imul	 edx, 88000		; 000157c0H
  00cfb	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00cfe	8d 94 11 04 7d
	00 00		 lea	 edx, DWORD PTR [ecx+edx+32004]
  00d05	8b 4d d4	 mov	 ecx, DWORD PTR _rNum$[ebp]
  00d08	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  00d0b	8b 5d 10	 mov	 ebx, DWORD PTR _Num$[ebp]
  00d0e	69 db c0 57 01
	00		 imul	 ebx, 88000		; 000157c0H
  00d14	89 b5 18 e0 ff
	ff		 mov	 DWORD PTR tv734[ebp], esi
  00d1a	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  00d1d	8d b4 1e 04 7d
	00 00		 lea	 esi, DWORD PTR [esi+ebx+32004]
  00d24	8b 5d d4	 mov	 ebx, DWORD PTR _rNum$[ebp]
  00d27	6b db 2c	 imul	 ebx, 44			; 0000002cH
  00d2a	8b 4c 0a 28	 mov	 ecx, DWORD PTR [edx+ecx+40]
  00d2e	2b 4c 1e 24	 sub	 ecx, DWORD PTR [esi+ebx+36]
  00d32	83 c1 01	 add	 ecx, 1
  00d35	99		 cdq
  00d36	f7 f9		 idiv	 ecx
  00d38	8b b5 18 e0 ff
	ff		 mov	 esi, DWORD PTR tv734[ebp]
  00d3e	03 54 3e 24	 add	 edx, DWORD PTR [esi+edi+36]
  00d42	89 95 68 e0 ff
	ff		 mov	 DWORD PTR _RandomSocketSlotInMixManager$220298[ebp], edx
$LN6@Box:

; 187  : 				}
; 188  : 
; 189  : 				lpObj->MixManagerSocket = RandomSocketSlotInMixManager;

  00d48	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d4b	8a 8d 68 e0 ff
	ff		 mov	 cl, BYTE PTR _RandomSocketSlotInMixManager$220298[ebp]
  00d51	88 88 18 28 00
	00		 mov	 BYTE PTR [eax+10264], cl
$LN9@Box:

; 190  : #endif
; 191  : 			}
; 192  : #endif
; 193  : #ifdef DRYNEA_31_10
; 194  : 			if(g_ExLicense.CheckUser(eExUB::drynea))

  00d57	6a 01		 push	 1
  00d59	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00d5e	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00d63	0f b6 c0	 movzx	 eax, al
  00d66	85 c0		 test	 eax, eax
  00d68	0f 84 b9 01 00
	00		 je	 $LN5@Box

; 195  : 			{
; 196  : 				srand(time(0));

  00d6e	6a 00		 push	 0
  00d70	e8 00 00 00 00	 call	 _time
  00d75	83 c4 04	 add	 esp, 4
  00d78	50		 push	 eax
  00d79	e8 00 00 00 00	 call	 _srand
  00d7e	83 c4 04	 add	 esp, 4

; 197  : 				int randomLuckDrynea = rand()%2;

  00d81	e8 00 00 00 00	 call	 _rand
  00d86	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00d8b	79 05		 jns	 SHORT $LN27@Box
  00d8d	48		 dec	 eax
  00d8e	83 c8 fe	 or	 eax, -2			; fffffffeH
  00d91	40		 inc	 eax
$LN27@Box:
  00d92	89 85 64 e0 ff
	ff		 mov	 DWORD PTR _randomLuckDrynea$220302[ebp], eax

; 198  : 				int randomSkillDrynea = rand()%2;

  00d98	e8 00 00 00 00	 call	 _rand
  00d9d	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00da2	79 05		 jns	 SHORT $LN28@Box
  00da4	48		 dec	 eax
  00da5	83 c8 fe	 or	 eax, -2			; fffffffeH
  00da8	40		 inc	 eax
$LN28@Box:
  00da9	89 85 60 e0 ff
	ff		 mov	 DWORD PTR _randomSkillDrynea$220303[ebp], eax

; 199  : 				int randomExcelentDrynea = rand()%2;

  00daf	e8 00 00 00 00	 call	 _rand
  00db4	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00db9	79 05		 jns	 SHORT $LN29@Box
  00dbb	48		 dec	 eax
  00dbc	83 c8 fe	 or	 eax, -2			; fffffffeH
  00dbf	40		 inc	 eax
$LN29@Box:
  00dc0	89 85 5c e0 ff
	ff		 mov	 DWORD PTR _randomExcelentDrynea$220304[ebp], eax

; 200  : 				if (randomExcelentDrynea)

  00dc6	83 bd 5c e0 ff
	ff 00		 cmp	 DWORD PTR _randomExcelentDrynea$220304[ebp], 0
  00dcd	0f 84 ad 00 00
	00		 je	 $LN4@Box

; 201  : 				{
; 202  : 					ItemSerialCreateSend(lpObj->m_Index, -1, 0, 0, ITEMGET(this->Mix[Num][rNum].Type,this->Mix[Num][rNum].Index), 0, 0, 
; 203  : 					randomSkillDrynea, (BYTE)randomLuckDrynea, (BYTE)this->Mix[Num][rNum].Opt, -1, (BYTE)cExl, cAnc);

  00dd3	0f b6 85 84 e0
	ff ff		 movzx	 eax, BYTE PTR _cAnc$220289[ebp]
  00dda	50		 push	 eax
  00ddb	0f b6 8d 88 e0
	ff ff		 movzx	 ecx, BYTE PTR _cExl$220288[ebp]
  00de2	51		 push	 ecx
  00de3	6a ff		 push	 -1
  00de5	8b 55 10	 mov	 edx, DWORD PTR _Num$[ebp]
  00de8	69 d2 c0 57 01
	00		 imul	 edx, 88000		; 000157c0H
  00dee	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00df1	8d 8c 10 04 7d
	00 00		 lea	 ecx, DWORD PTR [eax+edx+32004]
  00df8	8b 55 d4	 mov	 edx, DWORD PTR _rNum$[ebp]
  00dfb	6b d2 2c	 imul	 edx, 44			; 0000002cH
  00dfe	0f b6 44 11 18	 movzx	 eax, BYTE PTR [ecx+edx+24]
  00e03	50		 push	 eax
  00e04	0f b6 8d 64 e0
	ff ff		 movzx	 ecx, BYTE PTR _randomLuckDrynea$220302[ebp]
  00e0b	51		 push	 ecx
  00e0c	0f b6 95 60 e0
	ff ff		 movzx	 edx, BYTE PTR _randomSkillDrynea$220303[ebp]
  00e13	52		 push	 edx
  00e14	6a 00		 push	 0
  00e16	6a 00		 push	 0
  00e18	8b 45 10	 mov	 eax, DWORD PTR _Num$[ebp]
  00e1b	69 c0 c0 57 01
	00		 imul	 eax, 88000		; 000157c0H
  00e21	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00e24	8d 94 01 04 7d
	00 00		 lea	 edx, DWORD PTR [ecx+eax+32004]
  00e2b	8b 45 d4	 mov	 eax, DWORD PTR _rNum$[ebp]
  00e2e	6b c0 2c	 imul	 eax, 44			; 0000002cH
  00e31	8b 4c 02 04	 mov	 ecx, DWORD PTR [edx+eax+4]
  00e35	c1 e1 09	 shl	 ecx, 9
  00e38	8b 55 10	 mov	 edx, DWORD PTR _Num$[ebp]
  00e3b	69 d2 c0 57 01
	00		 imul	 edx, 88000		; 000157c0H
  00e41	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00e44	8d 94 10 04 7d
	00 00		 lea	 edx, DWORD PTR [eax+edx+32004]
  00e4b	8b 45 d4	 mov	 eax, DWORD PTR _rNum$[ebp]
  00e4e	6b c0 2c	 imul	 eax, 44			; 0000002cH
  00e51	03 4c 02 08	 add	 ecx, DWORD PTR [edx+eax+8]
  00e55	51		 push	 ecx
  00e56	6a 00		 push	 0
  00e58	6a 00		 push	 0
  00e5a	68 ff 00 00 00	 push	 255			; 000000ffH
  00e5f	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00e62	8b 11		 mov	 edx, DWORD PTR [ecx]
  00e64	52		 push	 edx
  00e65	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  00e6a	83 c4 34	 add	 esp, 52			; 00000034H

; 204  : 					::gObjInventoryCommit(lpObj->m_Index);

  00e6d	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e70	8b 08		 mov	 ecx, DWORD PTR [eax]
  00e72	51		 push	 ecx
  00e73	e8 00 00 00 00	 call	 ?gObjInventoryCommit@@YAHH@Z ; gObjInventoryCommit
  00e78	83 c4 04	 add	 esp, 4

; 205  : 				}
; 206  : 				else

  00e7b	e9 a2 00 00 00	 jmp	 $LN3@Box
$LN4@Box:

; 207  : 				{
; 208  : 					ItemSerialCreateSend(lpObj->m_Index, -1, 0, 0, ITEMGET(this->Mix[Num][rNum].Type,this->Mix[Num][rNum].Index), 0, 0, 
; 209  : 					randomSkillDrynea, (BYTE)randomLuckDrynea, (BYTE)this->Mix[Num][rNum].Opt, -1, 0, cAnc);

  00e80	0f b6 85 84 e0
	ff ff		 movzx	 eax, BYTE PTR _cAnc$220289[ebp]
  00e87	50		 push	 eax
  00e88	6a 00		 push	 0
  00e8a	6a ff		 push	 -1
  00e8c	8b 4d 10	 mov	 ecx, DWORD PTR _Num$[ebp]
  00e8f	69 c9 c0 57 01
	00		 imul	 ecx, 88000		; 000157c0H
  00e95	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00e98	8d 84 0a 04 7d
	00 00		 lea	 eax, DWORD PTR [edx+ecx+32004]
  00e9f	8b 4d d4	 mov	 ecx, DWORD PTR _rNum$[ebp]
  00ea2	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  00ea5	0f b6 54 08 18	 movzx	 edx, BYTE PTR [eax+ecx+24]
  00eaa	52		 push	 edx
  00eab	0f b6 85 64 e0
	ff ff		 movzx	 eax, BYTE PTR _randomLuckDrynea$220302[ebp]
  00eb2	50		 push	 eax
  00eb3	0f b6 8d 60 e0
	ff ff		 movzx	 ecx, BYTE PTR _randomSkillDrynea$220303[ebp]
  00eba	51		 push	 ecx
  00ebb	6a 00		 push	 0
  00ebd	6a 00		 push	 0
  00ebf	8b 55 10	 mov	 edx, DWORD PTR _Num$[ebp]
  00ec2	69 d2 c0 57 01
	00		 imul	 edx, 88000		; 000157c0H
  00ec8	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00ecb	8d 8c 10 04 7d
	00 00		 lea	 ecx, DWORD PTR [eax+edx+32004]
  00ed2	8b 55 d4	 mov	 edx, DWORD PTR _rNum$[ebp]
  00ed5	6b d2 2c	 imul	 edx, 44			; 0000002cH
  00ed8	8b 44 11 04	 mov	 eax, DWORD PTR [ecx+edx+4]
  00edc	c1 e0 09	 shl	 eax, 9
  00edf	8b 4d 10	 mov	 ecx, DWORD PTR _Num$[ebp]
  00ee2	69 c9 c0 57 01
	00		 imul	 ecx, 88000		; 000157c0H
  00ee8	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00eeb	8d 8c 0a 04 7d
	00 00		 lea	 ecx, DWORD PTR [edx+ecx+32004]
  00ef2	8b 55 d4	 mov	 edx, DWORD PTR _rNum$[ebp]
  00ef5	6b d2 2c	 imul	 edx, 44			; 0000002cH
  00ef8	03 44 11 08	 add	 eax, DWORD PTR [ecx+edx+8]
  00efc	50		 push	 eax
  00efd	6a 00		 push	 0
  00eff	6a 00		 push	 0
  00f01	68 ff 00 00 00	 push	 255			; 000000ffH
  00f06	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00f09	8b 08		 mov	 ecx, DWORD PTR [eax]
  00f0b	51		 push	 ecx
  00f0c	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  00f11	83 c4 34	 add	 esp, 52			; 00000034H

; 210  : 					::gObjInventoryCommit(lpObj->m_Index);

  00f14	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00f17	8b 08		 mov	 ecx, DWORD PTR [eax]
  00f19	51		 push	 ecx
  00f1a	e8 00 00 00 00	 call	 ?gObjInventoryCommit@@YAHH@Z ; gObjInventoryCommit
  00f1f	83 c4 04	 add	 esp, 4
$LN3@Box:

; 211  : 				}
; 212  : 			}
; 213  : 			else

  00f22	e9 d6 00 00 00	 jmp	 $LN2@Box
$LN5@Box:

; 214  : 			{
; 215  : 				ItemSerialCreateSend(lpObj->m_Index, -1, 0, 0, ITEMGET(this->Mix[Num][rNum].Type,this->Mix[Num][rNum].Index), 0, 0, 
; 216  : 				this->Mix[Num][rNum].Skill, (BYTE)this->Mix[Num][rNum].Luck, (BYTE)this->Mix[Num][rNum].Opt, -1, (BYTE)cExl, cAnc);

  00f27	0f b6 85 84 e0
	ff ff		 movzx	 eax, BYTE PTR _cAnc$220289[ebp]
  00f2e	50		 push	 eax
  00f2f	0f b6 8d 88 e0
	ff ff		 movzx	 ecx, BYTE PTR _cExl$220288[ebp]
  00f36	51		 push	 ecx
  00f37	6a ff		 push	 -1
  00f39	8b 55 10	 mov	 edx, DWORD PTR _Num$[ebp]
  00f3c	69 d2 c0 57 01
	00		 imul	 edx, 88000		; 000157c0H
  00f42	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00f45	8d 8c 10 04 7d
	00 00		 lea	 ecx, DWORD PTR [eax+edx+32004]
  00f4c	8b 55 d4	 mov	 edx, DWORD PTR _rNum$[ebp]
  00f4f	6b d2 2c	 imul	 edx, 44			; 0000002cH
  00f52	0f b6 44 11 18	 movzx	 eax, BYTE PTR [ecx+edx+24]
  00f57	50		 push	 eax
  00f58	8b 4d 10	 mov	 ecx, DWORD PTR _Num$[ebp]
  00f5b	69 c9 c0 57 01
	00		 imul	 ecx, 88000		; 000157c0H
  00f61	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00f64	8d 84 0a 04 7d
	00 00		 lea	 eax, DWORD PTR [edx+ecx+32004]
  00f6b	8b 4d d4	 mov	 ecx, DWORD PTR _rNum$[ebp]
  00f6e	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  00f71	0f b6 54 08 14	 movzx	 edx, BYTE PTR [eax+ecx+20]
  00f76	52		 push	 edx
  00f77	8b 45 10	 mov	 eax, DWORD PTR _Num$[ebp]
  00f7a	69 c0 c0 57 01
	00		 imul	 eax, 88000		; 000157c0H
  00f80	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00f83	8d 94 01 04 7d
	00 00		 lea	 edx, DWORD PTR [ecx+eax+32004]
  00f8a	8b 45 d4	 mov	 eax, DWORD PTR _rNum$[ebp]
  00f8d	6b c0 2c	 imul	 eax, 44			; 0000002cH
  00f90	0f b6 4c 02 10	 movzx	 ecx, BYTE PTR [edx+eax+16]
  00f95	51		 push	 ecx
  00f96	6a 00		 push	 0
  00f98	6a 00		 push	 0
  00f9a	8b 55 10	 mov	 edx, DWORD PTR _Num$[ebp]
  00f9d	69 d2 c0 57 01
	00		 imul	 edx, 88000		; 000157c0H
  00fa3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00fa6	8d 8c 10 04 7d
	00 00		 lea	 ecx, DWORD PTR [eax+edx+32004]
  00fad	8b 55 d4	 mov	 edx, DWORD PTR _rNum$[ebp]
  00fb0	6b d2 2c	 imul	 edx, 44			; 0000002cH
  00fb3	8b 44 11 04	 mov	 eax, DWORD PTR [ecx+edx+4]
  00fb7	c1 e0 09	 shl	 eax, 9
  00fba	8b 4d 10	 mov	 ecx, DWORD PTR _Num$[ebp]
  00fbd	69 c9 c0 57 01
	00		 imul	 ecx, 88000		; 000157c0H
  00fc3	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00fc6	8d 8c 0a 04 7d
	00 00		 lea	 ecx, DWORD PTR [edx+ecx+32004]
  00fcd	8b 55 d4	 mov	 edx, DWORD PTR _rNum$[ebp]
  00fd0	6b d2 2c	 imul	 edx, 44			; 0000002cH
  00fd3	03 44 11 08	 add	 eax, DWORD PTR [ecx+edx+8]
  00fd7	50		 push	 eax
  00fd8	6a 00		 push	 0
  00fda	6a 00		 push	 0
  00fdc	68 ff 00 00 00	 push	 255			; 000000ffH
  00fe1	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00fe4	8b 08		 mov	 ecx, DWORD PTR [eax]
  00fe6	51		 push	 ecx
  00fe7	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  00fec	83 c4 34	 add	 esp, 52			; 00000034H

; 217  : 				::gObjInventoryCommit(lpObj->m_Index);

  00fef	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ff2	8b 08		 mov	 ecx, DWORD PTR [eax]
  00ff4	51		 push	 ecx
  00ff5	e8 00 00 00 00	 call	 ?gObjInventoryCommit@@YAHH@Z ; gObjInventoryCommit
  00ffa	83 c4 04	 add	 esp, 4
$LN2@Box:

; 218  : 			}
; 219  : #else
; 220  : 		ItemSerialCreateSend(lpObj->m_Index, -1, 0, 0, ITEMGET(this->Mix[Num][rNum].Type,this->Mix[Num][rNum].Index), 0, 0, 
; 221  : 			this->Mix[Num][rNum].Skill, (BYTE)this->Mix[Num][rNum].Luck, (BYTE)this->Mix[Num][rNum].Opt, -1, (BYTE)cExl, cAnc);
; 222  : 		::gObjInventoryCommit(lpObj->m_Index);
; 223  : #endif
; 224  : 
; 225  : 	}
; 226  : 	else

  00ffd	eb 33		 jmp	 SHORT $LN25@Box
$LN15@Box:

; 227  : 	{
; 228  : 		g_MixSystem.ChaosBoxInit(lpObj);

  00fff	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01002	50		 push	 eax
  01003	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  01008	e8 00 00 00 00	 call	 ?ChaosBoxInit@CMixSystem@@QAEHPAUOBJECTSTRUCT@@@Z ; CMixSystem::ChaosBoxInit

; 229  : 		::GCUserChaosBoxSend(lpObj, 0);

  0100d	6a 00		 push	 0
  0100f	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01012	50		 push	 eax
  01013	e8 00 00 00 00	 call	 ?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z ; GCUserChaosBoxSend
  01018	83 c4 08	 add	 esp, 8

; 230  : 		DataSend(lpObj->m_Index, (LPBYTE)&pMsg, pMsg.h.size);

  0101b	0f b6 45 e5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0101f	50		 push	 eax
  01020	8d 4d e4	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  01023	51		 push	 ecx
  01024	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01027	8b 02		 mov	 eax, DWORD PTR [edx]
  01029	50		 push	 eax
  0102a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0102f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN25@Box:

; 231  : 	}
; 232  : 
; 233  : }

  01032	5f		 pop	 edi
  01033	5e		 pop	 esi
  01034	5b		 pop	 ebx
  01035	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01038	33 cd		 xor	 ecx, ebp
  0103a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0103f	8b e5		 mov	 esp, ebp
  01041	5d		 pop	 ebp
  01042	c2 0c 00	 ret	 12			; 0000000cH
?Box@cChaosMixManager@@AAEXHHH@Z ENDP			; cChaosMixManager::Box
_TEXT	ENDS
EXTRN	__time64:PROC
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\time.inl
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_time	PROC

; 132  : {

  01050	55		 push	 ebp
  01051	8b ec		 mov	 ebp, esp
  01053	83 ec 40	 sub	 esp, 64			; 00000040H
  01056	53		 push	 ebx
  01057	56		 push	 esi
  01058	57		 push	 edi

; 133  :     return _time64(_Time);

  01059	8b 45 08	 mov	 eax, DWORD PTR __Time$[ebp]
  0105c	50		 push	 eax
  0105d	e8 00 00 00 00	 call	 __time64
  01062	83 c4 04	 add	 esp, 4

; 134  : }

  01065	5f		 pop	 edi
  01066	5e		 pop	 esi
  01067	5b		 pop	 ebx
  01068	8b e5		 mov	 esp, ebp
  0106a	5d		 pop	 ebp
  0106b	c3		 ret	 0
_time	ENDP
_TEXT	ENDS
PUBLIC	?Main@cChaosMixManager@@QAE_NHH@Z		; cChaosMixManager::Main
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\chaosmixmanager.cpp
_TEXT	SEGMENT
_i$220323 = -8						; size = 4
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_MixIndex$ = 12						; size = 4
?Main@cChaosMixManager@@QAE_NHH@Z PROC			; cChaosMixManager::Main
; _this$ = ecx

; 236  : {

  01070	55		 push	 ebp
  01071	8b ec		 mov	 ebp, esp
  01073	83 ec 48	 sub	 esp, 72			; 00000048H
  01076	53		 push	 ebx
  01077	56		 push	 esi
  01078	57		 push	 edi
  01079	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 237  : 	for(int i=0;i<this->MixCount;i++)

  0107c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$220323[ebp], 0
  01083	eb 09		 jmp	 SHORT $LN4@Main
$LN3@Main:
  01085	8b 45 f8	 mov	 eax, DWORD PTR _i$220323[ebp]
  01088	83 c0 01	 add	 eax, 1
  0108b	89 45 f8	 mov	 DWORD PTR _i$220323[ebp], eax
$LN4@Main:
  0108e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01091	8b 4d f8	 mov	 ecx, DWORD PTR _i$220323[ebp]
  01094	3b 08		 cmp	 ecx, DWORD PTR [eax]
  01096	7d 29		 jge	 SHORT $LN2@Main

; 238  : 	{
; 239  : 		if(this->MixID[i] == MixIndex)

  01098	8b 45 f8	 mov	 eax, DWORD PTR _i$220323[ebp]
  0109b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0109e	8b 54 81 04	 mov	 edx, DWORD PTR [ecx+eax*4+4]
  010a2	3b 55 0c	 cmp	 edx, DWORD PTR _MixIndex$[ebp]
  010a5	75 18		 jne	 SHORT $LN1@Main

; 240  : 		{
; 241  : 			this->Box(aIndex,MixIndex,i);

  010a7	8b 45 f8	 mov	 eax, DWORD PTR _i$220323[ebp]
  010aa	50		 push	 eax
  010ab	8b 4d 0c	 mov	 ecx, DWORD PTR _MixIndex$[ebp]
  010ae	51		 push	 ecx
  010af	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  010b2	52		 push	 edx
  010b3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  010b6	e8 00 00 00 00	 call	 ?Box@cChaosMixManager@@AAEXHHH@Z ; cChaosMixManager::Box

; 242  : 			return true;

  010bb	b0 01		 mov	 al, 1
  010bd	eb 04		 jmp	 SHORT $LN5@Main
$LN1@Main:

; 243  : 		}
; 244  : 	}

  010bf	eb c4		 jmp	 SHORT $LN3@Main
$LN2@Main:

; 245  : 	return false;

  010c1	32 c0		 xor	 al, al
$LN5@Main:

; 246  : }

  010c3	5f		 pop	 edi
  010c4	5e		 pop	 esi
  010c5	5b		 pop	 ebx
  010c6	8b e5		 mov	 esp, ebp
  010c8	5d		 pop	 ebp
  010c9	c2 08 00	 ret	 8
?Main@cChaosMixManager@@QAE_NHH@Z ENDP			; cChaosMixManager::Main
; Function compile flags: /Odtp /ZI
_nAnc$220347 = -28					; size = 4
_nExl$220346 = -24					; size = 4
_nOpt$220345 = -20					; size = 4
_i$220341 = -16						; size = 4
_count$ = -12						; size = 4
_lpObj$ = -8						; size = 4
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_iType$ = 12						; size = 4
_iLevel$ = 16						; size = 4
_iSkill$ = 20						; size = 4
_iLuck$ = 24						; size = 4
_iOpt$ = 28						; size = 4
_iExl$ = 32						; size = 4
_iAnc$ = 36						; size = 4
?nIBox@cChaosMixManager@@AAE_NHHHHHHHH@Z PROC		; cChaosMixManager::nIBox
; _this$ = ecx

; 249  : {

  010d0	55		 push	 ebp
  010d1	8b ec		 mov	 ebp, esp
  010d3	83 ec 5c	 sub	 esp, 92			; 0000005cH
  010d6	53		 push	 ebx
  010d7	56		 push	 esi
  010d8	57		 push	 edi
  010d9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 250  : 	LPOBJ lpObj = &gObj[aIndex];

  010dc	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  010df	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  010e5	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  010eb	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 251  : 
; 252  : 	int count = 0;

  010ee	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0

; 253  : 	for(int i = 0; i < 32; i++)

  010f5	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$220341[ebp], 0
  010fc	eb 09		 jmp	 SHORT $LN10@nIBox
$LN9@nIBox:
  010fe	8b 45 f0	 mov	 eax, DWORD PTR _i$220341[ebp]
  01101	83 c0 01	 add	 eax, 1
  01104	89 45 f0	 mov	 DWORD PTR _i$220341[ebp], eax
$LN10@nIBox:
  01107	83 7d f0 20	 cmp	 DWORD PTR _i$220341[ebp], 32 ; 00000020H
  0110b	0f 8d 01 01 00
	00		 jge	 $LN8@nIBox

; 254  : 	{
; 255  : 		int nOpt = 0;

  01111	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _nOpt$220345[ebp], 0

; 256  : 		int nExl = 0;

  01118	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _nExl$220346[ebp], 0

; 257  : 		int nAnc = 0;

  0111f	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _nAnc$220347[ebp], 0

; 258  : 		if(lpObj->pChaosBox[i].m_Option3 > 0)		nOpt = 1;

  01126	8b 45 f0	 mov	 eax, DWORD PTR _i$220341[ebp]
  01129	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  0112f	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01132	8b 91 78 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3704]
  01138	0f b6 84 02 96
	00 00 00	 movzx	 eax, BYTE PTR [edx+eax+150]
  01140	85 c0		 test	 eax, eax
  01142	7e 07		 jle	 SHORT $LN7@nIBox
  01144	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _nOpt$220345[ebp], 1
$LN7@nIBox:

; 259  : 		if(lpObj->pChaosBox[i].m_NewOption > 0)		nExl = 1;

  0114b	8b 45 f0	 mov	 eax, DWORD PTR _i$220341[ebp]
  0114e	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  01154	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01157	8b 91 78 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3704]
  0115d	0f b6 84 02 97
	00 00 00	 movzx	 eax, BYTE PTR [edx+eax+151]
  01165	85 c0		 test	 eax, eax
  01167	7e 07		 jle	 SHORT $LN6@nIBox
  01169	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _nExl$220346[ebp], 1
$LN6@nIBox:

; 260  : 		if(lpObj->pChaosBox[i].m_SetOption > 0)		nAnc = 1;

  01170	8b 45 f0	 mov	 eax, DWORD PTR _i$220341[ebp]
  01173	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  01179	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0117c	8b 91 78 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3704]
  01182	0f b6 84 02 ae
	00 00 00	 movzx	 eax, BYTE PTR [edx+eax+174]
  0118a	85 c0		 test	 eax, eax
  0118c	7e 07		 jle	 SHORT $LN5@nIBox
  0118e	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _nAnc$220347[ebp], 1
$LN5@nIBox:

; 261  : 		//----
; 262  : 		if( iType == 0 )

  01195	83 7d 0c 00	 cmp	 DWORD PTR _iType$[ebp], 0
  01199	75 1e		 jne	 SHORT $LN4@nIBox

; 263  : 		{
; 264  : 			if( nOpt == iOpt
; 265  : 				&& nExl == iExl
; 266  : 				&& nAnc == iAnc )

  0119b	8b 45 ec	 mov	 eax, DWORD PTR _nOpt$220345[ebp]
  0119e	3b 45 1c	 cmp	 eax, DWORD PTR _iOpt$[ebp]
  011a1	75 14		 jne	 SHORT $LN3@nIBox
  011a3	8b 45 e8	 mov	 eax, DWORD PTR _nExl$220346[ebp]
  011a6	3b 45 20	 cmp	 eax, DWORD PTR _iExl$[ebp]
  011a9	75 0c		 jne	 SHORT $LN3@nIBox
  011ab	8b 45 e4	 mov	 eax, DWORD PTR _nAnc$220347[ebp]
  011ae	3b 45 24	 cmp	 eax, DWORD PTR _iAnc$[ebp]
  011b1	75 04		 jne	 SHORT $LN3@nIBox

; 267  : 				return true;

  011b3	b0 01		 mov	 al, 1
  011b5	eb 5d		 jmp	 SHORT $LN11@nIBox
$LN3@nIBox:

; 268  : 		}
; 269  : 		else

  011b7	eb 54		 jmp	 SHORT $LN2@nIBox
$LN4@nIBox:

; 270  : 		{
; 271  : 			if( lpObj->pChaosBox[i].m_Type == iType 
; 272  : 				&& lpObj->pChaosBox[i].m_Level == iLevel
; 273  : 				&& nOpt == iOpt
; 274  : 				&& nExl == iExl
; 275  : 				&& nAnc == iAnc )

  011b9	8b 45 f0	 mov	 eax, DWORD PTR _i$220341[ebp]
  011bc	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  011c2	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  011c5	8b 91 78 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3704]
  011cb	0f bf 44 02 06	 movsx	 eax, WORD PTR [edx+eax+6]
  011d0	3b 45 0c	 cmp	 eax, DWORD PTR _iType$[ebp]
  011d3	75 38		 jne	 SHORT $LN2@nIBox
  011d5	8b 45 f0	 mov	 eax, DWORD PTR _i$220341[ebp]
  011d8	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  011de	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  011e1	8b 91 78 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3704]
  011e7	0f bf 44 02 08	 movsx	 eax, WORD PTR [edx+eax+8]
  011ec	3b 45 10	 cmp	 eax, DWORD PTR _iLevel$[ebp]
  011ef	75 1c		 jne	 SHORT $LN2@nIBox
  011f1	8b 45 ec	 mov	 eax, DWORD PTR _nOpt$220345[ebp]
  011f4	3b 45 1c	 cmp	 eax, DWORD PTR _iOpt$[ebp]
  011f7	75 14		 jne	 SHORT $LN2@nIBox
  011f9	8b 45 e8	 mov	 eax, DWORD PTR _nExl$220346[ebp]
  011fc	3b 45 20	 cmp	 eax, DWORD PTR _iExl$[ebp]
  011ff	75 0c		 jne	 SHORT $LN2@nIBox
  01201	8b 45 e4	 mov	 eax, DWORD PTR _nAnc$220347[ebp]
  01204	3b 45 24	 cmp	 eax, DWORD PTR _iAnc$[ebp]
  01207	75 04		 jne	 SHORT $LN2@nIBox

; 276  : 				return true;

  01209	b0 01		 mov	 al, 1
  0120b	eb 07		 jmp	 SHORT $LN11@nIBox
$LN2@nIBox:

; 277  : 		}
; 278  : 		//----
; 279  : 	}

  0120d	e9 ec fe ff ff	 jmp	 $LN9@nIBox
$LN8@nIBox:

; 280  : 	return false;

  01212	32 c0		 xor	 al, al
$LN11@nIBox:

; 281  : }

  01214	5f		 pop	 edi
  01215	5e		 pop	 esi
  01216	5b		 pop	 ebx
  01217	8b e5		 mov	 esp, ebp
  01219	5d		 pop	 ebp
  0121a	c2 20 00	 ret	 32			; 00000020H
?nIBox@cChaosMixManager@@AAE_NHHHHHHHH@Z ENDP		; cChaosMixManager::nIBox
_TEXT	ENDS
END
