; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	D:\Projects\ExTeam6.3\Source\GameServer\GameServer\MuMsg.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?nMsg@@3HA					; nMsg
_BSS	SEGMENT
?nMsg@@3HA DD	01H DUP (?)				; nMsg
_BSS	ENDS
PUBLIC	?fnMsg@@YAHXZ					; fnMsg
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\mumsg.cpp
_TEXT	SEGMENT
?fnMsg@@YAHXZ PROC					; fnMsg

; 7    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 8    : 	return 42;

  00009	b8 2a 00 00 00	 mov	 eax, 42			; 0000002aH

; 9    : }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?fnMsg@@YAHXZ ENDP					; fnMsg
_TEXT	ENDS
PUBLIC	??_C@_09OPBDKGIP@Msg?5error?$AA@		; `string'
PUBLIC	??0CMsg@@QAE@XZ					; CMsg::CMsg
EXTRN	_strcpy:PROC
EXTRN	_memset:PROC
;	COMDAT ??_C@_09OPBDKGIP@Msg?5error?$AA@
CONST	SEGMENT
??_C@_09OPBDKGIP@Msg?5error?$AA@ DB 'Msg error', 00H	; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CMsg@@QAE@XZ PROC					; CMsg::CMsg
; _this$ = ecx

; 12   : {

  00020	55		 push	 ebp
  00021	8b ec		 mov	 ebp, esp
  00023	83 ec 44	 sub	 esp, 68			; 00000044H
  00026	53		 push	 ebx
  00027	56		 push	 esi
  00028	57		 push	 edi
  00029	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 13   : 	memset(&this->szDefaultMsg  , 0, sizeof(this->szDefaultMsg ) );

  0002c	6a 32		 push	 50			; 00000032H
  0002e	6a 00		 push	 0
  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	05 24 00 02 00	 add	 eax, 131108		; 00020024H
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 _memset
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14   : 	this->Msghead = NULL;

  00041	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00044	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 15   : 	strcpy(this->szDefaultMsg , "Msg error");

  0004a	68 00 00 00 00	 push	 OFFSET ??_C@_09OPBDKGIP@Msg?5error?$AA@
  0004f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00052	05 24 00 02 00	 add	 eax, 131108		; 00020024H
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 _strcpy
  0005d	83 c4 08	 add	 esp, 8

; 16   : }

  00060	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
??0CMsg@@QAE@XZ ENDP					; CMsg::CMsg
_TEXT	ENDS
PUBLIC	?lMsgFree@CMsg@@AAEXXZ				; CMsg::lMsgFree
PUBLIC	??1CMsg@@QAE@XZ					; CMsg::~CMsg
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CMsg@@QAE@XZ PROC					; CMsg::~CMsg
; _this$ = ecx

; 19   : {

  00070	55		 push	 ebp
  00071	8b ec		 mov	 ebp, esp
  00073	83 ec 44	 sub	 esp, 68			; 00000044H
  00076	53		 push	 ebx
  00077	56		 push	 esi
  00078	57		 push	 edi
  00079	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 20   : 	this->lMsgFree();

  0007c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	e8 00 00 00 00	 call	 ?lMsgFree@CMsg@@AAEXXZ	; CMsg::lMsgFree

; 21   : }

  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c3		 ret	 0
??1CMsg@@QAE@XZ ENDP					; CMsg::~CMsg
_TEXT	ENDS
PUBLIC	?XorBuffer@CMsg@@AAEXPADH@Z			; CMsg::XorBuffer
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_iCounter$204408 = -8					; size = 4
_this$ = -4						; size = 4
_buff$ = 8						; size = 4
_len$ = 12						; size = 4
?XorBuffer@CMsg@@AAEXPADH@Z PROC			; CMsg::XorBuffer
; _this$ = ecx

; 24   : {

  00090	55		 push	 ebp
  00091	8b ec		 mov	 ebp, esp
  00093	83 ec 48	 sub	 esp, 72			; 00000048H
  00096	53		 push	 ebx
  00097	56		 push	 esi
  00098	57		 push	 edi
  00099	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 25   : 	if (len <=0)

  0009c	83 7d 0c 00	 cmp	 DWORD PTR _len$[ebp], 0
  000a0	7f 02		 jg	 SHORT $LN4@XorBuffer

; 26   : 	{
; 27   : 		return;

  000a2	eb 33		 jmp	 SHORT $LN5@XorBuffer
$LN4@XorBuffer:

; 28   : 	}
; 29   : 
; 30   : 	for(int iCounter=0;iCounter<len;iCounter++)

  000a4	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iCounter$204408[ebp], 0
  000ab	eb 09		 jmp	 SHORT $LN3@XorBuffer
$LN2@XorBuffer:
  000ad	8b 45 f8	 mov	 eax, DWORD PTR _iCounter$204408[ebp]
  000b0	83 c0 01	 add	 eax, 1
  000b3	89 45 f8	 mov	 DWORD PTR _iCounter$204408[ebp], eax
$LN3@XorBuffer:
  000b6	8b 45 f8	 mov	 eax, DWORD PTR _iCounter$204408[ebp]
  000b9	3b 45 0c	 cmp	 eax, DWORD PTR _len$[ebp]
  000bc	7d 19		 jge	 SHORT $LN5@XorBuffer

; 31   : 	{
; 32   : 		buff[iCounter] = buff[iCounter]^0xCA;

  000be	8b 45 08	 mov	 eax, DWORD PTR _buff$[ebp]
  000c1	03 45 f8	 add	 eax, DWORD PTR _iCounter$204408[ebp]
  000c4	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000c7	81 f1 ca 00 00
	00		 xor	 ecx, 202		; 000000caH
  000cd	8b 55 08	 mov	 edx, DWORD PTR _buff$[ebp]
  000d0	03 55 f8	 add	 edx, DWORD PTR _iCounter$204408[ebp]
  000d3	88 0a		 mov	 BYTE PTR [edx], cl

; 33   : 	}

  000d5	eb d6		 jmp	 SHORT $LN2@XorBuffer
$LN5@XorBuffer:

; 34   : }

  000d7	5f		 pop	 edi
  000d8	5e		 pop	 esi
  000d9	5b		 pop	 ebx
  000da	8b e5		 mov	 esp, ebp
  000dc	5d		 pop	 ebp
  000dd	c2 08 00	 ret	 8
?XorBuffer@CMsg@@AAEXPADH@Z ENDP			; CMsg::XorBuffer
_TEXT	ENDS
PUBLIC	?lMsgListAdd@CMsg@@AAEHHPAE@Z			; CMsg::lMsgListAdd
PUBLIC	??_C@_0CB@JGNNNKFK@?$MA?P?$LE?B?A?$NP?5?$LF?$KF?$MA?L?E?M?$MA?G?$LA?$LD?$LM?v?5?$LP?$KB?$LH?$KP?5?$MA?T?$LE?O?$LE?Y?4@ ; `string'
PUBLIC	??_C@_05NAOIJFC@Error?$AA@			; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?DataFileLoadVer01@CMsg@@AAEXPAU_iobuf@@@Z	; CMsg::DataFileLoadVer01
EXTRN	_fread:PROC
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_0CB@JGNNNKFK@?$MA?P?$LE?B?A?$NP?5?$LF?$KF?$MA?L?E?M?$MA?G?$LA?$LD?$LM?v?5?$LP?$KB?$LH?$KP?5?$MA?T?$LE?O?$LE?Y?4@
CONST	SEGMENT
??_C@_0CB@JGNNNKFK@?$MA?P?$LE?B?A?$NP?5?$LF?$KF?$MA?L?E?M?$MA?G?$LA?$LD?$LM?v?5?$LP?$KB?$LH?$KP?5?$MA?T?$LE?O?$LE?Y?4@ DB 0c0H
	DB	0d0H, 0b4H, 0c2H, 0c1H, 0dfH, ' ', 0b5H, 0a5H, 0c0H, 0ccH, 0c5H
	DB	0cdH, 0c0H, 0c7H, 0b0H, 0b3H, 0bcH, 0f6H, ' ', 0bfH, 0a1H, 0b7H
	DB	0afH, ' ', 0c0H, 0d4H, 0b4H, 0cfH, 0b4H, 0d9H, '.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05NAOIJFC@Error?$AA@
CONST	SEGMENT
??_C@_05NAOIJFC@Error?$AA@ DB 'Error', 00H		; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_Max$ = -276						; size = 4
_Len$ = -272						; size = 2
_Index$ = -268						; size = 2
_szTemp$ = -264						; size = 256
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
?DataFileLoadVer01@CMsg@@AAEXPAU_iobuf@@@Z PROC		; CMsg::DataFileLoadVer01
; _this$ = ecx

; 37   : {

  000e0	55		 push	 ebp
  000e1	8b ec		 mov	 ebp, esp
  000e3	81 ec 54 01 00
	00		 sub	 esp, 340		; 00000154H
  000e9	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  000ee	33 c5		 xor	 eax, ebp
  000f0	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  000f3	53		 push	 ebx
  000f4	56		 push	 esi
  000f5	57		 push	 edi
  000f6	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 38   : 	unsigned char szTemp[256];
; 39   : 	short Index;
; 40   : 	unsigned short Len;
; 41   : 
; 42   : 	int Max=this->LoadHeader.count;

  000f9	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000fc	8b 88 20 00 02
	00		 mov	 ecx, DWORD PTR [eax+131104]
  00102	89 8d ec fe ff
	ff		 mov	 DWORD PTR _Max$[ebp], ecx

; 43   : 
; 44   : 	if (Max <= 0)

  00108	83 bd ec fe ff
	ff 00		 cmp	 DWORD PTR _Max$[ebp], 0
  0010f	7f 19		 jg	 SHORT $LN2@DataFileLo

; 45   : 	{
; 46   : 		MessageBox(NULL, "읽는중 데이터의개수 에러 입니다."	, "Error", MB_OK|MB_APPLMODAL); // Modification error data while reading

  00111	6a 00		 push	 0
  00113	68 00 00 00 00	 push	 OFFSET ??_C@_05NAOIJFC@Error?$AA@
  00118	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@JGNNNKFK@?$MA?P?$LE?B?A?$NP?5?$LF?$KF?$MA?L?E?M?$MA?G?$LA?$LD?$LM?v?5?$LP?$KB?$LH?$KP?5?$MA?T?$LE?O?$LE?Y?4@
  0011d	6a 00		 push	 0
  0011f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 47   : 		return;

  00125	e9 c0 00 00 00	 jmp	 $LN4@DataFileLo
$LN2@DataFileLo:

; 48   : 	}
; 49   : 
; 50   : 	while ( Max-- )

  0012a	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _Max$[ebp]
  00130	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _Max$[ebp]
  00136	83 e9 01	 sub	 ecx, 1
  00139	89 8d ec fe ff
	ff		 mov	 DWORD PTR _Max$[ebp], ecx
  0013f	85 c0		 test	 eax, eax
  00141	0f 84 a3 00 00
	00		 je	 $LN4@DataFileLo

; 51   : 	{
; 52   : 		memset(&szTemp, 0, sizeof(szTemp) );

  00147	68 00 01 00 00	 push	 256			; 00000100H
  0014c	6a 00		 push	 0
  0014e	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  00154	50		 push	 eax
  00155	e8 00 00 00 00	 call	 _memset
  0015a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 53   : 
; 54   : 		fread(&Index , 2, 1, filename);

  0015d	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00160	50		 push	 eax
  00161	6a 01		 push	 1
  00163	6a 02		 push	 2
  00165	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _Index$[ebp]
  0016b	51		 push	 ecx
  0016c	e8 00 00 00 00	 call	 _fread
  00171	83 c4 10	 add	 esp, 16			; 00000010H

; 55   : 		fread(&Len , 2, 1, filename);

  00174	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00177	50		 push	 eax
  00178	6a 01		 push	 1
  0017a	6a 02		 push	 2
  0017c	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _Len$[ebp]
  00182	51		 push	 ecx
  00183	e8 00 00 00 00	 call	 _fread
  00188	83 c4 10	 add	 esp, 16			; 00000010H

; 56   : 		fread(szTemp , Len , 1, filename);

  0018b	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0018e	50		 push	 eax
  0018f	6a 01		 push	 1
  00191	0f b7 8d f0 fe
	ff ff		 movzx	 ecx, WORD PTR _Len$[ebp]
  00198	51		 push	 ecx
  00199	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _szTemp$[ebp]
  0019f	52		 push	 edx
  001a0	e8 00 00 00 00	 call	 _fread
  001a5	83 c4 10	 add	 esp, 16			; 00000010H

; 57   : 		szTemp[Len]=0;

  001a8	0f b7 85 f0 fe
	ff ff		 movzx	 eax, WORD PTR _Len$[ebp]
  001af	c6 84 05 f8 fe
	ff ff 00	 mov	 BYTE PTR _szTemp$[ebp+eax], 0

; 58   : 
; 59   : 		this->XorBuffer((char*)szTemp , Len );

  001b7	0f b7 85 f0 fe
	ff ff		 movzx	 eax, WORD PTR _Len$[ebp]
  001be	50		 push	 eax
  001bf	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _szTemp$[ebp]
  001c5	51		 push	 ecx
  001c6	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001c9	e8 00 00 00 00	 call	 ?XorBuffer@CMsg@@AAEXPADH@Z ; CMsg::XorBuffer

; 60   : 		this->lMsgListAdd( Index, (unsigned char*) szTemp);

  001ce	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  001d4	50		 push	 eax
  001d5	0f bf 8d f4 fe
	ff ff		 movsx	 ecx, WORD PTR _Index$[ebp]
  001dc	51		 push	 ecx
  001dd	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001e0	e8 00 00 00 00	 call	 ?lMsgListAdd@CMsg@@AAEHHPAE@Z ; CMsg::lMsgListAdd

; 61   : 	} 

  001e5	e9 40 ff ff ff	 jmp	 $LN2@DataFileLo
$LN4@DataFileLo:

; 62   : }

  001ea	5f		 pop	 edi
  001eb	5e		 pop	 esi
  001ec	5b		 pop	 ebx
  001ed	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001f0	33 cd		 xor	 ecx, ebp
  001f2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001f7	8b e5		 mov	 esp, ebp
  001f9	5d		 pop	 ebp
  001fa	c2 04 00	 ret	 4
?DataFileLoadVer01@CMsg@@AAEXPAU_iobuf@@@Z ENDP		; CMsg::DataFileLoadVer01
_TEXT	ENDS
PUBLIC	??_C@_0CC@ILABMKML@?A?v?$LP?x?G?O?A?v?5?$LO?J?$LE?B?5?$LJ?v?A?$KP?5?$LF?$KF?$MA?L?E?M?5?$MA?T?$LE?O?$LE?Y@ ; `string'
PUBLIC	??_C@_0BF@OLFGABCH@TextCode?5Type?5Wrong?4?$AA@	; `string'
PUBLIC	?lMsgListInit@CMsg@@AAEHXZ			; CMsg::lMsgListInit
PUBLIC	??_C@_0BD@LBFAGOFH@Could?5not?5open?5?$CFs?4?$AA@ ; `string'
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?LoadWTF@CMsg@@QAEXPAD@Z			; CMsg::LoadWTF
EXTRN	_fclose:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	_fopen:PROC
;	COMDAT ??_C@_0CC@ILABMKML@?A?v?$LP?x?G?O?A?v?5?$LO?J?$LE?B?5?$LJ?v?A?$KP?5?$LF?$KF?$MA?L?E?M?5?$MA?T?$LE?O?$LE?Y@
CONST	SEGMENT
??_C@_0CC@ILABMKML@?A?v?$LP?x?G?O?A?v?5?$LO?J?$LE?B?5?$LJ?v?A?$KP?5?$LF?$KF?$MA?L?E?M?5?$MA?T?$LE?O?$LE?Y@ DB 0c1H
	DB	0f6H, 0bfH, 0f8H, 0c7H, 0cfH, 0c1H, 0f6H, ' ', 0beH, 0caH, 0b4H
	DB	0c2H, ' ', 0b9H, 0f6H, 0c1H, 0afH, ' ', 0b5H, 0a5H, 0c0H, 0ccH
	DB	0c5H, 0cdH, ' ', 0c0H, 0d4H, 0b4H, 0cfH, 0b4H, 0d9H, '.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@OLFGABCH@TextCode?5Type?5Wrong?4?$AA@
CONST	SEGMENT
??_C@_0BF@OLFGABCH@TextCode?5Type?5Wrong?4?$AA@ DB 'TextCode Type Wrong.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LBFAGOFH@Could?5not?5open?5?$CFs?4?$AA@
CONST	SEGMENT
??_C@_0BD@LBFAGOFH@Could?5not?5open?5?$CFs?4?$AA@ DB 'Could not open %s.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_szBufferError$ = -140					; size = 128
_WTFFile$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
?LoadWTF@CMsg@@QAEXPAD@Z PROC				; CMsg::LoadWTF
; _this$ = ecx

; 65   : {

  00200	55		 push	 ebp
  00201	8b ec		 mov	 ebp, esp
  00203	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00209	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0020e	33 c5		 xor	 eax, ebp
  00210	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00213	53		 push	 ebx
  00214	56		 push	 esi
  00215	57		 push	 edi
  00216	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 66   : 	FILE* WTFFile;
; 67   : 	char szBufferError[128];
; 68   : 	
; 69   : 	WTFFile =fopen(filename, "rb");	//ok

  00219	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb?$AA@
  0021e	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00221	50		 push	 eax
  00222	e8 00 00 00 00	 call	 _fopen
  00227	83 c4 08	 add	 esp, 8
  0022a	89 45 f4	 mov	 DWORD PTR _WTFFile$[ebp], eax

; 70   : 	
; 71   : 	if (WTFFile == 0 )

  0022d	83 7d f4 00	 cmp	 DWORD PTR _WTFFile$[ebp], 0
  00231	75 34		 jne	 SHORT $LN6@LoadWTF

; 72   : 	{
; 73   : 		wsprintf(szBufferError, "Could not open %s.", filename);	

  00233	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00236	50		 push	 eax
  00237	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@LBFAGOFH@Could?5not?5open?5?$CFs?4?$AA@
  0023c	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _szBufferError$[ebp]
  00242	51		 push	 ecx
  00243	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00249	83 c4 0c	 add	 esp, 12			; 0000000cH

; 74   : 		MessageBox(NULL, szBufferError, "Error", MB_OK|MB_APPLMODAL);

  0024c	6a 00		 push	 0
  0024e	68 00 00 00 00	 push	 OFFSET ??_C@_05NAOIJFC@Error?$AA@
  00253	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _szBufferError$[ebp]
  00259	50		 push	 eax
  0025a	6a 00		 push	 0
  0025c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 75   : 		return;

  00262	e9 8b 00 00 00	 jmp	 $LN7@LoadWTF
$LN6@LoadWTF:

; 76   : 	}
; 77   : 
; 78   : 	if (this->lMsgListInit() != 0)

  00267	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0026a	e8 00 00 00 00	 call	 ?lMsgListInit@CMsg@@AAEHXZ ; CMsg::lMsgListInit
  0026f	85 c0		 test	 eax, eax
  00271	74 7f		 je	 SHORT $LN7@LoadWTF

; 79   : 	{
; 80   : 		fread(&this->LoadHeader, 28, 1, WTFFile);

  00273	8b 45 f4	 mov	 eax, DWORD PTR _WTFFile$[ebp]
  00276	50		 push	 eax
  00277	6a 01		 push	 1
  00279	6a 1c		 push	 28			; 0000001cH
  0027b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0027e	81 c1 08 00 02
	00		 add	 ecx, 131080		; 00020008H
  00284	51		 push	 ecx
  00285	e8 00 00 00 00	 call	 _fread
  0028a	83 c4 10	 add	 esp, 16			; 00000010H

; 81   : 
; 82   : 		if (this->LoadHeader.headcode != 0xCC)

  0028d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00290	0f b6 88 08 00
	02 00		 movzx	 ecx, BYTE PTR [eax+131080]
  00297	81 f9 cc 00 00
	00		 cmp	 ecx, 204		; 000000ccH
  0029d	74 16		 je	 SHORT $LN4@LoadWTF

; 83   : 		{
; 84   : 			MessageBox(NULL, "TextCode Type Wrong.", "Error", MB_OK|MB_APPLMODAL);

  0029f	6a 00		 push	 0
  002a1	68 00 00 00 00	 push	 OFFSET ??_C@_05NAOIJFC@Error?$AA@
  002a6	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@OLFGABCH@TextCode?5Type?5Wrong?4?$AA@
  002ab	6a 00		 push	 0
  002ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
  002b3	eb 31		 jmp	 SHORT $LN3@LoadWTF
$LN4@LoadWTF:

; 85   : 		}
; 86   : 		else if ( (this->LoadHeader.version -1) != 0)

  002b5	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  002b8	0f b6 88 09 00
	02 00		 movzx	 ecx, BYTE PTR [eax+131081]
  002bf	83 e9 01	 sub	 ecx, 1
  002c2	74 16		 je	 SHORT $LN2@LoadWTF

; 87   : 		{
; 88   : 			MessageBox(NULL, "지원하지 않는 버젼 데이터 입니다.", "Error", MB_OK|MB_APPLMODAL);

  002c4	6a 00		 push	 0
  002c6	68 00 00 00 00	 push	 OFFSET ??_C@_05NAOIJFC@Error?$AA@
  002cb	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@ILABMKML@?A?v?$LP?x?G?O?A?v?5?$LO?J?$LE?B?5?$LJ?v?A?$KP?5?$LF?$KF?$MA?L?E?M?5?$MA?T?$LE?O?$LE?Y@
  002d0	6a 00		 push	 0
  002d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 89   : 		}
; 90   : 		else

  002d8	eb 0c		 jmp	 SHORT $LN3@LoadWTF
$LN2@LoadWTF:

; 91   : 		{
; 92   : 			DataFileLoadVer01(WTFFile);

  002da	8b 45 f4	 mov	 eax, DWORD PTR _WTFFile$[ebp]
  002dd	50		 push	 eax
  002de	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  002e1	e8 00 00 00 00	 call	 ?DataFileLoadVer01@CMsg@@AAEXPAU_iobuf@@@Z ; CMsg::DataFileLoadVer01
$LN3@LoadWTF:

; 93   : 		}
; 94   : 		fclose(WTFFile);

  002e6	8b 45 f4	 mov	 eax, DWORD PTR _WTFFile$[ebp]
  002e9	50		 push	 eax
  002ea	e8 00 00 00 00	 call	 _fclose
  002ef	83 c4 04	 add	 esp, 4
$LN7@LoadWTF:

; 95   : 	}
; 96   : }

  002f2	5f		 pop	 edi
  002f3	5e		 pop	 esi
  002f4	5b		 pop	 ebx
  002f5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002f8	33 cd		 xor	 ecx, ebp
  002fa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002ff	8b e5		 mov	 esp, ebp
  00301	5d		 pop	 ebp
  00302	c2 04 00	 ret	 4
?LoadWTF@CMsg@@QAEXPAD@Z ENDP				; CMsg::LoadWTF
_TEXT	ENDS
PUBLIC	??_C@_0CA@OBAGPFFE@Memory?5Allocation?5Error?5?$CIMuMsg?$CJ?$AA@ ; `string'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT ??_C@_0CA@OBAGPFFE@Memory?5Allocation?5Error?5?$CIMuMsg?$CJ?$AA@
CONST	SEGMENT
??_C@_0CA@OBAGPFFE@Memory?5Allocation?5Error?5?$CIMuMsg?$CJ?$AA@ DB 'Memo'
	DB	'ry Allocation Error (MuMsg)', 00H		; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
$T204537 = -76						; size = 4
_msg$ = -8						; size = 4
_this$ = -4						; size = 4
?lMsgListInit@CMsg@@AAEHXZ PROC				; CMsg::lMsgListInit
; _this$ = ecx

; 99   : {

  00310	55		 push	 ebp
  00311	8b ec		 mov	 ebp, esp
  00313	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00316	53		 push	 ebx
  00317	56		 push	 esi
  00318	57		 push	 edi
  00319	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 100  : 	LPMSG_STRUCT msg = new MSG_STRUCT;

  0031c	6a 0c		 push	 12			; 0000000cH
  0031e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00323	83 c4 04	 add	 esp, 4
  00326	89 45 b4	 mov	 DWORD PTR $T204537[ebp], eax
  00329	8b 45 b4	 mov	 eax, DWORD PTR $T204537[ebp]
  0032c	89 45 f8	 mov	 DWORD PTR _msg$[ebp], eax

; 101  : 
; 102  : 	if ( msg == NULL )

  0032f	83 7d f8 00	 cmp	 DWORD PTR _msg$[ebp], 0
  00333	75 18		 jne	 SHORT $LN1@lMsgListIn

; 103  : 	{
; 104  : 		MessageBox(NULL, "Memory Allocation Error (MuMsg)", "Error", MB_OK);

  00335	6a 00		 push	 0
  00337	68 00 00 00 00	 push	 OFFSET ??_C@_05NAOIJFC@Error?$AA@
  0033c	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@OBAGPFFE@Memory?5Allocation?5Error?5?$CIMuMsg?$CJ?$AA@
  00341	6a 00		 push	 0
  00343	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 105  : 		return 0;

  00349	33 c0		 xor	 eax, eax
  0034b	eb 38		 jmp	 SHORT $LN2@lMsgListIn
$LN1@lMsgListIn:

; 106  : 	}
; 107  : 	msg->next  =NULL;

  0034d	8b 45 f8	 mov	 eax, DWORD PTR _msg$[ebp]
  00350	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 108  : 	msg->number  =0;

  00356	8b 45 f8	 mov	 eax, DWORD PTR _msg$[ebp]
  00359	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 109  : 	msg->msg = NULL;

  00360	8b 45 f8	 mov	 eax, DWORD PTR _msg$[ebp]
  00363	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 110  : 	memset(this->MsgIndex, 0, sizeof(this->MsgIndex));

  0036a	68 00 00 02 00	 push	 131072			; 00020000H
  0036f	6a 00		 push	 0
  00371	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00374	83 c0 08	 add	 eax, 8
  00377	50		 push	 eax
  00378	e8 00 00 00 00	 call	 _memset
  0037d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 111  : 	return 1;

  00380	b8 01 00 00 00	 mov	 eax, 1
$LN2@lMsgListIn:

; 112  : }

  00385	5f		 pop	 edi
  00386	5e		 pop	 esi
  00387	5b		 pop	 ebx
  00388	8b e5		 mov	 esp, ebp
  0038a	5d		 pop	 ebp
  0038b	c3		 ret	 0
?lMsgListInit@CMsg@@AAEHXZ ENDP				; CMsg::lMsgListInit
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
$T204539 = -80						; size = 4
$T204540 = -76						; size = 4
_n$204455 = -8						; size = 4
_this$ = -4						; size = 4
?lMsgFree@CMsg@@AAEXXZ PROC				; CMsg::lMsgFree
; _this$ = ecx

; 115  : {

  00390	55		 push	 ebp
  00391	8b ec		 mov	 ebp, esp
  00393	83 ec 50	 sub	 esp, 80			; 00000050H
  00396	53		 push	 ebx
  00397	56		 push	 esi
  00398	57		 push	 edi
  00399	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 116  : 	for ( int n = 0; n < 32768; n++ )

  0039c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$204455[ebp], 0
  003a3	eb 09		 jmp	 SHORT $LN4@lMsgFree
$LN3@lMsgFree:
  003a5	8b 45 f8	 mov	 eax, DWORD PTR _n$204455[ebp]
  003a8	83 c0 01	 add	 eax, 1
  003ab	89 45 f8	 mov	 DWORD PTR _n$204455[ebp], eax
$LN4@lMsgFree:
  003ae	81 7d f8 00 80
	00 00		 cmp	 DWORD PTR _n$204455[ebp], 32768 ; 00008000H
  003b5	7d 44		 jge	 SHORT $LN5@lMsgFree

; 117  : 	{
; 118  : 		if ( this->MsgIndex[n] != 0 )

  003b7	8b 45 f8	 mov	 eax, DWORD PTR _n$204455[ebp]
  003ba	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003bd	83 7c 81 08 00	 cmp	 DWORD PTR [ecx+eax*4+8], 0
  003c2	74 35		 je	 SHORT $LN1@lMsgFree

; 119  : 		{
; 120  : 			delete [] this->MsgIndex[n]->msg ;

  003c4	8b 45 f8	 mov	 eax, DWORD PTR _n$204455[ebp]
  003c7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003ca	8b 54 81 08	 mov	 edx, DWORD PTR [ecx+eax*4+8]
  003ce	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  003d1	89 45 b0	 mov	 DWORD PTR $T204539[ebp], eax
  003d4	8b 4d b0	 mov	 ecx, DWORD PTR $T204539[ebp]
  003d7	51		 push	 ecx
  003d8	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  003dd	83 c4 04	 add	 esp, 4

; 121  : 			delete this->MsgIndex[n];

  003e0	8b 45 f8	 mov	 eax, DWORD PTR _n$204455[ebp]
  003e3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003e6	8b 54 81 08	 mov	 edx, DWORD PTR [ecx+eax*4+8]
  003ea	89 55 b4	 mov	 DWORD PTR $T204540[ebp], edx
  003ed	8b 45 b4	 mov	 eax, DWORD PTR $T204540[ebp]
  003f0	50		 push	 eax
  003f1	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  003f6	83 c4 04	 add	 esp, 4
$LN1@lMsgFree:

; 122  : 		}
; 123  : 	}

  003f9	eb aa		 jmp	 SHORT $LN3@lMsgFree
$LN5@lMsgFree:

; 124  : }

  003fb	5f		 pop	 edi
  003fc	5e		 pop	 esi
  003fd	5b		 pop	 ebx
  003fe	8b e5		 mov	 esp, ebp
  00400	5d		 pop	 ebp
  00401	c3		 ret	 0
?lMsgFree@CMsg@@AAEXXZ ENDP				; CMsg::lMsgFree
_TEXT	ENDS
PUBLIC	?lMsgListNew@CMsg@@AAEPAUMSG_STRUCT@@XZ		; CMsg::lMsgListNew
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
$T204542 = -72						; size = 4
_this$ = -4						; size = 4
?lMsgListNew@CMsg@@AAEPAUMSG_STRUCT@@XZ PROC		; CMsg::lMsgListNew
; _this$ = ecx

; 127  : {

  00410	55		 push	 ebp
  00411	8b ec		 mov	 ebp, esp
  00413	83 ec 48	 sub	 esp, 72			; 00000048H
  00416	53		 push	 ebx
  00417	56		 push	 esi
  00418	57		 push	 edi
  00419	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 128  : 	return new MSG_STRUCT;

  0041c	6a 0c		 push	 12			; 0000000cH
  0041e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00423	83 c4 04	 add	 esp, 4
  00426	89 45 b8	 mov	 DWORD PTR $T204542[ebp], eax
  00429	8b 45 b8	 mov	 eax, DWORD PTR $T204542[ebp]

; 129  : }

  0042c	5f		 pop	 edi
  0042d	5e		 pop	 esi
  0042e	5b		 pop	 ebx
  0042f	8b e5		 mov	 esp, ebp
  00431	5d		 pop	 ebp
  00432	c3		 ret	 0
?lMsgListNew@CMsg@@AAEPAUMSG_STRUCT@@XZ ENDP		; CMsg::lMsgListNew
_TEXT	ENDS
PUBLIC	??_C@_0BP@CIHPAEKD@Message?5Index?5Table?5Make?5Error?$AA@ ; `string'
PUBLIC	??_C@_0CC@PKJPBHBB@Memory?5Allocation?5Error?5?$CD2?$CIMuMsg@ ; `string'
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	_strlen:PROC
;	COMDAT ??_C@_0BP@CIHPAEKD@Message?5Index?5Table?5Make?5Error?$AA@
CONST	SEGMENT
??_C@_0BP@CIHPAEKD@Message?5Index?5Table?5Make?5Error?$AA@ DB 'Message In'
	DB	'dex Table Make Error', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@PKJPBHBB@Memory?5Allocation?5Error?5?$CD2?$CIMuMsg@
CONST	SEGMENT
??_C@_0CC@PKJPBHBB@Memory?5Allocation?5Error?5?$CD2?$CIMuMsg@ DB 'Memory '
	DB	'Allocation Error #2(MuMsg)', 00H		; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
$T204544 = -80						; size = 4
_pPointer$ = -12					; size = 4
_MsgLen$ = -8						; size = 4
_this$ = -4						; size = 4
_index$ = 8						; size = 4
_smsg$ = 12						; size = 4
?lMsgListAdd@CMsg@@AAEHHPAE@Z PROC			; CMsg::lMsgListAdd
; _this$ = ecx

; 132  : {

  00440	55		 push	 ebp
  00441	8b ec		 mov	 ebp, esp
  00443	83 ec 50	 sub	 esp, 80			; 00000050H
  00446	53		 push	 ebx
  00447	56		 push	 esi
  00448	57		 push	 edi
  00449	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 133  : 	int MsgLen=strlen((char*)smsg);

  0044c	8b 45 0c	 mov	 eax, DWORD PTR _smsg$[ebp]
  0044f	50		 push	 eax
  00450	e8 00 00 00 00	 call	 _strlen
  00455	83 c4 04	 add	 esp, 4
  00458	89 45 f8	 mov	 DWORD PTR _MsgLen$[ebp], eax

; 134  : 	char* pPointer;
; 135  : 	
; 136  : 	if ( MsgLen > 0 )

  0045b	83 7d f8 00	 cmp	 DWORD PTR _MsgLen$[ebp], 0
  0045f	0f 8e c2 00 00
	00		 jle	 $LN6@lMsgListAd

; 137  : 	{
; 138  : 		this->MsgIndex[index]=this->lMsgListNew();

  00465	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00468	e8 00 00 00 00	 call	 ?lMsgListNew@CMsg@@AAEPAUMSG_STRUCT@@XZ ; CMsg::lMsgListNew
  0046d	8b 4d 08	 mov	 ecx, DWORD PTR _index$[ebp]
  00470	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00473	89 44 8a 08	 mov	 DWORD PTR [edx+ecx*4+8], eax

; 139  : 	
; 140  : 		if (this->MsgIndex[index] == 0)

  00477	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  0047a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0047d	83 7c 81 08 00	 cmp	 DWORD PTR [ecx+eax*4+8], 0
  00482	75 1b		 jne	 SHORT $LN5@lMsgListAd

; 141  : 		{
; 142  : 			MessageBox(NULL, "Memory Allocation Error #2(MuMsg)", "Error", MB_OK);

  00484	6a 00		 push	 0
  00486	68 00 00 00 00	 push	 OFFSET ??_C@_05NAOIJFC@Error?$AA@
  0048b	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@PKJPBHBB@Memory?5Allocation?5Error?5?$CD2?$CIMuMsg@
  00490	6a 00		 push	 0
  00492	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 143  : 			return 0;

  00498	33 c0		 xor	 eax, eax
  0049a	e9 8d 00 00 00	 jmp	 $LN7@lMsgListAd
$LN5@lMsgListAd:

; 144  : 		}
; 145  : 
; 146  : 		pPointer = new char[MsgLen+1];

  0049f	8b 45 f8	 mov	 eax, DWORD PTR _MsgLen$[ebp]
  004a2	83 c0 01	 add	 eax, 1
  004a5	50		 push	 eax
  004a6	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  004ab	83 c4 04	 add	 esp, 4
  004ae	89 45 b0	 mov	 DWORD PTR $T204544[ebp], eax
  004b1	8b 4d b0	 mov	 ecx, DWORD PTR $T204544[ebp]
  004b4	89 4d f4	 mov	 DWORD PTR _pPointer$[ebp], ecx

; 147  : 		
; 148  : 		if ( pPointer  != 0 )

  004b7	83 7d f4 00	 cmp	 DWORD PTR _pPointer$[ebp], 0
  004bb	74 6a		 je	 SHORT $LN6@lMsgListAd

; 149  : 		{
; 150  : 			this->MsgIndex[index]->number=index;

  004bd	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  004c0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  004c3	8b 54 81 08	 mov	 edx, DWORD PTR [ecx+eax*4+8]
  004c7	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  004ca	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 151  : 		
; 152  : 			
; 153  : 			if ( index >= 0 || index < 32767 )

  004cd	83 7d 08 00	 cmp	 DWORD PTR _index$[ebp], 0
  004d1	7d 09		 jge	 SHORT $LN2@lMsgListAd
  004d3	81 7d 08 ff 7f
	00 00		 cmp	 DWORD PTR _index$[ebp], 32767 ; 00007fffH
  004da	7d 33		 jge	 SHORT $LN3@lMsgListAd
$LN2@lMsgListAd:

; 154  : 			{
; 155  : 				this->MsgIndex[index]->msg = (unsigned char*)pPointer;

  004dc	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  004df	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  004e2	8b 54 81 08	 mov	 edx, DWORD PTR [ecx+eax*4+8]
  004e6	8b 45 f4	 mov	 eax, DWORD PTR _pPointer$[ebp]
  004e9	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 156  : 				strcpy((char*)this->MsgIndex[index]->msg , (char*)smsg);

  004ec	8b 45 0c	 mov	 eax, DWORD PTR _smsg$[ebp]
  004ef	50		 push	 eax
  004f0	8b 4d 08	 mov	 ecx, DWORD PTR _index$[ebp]
  004f3	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  004f6	8b 44 8a 08	 mov	 eax, DWORD PTR [edx+ecx*4+8]
  004fa	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  004fd	51		 push	 ecx
  004fe	e8 00 00 00 00	 call	 _strcpy
  00503	83 c4 08	 add	 esp, 8

; 157  : 				return 1;

  00506	b8 01 00 00 00	 mov	 eax, 1
  0050b	eb 1f		 jmp	 SHORT $LN7@lMsgListAd

; 158  : 			}
; 159  : 			else

  0050d	eb 18		 jmp	 SHORT $LN6@lMsgListAd
$LN3@lMsgListAd:

; 160  : 			{
; 161  : 				MessageBox(NULL, "Message Index Table Make Error", "Error", MB_OK);

  0050f	6a 00		 push	 0
  00511	68 00 00 00 00	 push	 OFFSET ??_C@_05NAOIJFC@Error?$AA@
  00516	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@CIHPAEKD@Message?5Index?5Table?5Make?5Error?$AA@
  0051b	6a 00		 push	 0
  0051d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 162  : 				return 0;

  00523	33 c0		 xor	 eax, eax
  00525	eb 05		 jmp	 SHORT $LN7@lMsgListAd
$LN6@lMsgListAd:

; 163  : 			}
; 164  : 
; 165  : 		}
; 166  : 	}
; 167  : 
; 168  : 
; 169  : 	return 1;

  00527	b8 01 00 00 00	 mov	 eax, 1
$LN7@lMsgListAd:

; 170  : }

  0052c	5f		 pop	 edi
  0052d	5e		 pop	 esi
  0052e	5b		 pop	 ebx
  0052f	8b e5		 mov	 esp, ebp
  00531	5d		 pop	 ebp
  00532	c2 08 00	 ret	 8
?lMsgListAdd@CMsg@@AAEHHPAE@Z ENDP			; CMsg::lMsgListAdd
_TEXT	ENDS
PUBLIC	??_C@_07BEIHKDLJ@Message?$AA@			; `string'
PUBLIC	?lMsgListPrint@CMsg@@AAEXXZ			; CMsg::lMsgListPrint
;	COMDAT ??_C@_07BEIHKDLJ@Message?$AA@
CONST	SEGMENT
??_C@_07BEIHKDLJ@Message?$AA@ DB 'Message', 00H		; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_n$204491 = -8						; size = 4
_this$ = -4						; size = 4
?lMsgListPrint@CMsg@@AAEXXZ PROC			; CMsg::lMsgListPrint
; _this$ = ecx

; 173  : {

  00540	55		 push	 ebp
  00541	8b ec		 mov	 ebp, esp
  00543	83 ec 48	 sub	 esp, 72			; 00000048H
  00546	53		 push	 ebx
  00547	56		 push	 esi
  00548	57		 push	 edi
  00549	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 174  : 	for ( int n = 0; n<32768 ; n++)

  0054c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$204491[ebp], 0
  00553	eb 09		 jmp	 SHORT $LN4@lMsgListPr
$LN3@lMsgListPr:
  00555	8b 45 f8	 mov	 eax, DWORD PTR _n$204491[ebp]
  00558	83 c0 01	 add	 eax, 1
  0055b	89 45 f8	 mov	 DWORD PTR _n$204491[ebp], eax
$LN4@lMsgListPr:
  0055e	81 7d f8 00 80
	00 00		 cmp	 DWORD PTR _n$204491[ebp], 32768 ; 00008000H
  00565	7d 2c		 jge	 SHORT $LN5@lMsgListPr

; 175  : 	{
; 176  : 		if ( this->MsgIndex[n] != 0 )

  00567	8b 45 f8	 mov	 eax, DWORD PTR _n$204491[ebp]
  0056a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0056d	83 7c 81 08 00	 cmp	 DWORD PTR [ecx+eax*4+8], 0
  00572	74 1d		 je	 SHORT $LN1@lMsgListPr

; 177  : 		{
; 178  : 			MessageBox(NULL, (char*)this->MsgIndex[n]->msg, "Message", MB_OK);

  00574	6a 00		 push	 0
  00576	68 00 00 00 00	 push	 OFFSET ??_C@_07BEIHKDLJ@Message?$AA@
  0057b	8b 45 f8	 mov	 eax, DWORD PTR _n$204491[ebp]
  0057e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00581	8b 54 81 08	 mov	 edx, DWORD PTR [ecx+eax*4+8]
  00585	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00588	50		 push	 eax
  00589	6a 00		 push	 0
  0058b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
$LN1@lMsgListPr:

; 179  : 		}
; 180  : 	}

  00591	eb c2		 jmp	 SHORT $LN3@lMsgListPr
$LN5@lMsgListPr:

; 181  : }

  00593	5f		 pop	 edi
  00594	5e		 pop	 esi
  00595	5b		 pop	 ebx
  00596	8b e5		 mov	 esp, ebp
  00598	5d		 pop	 ebp
  00599	c3		 ret	 0
?lMsgListPrint@CMsg@@AAEXXZ ENDP			; CMsg::lMsgListPrint
_TEXT	ENDS
PUBLIC	?Get@CMsg@@QAEPADH@Z				; CMsg::Get
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
?Get@CMsg@@QAEPADH@Z PROC				; CMsg::Get
; _this$ = ecx

; 184  : {

  005a0	55		 push	 ebp
  005a1	8b ec		 mov	 ebp, esp
  005a3	83 ec 44	 sub	 esp, 68			; 00000044H
  005a6	53		 push	 ebx
  005a7	56		 push	 esi
  005a8	57		 push	 edi
  005a9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 185  : 	if ( index >= 0 && index < 32768 )

  005ac	83 7d 08 00	 cmp	 DWORD PTR _index$[ebp], 0
  005b0	7c 67		 jl	 SHORT $LN4@Get
  005b2	81 7d 08 00 80
	00 00		 cmp	 DWORD PTR _index$[ebp], 32768 ; 00008000H
  005b9	7d 5e		 jge	 SHORT $LN4@Get

; 186  : 	{
; 187  : 		if ( this->MsgIndex[index] == 0 )

  005bb	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  005be	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  005c1	83 7c 81 08 00	 cmp	 DWORD PTR [ecx+eax*4+8], 0
  005c6	75 0a		 jne	 SHORT $LN3@Get

; 188  : 		{
; 189  : 			return this->szDefaultMsg;

  005c8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  005cb	05 24 00 02 00	 add	 eax, 131108		; 00020024H
  005d0	eb 4f		 jmp	 SHORT $LN5@Get
$LN3@Get:

; 190  : 		}
; 191  : 			
; 192  : 		if ( this->MsgIndex[index]->msg == 0 )

  005d2	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  005d5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  005d8	8b 54 81 08	 mov	 edx, DWORD PTR [ecx+eax*4+8]
  005dc	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  005e0	75 0a		 jne	 SHORT $LN2@Get

; 193  : 		{
; 194  : 			return this->szDefaultMsg;

  005e2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  005e5	05 24 00 02 00	 add	 eax, 131108		; 00020024H
  005ea	eb 35		 jmp	 SHORT $LN5@Get
$LN2@Get:

; 195  : 		}
; 196  : 
; 197  : 		if ( *this->MsgIndex[index]->msg == 0 )

  005ec	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  005ef	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  005f2	8b 54 81 08	 mov	 edx, DWORD PTR [ecx+eax*4+8]
  005f6	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  005f9	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  005fc	85 c9		 test	 ecx, ecx
  005fe	75 0a		 jne	 SHORT $LN1@Get

; 198  : 		{
; 199  : 			return this->szDefaultMsg;

  00600	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00603	05 24 00 02 00	 add	 eax, 131108		; 00020024H
  00608	eb 17		 jmp	 SHORT $LN5@Get
$LN1@Get:

; 200  : 		}
; 201  : 
; 202  : 		return (char*)this->MsgIndex[index]->msg;

  0060a	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  0060d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00610	8b 54 81 08	 mov	 edx, DWORD PTR [ecx+eax*4+8]
  00614	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00617	eb 08		 jmp	 SHORT $LN5@Get
$LN4@Get:

; 203  : 	}
; 204  : 	return (char*)this->szDefaultMsg;

  00619	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0061c	05 24 00 02 00	 add	 eax, 131108		; 00020024H
$LN5@Get:

; 205  : 		
; 206  : }

  00621	5f		 pop	 edi
  00622	5e		 pop	 esi
  00623	5b		 pop	 ebx
  00624	8b e5		 mov	 esp, ebp
  00626	5d		 pop	 ebp
  00627	c2 04 00	 ret	 4
?Get@CMsg@@QAEPADH@Z ENDP				; CMsg::Get
_TEXT	ENDS
END
