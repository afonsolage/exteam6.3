; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	D:\Projects\ExTeam6.3\Source\GameServer\GameServer\EventManagement.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Odtp /ZI
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@vector:
  00009	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000c	83 e8 01	 sub	 eax, 1
  0000f	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00012	78 11		 js	 SHORT $LN3@vector
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00017	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  0001d	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00020	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00023	eb e4		 jmp	 SHORT $LN2@vector
$LN3@vector:
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??1?$map@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@QAE@XZ ; std::map<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> > >::~map<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> > >
PUBLIC	??1?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE@XZ ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::~vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >
PUBLIC	?Clear@CEventManagement@@QAEXXZ			; CEventManagement::Clear
PUBLIC	??0?$map@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@QAE@XZ ; std::map<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> > >::map<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> > >
PUBLIC	??0?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE@XZ ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >
PUBLIC	??_7CEventManagement@@6B@			; CEventManagement::`vftable'
PUBLIC	??0CEventManagement@@QAE@XZ			; CEventManagement::CEventManagement
PUBLIC	??_R4CEventManagement@@6B@			; CEventManagement::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCEventManagement@@@8			; CEventManagement `RTTI Type Descriptor'
PUBLIC	??_R3CEventManagement@@8			; CEventManagement::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CEventManagement@@8			; CEventManagement::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CEventManagement@@8		; CEventManagement::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ECEventManagement@@UAEPAXI@Z:PROC		; CEventManagement::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CEventManagement@@8
; File d:\projects\exteam6.3\source\gameserver\gameserver\eventmanagement.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@CEventManagement@@8 DD FLAT:??_R0?AVCEventManagement@@@8 ; CEventManagement::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CEventManagement@@8
rdata$r	ENDS
;	COMDAT ??_R2CEventManagement@@8
rdata$r	SEGMENT
??_R2CEventManagement@@8 DD FLAT:??_R1A@?0A@EA@CEventManagement@@8 ; CEventManagement::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CEventManagement@@8
rdata$r	SEGMENT
??_R3CEventManagement@@8 DD 00H				; CEventManagement::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CEventManagement@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCEventManagement@@@8
_DATA	SEGMENT
??_R0?AVCEventManagement@@@8 DD FLAT:??_7type_info@@6B@	; CEventManagement `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCEventManagement@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CEventManagement@@6B@
rdata$r	SEGMENT
??_R4CEventManagement@@6B@ DD 00H			; CEventManagement::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCEventManagement@@@8
	DD	FLAT:??_R3CEventManagement@@8
rdata$r	ENDS
;	COMDAT ??_7CEventManagement@@6B@
CONST	SEGMENT
??_7CEventManagement@@6B@ DD FLAT:??_R4CEventManagement@@6B@ ; CEventManagement::`vftable'
	DD	FLAT:??_ECEventManagement@@UAEPAXI@Z
CONST	ENDS
xdata$x	SEGMENT
__unwindtable$??0CEventManagement@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CEventManagement@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CEventManagement@@QAE@XZ$1
__ehfuncinfo$??0CEventManagement@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0CEventManagement@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CEventManagement@@QAE@XZ PROC			; CEventManagement::CEventManagement
; _this$ = ecx

; 16   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CEventManagement@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CEventManagement@@6B@
  00034	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0003a	e8 00 00 00 00	 call	 ??0?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE@XZ ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >
  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00046	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0004c	e8 00 00 00 00	 call	 ??0?$map@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@QAE@XZ ; std::map<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> > >::map<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> > >
  00051	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 17   : 	this->m_bEventStart = false;

  00055	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00058	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 18   : 	this->m_bHasData = false;

  0005f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00062	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 19   : 	this->Clear();

  00069	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	e8 00 00 00 00	 call	 ?Clear@CEventManagement@@QAEXXZ ; CEventManagement::Clear

; 20   : }

  00071	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00078	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0007b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00085	59		 pop	 ecx
  00086	5f		 pop	 edi
  00087	5e		 pop	 esi
  00088	5b		 pop	 ebx
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0CEventManagement@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE@XZ ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::~vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >
__unwindfunclet$??0CEventManagement@@QAE@XZ$1:
  0000b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00011	e9 00 00 00 00	 jmp	 ??1?$map@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@QAE@XZ
__ehhandler$??0CEventManagement@@QAE@XZ:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CEventManagement@@QAE@XZ
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CEventManagement@@QAE@XZ ENDP			; CEventManagement::CEventManagement
PUBLIC	??1CEventManagement@@UAE@XZ			; CEventManagement::~CEventManagement
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp /ZI
;	COMDAT ??_GCEventManagement@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCEventManagement@@UAEPAXI@Z PROC			; CEventManagement::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1CEventManagement@@UAE@XZ ; CEventManagement::~CEventManagement
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_GCEventManagement@@UAEPAXI@Z ENDP			; CEventManagement::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::~_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >
; Function compile flags: /Odtp /ZI
;	COMDAT ??1?$map@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$map@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@QAE@XZ PROC ; std::map<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> > >::~map<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::~_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >
  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1?$map@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@QAE@XZ ENDP ; std::map<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> > >::~map<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> > >
_TEXT	ENDS
xdata$x	SEGMENT
__unwindtable$??1CEventManagement@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CEventManagement@@UAE@XZ$0
__ehfuncinfo$??1CEventManagement@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CEventManagement@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CEventManagement@@UAE@XZ PROC			; CEventManagement::~CEventManagement
; _this$ = ecx

; 23   : {

  00090	55		 push	 ebp
  00091	8b ec		 mov	 ebp, esp
  00093	6a ff		 push	 -1
  00095	68 00 00 00 00	 push	 __ehhandler$??1CEventManagement@@UAE@XZ
  0009a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  000a0	50		 push	 eax
  000a1	83 ec 44	 sub	 esp, 68			; 00000044H
  000a4	53		 push	 ebx
  000a5	56		 push	 esi
  000a6	57		 push	 edi
  000a7	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  000ac	33 c5		 xor	 eax, ebp
  000ae	50		 push	 eax
  000af	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  000b2	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  000b8	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  000bb	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000be	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CEventManagement@@6B@
  000c4	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 24   : 	return;
; 25   : }

  000cb	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000ce	83 c1 1c	 add	 ecx, 28			; 0000001cH
  000d1	e8 00 00 00 00	 call	 ??1?$map@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@QAE@XZ
  000d6	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000dd	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000e0	83 c1 0c	 add	 ecx, 12			; 0000000cH
  000e3	e8 00 00 00 00	 call	 ??1?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE@XZ ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::~vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >
  000e8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000eb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000f2	59		 pop	 ecx
  000f3	5f		 pop	 edi
  000f4	5e		 pop	 esi
  000f5	5b		 pop	 ebx
  000f6	8b e5		 mov	 esp, ebp
  000f8	5d		 pop	 ebp
  000f9	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??1CEventManagement@@UAE@XZ$0:
  00031	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00037	e9 00 00 00 00	 jmp	 ??1?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE@XZ ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::~vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >
__ehhandler$??1CEventManagement@@UAE@XZ:
  0003c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00040	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00043	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00046	33 c8		 xor	 ecx, eax
  00048	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CEventManagement@@UAE@XZ
  00052	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CEventManagement@@UAE@XZ ENDP			; CEventManagement::~CEventManagement
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::clear
PUBLIC	?clear@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAEXXZ ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::clear
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@CEventManagement@@QAEXXZ PROC			; CEventManagement::Clear
; _this$ = ecx

; 28   : {

  00100	55		 push	 ebp
  00101	8b ec		 mov	 ebp, esp
  00103	83 ec 44	 sub	 esp, 68			; 00000044H
  00106	53		 push	 ebx
  00107	56		 push	 esi
  00108	57		 push	 edi
  00109	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 29   : 	this->m_vtEventTime.clear();

  0010c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0010f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00112	e8 00 00 00 00	 call	 ?clear@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAEXXZ ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::clear

; 30   : 	this->m_mapEventObj.clear();

  00117	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0011a	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0011d	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::clear

; 31   : 	this->m_wToday_Year = 0;

  00122	33 c0		 xor	 eax, eax
  00124	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00127	66 89 41 2c	 mov	 WORD PTR [ecx+44], ax

; 32   : 	this->m_wToday_Month = 0;

  0012b	33 c0		 xor	 eax, eax
  0012d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00130	66 89 41 2e	 mov	 WORD PTR [ecx+46], ax

; 33   : 	this->m_wToday_Day = 0;

  00134	33 c0		 xor	 eax, eax
  00136	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00139	66 89 41 30	 mov	 WORD PTR [ecx+48], ax

; 34   : }

  0013d	5f		 pop	 edi
  0013e	5e		 pop	 esi
  0013f	5b		 pop	 ebx
  00140	8b e5		 mov	 esp, ebp
  00142	5d		 pop	 ebp
  00143	c3		 ret	 0
?Clear@CEventManagement@@QAEXXZ ENDP			; CEventManagement::Clear
_TEXT	ENDS
PUBLIC	?SetMenualStart@CRingAttackEvent@@QAEXH@Z	; CRingAttackEvent::SetMenualStart
PUBLIC	?SetMenualStart@CEledoradoEvent@@QAEXH@Z	; CEledoradoEvent::SetMenualStart
PUBLIC	?SetMenualStart@CAttackEvent@@QAEXH@Z		; CAttackEvent::SetMenualStart
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QBEAAUEVENT_ID_TIME@@XZ ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator*
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator!=
PUBLIC	?end@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@2@XZ ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::end
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator++
PUBLIC	?begin@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@2@XZ ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::begin
PUBLIC	?SetMenualStart@CDragonEvent@@QAEXH@Z		; CDragonEvent::SetMenualStart
PUBLIC	??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHPAX@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator->
PUBLIC	??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator!=
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::end
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::find
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAE@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >
PUBLIC	__$ArrayPad$
PUBLIC	?Init@CEventManagement@@QAEXH@Z			; CEventManagement::Init
EXTRN	__imp__GetLocalTime@4:PROC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
$T227190 = -316						; size = 4
$T227191 = -312						; size = 4
$T227192 = -308						; size = 4
$T227193 = -304						; size = 4
$T227194 = -300						; size = 4
$T227195 = -296						; size = 4
$T227196 = -292						; size = 4
$T227197 = -288						; size = 4
$T227198 = -284						; size = 4
$T227199 = -280						; size = 4
$T227200 = -276						; size = 4
$T227201 = -272						; size = 4
$T227202 = -268						; size = 4
$T227203 = -264						; size = 4
$T227204 = -260						; size = 4
$T227205 = -256						; size = 4
$T227206 = -252						; size = 4
$T227207 = -248						; size = 4
$T227208 = -244						; size = 4
$T227209 = -240						; size = 4
$T227210 = -236						; size = 4
$T227211 = -232						; size = 4
$T227212 = -228						; size = 4
$T227213 = -224						; size = 4
$T227214 = -220						; size = 4
$T227215 = -216						; size = 4
$T227216 = -212						; size = 4
$T227217 = -208						; size = 4
$T227218 = -204						; size = 4
$T227219 = -200						; size = 4
$T227220 = -196						; size = 4
$T227221 = -192						; size = 4
$T227222 = -188						; size = 4
$T227223 = -184						; size = 4
$T227224 = -180						; size = 4
$T227225 = -176						; size = 4
$T227226 = -172						; size = 4
$T227227 = -168						; size = 4
$T227228 = -164						; size = 4
$T227229 = -160						; size = 4
_lpEvent$224114 = -92					; size = 4
_lpEvent$224108 = -88					; size = 4
_lpEvent$224102 = -84					; size = 4
_lpEvent$224096 = -80					; size = 4
_lpEvent$224090 = -76					; size = 4
__Itor$224085 = -72					; size = 4
_it$224063 = -68					; size = 4
_lpEvent$224057 = -64					; size = 4
_it$224045 = -60					; size = 4
_lpEvent$224039 = -56					; size = 4
_it$224027 = -52					; size = 4
_lpEvent$224021 = -48					; size = 4
_it$224009 = -44					; size = 4
_lpEvent$224003 = -40					; size = 4
_it$223975 = -36					; size = 4
_lpEvent$223693 = -32					; size = 4
__Itor$223672 = -28					; size = 4
_sysTime$223522 = -24					; size = 16
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_bEventStart$ = 8					; size = 4
?Init@CEventManagement@@QAEXH@Z PROC			; CEventManagement::Init
; _this$ = ecx

; 37   : {

  00150	55		 push	 ebp
  00151	8b ec		 mov	 ebp, esp
  00153	81 ec 3c 01 00
	00		 sub	 esp, 316		; 0000013cH
  00159	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0015e	33 c5		 xor	 eax, ebp
  00160	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00163	53		 push	 ebx
  00164	56		 push	 esi
  00165	57		 push	 edi
  00166	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 38   : 	this->m_bEventStart = bEventStart;

  00169	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0016c	8b 4d 08	 mov	 ecx, DWORD PTR _bEventStart$[ebp]
  0016f	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 39   : 
; 40   : 	if ( this->m_bHasData != false && this->m_bEventStart != false )

  00172	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00175	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00179	0f 84 0a 04 00
	00		 je	 $LN32@Init
  0017f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00182	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00186	0f 84 fd 03 00
	00		 je	 $LN32@Init

; 41   : 	{
; 42   : 		SYSTEMTIME sysTime;
; 43   : 
; 44   : 		GetLocalTime(&sysTime);

  0018c	8d 45 e8	 lea	 eax, DWORD PTR _sysTime$223522[ebp]
  0018f	50		 push	 eax
  00190	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocalTime@4

; 45   : 		this->m_wToday_Year = sysTime.wYear;

  00196	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00199	66 8b 4d e8	 mov	 cx, WORD PTR _sysTime$223522[ebp]
  0019d	66 89 48 2c	 mov	 WORD PTR [eax+44], cx

; 46   : 		this->m_wToday_Month = sysTime.wMonth;

  001a1	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001a4	66 8b 4d ea	 mov	 cx, WORD PTR _sysTime$223522[ebp+2]
  001a8	66 89 48 2e	 mov	 WORD PTR [eax+46], cx

; 47   : 		this->m_wToday_Day = sysTime.wDay;

  001ac	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001af	66 8b 4d ee	 mov	 cx, WORD PTR _sysTime$223522[ebp+6]
  001b3	66 89 48 30	 mov	 WORD PTR [eax+48], cx

; 48   : 
; 49   : 		std::map<int, void *>::iterator _Itor;

  001b7	8d 4d e4	 lea	 ecx, DWORD PTR __Itor$223672[ebp]
  001ba	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAE@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >

; 50   : 		
; 51   : 		_Itor = this->m_mapEventObj.find(EVENT_ID_DRAGONHERD);

  001bf	c7 85 c4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T227190[ebp], 0
  001c9	8d 85 c4 fe ff
	ff		 lea	 eax, DWORD PTR $T227190[ebp]
  001cf	50		 push	 eax
  001d0	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T227191[ebp]
  001d6	51		 push	 ecx
  001d7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001da	83 c1 1c	 add	 ecx, 28			; 0000001cH
  001dd	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::find
  001e2	8b 10		 mov	 edx, DWORD PTR [eax]
  001e4	89 55 e4	 mov	 DWORD PTR __Itor$223672[ebp], edx

; 52   : 
; 53   : 		if ( _Itor != this->m_mapEventObj.end() )

  001e7	8d 85 cc fe ff
	ff		 lea	 eax, DWORD PTR $T227192[ebp]
  001ed	50		 push	 eax
  001ee	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001f1	83 c1 1c	 add	 ecx, 28			; 0000001cH
  001f4	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::end
  001f9	50		 push	 eax
  001fa	8d 4d e4	 lea	 ecx, DWORD PTR __Itor$223672[ebp]
  001fd	e8 00 00 00 00	 call	 ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator!=
  00202	0f b6 c8	 movzx	 ecx, al
  00205	85 c9		 test	 ecx, ecx
  00207	74 75		 je	 SHORT $LN31@Init

; 54   : 		{
; 55   : 			CDragonEvent * lpEvent = (CDragonEvent *)_Itor->second;

  00209	8d 4d e4	 lea	 ecx, DWORD PTR __Itor$223672[ebp]
  0020c	e8 00 00 00 00	 call	 ??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHPAX@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator->
  00211	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00214	89 45 e0	 mov	 DWORD PTR _lpEvent$223693[ebp], eax

; 56   : 			lpEvent->SetMenualStart(FALSE);

  00217	6a 00		 push	 0
  00219	8b 4d e0	 mov	 ecx, DWORD PTR _lpEvent$223693[ebp]
  0021c	e8 00 00 00 00	 call	 ?SetMenualStart@CDragonEvent@@QAEXH@Z ; CDragonEvent::SetMenualStart

; 57   : 
; 58   : 			for (std::vector<EVENT_ID_TIME>::iterator it = this->m_vtEventTime.begin() ; it != this->m_vtEventTime.end(); it++)

  00221	8d 45 dc	 lea	 eax, DWORD PTR _it$223975[ebp]
  00224	50		 push	 eax
  00225	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00228	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0022b	e8 00 00 00 00	 call	 ?begin@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@2@XZ ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::begin
  00230	eb 11		 jmp	 SHORT $LN30@Init
$LN29@Init:
  00232	6a 00		 push	 0
  00234	8d 85 d0 fe ff
	ff		 lea	 eax, DWORD PTR $T227193[ebp]
  0023a	50		 push	 eax
  0023b	8d 4d dc	 lea	 ecx, DWORD PTR _it$223975[ebp]
  0023e	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator++
$LN30@Init:
  00243	8d 85 d4 fe ff
	ff		 lea	 eax, DWORD PTR $T227194[ebp]
  00249	50		 push	 eax
  0024a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0024d	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00250	e8 00 00 00 00	 call	 ?end@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@2@XZ ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::end
  00255	50		 push	 eax
  00256	8d 4d dc	 lea	 ecx, DWORD PTR _it$223975[ebp]
  00259	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator!=
  0025e	0f b6 c8	 movzx	 ecx, al
  00261	85 c9		 test	 ecx, ecx
  00263	74 19		 je	 SHORT $LN31@Init

; 59   : 			{
; 60   : 				if ( (*(it)).m_eEventKind == EVENT_ID_DRAGONHERD )

  00265	8d 4d dc	 lea	 ecx, DWORD PTR _it$223975[ebp]
  00268	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QBEAAUEVENT_ID_TIME@@XZ ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator*
  0026d	83 38 00	 cmp	 DWORD PTR [eax], 0
  00270	75 0a		 jne	 SHORT $LN27@Init

; 61   : 				{
; 62   : 					lpEvent->SetMenualStart(TRUE);

  00272	6a 01		 push	 1
  00274	8b 4d e0	 mov	 ecx, DWORD PTR _lpEvent$223693[ebp]
  00277	e8 00 00 00 00	 call	 ?SetMenualStart@CDragonEvent@@QAEXH@Z ; CDragonEvent::SetMenualStart
$LN27@Init:

; 63   : 				}
; 64   : 			}

  0027c	eb b4		 jmp	 SHORT $LN29@Init
$LN31@Init:

; 65   : 		}
; 66   : 
; 67   : 		_Itor = this->m_mapEventObj.find(EVENT_ID_UNDERTROOP);

  0027e	c7 85 d8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR $T227195[ebp], 1
  00288	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR $T227195[ebp]
  0028e	50		 push	 eax
  0028f	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR $T227196[ebp]
  00295	51		 push	 ecx
  00296	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00299	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0029c	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::find
  002a1	8b 10		 mov	 edx, DWORD PTR [eax]
  002a3	89 55 e4	 mov	 DWORD PTR __Itor$223672[ebp], edx

; 68   : 
; 69   : 		if ( _Itor != this->m_mapEventObj.end() )

  002a6	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR $T227197[ebp]
  002ac	50		 push	 eax
  002ad	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  002b0	83 c1 1c	 add	 ecx, 28			; 0000001cH
  002b3	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::end
  002b8	50		 push	 eax
  002b9	8d 4d e4	 lea	 ecx, DWORD PTR __Itor$223672[ebp]
  002bc	e8 00 00 00 00	 call	 ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator!=
  002c1	0f b6 c8	 movzx	 ecx, al
  002c4	85 c9		 test	 ecx, ecx
  002c6	74 75		 je	 SHORT $LN26@Init

; 70   : 		{
; 71   : 			CAttackEvent * lpEvent = (CAttackEvent *)_Itor->second;

  002c8	8d 4d e4	 lea	 ecx, DWORD PTR __Itor$223672[ebp]
  002cb	e8 00 00 00 00	 call	 ??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHPAX@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator->
  002d0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  002d3	89 45 d8	 mov	 DWORD PTR _lpEvent$224003[ebp], eax

; 72   : 			lpEvent->SetMenualStart(FALSE);

  002d6	6a 00		 push	 0
  002d8	8b 4d d8	 mov	 ecx, DWORD PTR _lpEvent$224003[ebp]
  002db	e8 00 00 00 00	 call	 ?SetMenualStart@CAttackEvent@@QAEXH@Z ; CAttackEvent::SetMenualStart

; 73   : 
; 74   : 			for (std::vector<EVENT_ID_TIME>::iterator it = this->m_vtEventTime.begin() ; it != this->m_vtEventTime.end(); it++)

  002e0	8d 45 d4	 lea	 eax, DWORD PTR _it$224009[ebp]
  002e3	50		 push	 eax
  002e4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  002e7	83 c1 0c	 add	 ecx, 12			; 0000000cH
  002ea	e8 00 00 00 00	 call	 ?begin@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@2@XZ ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::begin
  002ef	eb 11		 jmp	 SHORT $LN25@Init
$LN24@Init:
  002f1	6a 00		 push	 0
  002f3	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR $T227198[ebp]
  002f9	50		 push	 eax
  002fa	8d 4d d4	 lea	 ecx, DWORD PTR _it$224009[ebp]
  002fd	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator++
$LN25@Init:
  00302	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR $T227199[ebp]
  00308	50		 push	 eax
  00309	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0030c	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0030f	e8 00 00 00 00	 call	 ?end@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@2@XZ ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::end
  00314	50		 push	 eax
  00315	8d 4d d4	 lea	 ecx, DWORD PTR _it$224009[ebp]
  00318	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator!=
  0031d	0f b6 c8	 movzx	 ecx, al
  00320	85 c9		 test	 ecx, ecx
  00322	74 19		 je	 SHORT $LN26@Init

; 75   : 			{
; 76   : 				if ( (*(it)).m_eEventKind == EVENT_ID_UNDERTROOP )

  00324	8d 4d d4	 lea	 ecx, DWORD PTR _it$224009[ebp]
  00327	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QBEAAUEVENT_ID_TIME@@XZ ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator*
  0032c	83 38 01	 cmp	 DWORD PTR [eax], 1
  0032f	75 0a		 jne	 SHORT $LN22@Init

; 77   : 				{
; 78   : 					lpEvent->SetMenualStart(TRUE);

  00331	6a 01		 push	 1
  00333	8b 4d d8	 mov	 ecx, DWORD PTR _lpEvent$224003[ebp]
  00336	e8 00 00 00 00	 call	 ?SetMenualStart@CAttackEvent@@QAEXH@Z ; CAttackEvent::SetMenualStart
$LN22@Init:

; 79   : 				}
; 80   : 			}

  0033b	eb b4		 jmp	 SHORT $LN24@Init
$LN26@Init:

; 81   : 		}
; 82   : 
; 83   : 		_Itor = this->m_mapEventObj.find(EVENT_ID_ELDORADO);

  0033d	c7 85 ec fe ff
	ff 02 00 00 00	 mov	 DWORD PTR $T227200[ebp], 2
  00347	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR $T227200[ebp]
  0034d	50		 push	 eax
  0034e	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR $T227201[ebp]
  00354	51		 push	 ecx
  00355	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00358	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0035b	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::find
  00360	8b 10		 mov	 edx, DWORD PTR [eax]
  00362	89 55 e4	 mov	 DWORD PTR __Itor$223672[ebp], edx

; 84   : 
; 85   : 		if ( _Itor != this->m_mapEventObj.end() )

  00365	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR $T227202[ebp]
  0036b	50		 push	 eax
  0036c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0036f	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00372	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::end
  00377	50		 push	 eax
  00378	8d 4d e4	 lea	 ecx, DWORD PTR __Itor$223672[ebp]
  0037b	e8 00 00 00 00	 call	 ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator!=
  00380	0f b6 c8	 movzx	 ecx, al
  00383	85 c9		 test	 ecx, ecx
  00385	74 75		 je	 SHORT $LN21@Init

; 86   : 		{
; 87   : 			CEledoradoEvent * lpEvent = (CEledoradoEvent *)_Itor->second;

  00387	8d 4d e4	 lea	 ecx, DWORD PTR __Itor$223672[ebp]
  0038a	e8 00 00 00 00	 call	 ??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHPAX@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator->
  0038f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00392	89 45 d0	 mov	 DWORD PTR _lpEvent$224021[ebp], eax

; 88   : 			lpEvent->SetMenualStart(FALSE);

  00395	6a 00		 push	 0
  00397	8b 4d d0	 mov	 ecx, DWORD PTR _lpEvent$224021[ebp]
  0039a	e8 00 00 00 00	 call	 ?SetMenualStart@CEledoradoEvent@@QAEXH@Z ; CEledoradoEvent::SetMenualStart

; 89   : 
; 90   : 			for (std::vector<EVENT_ID_TIME>::iterator it = this->m_vtEventTime.begin() ; it != this->m_vtEventTime.end(); it++)

  0039f	8d 45 cc	 lea	 eax, DWORD PTR _it$224027[ebp]
  003a2	50		 push	 eax
  003a3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  003a6	83 c1 0c	 add	 ecx, 12			; 0000000cH
  003a9	e8 00 00 00 00	 call	 ?begin@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@2@XZ ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::begin
  003ae	eb 11		 jmp	 SHORT $LN20@Init
$LN19@Init:
  003b0	6a 00		 push	 0
  003b2	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR $T227203[ebp]
  003b8	50		 push	 eax
  003b9	8d 4d cc	 lea	 ecx, DWORD PTR _it$224027[ebp]
  003bc	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator++
$LN20@Init:
  003c1	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR $T227204[ebp]
  003c7	50		 push	 eax
  003c8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  003cb	83 c1 0c	 add	 ecx, 12			; 0000000cH
  003ce	e8 00 00 00 00	 call	 ?end@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@2@XZ ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::end
  003d3	50		 push	 eax
  003d4	8d 4d cc	 lea	 ecx, DWORD PTR _it$224027[ebp]
  003d7	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator!=
  003dc	0f b6 c8	 movzx	 ecx, al
  003df	85 c9		 test	 ecx, ecx
  003e1	74 19		 je	 SHORT $LN21@Init

; 91   : 			{
; 92   : 				if ( (*(it)).m_eEventKind == EVENT_ID_ELDORADO )

  003e3	8d 4d cc	 lea	 ecx, DWORD PTR _it$224027[ebp]
  003e6	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QBEAAUEVENT_ID_TIME@@XZ ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator*
  003eb	83 38 02	 cmp	 DWORD PTR [eax], 2
  003ee	75 0a		 jne	 SHORT $LN17@Init

; 93   : 				{
; 94   : 					lpEvent->SetMenualStart(TRUE);

  003f0	6a 01		 push	 1
  003f2	8b 4d d0	 mov	 ecx, DWORD PTR _lpEvent$224021[ebp]
  003f5	e8 00 00 00 00	 call	 ?SetMenualStart@CEledoradoEvent@@QAEXH@Z ; CEledoradoEvent::SetMenualStart
$LN17@Init:

; 95   : 				}
; 96   : 			}

  003fa	eb b4		 jmp	 SHORT $LN19@Init
$LN21@Init:

; 97   : 		}
; 98   : 
; 99   : 
; 100  : 		_Itor = this->m_mapEventObj.find(EVENT_ID_WHITEMAGE);

  003fc	c7 85 00 ff ff
	ff 03 00 00 00	 mov	 DWORD PTR $T227205[ebp], 3
  00406	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR $T227205[ebp]
  0040c	50		 push	 eax
  0040d	8d 8d 04 ff ff
	ff		 lea	 ecx, DWORD PTR $T227206[ebp]
  00413	51		 push	 ecx
  00414	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00417	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0041a	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::find
  0041f	8b 10		 mov	 edx, DWORD PTR [eax]
  00421	89 55 e4	 mov	 DWORD PTR __Itor$223672[ebp], edx

; 101  : 
; 102  : 		if ( _Itor != this->m_mapEventObj.end() )

  00424	8d 85 08 ff ff
	ff		 lea	 eax, DWORD PTR $T227207[ebp]
  0042a	50		 push	 eax
  0042b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0042e	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00431	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::end
  00436	50		 push	 eax
  00437	8d 4d e4	 lea	 ecx, DWORD PTR __Itor$223672[ebp]
  0043a	e8 00 00 00 00	 call	 ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator!=
  0043f	0f b6 c8	 movzx	 ecx, al
  00442	85 c9		 test	 ecx, ecx
  00444	74 75		 je	 SHORT $LN16@Init

; 103  : 		{
; 104  : 			CRingAttackEvent * lpEvent = (CRingAttackEvent *)_Itor->second;

  00446	8d 4d e4	 lea	 ecx, DWORD PTR __Itor$223672[ebp]
  00449	e8 00 00 00 00	 call	 ??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHPAX@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator->
  0044e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00451	89 45 c8	 mov	 DWORD PTR _lpEvent$224039[ebp], eax

; 105  : 			lpEvent->SetMenualStart(FALSE);

  00454	6a 00		 push	 0
  00456	8b 4d c8	 mov	 ecx, DWORD PTR _lpEvent$224039[ebp]
  00459	e8 00 00 00 00	 call	 ?SetMenualStart@CRingAttackEvent@@QAEXH@Z ; CRingAttackEvent::SetMenualStart

; 106  : 
; 107  : 			for (std::vector<EVENT_ID_TIME>::iterator it = this->m_vtEventTime.begin() ; it != this->m_vtEventTime.end(); it++)

  0045e	8d 45 c4	 lea	 eax, DWORD PTR _it$224045[ebp]
  00461	50		 push	 eax
  00462	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00465	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00468	e8 00 00 00 00	 call	 ?begin@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@2@XZ ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::begin
  0046d	eb 11		 jmp	 SHORT $LN15@Init
$LN14@Init:
  0046f	6a 00		 push	 0
  00471	8d 85 0c ff ff
	ff		 lea	 eax, DWORD PTR $T227208[ebp]
  00477	50		 push	 eax
  00478	8d 4d c4	 lea	 ecx, DWORD PTR _it$224045[ebp]
  0047b	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator++
$LN15@Init:
  00480	8d 85 10 ff ff
	ff		 lea	 eax, DWORD PTR $T227209[ebp]
  00486	50		 push	 eax
  00487	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0048a	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0048d	e8 00 00 00 00	 call	 ?end@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@2@XZ ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::end
  00492	50		 push	 eax
  00493	8d 4d c4	 lea	 ecx, DWORD PTR _it$224045[ebp]
  00496	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator!=
  0049b	0f b6 c8	 movzx	 ecx, al
  0049e	85 c9		 test	 ecx, ecx
  004a0	74 19		 je	 SHORT $LN16@Init

; 108  : 			{
; 109  : 				if ( (*(it)).m_eEventKind == EVENT_ID_ELDORADO ) //wtf?

  004a2	8d 4d c4	 lea	 ecx, DWORD PTR _it$224045[ebp]
  004a5	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QBEAAUEVENT_ID_TIME@@XZ ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator*
  004aa	83 38 02	 cmp	 DWORD PTR [eax], 2
  004ad	75 0a		 jne	 SHORT $LN12@Init

; 110  : 				{
; 111  : 					lpEvent->SetMenualStart(TRUE);

  004af	6a 01		 push	 1
  004b1	8b 4d c8	 mov	 ecx, DWORD PTR _lpEvent$224039[ebp]
  004b4	e8 00 00 00 00	 call	 ?SetMenualStart@CRingAttackEvent@@QAEXH@Z ; CRingAttackEvent::SetMenualStart
$LN12@Init:

; 112  : 				}
; 113  : 			}

  004b9	eb b4		 jmp	 SHORT $LN14@Init
$LN16@Init:

; 114  : 		}
; 115  : 
; 116  : 		//Season 4.5 addon
; 117  : 		_Itor = this->m_mapEventObj.find(EVENT_ID_XMASATTACK);

  004bb	c7 85 14 ff ff
	ff 04 00 00 00	 mov	 DWORD PTR $T227210[ebp], 4
  004c5	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR $T227210[ebp]
  004cb	50		 push	 eax
  004cc	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR $T227211[ebp]
  004d2	51		 push	 ecx
  004d3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  004d6	83 c1 1c	 add	 ecx, 28			; 0000001cH
  004d9	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::find
  004de	8b 10		 mov	 edx, DWORD PTR [eax]
  004e0	89 55 e4	 mov	 DWORD PTR __Itor$223672[ebp], edx

; 118  : 
; 119  : 		if ( _Itor != this->m_mapEventObj.end() )

  004e3	8d 85 1c ff ff
	ff		 lea	 eax, DWORD PTR $T227212[ebp]
  004e9	50		 push	 eax
  004ea	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  004ed	83 c1 1c	 add	 ecx, 28			; 0000001cH
  004f0	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::end
  004f5	50		 push	 eax
  004f6	8d 4d e4	 lea	 ecx, DWORD PTR __Itor$223672[ebp]
  004f9	e8 00 00 00 00	 call	 ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator!=
  004fe	0f b6 c8	 movzx	 ecx, al
  00501	85 c9		 test	 ecx, ecx
  00503	74 7f		 je	 SHORT $LN11@Init

; 120  : 		{
; 121  : 			CXMasAttackEvent * lpEvent = (CXMasAttackEvent *)_Itor->second;

  00505	8d 4d e4	 lea	 ecx, DWORD PTR __Itor$223672[ebp]
  00508	e8 00 00 00 00	 call	 ??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHPAX@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator->
  0050d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00510	89 45 c0	 mov	 DWORD PTR _lpEvent$224057[ebp], eax

; 122  : 			
; 123  : 			lpEvent->SetMenualStart(FALSE);

  00513	6a 00		 push	 0
  00515	8b 45 c0	 mov	 eax, DWORD PTR _lpEvent$224057[ebp]
  00518	8b 10		 mov	 edx, DWORD PTR [eax]
  0051a	8b 4d c0	 mov	 ecx, DWORD PTR _lpEvent$224057[ebp]
  0051d	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00520	ff d0		 call	 eax

; 124  : 
; 125  : 			for (std::vector<EVENT_ID_TIME>::iterator it = this->m_vtEventTime.begin() ; it != this->m_vtEventTime.end(); it++)

  00522	8d 45 bc	 lea	 eax, DWORD PTR _it$224063[ebp]
  00525	50		 push	 eax
  00526	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00529	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0052c	e8 00 00 00 00	 call	 ?begin@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@2@XZ ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::begin
  00531	eb 11		 jmp	 SHORT $LN10@Init
$LN9@Init:
  00533	6a 00		 push	 0
  00535	8d 85 20 ff ff
	ff		 lea	 eax, DWORD PTR $T227213[ebp]
  0053b	50		 push	 eax
  0053c	8d 4d bc	 lea	 ecx, DWORD PTR _it$224063[ebp]
  0053f	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator++
$LN10@Init:
  00544	8d 85 24 ff ff
	ff		 lea	 eax, DWORD PTR $T227214[ebp]
  0054a	50		 push	 eax
  0054b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0054e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00551	e8 00 00 00 00	 call	 ?end@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@2@XZ ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::end
  00556	50		 push	 eax
  00557	8d 4d bc	 lea	 ecx, DWORD PTR _it$224063[ebp]
  0055a	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator!=
  0055f	0f b6 c8	 movzx	 ecx, al
  00562	85 c9		 test	 ecx, ecx
  00564	74 1e		 je	 SHORT $LN11@Init

; 126  : 			{
; 127  : 				if ( (*(it)).m_eEventKind == EVENT_ID_XMASATTACK )

  00566	8d 4d bc	 lea	 ecx, DWORD PTR _it$224063[ebp]
  00569	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QBEAAUEVENT_ID_TIME@@XZ ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator*
  0056e	83 38 04	 cmp	 DWORD PTR [eax], 4
  00571	75 0f		 jne	 SHORT $LN7@Init

; 128  : 				{
; 129  : 					lpEvent->SetMenualStart(TRUE);

  00573	6a 01		 push	 1
  00575	8b 45 c0	 mov	 eax, DWORD PTR _lpEvent$224057[ebp]
  00578	8b 10		 mov	 edx, DWORD PTR [eax]
  0057a	8b 4d c0	 mov	 ecx, DWORD PTR _lpEvent$224057[ebp]
  0057d	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00580	ff d0		 call	 eax
$LN7@Init:

; 130  : 				}
; 131  : 			}

  00582	eb af		 jmp	 SHORT $LN9@Init
$LN11@Init:

; 132  : 		}
; 133  : 
; 134  : 	}
; 135  : 	else

  00584	e9 f7 01 00 00	 jmp	 $LN33@Init
$LN32@Init:

; 136  : 	{
; 137  : 		std::map<int, void *>::iterator _Itor;

  00589	8d 4d b8	 lea	 ecx, DWORD PTR __Itor$224085[ebp]
  0058c	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAE@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >

; 138  : 		
; 139  : 		_Itor = this->m_mapEventObj.find(EVENT_ID_DRAGONHERD);

  00591	c7 85 28 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T227215[ebp], 0
  0059b	8d 85 28 ff ff
	ff		 lea	 eax, DWORD PTR $T227215[ebp]
  005a1	50		 push	 eax
  005a2	8d 8d 2c ff ff
	ff		 lea	 ecx, DWORD PTR $T227216[ebp]
  005a8	51		 push	 ecx
  005a9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  005ac	83 c1 1c	 add	 ecx, 28			; 0000001cH
  005af	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::find
  005b4	8b 10		 mov	 edx, DWORD PTR [eax]
  005b6	89 55 b8	 mov	 DWORD PTR __Itor$224085[ebp], edx

; 140  : 		
; 141  : 		if ( _Itor != this->m_mapEventObj.end() )

  005b9	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR $T227217[ebp]
  005bf	50		 push	 eax
  005c0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  005c3	83 c1 1c	 add	 ecx, 28			; 0000001cH
  005c6	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::end
  005cb	50		 push	 eax
  005cc	8d 4d b8	 lea	 ecx, DWORD PTR __Itor$224085[ebp]
  005cf	e8 00 00 00 00	 call	 ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator!=
  005d4	0f b6 c8	 movzx	 ecx, al
  005d7	85 c9		 test	 ecx, ecx
  005d9	74 18		 je	 SHORT $LN5@Init

; 142  : 		{
; 143  : 			CDragonEvent * lpEvent = (CDragonEvent *)_Itor->second;

  005db	8d 4d b8	 lea	 ecx, DWORD PTR __Itor$224085[ebp]
  005de	e8 00 00 00 00	 call	 ??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHPAX@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator->
  005e3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  005e6	89 45 b4	 mov	 DWORD PTR _lpEvent$224090[ebp], eax

; 144  : 			lpEvent->SetMenualStart(FALSE);

  005e9	6a 00		 push	 0
  005eb	8b 4d b4	 mov	 ecx, DWORD PTR _lpEvent$224090[ebp]
  005ee	e8 00 00 00 00	 call	 ?SetMenualStart@CDragonEvent@@QAEXH@Z ; CDragonEvent::SetMenualStart
$LN5@Init:

; 145  : 		}
; 146  : 
; 147  : 	
; 148  : 		_Itor = this->m_mapEventObj.find(EVENT_ID_UNDERTROOP);

  005f3	c7 85 34 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR $T227218[ebp], 1
  005fd	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR $T227218[ebp]
  00603	50		 push	 eax
  00604	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR $T227219[ebp]
  0060a	51		 push	 ecx
  0060b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0060e	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00611	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::find
  00616	8b 10		 mov	 edx, DWORD PTR [eax]
  00618	89 55 b8	 mov	 DWORD PTR __Itor$224085[ebp], edx

; 149  : 		
; 150  : 		if ( _Itor != this->m_mapEventObj.end() )

  0061b	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR $T227220[ebp]
  00621	50		 push	 eax
  00622	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00625	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00628	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::end
  0062d	50		 push	 eax
  0062e	8d 4d b8	 lea	 ecx, DWORD PTR __Itor$224085[ebp]
  00631	e8 00 00 00 00	 call	 ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator!=
  00636	0f b6 c8	 movzx	 ecx, al
  00639	85 c9		 test	 ecx, ecx
  0063b	74 18		 je	 SHORT $LN4@Init

; 151  : 		{
; 152  : 			CAttackEvent * lpEvent = (CAttackEvent *)_Itor->second;

  0063d	8d 4d b8	 lea	 ecx, DWORD PTR __Itor$224085[ebp]
  00640	e8 00 00 00 00	 call	 ??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHPAX@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator->
  00645	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00648	89 45 b0	 mov	 DWORD PTR _lpEvent$224096[ebp], eax

; 153  : 			lpEvent->SetMenualStart(FALSE);

  0064b	6a 00		 push	 0
  0064d	8b 4d b0	 mov	 ecx, DWORD PTR _lpEvent$224096[ebp]
  00650	e8 00 00 00 00	 call	 ?SetMenualStart@CAttackEvent@@QAEXH@Z ; CAttackEvent::SetMenualStart
$LN4@Init:

; 154  : 		}
; 155  : 
; 156  : 		_Itor = this->m_mapEventObj.find(EVENT_ID_ELDORADO);

  00655	c7 85 40 ff ff
	ff 02 00 00 00	 mov	 DWORD PTR $T227221[ebp], 2
  0065f	8d 85 40 ff ff
	ff		 lea	 eax, DWORD PTR $T227221[ebp]
  00665	50		 push	 eax
  00666	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR $T227222[ebp]
  0066c	51		 push	 ecx
  0066d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00670	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00673	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::find
  00678	8b 10		 mov	 edx, DWORD PTR [eax]
  0067a	89 55 b8	 mov	 DWORD PTR __Itor$224085[ebp], edx

; 157  : 		
; 158  : 		if ( _Itor != this->m_mapEventObj.end() )

  0067d	8d 85 48 ff ff
	ff		 lea	 eax, DWORD PTR $T227223[ebp]
  00683	50		 push	 eax
  00684	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00687	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0068a	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::end
  0068f	50		 push	 eax
  00690	8d 4d b8	 lea	 ecx, DWORD PTR __Itor$224085[ebp]
  00693	e8 00 00 00 00	 call	 ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator!=
  00698	0f b6 c8	 movzx	 ecx, al
  0069b	85 c9		 test	 ecx, ecx
  0069d	74 18		 je	 SHORT $LN3@Init

; 159  : 		{
; 160  : 			CEledoradoEvent * lpEvent = (CEledoradoEvent *)_Itor->second;

  0069f	8d 4d b8	 lea	 ecx, DWORD PTR __Itor$224085[ebp]
  006a2	e8 00 00 00 00	 call	 ??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHPAX@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator->
  006a7	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  006aa	89 45 ac	 mov	 DWORD PTR _lpEvent$224102[ebp], eax

; 161  : 			lpEvent->SetMenualStart(FALSE);

  006ad	6a 00		 push	 0
  006af	8b 4d ac	 mov	 ecx, DWORD PTR _lpEvent$224102[ebp]
  006b2	e8 00 00 00 00	 call	 ?SetMenualStart@CEledoradoEvent@@QAEXH@Z ; CEledoradoEvent::SetMenualStart
$LN3@Init:

; 162  : 		}
; 163  : 
; 164  : 		_Itor = this->m_mapEventObj.find(EVENT_ID_WHITEMAGE);

  006b7	c7 85 4c ff ff
	ff 03 00 00 00	 mov	 DWORD PTR $T227224[ebp], 3
  006c1	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR $T227224[ebp]
  006c7	50		 push	 eax
  006c8	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR $T227225[ebp]
  006ce	51		 push	 ecx
  006cf	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  006d2	83 c1 1c	 add	 ecx, 28			; 0000001cH
  006d5	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::find
  006da	8b 10		 mov	 edx, DWORD PTR [eax]
  006dc	89 55 b8	 mov	 DWORD PTR __Itor$224085[ebp], edx

; 165  : 		
; 166  : 		if ( _Itor != this->m_mapEventObj.end() )

  006df	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR $T227226[ebp]
  006e5	50		 push	 eax
  006e6	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  006e9	83 c1 1c	 add	 ecx, 28			; 0000001cH
  006ec	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::end
  006f1	50		 push	 eax
  006f2	8d 4d b8	 lea	 ecx, DWORD PTR __Itor$224085[ebp]
  006f5	e8 00 00 00 00	 call	 ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator!=
  006fa	0f b6 c8	 movzx	 ecx, al
  006fd	85 c9		 test	 ecx, ecx
  006ff	74 18		 je	 SHORT $LN2@Init

; 167  : 		{
; 168  : 			CRingAttackEvent * lpEvent = (CRingAttackEvent *)_Itor->second;

  00701	8d 4d b8	 lea	 ecx, DWORD PTR __Itor$224085[ebp]
  00704	e8 00 00 00 00	 call	 ??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHPAX@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator->
  00709	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0070c	89 45 a8	 mov	 DWORD PTR _lpEvent$224108[ebp], eax

; 169  : 			lpEvent->SetMenualStart(FALSE);

  0070f	6a 00		 push	 0
  00711	8b 4d a8	 mov	 ecx, DWORD PTR _lpEvent$224108[ebp]
  00714	e8 00 00 00 00	 call	 ?SetMenualStart@CRingAttackEvent@@QAEXH@Z ; CRingAttackEvent::SetMenualStart
$LN2@Init:

; 170  : 		}
; 171  : 
; 172  : 		//Season 4.5 addon
; 173  : 		_Itor = this->m_mapEventObj.find(EVENT_ID_XMASATTACK);

  00719	c7 85 58 ff ff
	ff 04 00 00 00	 mov	 DWORD PTR $T227227[ebp], 4
  00723	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR $T227227[ebp]
  00729	50		 push	 eax
  0072a	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR $T227228[ebp]
  00730	51		 push	 ecx
  00731	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00734	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00737	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::find
  0073c	8b 10		 mov	 edx, DWORD PTR [eax]
  0073e	89 55 b8	 mov	 DWORD PTR __Itor$224085[ebp], edx

; 174  : 		
; 175  : 		if ( _Itor != this->m_mapEventObj.end() )

  00741	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR $T227229[ebp]
  00747	50		 push	 eax
  00748	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0074b	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0074e	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::end
  00753	50		 push	 eax
  00754	8d 4d b8	 lea	 ecx, DWORD PTR __Itor$224085[ebp]
  00757	e8 00 00 00 00	 call	 ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator!=
  0075c	0f b6 c8	 movzx	 ecx, al
  0075f	85 c9		 test	 ecx, ecx
  00761	74 1d		 je	 SHORT $LN33@Init

; 176  : 		{
; 177  : 			CXMasAttackEvent * lpEvent = (CXMasAttackEvent *)_Itor->second;

  00763	8d 4d b8	 lea	 ecx, DWORD PTR __Itor$224085[ebp]
  00766	e8 00 00 00 00	 call	 ??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHPAX@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator->
  0076b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0076e	89 45 a4	 mov	 DWORD PTR _lpEvent$224114[ebp], eax

; 178  : 			lpEvent->SetMenualStart(FALSE);

  00771	6a 00		 push	 0
  00773	8b 45 a4	 mov	 eax, DWORD PTR _lpEvent$224114[ebp]
  00776	8b 10		 mov	 edx, DWORD PTR [eax]
  00778	8b 4d a4	 mov	 ecx, DWORD PTR _lpEvent$224114[ebp]
  0077b	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0077e	ff d0		 call	 eax
$LN33@Init:

; 179  : 		}
; 180  : 	}
; 181  : }

  00780	5f		 pop	 edi
  00781	5e		 pop	 esi
  00782	5b		 pop	 ebx
  00783	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00786	33 cd		 xor	 ecx, ebp
  00788	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0078d	8b e5		 mov	 esp, ebp
  0078f	5d		 pop	 ebp
  00790	c2 04 00	 ret	 4
?Init@CEventManagement@@QAEXH@Z ENDP			; CEventManagement::Init
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\dragonevent.h
_TEXT	ENDS
;	COMDAT ?SetMenualStart@CDragonEvent@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bMenualStart$ = 8					; size = 4
?SetMenualStart@CDragonEvent@@QAEXH@Z PROC		; CDragonEvent::SetMenualStart, COMDAT
; _this$ = ecx

; 23   : 	void SetMenualStart(BOOL bMenualStart){this->m_bMenualStart = bMenualStart;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _bMenualStart$[ebp]
  00012	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?SetMenualStart@CDragonEvent@@QAEXH@Z ENDP		; CDragonEvent::SetMenualStart
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\attackevent.h
_TEXT	ENDS
;	COMDAT ?SetMenualStart@CAttackEvent@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bMenualStart$ = 8					; size = 4
?SetMenualStart@CAttackEvent@@QAEXH@Z PROC		; CAttackEvent::SetMenualStart, COMDAT
; _this$ = ecx

; 22   : 	void SetMenualStart(BOOL bMenualStart){this->m_bMenualStart = bMenualStart;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _bMenualStart$[ebp]
  00012	89 48 28	 mov	 DWORD PTR [eax+40], ecx
  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?SetMenualStart@CAttackEvent@@QAEXH@Z ENDP		; CAttackEvent::SetMenualStart
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\eledoradoevent.h
_TEXT	ENDS
;	COMDAT ?SetMenualStart@CEledoradoEvent@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bMenualStart$ = 8					; size = 4
?SetMenualStart@CEledoradoEvent@@QAEXH@Z PROC		; CEledoradoEvent::SetMenualStart, COMDAT
; _this$ = ecx

; 37   : 	void SetMenualStart(BOOL bMenualStart){this->m_bMenualStart = bMenualStart;}	// line : 57

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _bMenualStart$[ebp]
  00012	89 48 68	 mov	 DWORD PTR [eax+104], ecx
  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?SetMenualStart@CEledoradoEvent@@QAEXH@Z ENDP		; CEledoradoEvent::SetMenualStart
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\ringattackevent.h
_TEXT	ENDS
;	COMDAT ?SetMenualStart@CRingAttackEvent@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bMenualStart$ = 8					; size = 4
?SetMenualStart@CRingAttackEvent@@QAEXH@Z PROC		; CRingAttackEvent::SetMenualStart, COMDAT
; _this$ = ecx

; 71   : 	void SetMenualStart(BOOL bMenualStart){this->m_bMenualStart = bMenualStart;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _bMenualStart$[ebp]
  00012	89 88 54 01 00
	00		 mov	 DWORD PTR [eax+340], ecx
  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?SetMenualStart@CRingAttackEvent@@QAEXH@Z ENDP		; CRingAttackEvent::SetMenualStart
_TEXT	ENDS
PUBLIC	?StartEvent@CEventManagement@@QAEXH@Z		; CEventManagement::StartEvent
PUBLIC	??_C@_0DP@MCJNEPAH@?$KB?$NL?$KB?$NM?$FLEvent?5Management?$FN?5?$MA?L?$LK?$KF?F?$KO?$LN?C?$MA@ ; `string'
PUBLIC	??_C@_0DD@KCCAIPNL@?$KB?$NL?$KB?$NM?$FLEvent?5Management?$FN?5?$LD?$KP?B?$KF?5?$LK?$KP?$LA?f@ ; `string'
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >
PUBLIC	?empty@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QBE_NXZ ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::empty
PUBLIC	__$ArrayPad$
PUBLIC	?Run@CEventManagement@@QAEXXZ			; CEventManagement::Run
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
;	COMDAT ??_C@_0DP@MCJNEPAH@?$KB?$NL?$KB?$NM?$FLEvent?5Management?$FN?5?$MA?L?$LK?$KF?F?$KO?$LN?C?$MA@
; File d:\projects\exteam6.3\source\gameserver\gameserver\eventmanagement.cpp
CONST	SEGMENT
??_C@_0DP@MCJNEPAH@?$KB?$NL?$KB?$NM?$FLEvent?5Management?$FN?5?$MA?L?$LK?$KF?F?$KO?$LN?C?$MA@ DB 0a1H
	DB	0dbH, 0a1H, 0dcH, '[Event Management] ', 0c0H, 0ccH, 0baH, 0a5H
	DB	0c6H, 0aeH, 0bdH, 0c3H, 0c0H, 0dbH, 0c7H, 0d4H, '. (%d) %02d %'
	DB	'02d (state=%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@KCCAIPNL@?$KB?$NL?$KB?$NM?$FLEvent?5Management?$FN?5?$LD?$KP?B?$KF?5?$LK?$KP?$LA?f@
CONST	SEGMENT
??_C@_0DD@KCCAIPNL@?$KB?$NL?$KB?$NM?$FLEvent?5Management?$FN?5?$LD?$KP?B?$KF?5?$LK?$KP?$LA?f@ DB 0a1H
	DB	0dbH, 0a1H, 0dcH, '[Event Management] ', 0b3H, 0afH, 0c2H, 0a5H
	DB	' ', 0baH, 0afH, 0b0H, 0e6H, 0b5H, 0caH, '. %02d %02d %02d', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
$T227240 = -116						; size = 4
$T227241 = -112						; size = 4
$T227242 = -108						; size = 4
$T227243 = -104						; size = 4
$T227244 = -100						; size = 4
$T227245 = -96						; size = 4
_it$ = -28						; size = 4
_sysTime$ = -24						; size = 16
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?Run@CEventManagement@@QAEXXZ PROC			; CEventManagement::Run
; _this$ = ecx

; 184  : {

  007a0	55		 push	 ebp
  007a1	8b ec		 mov	 ebp, esp
  007a3	83 ec 74	 sub	 esp, 116		; 00000074H
  007a6	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  007ab	33 c5		 xor	 eax, ebp
  007ad	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  007b0	53		 push	 ebx
  007b1	56		 push	 esi
  007b2	57		 push	 edi
  007b3	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 185  : 	if ( this->m_bEventStart == false || this->m_bHasData == false || this->m_vtEventTime.empty() != FALSE )

  007b6	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  007b9	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  007bd	74 1b		 je	 SHORT $LN10@Run
  007bf	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  007c2	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  007c6	74 12		 je	 SHORT $LN10@Run
  007c8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  007cb	83 c1 0c	 add	 ecx, 12			; 0000000cH
  007ce	e8 00 00 00 00	 call	 ?empty@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QBE_NXZ ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::empty
  007d3	0f b6 c0	 movzx	 eax, al
  007d6	85 c0		 test	 eax, eax
  007d8	74 05		 je	 SHORT $LN11@Run
$LN10@Run:

; 186  : 	{
; 187  : 		return;

  007da	e9 af 01 00 00	 jmp	 $LN12@Run
$LN11@Run:

; 188  : 	}
; 189  : 
; 190  : 	SYSTEMTIME sysTime;
; 191  : 	std::vector<EVENT_ID_TIME>::iterator it;

  007df	8d 4d e4	 lea	 ecx, DWORD PTR _it$[ebp]
  007e2	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >

; 192  : 
; 193  : 	GetLocalTime(&sysTime);

  007e7	8d 45 e8	 lea	 eax, DWORD PTR _sysTime$[ebp]
  007ea	50		 push	 eax
  007eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocalTime@4

; 194  : 
; 195  : 	if ( this->m_wToday_Year != sysTime.wYear || this->m_wToday_Month != sysTime.wMonth || this->m_wToday_Day != sysTime.wDay )

  007f1	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  007f4	0f b7 48 2c	 movzx	 ecx, WORD PTR [eax+44]
  007f8	0f b7 55 e8	 movzx	 edx, WORD PTR _sysTime$[ebp]
  007fc	3b ca		 cmp	 ecx, edx
  007fe	75 22		 jne	 SHORT $LN8@Run
  00800	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00803	0f b7 48 2e	 movzx	 ecx, WORD PTR [eax+46]
  00807	0f b7 55 ea	 movzx	 edx, WORD PTR _sysTime$[ebp+2]
  0080b	3b ca		 cmp	 ecx, edx
  0080d	75 13		 jne	 SHORT $LN8@Run
  0080f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00812	0f b7 48 30	 movzx	 ecx, WORD PTR [eax+48]
  00816	0f b7 55 ee	 movzx	 edx, WORD PTR _sysTime$[ebp+6]
  0081a	3b ca		 cmp	 ecx, edx
  0081c	0f 84 98 00 00
	00		 je	 $LN9@Run
$LN8@Run:

; 196  : 	{
; 197  : 		for ( it = this->m_vtEventTime.begin() ; it != this->m_vtEventTime.end() ; it++ )

  00822	8d 45 8c	 lea	 eax, DWORD PTR $T227240[ebp]
  00825	50		 push	 eax
  00826	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00829	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0082c	e8 00 00 00 00	 call	 ?begin@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@2@XZ ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::begin
  00831	8b 08		 mov	 ecx, DWORD PTR [eax]
  00833	89 4d e4	 mov	 DWORD PTR _it$[ebp], ecx
  00836	eb 0e		 jmp	 SHORT $LN7@Run
$LN6@Run:
  00838	6a 00		 push	 0
  0083a	8d 45 90	 lea	 eax, DWORD PTR $T227241[ebp]
  0083d	50		 push	 eax
  0083e	8d 4d e4	 lea	 ecx, DWORD PTR _it$[ebp]
  00841	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator++
$LN7@Run:
  00846	8d 45 94	 lea	 eax, DWORD PTR $T227242[ebp]
  00849	50		 push	 eax
  0084a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0084d	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00850	e8 00 00 00 00	 call	 ?end@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@2@XZ ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::end
  00855	50		 push	 eax
  00856	8d 4d e4	 lea	 ecx, DWORD PTR _it$[ebp]
  00859	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator!=
  0085e	0f b6 c8	 movzx	 ecx, al
  00861	85 c9		 test	 ecx, ecx
  00863	74 0e		 je	 SHORT $LN5@Run

; 198  : 		{
; 199  : 			(*(it)).m_bEventStarted = false;

  00865	8d 4d e4	 lea	 ecx, DWORD PTR _it$[ebp]
  00868	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QBEAAUEVENT_ID_TIME@@XZ ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator*
  0086d	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 200  : 		}

  00871	eb c5		 jmp	 SHORT $LN6@Run
$LN5@Run:

; 201  : 
; 202  : 		LogAddTD("[Event Management]  . %02d %02d %02d", this->m_wToday_Year, this->m_wToday_Month, this->m_wToday_Day);

  00873	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00876	0f b7 48 30	 movzx	 ecx, WORD PTR [eax+48]
  0087a	51		 push	 ecx
  0087b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0087e	0f b7 42 2e	 movzx	 eax, WORD PTR [edx+46]
  00882	50		 push	 eax
  00883	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00886	0f b7 51 2c	 movzx	 edx, WORD PTR [ecx+44]
  0088a	52		 push	 edx
  0088b	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@KCCAIPNL@?$KB?$NL?$KB?$NM?$FLEvent?5Management?$FN?5?$LD?$KP?B?$KF?5?$LK?$KP?$LA?f@
  00890	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00896	83 c4 10	 add	 esp, 16			; 00000010H

; 203  : 
; 204  : 		this->m_wToday_Year = sysTime.wYear;

  00899	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0089c	66 8b 4d e8	 mov	 cx, WORD PTR _sysTime$[ebp]
  008a0	66 89 48 2c	 mov	 WORD PTR [eax+44], cx

; 205  : 		this->m_wToday_Month = sysTime.wMonth;

  008a4	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  008a7	66 8b 4d ea	 mov	 cx, WORD PTR _sysTime$[ebp+2]
  008ab	66 89 48 2e	 mov	 WORD PTR [eax+46], cx

; 206  : 		this->m_wToday_Day = sysTime.wDay;

  008af	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  008b2	66 8b 4d ee	 mov	 cx, WORD PTR _sysTime$[ebp+6]
  008b6	66 89 48 30	 mov	 WORD PTR [eax+48], cx
$LN9@Run:

; 207  : 	}
; 208  : 
; 209  : 	for ( it = this->m_vtEventTime.begin() ; it != this->m_vtEventTime.end() ; it++ )

  008ba	8d 45 98	 lea	 eax, DWORD PTR $T227243[ebp]
  008bd	50		 push	 eax
  008be	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  008c1	83 c1 0c	 add	 ecx, 12			; 0000000cH
  008c4	e8 00 00 00 00	 call	 ?begin@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@2@XZ ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::begin
  008c9	8b 08		 mov	 ecx, DWORD PTR [eax]
  008cb	89 4d e4	 mov	 DWORD PTR _it$[ebp], ecx
  008ce	eb 0e		 jmp	 SHORT $LN4@Run
$LN3@Run:
  008d0	6a 00		 push	 0
  008d2	8d 45 9c	 lea	 eax, DWORD PTR $T227244[ebp]
  008d5	50		 push	 eax
  008d6	8d 4d e4	 lea	 ecx, DWORD PTR _it$[ebp]
  008d9	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator++
$LN4@Run:
  008de	8d 45 a0	 lea	 eax, DWORD PTR $T227245[ebp]
  008e1	50		 push	 eax
  008e2	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  008e5	83 c1 0c	 add	 ecx, 12			; 0000000cH
  008e8	e8 00 00 00 00	 call	 ?end@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@2@XZ ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::end
  008ed	50		 push	 eax
  008ee	8d 4d e4	 lea	 ecx, DWORD PTR _it$[ebp]
  008f1	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator!=
  008f6	0f b6 c8	 movzx	 ecx, al
  008f9	85 c9		 test	 ecx, ecx
  008fb	0f 84 8d 00 00
	00		 je	 $LN12@Run

; 210  : 	{
; 211  : 		if ( sysTime.wHour == (*(it)).m_iHour && sysTime.wMinute == (*(it)).m_iMinute && (*(it)).m_bEventStarted == false )

  00901	0f b7 75 f0	 movzx	 esi, WORD PTR _sysTime$[ebp+8]
  00905	8d 4d e4	 lea	 ecx, DWORD PTR _it$[ebp]
  00908	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QBEAAUEVENT_ID_TIME@@XZ ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator*
  0090d	3b 70 04	 cmp	 esi, DWORD PTR [eax+4]
  00910	75 77		 jne	 SHORT $LN1@Run
  00912	0f b7 75 f2	 movzx	 esi, WORD PTR _sysTime$[ebp+10]
  00916	8d 4d e4	 lea	 ecx, DWORD PTR _it$[ebp]
  00919	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QBEAAUEVENT_ID_TIME@@XZ ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator*
  0091e	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  00921	75 66		 jne	 SHORT $LN1@Run
  00923	8d 4d e4	 lea	 ecx, DWORD PTR _it$[ebp]
  00926	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QBEAAUEVENT_ID_TIME@@XZ ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator*
  0092b	0f b6 40 0c	 movzx	 eax, BYTE PTR [eax+12]
  0092f	85 c0		 test	 eax, eax
  00931	75 56		 jne	 SHORT $LN1@Run

; 212  : 		{
; 213  : 			LogAddTD("[Event Management] . (%d) %02d %02d (state=%d)", (*(it)).m_eEventKind , (*(it)).m_iHour, sysTime.wMinute , (*(it)).m_bEventStarted);

  00933	8d 4d e4	 lea	 ecx, DWORD PTR _it$[ebp]
  00936	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QBEAAUEVENT_ID_TIME@@XZ ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator*
  0093b	0f b6 40 0c	 movzx	 eax, BYTE PTR [eax+12]
  0093f	50		 push	 eax
  00940	0f b7 4d f2	 movzx	 ecx, WORD PTR _sysTime$[ebp+10]
  00944	51		 push	 ecx
  00945	8d 4d e4	 lea	 ecx, DWORD PTR _it$[ebp]
  00948	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QBEAAUEVENT_ID_TIME@@XZ ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator*
  0094d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00950	52		 push	 edx
  00951	8d 4d e4	 lea	 ecx, DWORD PTR _it$[ebp]
  00954	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QBEAAUEVENT_ID_TIME@@XZ ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator*
  00959	8b 00		 mov	 eax, DWORD PTR [eax]
  0095b	50		 push	 eax
  0095c	68 00 00 00 00	 push	 OFFSET ??_C@_0DP@MCJNEPAH@?$KB?$NL?$KB?$NM?$FLEvent?5Management?$FN?5?$MA?L?$LK?$KF?F?$KO?$LN?C?$MA@
  00961	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00967	83 c4 14	 add	 esp, 20			; 00000014H

; 214  : 
; 215  : 			(*(it)).m_bEventStarted = true;

  0096a	8d 4d e4	 lea	 ecx, DWORD PTR _it$[ebp]
  0096d	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QBEAAUEVENT_ID_TIME@@XZ ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator*
  00972	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 216  : 			this->StartEvent((*(it)).m_eEventKind);

  00976	8d 4d e4	 lea	 ecx, DWORD PTR _it$[ebp]
  00979	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QBEAAUEVENT_ID_TIME@@XZ ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator*
  0097e	8b 00		 mov	 eax, DWORD PTR [eax]
  00980	50		 push	 eax
  00981	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00984	e8 00 00 00 00	 call	 ?StartEvent@CEventManagement@@QAEXH@Z ; CEventManagement::StartEvent
$LN1@Run:

; 217  : 		}
; 218  : 	}

  00989	e9 42 ff ff ff	 jmp	 $LN3@Run
$LN12@Run:

; 219  : }

  0098e	5f		 pop	 edi
  0098f	5e		 pop	 esi
  00990	5b		 pop	 ebx
  00991	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00994	33 cd		 xor	 ecx, ebp
  00996	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0099b	8b e5		 mov	 esp, ebp
  0099d	5d		 pop	 ebp
  0099e	c3		 ret	 0
?Run@CEventManagement@@QAEXXZ ENDP			; CEventManagement::Run
_TEXT	ENDS
EXTRN	?Start_Menual@CRingAttackEvent@@QAEXXZ:PROC	; CRingAttackEvent::Start_Menual
EXTRN	?Start_Menual@CEledoradoEvent@@QAEXXZ:PROC	; CEledoradoEvent::Start_Menual
EXTRN	?Start_Menual@CAttackEvent@@QAEXXZ:PROC		; CAttackEvent::Start_Menual
EXTRN	?Start_Menual@CDragonEvent@@QAEXXZ:PROC		; CDragonEvent::Start_Menual
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv64 = -152						; size = 4
$T227247 = -148						; size = 4
$T227248 = -144						; size = 4
$T227249 = -140						; size = 4
$T227250 = -136						; size = 4
$T227251 = -132						; size = 4
$T227252 = -128						; size = 4
$T227253 = -124						; size = 4
$T227254 = -120						; size = 4
$T227255 = -116						; size = 4
$T227256 = -112						; size = 4
_lpEvent$224255 = -44					; size = 4
__Itor$224250 = -40					; size = 4
_lpEvent$224234 = -36					; size = 4
__Itor$224229 = -32					; size = 4
_lpEvent$224213 = -28					; size = 4
__Itor$224208 = -24					; size = 4
_lpEvent$224192 = -20					; size = 4
__Itor$224187 = -16					; size = 4
_lpEvent$224171 = -12					; size = 4
__Itor$224166 = -8					; size = 4
_this$ = -4						; size = 4
_eEventKind$ = 8					; size = 4
?StartEvent@CEventManagement@@QAEXH@Z PROC		; CEventManagement::StartEvent
; _this$ = ecx

; 222  : {

  009a0	55		 push	 ebp
  009a1	8b ec		 mov	 ebp, esp
  009a3	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H
  009a9	53		 push	 ebx
  009aa	56		 push	 esi
  009ab	57		 push	 edi
  009ac	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 223  : 	switch ( eEventKind )

  009af	8b 45 08	 mov	 eax, DWORD PTR _eEventKind$[ebp]
  009b2	89 85 68 ff ff
	ff		 mov	 DWORD PTR tv64[ebp], eax
  009b8	83 bd 68 ff ff
	ff 04		 cmp	 DWORD PTR tv64[ebp], 4
  009bf	0f 87 c6 01 00
	00		 ja	 $LN13@StartEvent
  009c5	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR tv64[ebp]
  009cb	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN15@StartEvent[ecx*4]
$LN10@StartEvent:

; 224  : 	{
; 225  : 		case EVENT_ID_DRAGONHERD:
; 226  : 			{
; 227  : 				std::map<int, void *>::iterator _Itor = this->m_mapEventObj.find(EVENT_ID_DRAGONHERD);

  009d2	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T227247[ebp], 0
  009dc	8d 85 6c ff ff
	ff		 lea	 eax, DWORD PTR $T227247[ebp]
  009e2	50		 push	 eax
  009e3	8d 4d f8	 lea	 ecx, DWORD PTR __Itor$224166[ebp]
  009e6	51		 push	 ecx
  009e7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  009ea	83 c1 1c	 add	 ecx, 28			; 0000001cH
  009ed	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::find

; 228  : 
; 229  : 				if ( _Itor != this->m_mapEventObj.end() )

  009f2	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR $T227248[ebp]
  009f8	50		 push	 eax
  009f9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  009fc	83 c1 1c	 add	 ecx, 28			; 0000001cH
  009ff	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::end
  00a04	50		 push	 eax
  00a05	8d 4d f8	 lea	 ecx, DWORD PTR __Itor$224166[ebp]
  00a08	e8 00 00 00 00	 call	 ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator!=
  00a0d	0f b6 c8	 movzx	 ecx, al
  00a10	85 c9		 test	 ecx, ecx
  00a12	74 16		 je	 SHORT $LN9@StartEvent

; 230  : 				{
; 231  : 					CDragonEvent * lpEvent = (CDragonEvent *)_Itor->second;

  00a14	8d 4d f8	 lea	 ecx, DWORD PTR __Itor$224166[ebp]
  00a17	e8 00 00 00 00	 call	 ??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHPAX@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator->
  00a1c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00a1f	89 45 f4	 mov	 DWORD PTR _lpEvent$224171[ebp], eax

; 232  : 					lpEvent->Start_Menual();

  00a22	8b 4d f4	 mov	 ecx, DWORD PTR _lpEvent$224171[ebp]
  00a25	e8 00 00 00 00	 call	 ?Start_Menual@CDragonEvent@@QAEXXZ ; CDragonEvent::Start_Menual
$LN9@StartEvent:

; 233  : 				}
; 234  : 			}
; 235  : 			break;

  00a2a	e9 5c 01 00 00	 jmp	 $LN13@StartEvent
$LN8@StartEvent:

; 236  : 
; 237  : 		case EVENT_ID_UNDERTROOP:
; 238  : 			{
; 239  : 				std::map<int, void *>::iterator _Itor = this->m_mapEventObj.find(EVENT_ID_UNDERTROOP);

  00a2f	c7 85 74 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR $T227249[ebp], 1
  00a39	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR $T227249[ebp]
  00a3f	50		 push	 eax
  00a40	8d 4d f0	 lea	 ecx, DWORD PTR __Itor$224187[ebp]
  00a43	51		 push	 ecx
  00a44	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a47	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00a4a	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::find

; 240  : 
; 241  : 				if ( _Itor != this->m_mapEventObj.end() )

  00a4f	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR $T227250[ebp]
  00a55	50		 push	 eax
  00a56	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a59	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00a5c	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::end
  00a61	50		 push	 eax
  00a62	8d 4d f0	 lea	 ecx, DWORD PTR __Itor$224187[ebp]
  00a65	e8 00 00 00 00	 call	 ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator!=
  00a6a	0f b6 c8	 movzx	 ecx, al
  00a6d	85 c9		 test	 ecx, ecx
  00a6f	74 16		 je	 SHORT $LN7@StartEvent

; 242  : 				{
; 243  : 					CAttackEvent * lpEvent = (CAttackEvent *)_Itor->second;

  00a71	8d 4d f0	 lea	 ecx, DWORD PTR __Itor$224187[ebp]
  00a74	e8 00 00 00 00	 call	 ??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHPAX@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator->
  00a79	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00a7c	89 45 ec	 mov	 DWORD PTR _lpEvent$224192[ebp], eax

; 244  : 					lpEvent->Start_Menual();

  00a7f	8b 4d ec	 mov	 ecx, DWORD PTR _lpEvent$224192[ebp]
  00a82	e8 00 00 00 00	 call	 ?Start_Menual@CAttackEvent@@QAEXXZ ; CAttackEvent::Start_Menual
$LN7@StartEvent:

; 245  : 				}
; 246  : 			}
; 247  : 			break;

  00a87	e9 ff 00 00 00	 jmp	 $LN13@StartEvent
$LN6@StartEvent:

; 248  : 
; 249  : 		case EVENT_ID_ELDORADO:
; 250  : 			{
; 251  : 				std::map<int, void *>::iterator _Itor = this->m_mapEventObj.find(EVENT_ID_ELDORADO);

  00a8c	c7 85 7c ff ff
	ff 02 00 00 00	 mov	 DWORD PTR $T227251[ebp], 2
  00a96	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR $T227251[ebp]
  00a9c	50		 push	 eax
  00a9d	8d 4d e8	 lea	 ecx, DWORD PTR __Itor$224208[ebp]
  00aa0	51		 push	 ecx
  00aa1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00aa4	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00aa7	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::find

; 252  : 
; 253  : 				if ( _Itor != this->m_mapEventObj.end() )

  00aac	8d 45 80	 lea	 eax, DWORD PTR $T227252[ebp]
  00aaf	50		 push	 eax
  00ab0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00ab3	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00ab6	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::end
  00abb	50		 push	 eax
  00abc	8d 4d e8	 lea	 ecx, DWORD PTR __Itor$224208[ebp]
  00abf	e8 00 00 00 00	 call	 ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator!=
  00ac4	0f b6 c8	 movzx	 ecx, al
  00ac7	85 c9		 test	 ecx, ecx
  00ac9	74 16		 je	 SHORT $LN5@StartEvent

; 254  : 				{
; 255  : 					CEledoradoEvent * lpEvent = (CEledoradoEvent *)_Itor->second;

  00acb	8d 4d e8	 lea	 ecx, DWORD PTR __Itor$224208[ebp]
  00ace	e8 00 00 00 00	 call	 ??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHPAX@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator->
  00ad3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00ad6	89 45 e4	 mov	 DWORD PTR _lpEvent$224213[ebp], eax

; 256  : 					lpEvent->Start_Menual();

  00ad9	8b 4d e4	 mov	 ecx, DWORD PTR _lpEvent$224213[ebp]
  00adc	e8 00 00 00 00	 call	 ?Start_Menual@CEledoradoEvent@@QAEXXZ ; CEledoradoEvent::Start_Menual
$LN5@StartEvent:

; 257  : 				}
; 258  : 			}
; 259  : 			break;

  00ae1	e9 a5 00 00 00	 jmp	 $LN13@StartEvent
$LN4@StartEvent:

; 260  : 
; 261  : 		case EVENT_ID_WHITEMAGE:
; 262  : 			{
; 263  : 				std::map<int, void *>::iterator _Itor = this->m_mapEventObj.find(EVENT_ID_WHITEMAGE);

  00ae6	c7 45 84 03 00
	00 00		 mov	 DWORD PTR $T227253[ebp], 3
  00aed	8d 45 84	 lea	 eax, DWORD PTR $T227253[ebp]
  00af0	50		 push	 eax
  00af1	8d 4d e0	 lea	 ecx, DWORD PTR __Itor$224229[ebp]
  00af4	51		 push	 ecx
  00af5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00af8	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00afb	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::find

; 264  : 
; 265  : 				if ( _Itor != this->m_mapEventObj.end() )

  00b00	8d 45 88	 lea	 eax, DWORD PTR $T227254[ebp]
  00b03	50		 push	 eax
  00b04	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00b07	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00b0a	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::end
  00b0f	50		 push	 eax
  00b10	8d 4d e0	 lea	 ecx, DWORD PTR __Itor$224229[ebp]
  00b13	e8 00 00 00 00	 call	 ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator!=
  00b18	0f b6 c8	 movzx	 ecx, al
  00b1b	85 c9		 test	 ecx, ecx
  00b1d	74 16		 je	 SHORT $LN3@StartEvent

; 266  : 				{
; 267  : 					CRingAttackEvent * lpEvent = (CRingAttackEvent *)_Itor->second;

  00b1f	8d 4d e0	 lea	 ecx, DWORD PTR __Itor$224229[ebp]
  00b22	e8 00 00 00 00	 call	 ??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHPAX@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator->
  00b27	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00b2a	89 45 dc	 mov	 DWORD PTR _lpEvent$224234[ebp], eax

; 268  : 					lpEvent->Start_Menual();

  00b2d	8b 4d dc	 mov	 ecx, DWORD PTR _lpEvent$224234[ebp]
  00b30	e8 00 00 00 00	 call	 ?Start_Menual@CRingAttackEvent@@QAEXXZ ; CRingAttackEvent::Start_Menual
$LN3@StartEvent:

; 269  : 				}
; 270  : 			}
; 271  : 			break;

  00b35	eb 54		 jmp	 SHORT $LN13@StartEvent
$LN2@StartEvent:

; 272  : 
; 273  : 		case EVENT_ID_XMASATTACK:
; 274  : 			{
; 275  : 				std::map<int, void *>::iterator _Itor = this->m_mapEventObj.find(EVENT_ID_XMASATTACK);

  00b37	c7 45 8c 04 00
	00 00		 mov	 DWORD PTR $T227255[ebp], 4
  00b3e	8d 45 8c	 lea	 eax, DWORD PTR $T227255[ebp]
  00b41	50		 push	 eax
  00b42	8d 4d d8	 lea	 ecx, DWORD PTR __Itor$224250[ebp]
  00b45	51		 push	 ecx
  00b46	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00b49	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00b4c	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::find

; 276  : 
; 277  : 				if ( _Itor != this->m_mapEventObj.end() )

  00b51	8d 45 90	 lea	 eax, DWORD PTR $T227256[ebp]
  00b54	50		 push	 eax
  00b55	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00b58	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00b5b	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::end
  00b60	50		 push	 eax
  00b61	8d 4d d8	 lea	 ecx, DWORD PTR __Itor$224250[ebp]
  00b64	e8 00 00 00 00	 call	 ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator!=
  00b69	0f b6 c8	 movzx	 ecx, al
  00b6c	85 c9		 test	 ecx, ecx
  00b6e	74 1b		 je	 SHORT $LN13@StartEvent

; 278  : 				{
; 279  : 					CXMasAttackEvent * lpEvent = (CXMasAttackEvent *)_Itor->second;

  00b70	8d 4d d8	 lea	 ecx, DWORD PTR __Itor$224250[ebp]
  00b73	e8 00 00 00 00	 call	 ??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHPAX@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator->
  00b78	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00b7b	89 45 d4	 mov	 DWORD PTR _lpEvent$224255[ebp], eax

; 280  : 					lpEvent->Start_Menual();

  00b7e	8b 45 d4	 mov	 eax, DWORD PTR _lpEvent$224255[ebp]
  00b81	8b 10		 mov	 edx, DWORD PTR [eax]
  00b83	8b 4d d4	 mov	 ecx, DWORD PTR _lpEvent$224255[ebp]
  00b86	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00b89	ff d0		 call	 eax
$LN13@StartEvent:

; 281  : 				}
; 282  : 			}
; 283  : 			break;
; 284  : 	}
; 285  : }

  00b8b	5f		 pop	 edi
  00b8c	5e		 pop	 esi
  00b8d	5b		 pop	 ebx
  00b8e	8b e5		 mov	 esp, ebp
  00b90	5d		 pop	 ebp
  00b91	c2 04 00	 ret	 4
$LN15@StartEvent:
  00b94	00 00 00 00	 DD	 $LN10@StartEvent
  00b98	00 00 00 00	 DD	 $LN8@StartEvent
  00b9c	00 00 00 00	 DD	 $LN6@StartEvent
  00ba0	00 00 00 00	 DD	 $LN4@StartEvent
  00ba4	00 00 00 00	 DD	 $LN2@StartEvent
?StartEvent@CEventManagement@@QAEXH@Z ENDP		; CEventManagement::StartEvent
_TEXT	ENDS
PUBLIC	??_C@_0BF@ENKDDIBD@?$FLDOTH?$FN?5?$CFs?5file?5load?$CB?$AA@ ; `string'
PUBLIC	?push_back@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAEXABUEVENT_ID_TIME@@@Z ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::push_back
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	??_C@_0CA@JEMAOPLJ@?$FLDOTH?$FN?5Info?5file?5Load?5Fail?5?$FL?$CFs?$FN?$AA@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?Load@CEventManagement@@QAE_NPAD@Z		; CEventManagement::Load
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	_fclose:PROC
EXTRN	_strcmp:PROC
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	_fopen:PROC
EXTRN	__ftol2_sse:PROC
_BSS	SEGMENT
_TokenString DB	064H DUP (?)
_TokenNumber DD	01H DUP (?)
_SMDFile DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BF@ENKDDIBD@?$FLDOTH?$FN?5?$CFs?5file?5load?$CB?$AA@
CONST	SEGMENT
??_C@_0BF@ENKDDIBD@?$FLDOTH?$FN?5?$CFs?5file?5load?$CB?$AA@ DB '[DOTH] %s'
	DB	' file load!', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JEMAOPLJ@?$FLDOTH?$FN?5Info?5file?5Load?5Fail?5?$FL?$CFs?$FN?$AA@
CONST	SEGMENT
??_C@_0CA@JEMAOPLJ@?$FLDOTH?$FN?5Info?5file?5Load?5Fail?5?$FL?$CFs?$FN?$AA@ DB '['
	DB	'DOTH] Info file Load Fail [%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_EIT$224277 = -32					; size = 16
_type$ = -16						; size = 4
_Token$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpszFileName$ = 8					; size = 4
?Load@CEventManagement@@QAE_NPAD@Z PROC			; CEventManagement::Load
; _this$ = ecx

; 288  : {

  00bb0	55		 push	 ebp
  00bb1	8b ec		 mov	 ebp, esp
  00bb3	83 ec 60	 sub	 esp, 96			; 00000060H
  00bb6	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00bbb	33 c5		 xor	 eax, ebp
  00bbd	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00bc0	53		 push	 ebx
  00bc1	56		 push	 esi
  00bc2	57		 push	 edi
  00bc3	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 289  : 	this->m_bHasData = false;

  00bc6	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00bc9	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 290  : 	this->Clear();

  00bd0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00bd3	e8 00 00 00 00	 call	 ?Clear@CEventManagement@@QAEXXZ ; CEventManagement::Clear

; 291  : 
; 292  : 	SMDFile = fopen(lpszFileName, "r");

  00bd8	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  00bdd	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  00be0	50		 push	 eax
  00be1	e8 00 00 00 00	 call	 _fopen
  00be6	83 c4 08	 add	 esp, 8
  00be9	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax

; 293  : 
; 294  : 	if ( SMDFile == NULL )

  00bee	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SMDFile, 0
  00bf5	75 18		 jne	 SHORT $LN8@Load

; 295  : 	{
; 296  : 		MsgBox("[DOTH] Info file Load Fail [%s]", lpszFileName);

  00bf7	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  00bfa	50		 push	 eax
  00bfb	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@JEMAOPLJ@?$FLDOTH?$FN?5Info?5file?5Load?5Fail?5?$FL?$CFs?$FN?$AA@
  00c00	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00c05	83 c4 08	 add	 esp, 8

; 297  : 
; 298  : 		return false;

  00c08	32 c0		 xor	 al, al
  00c0a	e9 e4 00 00 00	 jmp	 $LN9@Load
$LN8@Load:

; 299  : 	}
; 300  : 
; 301  : 	int Token;
; 302  : 	int type = -1;

  00c0f	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _type$[ebp], -1
$LN7@Load:

; 303  : 
; 304  : 	while ( true )

  00c16	b8 01 00 00 00	 mov	 eax, 1
  00c1b	85 c0		 test	 eax, eax
  00c1d	0f 84 a4 00 00
	00		 je	 $LN6@Load

; 305  : 	{
; 306  : 		Token = GetToken();

  00c23	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00c28	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 307  : 
; 308  : 		if ( Token == 2 )

  00c2b	83 7d f4 02	 cmp	 DWORD PTR _Token$[ebp], 2
  00c2f	75 05		 jne	 SHORT $LN5@Load

; 309  : 		{
; 310  : 			break;

  00c31	e9 91 00 00 00	 jmp	 $LN6@Load
$LN5@Load:

; 311  : 		}
; 312  : 
; 313  : 		type = (int)TokenNumber;

  00c36	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00c3c	e8 00 00 00 00	 call	 __ftol2_sse
  00c41	89 45 f0	 mov	 DWORD PTR _type$[ebp], eax
$LN4@Load:

; 314  : 
; 315  : 		while ( true )

  00c44	b8 01 00 00 00	 mov	 eax, 1
  00c49	85 c0		 test	 eax, eax
  00c4b	74 75		 je	 SHORT $LN3@Load

; 316  : 		{
; 317  : 			if ( type == 0 )

  00c4d	83 7d f0 00	 cmp	 DWORD PTR _type$[ebp], 0
  00c51	75 6d		 jne	 SHORT $LN2@Load

; 318  : 			{
; 319  : 				Token = GetToken();

  00c53	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00c58	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 320  : 
; 321  : 				if ( strcmp("end", TokenString) == 0 )

  00c5b	68 00 00 00 00	 push	 OFFSET _TokenString
  00c60	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  00c65	e8 00 00 00 00	 call	 _strcmp
  00c6a	83 c4 08	 add	 esp, 8
  00c6d	85 c0		 test	 eax, eax
  00c6f	75 02		 jne	 SHORT $LN1@Load

; 322  : 				{
; 323  : 					break;

  00c71	eb 4f		 jmp	 SHORT $LN3@Load
$LN1@Load:

; 324  : 				}
; 325  : 
; 326  : 				EVENT_ID_TIME EIT;
; 327  : 
; 328  : 				EIT.m_eEventKind = (int)TokenNumber;

  00c73	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00c79	e8 00 00 00 00	 call	 __ftol2_sse
  00c7e	89 45 e0	 mov	 DWORD PTR _EIT$224277[ebp], eax

; 329  : 
; 330  : 				Token = GetToken();

  00c81	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00c86	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 331  : 				EIT.m_iHour = (int)TokenNumber;

  00c89	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00c8f	e8 00 00 00 00	 call	 __ftol2_sse
  00c94	89 45 e4	 mov	 DWORD PTR _EIT$224277[ebp+4], eax

; 332  : 
; 333  : 				Token = GetToken();

  00c97	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00c9c	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 334  : 				EIT.m_iMinute = (int)TokenNumber;

  00c9f	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00ca5	e8 00 00 00 00	 call	 __ftol2_sse
  00caa	89 45 e8	 mov	 DWORD PTR _EIT$224277[ebp+8], eax

; 335  : 
; 336  : 				EIT.m_bEventStarted = false;

  00cad	c6 45 ec 00	 mov	 BYTE PTR _EIT$224277[ebp+12], 0

; 337  : 
; 338  : 				this->m_vtEventTime.push_back(EIT);

  00cb1	8d 45 e0	 lea	 eax, DWORD PTR _EIT$224277[ebp]
  00cb4	50		 push	 eax
  00cb5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00cb8	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00cbb	e8 00 00 00 00	 call	 ?push_back@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAEXABUEVENT_ID_TIME@@@Z ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::push_back
$LN2@Load:

; 339  : 			}
; 340  : 		}

  00cc0	eb 82		 jmp	 SHORT $LN4@Load
$LN3@Load:

; 341  : 	}

  00cc2	e9 4f ff ff ff	 jmp	 $LN7@Load
$LN6@Load:

; 342  : 
; 343  : 	fclose(SMDFile);

  00cc7	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00ccc	50		 push	 eax
  00ccd	e8 00 00 00 00	 call	 _fclose
  00cd2	83 c4 04	 add	 esp, 4

; 344  : 	LogAdd("[DOTH] %s file load!", lpszFileName);

  00cd5	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  00cd8	50		 push	 eax
  00cd9	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@ENKDDIBD@?$FLDOTH?$FN?5?$CFs?5file?5load?$CB?$AA@
  00cde	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00ce4	83 c4 08	 add	 esp, 8

; 345  : 
; 346  : 	this->m_bHasData = true;

  00ce7	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00cea	c7 40 08 01 00
	00 00		 mov	 DWORD PTR [eax+8], 1

; 347  : 
; 348  : 	return true;

  00cf1	b0 01		 mov	 al, 1
$LN9@Load:

; 349  : }

  00cf3	5f		 pop	 edi
  00cf4	5e		 pop	 esi
  00cf5	5b		 pop	 ebx
  00cf6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00cf9	33 cd		 xor	 ecx, ebp
  00cfb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00d00	8b e5		 mov	 esp, ebp
  00d02	5d		 pop	 ebp
  00d03	c2 04 00	 ret	 4
?Load@CEventManagement@@QAE_NPAD@Z ENDP			; CEventManagement::Load
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_isalnum:PROC
EXTRN	_isalpha:PROC
EXTRN	_atof:PROC
EXTRN	_isdigit:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_isspace:PROC
EXTRN	_fgetc:PROC
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_CurrentToken DD 01H DUP (?)
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\include\readscript.h
_BSS	ENDS
_TEXT	SEGMENT
tv90 = -180						; size = 4
_TempString$ = -112					; size = 100
_p$ = -12						; size = 4
_ch$ = -5						; size = 1
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken

; 24   : {

  00d10	55		 push	 ebp
  00d11	8b ec		 mov	 ebp, esp
  00d13	81 ec b4 00 00
	00		 sub	 esp, 180		; 000000b4H
  00d19	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00d1e	33 c5		 xor	 eax, ebp
  00d20	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00d23	53		 push	 ebx
  00d24	56		 push	 esi
  00d25	57		 push	 edi

; 25   : 	char ch;
; 26   : 	char* p;
; 27   : 	char TempString[100];
; 28   : 
; 29   : 	TokenString[0]=0;

  00d26	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _TokenString, 0
$LN31@GetToken:

; 30   : 
; 31   : 	do
; 32   : 	{
; 33   : 		if ((ch=fgetc(SMDFile)) == -1)

  00d2d	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00d32	50		 push	 eax
  00d33	e8 00 00 00 00	 call	 _fgetc
  00d38	83 c4 04	 add	 esp, 4
  00d3b	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00d3e	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00d42	83 f9 ff	 cmp	 ecx, -1
  00d45	75 0c		 jne	 SHORT $LN28@GetToken

; 34   : 		{
; 35   : 			return END;	// End of FILE (EOF)

  00d47	b8 02 00 00 00	 mov	 eax, 2
  00d4c	e9 f7 02 00 00	 jmp	 $LN32@GetToken

; 36   : 		}
; 37   : 		else

  00d51	eb 5b		 jmp	 SHORT $LN22@GetToken
$LN28@GetToken:

; 38   : 		{	
; 39   : 			if (ch=='/')		// this is /

  00d53	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00d57	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  00d5a	75 52		 jne	 SHORT $LN22@GetToken

; 40   : 			{
; 41   : 				if((ch=fgetc(SMDFile)) == '/')

  00d5c	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00d61	50		 push	 eax
  00d62	e8 00 00 00 00	 call	 _fgetc
  00d67	83 c4 04	 add	 esp, 4
  00d6a	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00d6d	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00d71	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  00d74	75 38		 jne	 SHORT $LN22@GetToken
$LN24@GetToken:

; 42   : 				{
; 43   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  00d76	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00d7a	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00d7d	74 1c		 je	 SHORT $LN23@GetToken
  00d7f	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00d83	83 f8 ff	 cmp	 eax, -1
  00d86	74 13		 je	 SHORT $LN23@GetToken

; 44   : 					{
; 45   : 						ch=fgetc(SMDFile);

  00d88	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00d8d	50		 push	 eax
  00d8e	e8 00 00 00 00	 call	 _fgetc
  00d93	83 c4 04	 add	 esp, 4
  00d96	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al

; 46   : 					}

  00d99	eb db		 jmp	 SHORT $LN24@GetToken
$LN23@GetToken:

; 47   : 	
; 48   : 					if (ch == -1)

  00d9b	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00d9f	83 f8 ff	 cmp	 eax, -1
  00da2	75 0a		 jne	 SHORT $LN22@GetToken

; 49   : 					{
; 50   : 						return END;	// End of FILE

  00da4	b8 02 00 00 00	 mov	 eax, 2
  00da9	e9 9a 02 00 00	 jmp	 $LN32@GetToken
$LN22@GetToken:

; 51   : 					}
; 52   : 				}
; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : 	while (isspace(ch) != 0);

  00dae	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00db2	50		 push	 eax
  00db3	e8 00 00 00 00	 call	 _isspace
  00db8	83 c4 04	 add	 esp, 4
  00dbb	85 c0		 test	 eax, eax
  00dbd	0f 85 6a ff ff
	ff		 jne	 $LN31@GetToken

; 57   : 
; 58   : 	
; 59   : 	switch(ch)

  00dc3	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00dc7	89 85 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], eax
  00dcd	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR tv90[ebp]
  00dd3	83 e9 22	 sub	 ecx, 34			; 00000022H
  00dd6	89 8d 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], ecx
  00ddc	83 bd 4c ff ff
	ff 5b		 cmp	 DWORD PTR tv90[ebp], 91	; 0000005bH
  00de3	0f 87 a3 01 00
	00		 ja	 $LN6@GetToken
  00de9	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR tv90[ebp]
  00def	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN34@GetToken[edx]
  00df6	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN35@GetToken[eax*4]
$LN19@GetToken:

; 60   : 	{
; 61   : 
; 62   : 	case 0x23:	// #
; 63   : 		return CurrentToken=COMMAND;

  00dfd	c7 05 00 00 00
	00 23 00 00 00	 mov	 DWORD PTR _CurrentToken, 35 ; 00000023H
  00e07	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00e0c	e9 37 02 00 00	 jmp	 $LN32@GetToken

; 64   : 		break;

  00e11	e9 30 02 00 00	 jmp	 $LN20@GetToken
$LN18@GetToken:

; 65   : 	
; 66   : 	case 0x3B:	// ;
; 67   : 		return CurrentToken=SEMICOLON;

  00e16	c7 05 00 00 00
	00 3b 00 00 00	 mov	 DWORD PTR _CurrentToken, 59 ; 0000003bH
  00e20	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00e25	e9 1e 02 00 00	 jmp	 $LN32@GetToken

; 68   : 		break;

  00e2a	e9 17 02 00 00	 jmp	 $LN20@GetToken
$LN17@GetToken:

; 69   : 	
; 70   : 	case 0x2C:	// ,
; 71   : 
; 72   : 		return CurrentToken=COMMA;

  00e2f	c7 05 00 00 00
	00 2c 00 00 00	 mov	 DWORD PTR _CurrentToken, 44 ; 0000002cH
  00e39	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00e3e	e9 05 02 00 00	 jmp	 $LN32@GetToken

; 73   : 		break;

  00e43	e9 fe 01 00 00	 jmp	 $LN20@GetToken
$LN16@GetToken:

; 74   : 	
; 75   : 	case 0x7B:	// {
; 76   : 		return CurrentToken = LP;

  00e48	c7 05 00 00 00
	00 7b 00 00 00	 mov	 DWORD PTR _CurrentToken, 123 ; 0000007bH
  00e52	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00e57	e9 ec 01 00 00	 jmp	 $LN32@GetToken

; 77   : 		break;

  00e5c	e9 e5 01 00 00	 jmp	 $LN20@GetToken
$LN15@GetToken:

; 78   : 
; 79   : 	case 0x7D:	// }
; 80   : 		return CurrentToken = RP;

  00e61	c7 05 00 00 00
	00 7d 00 00 00	 mov	 DWORD PTR _CurrentToken, 125 ; 0000007dH
  00e6b	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00e70	e9 d3 01 00 00	 jmp	 $LN32@GetToken

; 81   : 		break;

  00e75	e9 cc 01 00 00	 jmp	 $LN20@GetToken
$LN14@GetToken:

; 82   : 	// Nice Index Table :)	by Deathway
; 83   : 	// Numbers Case
; 84   : 	case 0x2D:	//-
; 85   : 	case 0x2E:	//.
; 86   : 	case '0':	//0
; 87   : 	case '1':	//1
; 88   : 	case '2':	//2
; 89   : 	case '3':	//3
; 90   : 	case '4':	//4		
; 91   : 	case '5':	//5
; 92   : 	case '6':	//6
; 93   : 	case '7':	//7
; 94   : 	case '8':	//8
; 95   : 	case '9':	//9
; 96   : 		ungetc(ch, SMDFile);

  00e7a	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00e7f	50		 push	 eax
  00e80	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00e84	51		 push	 ecx
  00e85	e8 00 00 00 00	 call	 _ungetc
  00e8a	83 c4 08	 add	 esp, 8

; 97   : 		p = TempString;

  00e8d	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  00e90	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN13@GetToken:

; 98   : 		
; 99   : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  00e93	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00e98	50		 push	 eax
  00e99	e8 00 00 00 00	 call	 _getc
  00e9e	83 c4 04	 add	 esp, 4
  00ea1	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00ea4	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00ea8	83 f9 ff	 cmp	 ecx, -1
  00eab	74 36		 je	 SHORT $LN12@GetToken
  00ead	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00eb1	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  00eb4	74 1a		 je	 SHORT $LN11@GetToken
  00eb6	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00eba	50		 push	 eax
  00ebb	e8 00 00 00 00	 call	 _isdigit
  00ec0	83 c4 04	 add	 esp, 4
  00ec3	85 c0		 test	 eax, eax
  00ec5	75 09		 jne	 SHORT $LN11@GetToken
  00ec7	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00ecb	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00ece	75 13		 jne	 SHORT $LN12@GetToken
$LN11@GetToken:

; 100  : 		{
; 101  : 			*p = ch;	// Construct a String

  00ed0	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00ed3	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00ed6	88 08		 mov	 BYTE PTR [eax], cl

; 102  : 			p++;

  00ed8	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00edb	83 c0 01	 add	 eax, 1
  00ede	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 103  : 		}		

  00ee1	eb b0		 jmp	 SHORT $LN13@GetToken
$LN12@GetToken:

; 104  : 		*p = 0;

  00ee3	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00ee6	c6 00 00	 mov	 BYTE PTR [eax], 0

; 105  : 		TokenNumber = atof( TempString);	// Select the first Byte as Main ID

  00ee9	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  00eec	50		 push	 eax
  00eed	e8 00 00 00 00	 call	 _atof
  00ef2	83 c4 04	 add	 esp, 4
  00ef5	d9 1d 00 00 00
	00		 fstp	 DWORD PTR _TokenNumber

; 106  : 		return CurrentToken  = NUMBER ;

  00efb	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CurrentToken, 1
  00f05	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00f0a	e9 39 01 00 00	 jmp	 $LN32@GetToken

; 107  : 		break;

  00f0f	e9 32 01 00 00	 jmp	 $LN20@GetToken
$LN10@GetToken:

; 108  : 
; 109  : 	case '\"':	// "	String Case
; 110  : 		p=&TokenString[0];

  00f14	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString
$LN9@GetToken:

; 111  : 		
; 112  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  00f1b	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00f20	50		 push	 eax
  00f21	e8 00 00 00 00	 call	 _getc
  00f26	83 c4 04	 add	 esp, 4
  00f29	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00f2c	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00f30	83 f9 ff	 cmp	 ecx, -1
  00f33	74 1c		 je	 SHORT $LN8@GetToken
  00f35	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00f39	83 f8 22	 cmp	 eax, 34			; 00000022H
  00f3c	74 13		 je	 SHORT $LN8@GetToken

; 113  : 		{
; 114  : 			*p = ch;

  00f3e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00f41	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00f44	88 08		 mov	 BYTE PTR [eax], cl

; 115  : 			p++;

  00f46	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00f49	83 c0 01	 add	 eax, 1
  00f4c	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 116  : 		}

  00f4f	eb ca		 jmp	 SHORT $LN9@GetToken
$LN8@GetToken:

; 117  : 		if (ch != 0x22 )

  00f51	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00f55	83 f8 22	 cmp	 eax, 34			; 00000022H
  00f58	74 13		 je	 SHORT $LN7@GetToken

; 118  : 		{
; 119  : 			ungetc(ch, SMDFile);

  00f5a	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00f5f	50		 push	 eax
  00f60	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00f64	51		 push	 ecx
  00f65	e8 00 00 00 00	 call	 _ungetc
  00f6a	83 c4 08	 add	 esp, 8
$LN7@GetToken:

; 120  : 		}
; 121  : 		*p = 0;

  00f6d	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00f70	c6 00 00	 mov	 BYTE PTR [eax], 0

; 122  : 		return CurrentToken = NAME;

  00f73	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0
  00f7d	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00f82	e9 c1 00 00 00	 jmp	 $LN32@GetToken

; 123  : 		break;

  00f87	e9 ba 00 00 00	 jmp	 $LN20@GetToken
$LN6@GetToken:

; 124  : 
; 125  : 	default:	// Others
; 126  : 		if (isalpha(ch))

  00f8c	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00f90	50		 push	 eax
  00f91	e8 00 00 00 00	 call	 _isalpha
  00f96	83 c4 04	 add	 esp, 4
  00f99	85 c0		 test	 eax, eax
  00f9b	0f 84 94 00 00
	00		 je	 $LN5@GetToken

; 127  : 		{
; 128  : 			p=&TokenString[0];

  00fa1	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString

; 129  : 			*p=ch;

  00fa8	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00fab	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00fae	88 08		 mov	 BYTE PTR [eax], cl

; 130  : 			p++;

  00fb0	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00fb3	83 c0 01	 add	 eax, 1
  00fb6	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN4@GetToken:

; 131  : 
; 132  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  00fb9	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00fbe	50		 push	 eax
  00fbf	e8 00 00 00 00	 call	 _getc
  00fc4	83 c4 04	 add	 esp, 4
  00fc7	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00fca	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00fce	83 f9 ff	 cmp	 ecx, -1
  00fd1	74 36		 je	 SHORT $LN3@GetToken
  00fd3	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00fd7	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  00fda	74 1a		 je	 SHORT $LN2@GetToken
  00fdc	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00fe0	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  00fe3	74 11		 je	 SHORT $LN2@GetToken
  00fe5	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00fe9	50		 push	 eax
  00fea	e8 00 00 00 00	 call	 _isalnum
  00fef	83 c4 04	 add	 esp, 4
  00ff2	85 c0		 test	 eax, eax
  00ff4	74 13		 je	 SHORT $LN3@GetToken
$LN2@GetToken:

; 133  : 			{
; 134  : 				*p=ch;

  00ff6	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00ff9	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00ffc	88 08		 mov	 BYTE PTR [eax], cl

; 135  : 				p++;

  00ffe	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  01001	83 c0 01	 add	 eax, 1
  01004	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 136  : 				
; 137  : 			}

  01007	eb b0		 jmp	 SHORT $LN4@GetToken
$LN3@GetToken:

; 138  : 
; 139  : 			ungetc(ch, SMDFile);

  01009	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0100e	50		 push	 eax
  0100f	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  01013	51		 push	 ecx
  01014	e8 00 00 00 00	 call	 _ungetc
  01019	83 c4 08	 add	 esp, 8

; 140  : 			*p=0;

  0101c	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0101f	c6 00 00	 mov	 BYTE PTR [eax], 0

; 141  : 			CurrentToken=NAME;

  01022	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0

; 142  : 			return CurrentToken;

  0102c	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  01031	eb 15		 jmp	 SHORT $LN32@GetToken

; 143  : 		}
; 144  : 		else

  01033	eb 11		 jmp	 SHORT $LN1@GetToken
$LN5@GetToken:

; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'

  01035	c7 05 00 00 00
	00 3c 00 00 00	 mov	 DWORD PTR _CurrentToken, 60 ; 0000003cH
  0103f	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  01044	eb 02		 jmp	 SHORT $LN32@GetToken
$LN1@GetToken:
$LN20@GetToken:

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;

  01046	33 c0		 xor	 eax, eax
$LN32@GetToken:

; 153  : }

  01048	5f		 pop	 edi
  01049	5e		 pop	 esi
  0104a	5b		 pop	 ebx
  0104b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0104e	33 cd		 xor	 ecx, ebp
  01050	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01055	8b e5		 mov	 esp, ebp
  01057	5d		 pop	 ebp
  01058	c3		 ret	 0
  01059	8d 49 00	 npad	 3
$LN35@GetToken:
  0105c	00 00 00 00	 DD	 $LN10@GetToken
  01060	00 00 00 00	 DD	 $LN19@GetToken
  01064	00 00 00 00	 DD	 $LN17@GetToken
  01068	00 00 00 00	 DD	 $LN14@GetToken
  0106c	00 00 00 00	 DD	 $LN18@GetToken
  01070	00 00 00 00	 DD	 $LN16@GetToken
  01074	00 00 00 00	 DD	 $LN15@GetToken
  01078	00 00 00 00	 DD	 $LN6@GetToken
$LN34@GetToken:
  0107c	00		 DB	 0
  0107d	01		 DB	 1
  0107e	07		 DB	 7
  0107f	07		 DB	 7
  01080	07		 DB	 7
  01081	07		 DB	 7
  01082	07		 DB	 7
  01083	07		 DB	 7
  01084	07		 DB	 7
  01085	07		 DB	 7
  01086	02		 DB	 2
  01087	03		 DB	 3
  01088	03		 DB	 3
  01089	07		 DB	 7
  0108a	03		 DB	 3
  0108b	03		 DB	 3
  0108c	03		 DB	 3
  0108d	03		 DB	 3
  0108e	03		 DB	 3
  0108f	03		 DB	 3
  01090	03		 DB	 3
  01091	03		 DB	 3
  01092	03		 DB	 3
  01093	03		 DB	 3
  01094	07		 DB	 7
  01095	04		 DB	 4
  01096	07		 DB	 7
  01097	07		 DB	 7
  01098	07		 DB	 7
  01099	07		 DB	 7
  0109a	07		 DB	 7
  0109b	07		 DB	 7
  0109c	07		 DB	 7
  0109d	07		 DB	 7
  0109e	07		 DB	 7
  0109f	07		 DB	 7
  010a0	07		 DB	 7
  010a1	07		 DB	 7
  010a2	07		 DB	 7
  010a3	07		 DB	 7
  010a4	07		 DB	 7
  010a5	07		 DB	 7
  010a6	07		 DB	 7
  010a7	07		 DB	 7
  010a8	07		 DB	 7
  010a9	07		 DB	 7
  010aa	07		 DB	 7
  010ab	07		 DB	 7
  010ac	07		 DB	 7
  010ad	07		 DB	 7
  010ae	07		 DB	 7
  010af	07		 DB	 7
  010b0	07		 DB	 7
  010b1	07		 DB	 7
  010b2	07		 DB	 7
  010b3	07		 DB	 7
  010b4	07		 DB	 7
  010b5	07		 DB	 7
  010b6	07		 DB	 7
  010b7	07		 DB	 7
  010b8	07		 DB	 7
  010b9	07		 DB	 7
  010ba	07		 DB	 7
  010bb	07		 DB	 7
  010bc	07		 DB	 7
  010bd	07		 DB	 7
  010be	07		 DB	 7
  010bf	07		 DB	 7
  010c0	07		 DB	 7
  010c1	07		 DB	 7
  010c2	07		 DB	 7
  010c3	07		 DB	 7
  010c4	07		 DB	 7
  010c5	07		 DB	 7
  010c6	07		 DB	 7
  010c7	07		 DB	 7
  010c8	07		 DB	 7
  010c9	07		 DB	 7
  010ca	07		 DB	 7
  010cb	07		 DB	 7
  010cc	07		 DB	 7
  010cd	07		 DB	 7
  010ce	07		 DB	 7
  010cf	07		 DB	 7
  010d0	07		 DB	 7
  010d1	07		 DB	 7
  010d2	07		 DB	 7
  010d3	07		 DB	 7
  010d4	07		 DB	 7
  010d5	05		 DB	 5
  010d6	07		 DB	 7
  010d7	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
PUBLIC	??$insert@U?$pair@HPAX@std@@@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HPAX@1@@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::insert<std::pair<int,void *> >
PUBLIC	??$?0AAHAAPAX@?$pair@HPAX@std@@QAE@AAHAAPAX@Z	; std::pair<int,void *>::pair<int,void *><int &,void * &>
PUBLIC	?RegEvent@CEventManagement@@QAEXHPAX@Z		; CEventManagement::RegEvent
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\eventmanagement.cpp
_TEXT	SEGMENT
$T227267 = -84						; size = 8
$T227268 = -76						; size = 8
_this$ = -4						; size = 4
_eEventKind$ = 8					; size = 4
_lpEventObj$ = 12					; size = 4
?RegEvent@CEventManagement@@QAEXHPAX@Z PROC		; CEventManagement::RegEvent
; _this$ = ecx

; 352  : {

  010e0	55		 push	 ebp
  010e1	8b ec		 mov	 ebp, esp
  010e3	83 ec 54	 sub	 esp, 84			; 00000054H
  010e6	53		 push	 ebx
  010e7	56		 push	 esi
  010e8	57		 push	 edi
  010e9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 353  : 	this->m_mapEventObj.insert( std::pair<int, void *>(eEventKind, lpEventObj) );

  010ec	8d 45 0c	 lea	 eax, DWORD PTR _lpEventObj$[ebp]
  010ef	50		 push	 eax
  010f0	8d 4d 08	 lea	 ecx, DWORD PTR _eEventKind$[ebp]
  010f3	51		 push	 ecx
  010f4	8d 4d ac	 lea	 ecx, DWORD PTR $T227267[ebp]
  010f7	e8 00 00 00 00	 call	 ??$?0AAHAAPAX@?$pair@HPAX@std@@QAE@AAHAAPAX@Z ; std::pair<int,void *>::pair<int,void *><int &,void * &>
  010fc	50		 push	 eax
  010fd	8d 55 b4	 lea	 edx, DWORD PTR $T227268[ebp]
  01100	52		 push	 edx
  01101	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01104	83 c1 1c	 add	 ecx, 28			; 0000001cH
  01107	e8 00 00 00 00	 call	 ??$insert@U?$pair@HPAX@std@@@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HPAX@1@@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::insert<std::pair<int,void *> >

; 354  : }

  0110c	5f		 pop	 edi
  0110d	5e		 pop	 esi
  0110e	5b		 pop	 ebx
  0110f	8b e5		 mov	 esp, ebp
  01111	5d		 pop	 ebp
  01112	c2 08 00	 ret	 8
?RegEvent@CEventManagement@@QAEXHPAX@Z ENDP		; CEventManagement::RegEvent
_TEXT	ENDS
PUBLIC	??0?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAE@XZ ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >
PUBLIC	??0CEventItemList@@QAE@XZ			; CEventItemList::CEventItemList
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CEventItemList@@QAE@XZ PROC				; CEventItemList::CEventItemList
; _this$ = ecx

; 357  : {

  01120	55		 push	 ebp
  01121	8b ec		 mov	 ebp, esp
  01123	83 ec 44	 sub	 esp, 68			; 00000044H
  01126	53		 push	 ebx
  01127	56		 push	 esi
  01128	57		 push	 edi
  01129	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0112c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0112f	e8 00 00 00 00	 call	 ??0?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAE@XZ ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >

; 358  : 	//empty
; 359  : }

  01134	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01137	5f		 pop	 edi
  01138	5e		 pop	 esi
  01139	5b		 pop	 ebx
  0113a	8b e5		 mov	 esp, ebp
  0113c	5d		 pop	 ebp
  0113d	c3		 ret	 0
??0CEventItemList@@QAE@XZ ENDP				; CEventItemList::CEventItemList
_TEXT	ENDS
PUBLIC	??1?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAE@XZ ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::~vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >
PUBLIC	?clear@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAEXXZ ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::clear
PUBLIC	??1CEventItemList@@QAE@XZ			; CEventItemList::~CEventItemList
xdata$x	SEGMENT
__unwindtable$??1CEventItemList@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CEventItemList@@QAE@XZ$0
__ehfuncinfo$??1CEventItemList@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CEventItemList@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CEventItemList@@QAE@XZ PROC				; CEventItemList::~CEventItemList
; _this$ = ecx

; 362  : {

  01140	55		 push	 ebp
  01141	8b ec		 mov	 ebp, esp
  01143	6a ff		 push	 -1
  01145	68 00 00 00 00	 push	 __ehhandler$??1CEventItemList@@QAE@XZ
  0114a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  01150	50		 push	 eax
  01151	83 ec 44	 sub	 esp, 68			; 00000044H
  01154	53		 push	 ebx
  01155	56		 push	 esi
  01156	57		 push	 edi
  01157	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0115c	33 c5		 xor	 eax, ebp
  0115e	50		 push	 eax
  0115f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  01162	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  01168	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0116b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 363  : 	this->m_vtEventItemList.clear();

  01172	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  01175	e8 00 00 00 00	 call	 ?clear@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAEXXZ ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::clear

; 364  : }

  0117a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  01181	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  01184	e8 00 00 00 00	 call	 ??1?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAE@XZ ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::~vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >
  01189	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0118c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  01193	59		 pop	 ecx
  01194	5f		 pop	 edi
  01195	5e		 pop	 esi
  01196	5b		 pop	 ebx
  01197	8b e5		 mov	 esp, ebp
  01199	5d		 pop	 ebp
  0119a	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??1CEventItemList@@QAE@XZ$0:
  00057	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	e9 00 00 00 00	 jmp	 ??1?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAE@XZ ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::~vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >
__ehhandler$??1CEventItemList@@QAE@XZ:
  0005f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00063	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00066	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00069	33 c8		 xor	 ecx, eax
  0006b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00070	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CEventItemList@@QAE@XZ
  00075	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CEventItemList@@QAE@XZ ENDP				; CEventItemList::~CEventItemList
PUBLIC	?push_back@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAEXABUEVENT_ID_ITEM_LIST@@@Z ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::push_back
PUBLIC	??_C@_0DI@CLECOPAG@?$FLEventItemList?4txt?$FN?5?9?5File?5load?5@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	?Load@CEventItemList@@QAEHPAD@Z			; CEventItemList::Load
;	COMDAT ??_C@_0DI@CLECOPAG@?$FLEventItemList?4txt?$FN?5?9?5File?5load?5@
CONST	SEGMENT
??_C@_0DI@CLECOPAG@?$FLEventItemList?4txt?$FN?5?9?5File?5load?5@ DB '[Eve'
	DB	'ntItemList.txt] - File load error : File Name Error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv190 = -96						; size = 4
tv181 = -96						; size = 4
tv172 = -96						; size = 4
tv163 = -96						; size = 4
tv154 = -96						; size = 4
tv188 = -92						; size = 4
tv179 = -92						; size = 4
tv170 = -92						; size = 4
tv161 = -92						; size = 4
tv152 = -92						; size = 4
tv185 = -86						; size = 2
tv176 = -86						; size = 2
tv167 = -86						; size = 2
tv158 = -86						; size = 2
tv149 = -86						; size = 2
_EIIL$224633 = -20					; size = 5
_type$ = -12						; size = 4
_Token$ = -8						; size = 4
_this$ = -4						; size = 4
_lpszFileName$ = 8					; size = 4
?Load@CEventItemList@@QAEHPAD@Z PROC			; CEventItemList::Load
; _this$ = ecx

; 367  : {

  011a0	55		 push	 ebp
  011a1	8b ec		 mov	 ebp, esp
  011a3	83 ec 60	 sub	 esp, 96			; 00000060H
  011a6	53		 push	 ebx
  011a7	56		 push	 esi
  011a8	57		 push	 edi
  011a9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 368  : 	if ( lpszFileName == NULL || !strcmp(lpszFileName, ""))

  011ac	83 7d 08 00	 cmp	 DWORD PTR _lpszFileName$[ebp], 0
  011b0	74 15		 je	 SHORT $LN9@Load@2
  011b2	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  011b7	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  011ba	50		 push	 eax
  011bb	e8 00 00 00 00	 call	 _strcmp
  011c0	83 c4 08	 add	 esp, 8
  011c3	85 c0		 test	 eax, eax
  011c5	75 15		 jne	 SHORT $LN10@Load@2
$LN9@Load@2:

; 369  : 	{
; 370  : 		LogAddTD("[EventItemList.txt] - File load error : File Name Error");

  011c7	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@CLECOPAG@?$FLEventItemList?4txt?$FN?5?9?5File?5load?5@
  011cc	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  011d2	83 c4 04	 add	 esp, 4

; 371  : 		return FALSE;

  011d5	33 c0		 xor	 eax, eax
  011d7	e9 a3 01 00 00	 jmp	 $LN11@Load@2
$LN10@Load@2:

; 372  : 	}
; 373  : 
; 374  : 	SMDFile = fopen(lpszFileName, "r");

  011dc	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  011e1	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  011e4	50		 push	 eax
  011e5	e8 00 00 00 00	 call	 _fopen
  011ea	83 c4 08	 add	 esp, 8
  011ed	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax

; 375  : 
; 376  : 	if ( SMDFile == NULL )

  011f2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SMDFile, 0
  011f9	75 18		 jne	 SHORT $LN8@Load@2

; 377  : 	{
; 378  : 		MsgBox("[DOTH] Info file Load Fail [%s]", lpszFileName);

  011fb	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  011fe	50		 push	 eax
  011ff	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@JEMAOPLJ@?$FLDOTH?$FN?5Info?5file?5Load?5Fail?5?$FL?$CFs?$FN?$AA@
  01204	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  01209	83 c4 08	 add	 esp, 8

; 379  : 
; 380  : 		return FALSE;

  0120c	33 c0		 xor	 eax, eax
  0120e	e9 6c 01 00 00	 jmp	 $LN11@Load@2
$LN8@Load@2:

; 381  : 	}
; 382  : 
; 383  : 	int Token;
; 384  : 	int type = -1;

  01213	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _type$[ebp], -1
$LN7@Load@2:

; 385  : 
; 386  : 	while ( true )

  0121a	b8 01 00 00 00	 mov	 eax, 1
  0121f	85 c0		 test	 eax, eax
  01221	0f 84 45 01 00
	00		 je	 $LN6@Load@2

; 387  : 	{
; 388  : 		Token = GetToken();

  01227	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0122c	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 389  : 
; 390  : 		if ( Token == 2 )

  0122f	83 7d f8 02	 cmp	 DWORD PTR _Token$[ebp], 2
  01233	75 05		 jne	 SHORT $LN5@Load@2

; 391  : 		{
; 392  : 			break;

  01235	e9 32 01 00 00	 jmp	 $LN6@Load@2
$LN5@Load@2:

; 393  : 		}
; 394  : 
; 395  : 		type = (int)TokenNumber;

  0123a	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  01240	e8 00 00 00 00	 call	 __ftol2_sse
  01245	89 45 f4	 mov	 DWORD PTR _type$[ebp], eax
$LN4@Load@2:

; 396  : 
; 397  : 		while ( true )

  01248	b8 01 00 00 00	 mov	 eax, 1
  0124d	85 c0		 test	 eax, eax
  0124f	0f 84 12 01 00
	00		 je	 $LN3@Load@2

; 398  : 		{
; 399  : 			if ( type == 0 )

  01255	83 7d f4 00	 cmp	 DWORD PTR _type$[ebp], 0
  01259	0f 85 03 01 00
	00		 jne	 $LN2@Load@2

; 400  : 			{
; 401  : 				Token = GetToken();

  0125f	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  01264	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 402  : 
; 403  : 				if ( strcmp("end", TokenString) == 0 )

  01267	68 00 00 00 00	 push	 OFFSET _TokenString
  0126c	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  01271	e8 00 00 00 00	 call	 _strcmp
  01276	83 c4 08	 add	 esp, 8
  01279	85 c0		 test	 eax, eax
  0127b	75 05		 jne	 SHORT $LN1@Load@2

; 404  : 				{
; 405  : 					break;

  0127d	e9 e5 00 00 00	 jmp	 $LN3@Load@2
$LN1@Load@2:

; 406  : 				}
; 407  : 
; 408  : 				EVENT_ID_ITEM_LIST EIIL;
; 409  : 
; 410  : 				EIIL.m_btSection = (BYTE)TokenNumber;

  01282	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  01288	d9 7d aa	 fnstcw	 WORD PTR tv149[ebp]
  0128b	0f b7 45 aa	 movzx	 eax, WORD PTR tv149[ebp]
  0128f	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  01294	89 45 a4	 mov	 DWORD PTR tv152[ebp], eax
  01297	d9 6d a4	 fldcw	 WORD PTR tv152[ebp]
  0129a	db 5d a0	 fistp	 DWORD PTR tv154[ebp]
  0129d	d9 6d aa	 fldcw	 WORD PTR tv149[ebp]
  012a0	8a 45 a0	 mov	 al, BYTE PTR tv154[ebp]
  012a3	88 45 ec	 mov	 BYTE PTR _EIIL$224633[ebp], al

; 411  : 
; 412  : 				Token = GetToken();

  012a6	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  012ab	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 413  : 				EIIL.m_btType = (BYTE)TokenNumber;

  012ae	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  012b4	d9 7d aa	 fnstcw	 WORD PTR tv158[ebp]
  012b7	0f b7 45 aa	 movzx	 eax, WORD PTR tv158[ebp]
  012bb	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  012c0	89 45 a4	 mov	 DWORD PTR tv161[ebp], eax
  012c3	d9 6d a4	 fldcw	 WORD PTR tv161[ebp]
  012c6	db 5d a0	 fistp	 DWORD PTR tv163[ebp]
  012c9	d9 6d aa	 fldcw	 WORD PTR tv158[ebp]
  012cc	8a 45 a0	 mov	 al, BYTE PTR tv163[ebp]
  012cf	88 45 ed	 mov	 BYTE PTR _EIIL$224633[ebp+1], al

; 414  : 
; 415  : 				Token = GetToken();

  012d2	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  012d7	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 416  : 				EIIL.m_btIndex = (BYTE)TokenNumber;

  012da	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  012e0	d9 7d aa	 fnstcw	 WORD PTR tv167[ebp]
  012e3	0f b7 45 aa	 movzx	 eax, WORD PTR tv167[ebp]
  012e7	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  012ec	89 45 a4	 mov	 DWORD PTR tv170[ebp], eax
  012ef	d9 6d a4	 fldcw	 WORD PTR tv170[ebp]
  012f2	db 5d a0	 fistp	 DWORD PTR tv172[ebp]
  012f5	d9 6d aa	 fldcw	 WORD PTR tv167[ebp]
  012f8	8a 45 a0	 mov	 al, BYTE PTR tv172[ebp]
  012fb	88 45 ee	 mov	 BYTE PTR _EIIL$224633[ebp+2], al

; 417  : 
; 418  : 				Token = GetToken();

  012fe	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  01303	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 419  : 				EIIL.m_btLevel = (BYTE)TokenNumber;

  01306	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0130c	d9 7d aa	 fnstcw	 WORD PTR tv176[ebp]
  0130f	0f b7 45 aa	 movzx	 eax, WORD PTR tv176[ebp]
  01313	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  01318	89 45 a4	 mov	 DWORD PTR tv179[ebp], eax
  0131b	d9 6d a4	 fldcw	 WORD PTR tv179[ebp]
  0131e	db 5d a0	 fistp	 DWORD PTR tv181[ebp]
  01321	d9 6d aa	 fldcw	 WORD PTR tv176[ebp]
  01324	8a 45 a0	 mov	 al, BYTE PTR tv181[ebp]
  01327	88 45 ef	 mov	 BYTE PTR _EIIL$224633[ebp+3], al

; 420  : 
; 421  : 				Token = GetToken();

  0132a	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0132f	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 422  : 				EIIL.m_btDur = (BYTE)TokenNumber;

  01332	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  01338	d9 7d aa	 fnstcw	 WORD PTR tv185[ebp]
  0133b	0f b7 45 aa	 movzx	 eax, WORD PTR tv185[ebp]
  0133f	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  01344	89 45 a4	 mov	 DWORD PTR tv188[ebp], eax
  01347	d9 6d a4	 fldcw	 WORD PTR tv188[ebp]
  0134a	db 5d a0	 fistp	 DWORD PTR tv190[ebp]
  0134d	d9 6d aa	 fldcw	 WORD PTR tv185[ebp]
  01350	8a 45 a0	 mov	 al, BYTE PTR tv190[ebp]
  01353	88 45 f0	 mov	 BYTE PTR _EIIL$224633[ebp+4], al

; 423  : 
; 424  : 				this->m_vtEventItemList.push_back(EIIL);

  01356	8d 45 ec	 lea	 eax, DWORD PTR _EIIL$224633[ebp]
  01359	50		 push	 eax
  0135a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0135d	e8 00 00 00 00	 call	 ?push_back@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAEXABUEVENT_ID_ITEM_LIST@@@Z ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::push_back
$LN2@Load@2:

; 425  : 			}
; 426  : 		}

  01362	e9 e1 fe ff ff	 jmp	 $LN4@Load@2
$LN3@Load@2:

; 427  : 	}

  01367	e9 ae fe ff ff	 jmp	 $LN7@Load@2
$LN6@Load@2:

; 428  : 
; 429  : 	fclose(SMDFile);

  0136c	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  01371	50		 push	 eax
  01372	e8 00 00 00 00	 call	 _fclose
  01377	83 c4 04	 add	 esp, 4

; 430  : 	return TRUE;

  0137a	b8 01 00 00 00	 mov	 eax, 1
$LN11@Load@2:

; 431  : }

  0137f	5f		 pop	 edi
  01380	5e		 pop	 esi
  01381	5b		 pop	 ebx
  01382	8b e5		 mov	 esp, ebp
  01384	5d		 pop	 ebp
  01385	c2 04 00	 ret	 4
?Load@CEventItemList@@QAEHPAD@Z ENDP			; CEventItemList::Load
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QBEAAUEVENT_ID_ITEM_LIST@@XZ ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::operator*
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::operator!=
PUBLIC	?end@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@2@XZ ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::end
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::operator++
PUBLIC	?begin@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@2@XZ ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::begin
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::_Vector_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >
PUBLIC	?SortItem@CEventItemList@@QAEHEPAE0@Z		; CEventItemList::SortItem
EXTRN	?ItemGetNumberMake@@YAHHH@Z:PROC		; ItemGetNumberMake
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
$T227279 = -84						; size = 4
$T227280 = -80						; size = 4
_btType$224799 = -10					; size = 1
_btIndex$224798 = -9					; size = 1
_it$ = -8						; size = 4
_this$ = -4						; size = 4
_giftsection$ = 8					; size = 1
_level$ = 12						; size = 4
_dur$ = 16						; size = 4
?SortItem@CEventItemList@@QAEHEPAE0@Z PROC		; CEventItemList::SortItem
; _this$ = ecx

; 434  : {

  01390	55		 push	 ebp
  01391	8b ec		 mov	 ebp, esp
  01393	83 ec 54	 sub	 esp, 84			; 00000054H
  01396	53		 push	 ebx
  01397	56		 push	 esi
  01398	57		 push	 edi
  01399	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 435  : 	std::vector<EVENT_ID_ITEM_LIST>::iterator it;

  0139c	8d 4d f8	 lea	 ecx, DWORD PTR _it$[ebp]
  0139f	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::_Vector_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >

; 436  : 
; 437  : 	for(it = this->m_vtEventItemList.begin(); it != this->m_vtEventItemList.end(); ++it)

  013a4	8d 45 ac	 lea	 eax, DWORD PTR $T227279[ebp]
  013a7	50		 push	 eax
  013a8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  013ab	e8 00 00 00 00	 call	 ?begin@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@2@XZ ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::begin
  013b0	8b 08		 mov	 ecx, DWORD PTR [eax]
  013b2	89 4d f8	 mov	 DWORD PTR _it$[ebp], ecx
  013b5	eb 08		 jmp	 SHORT $LN4@SortItem
$LN3@SortItem:
  013b7	8d 4d f8	 lea	 ecx, DWORD PTR _it$[ebp]
  013ba	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::operator++
$LN4@SortItem:
  013bf	8d 45 b0	 lea	 eax, DWORD PTR $T227280[ebp]
  013c2	50		 push	 eax
  013c3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  013c6	e8 00 00 00 00	 call	 ?end@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@2@XZ ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::end
  013cb	50		 push	 eax
  013cc	8d 4d f8	 lea	 ecx, DWORD PTR _it$[ebp]
  013cf	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::operator!=
  013d4	0f b6 c8	 movzx	 ecx, al
  013d7	85 c9		 test	 ecx, ecx
  013d9	74 68		 je	 SHORT $LN2@SortItem

; 438  : 	{
; 439  : 		if( (*it).m_btSection == giftsection)

  013db	8d 4d f8	 lea	 ecx, DWORD PTR _it$[ebp]
  013de	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QBEAAUEVENT_ID_ITEM_LIST@@XZ ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::operator*
  013e3	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  013e6	0f b6 4d 08	 movzx	 ecx, BYTE PTR _giftsection$[ebp]
  013ea	3b c1		 cmp	 eax, ecx
  013ec	75 50		 jne	 SHORT $LN1@SortItem

; 440  : 		{
; 441  : 			BYTE btIndex = (*it).m_btIndex;

  013ee	8d 4d f8	 lea	 ecx, DWORD PTR _it$[ebp]
  013f1	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QBEAAUEVENT_ID_ITEM_LIST@@XZ ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::operator*
  013f6	8a 40 02	 mov	 al, BYTE PTR [eax+2]
  013f9	88 45 f7	 mov	 BYTE PTR _btIndex$224798[ebp], al

; 442  : 			BYTE btType = (*it).m_btType;

  013fc	8d 4d f8	 lea	 ecx, DWORD PTR _it$[ebp]
  013ff	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QBEAAUEVENT_ID_ITEM_LIST@@XZ ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::operator*
  01404	8a 40 01	 mov	 al, BYTE PTR [eax+1]
  01407	88 45 f6	 mov	 BYTE PTR _btType$224799[ebp], al

; 443  : 			
; 444  : 			*level = (*it).m_btLevel;

  0140a	8d 4d f8	 lea	 ecx, DWORD PTR _it$[ebp]
  0140d	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QBEAAUEVENT_ID_ITEM_LIST@@XZ ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::operator*
  01412	8b 4d 0c	 mov	 ecx, DWORD PTR _level$[ebp]
  01415	8a 50 03	 mov	 dl, BYTE PTR [eax+3]
  01418	88 11		 mov	 BYTE PTR [ecx], dl

; 445  : 			*dur = (*it).m_btDur;

  0141a	8d 4d f8	 lea	 ecx, DWORD PTR _it$[ebp]
  0141d	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QBEAAUEVENT_ID_ITEM_LIST@@XZ ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::operator*
  01422	8b 4d 10	 mov	 ecx, DWORD PTR _dur$[ebp]
  01425	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  01428	88 11		 mov	 BYTE PTR [ecx], dl

; 446  : 			
; 447  : 			return ItemGetNumberMake(btType, btIndex);

  0142a	0f b6 45 f7	 movzx	 eax, BYTE PTR _btIndex$224798[ebp]
  0142e	50		 push	 eax
  0142f	0f b6 4d f6	 movzx	 ecx, BYTE PTR _btType$224799[ebp]
  01433	51		 push	 ecx
  01434	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  01439	83 c4 08	 add	 esp, 8
  0143c	eb 08		 jmp	 SHORT $LN5@SortItem
$LN1@SortItem:

; 448  : 		}
; 449  : 	}

  0143e	e9 74 ff ff ff	 jmp	 $LN3@SortItem
$LN2@SortItem:

; 450  : 	return -1;

  01443	83 c8 ff	 or	 eax, -1
$LN5@SortItem:

; 451  : }

  01446	5f		 pop	 edi
  01447	5e		 pop	 esi
  01448	5b		 pop	 ebx
  01449	8b e5		 mov	 esp, ebp
  0144b	5d		 pop	 ebp
  0144c	c2 0c 00	 ret	 12			; 0000000cH
?SortItem@CEventItemList@@QAEHEPAE0@Z ENDP		; CEventItemList::SortItem
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE@V?$allocator@UEVENT_ID_TIME@@@1@@Z ; std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >
PUBLIC	??0?$allocator@UEVENT_ID_TIME@@@std@@QAE@XZ	; std::allocator<EVENT_ID_TIME>::allocator<EVENT_ID_TIME>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T227282 = -72						; size = 4
_this$ = -4						; size = 4
??0?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE@XZ PROC ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	51		 push	 ecx
  0000d	8b cc		 mov	 ecx, esp
  0000f	89 65 b8	 mov	 DWORD PTR $T227282[ebp], esp
  00012	e8 00 00 00 00	 call	 ??0?$allocator@UEVENT_ID_TIME@@@std@@QAE@XZ ; std::allocator<EVENT_ID_TIME>::allocator<EVENT_ID_TIME>
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE@V?$allocator@UEVENT_ID_TIME@@@1@@Z ; std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >

; 508  : 		}

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE@XZ ENDP ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE@XZ ; std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::~_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >
PUBLIC	?_Tidy@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@IAEXXZ ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??1?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE@XZ PROC ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::~vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >, COMDAT
; _this$ = ecx

; 704  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 705  : 		_Tidy();

  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@IAEXXZ ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::_Tidy

; 706  : 		}

  0003a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??1?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE@XZ ; std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::~_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >
  00049	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE@XZ ; std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::~_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >
__ehhandler$??1?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE@XZ ENDP ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::~vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QAE@PAUEVENT_ID_TIME@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ?begin@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@2@XZ PROC ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 782  : 		return (iterator(this->_Myfirst, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	52		 push	 edx
  00016	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00019	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QAE@PAUEVENT_ID_TIME@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >
  0001e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 783  : 		}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?begin@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@2@XZ ENDP ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::begin
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?end@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@2@XZ PROC ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 792  : 		return (iterator(this->_Mylast, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	52		 push	 edx
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QAE@PAUEVENT_ID_TIME@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >
  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 793  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?end@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@2@XZ ENDP ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::end
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?empty@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?empty@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QBE_NXZ PROC ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::empty, COMDAT
; _this$ = ecx

; 888  : 		{	// test if sequence is empty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 889  : 		return (this->_Myfirst == this->_Mylast);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 10		 mov	 edx, DWORD PTR [eax]
  00014	33 c0		 xor	 eax, eax
  00016	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00019	0f 94 c0	 sete	 al

; 890  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
?empty@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QBE_NXZ ENDP ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::empty
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UEVENT_ID_TIME@@@std@@UEVENT_ID_TIME@@ABU3@@std@@YAXAAV?$allocator@UEVENT_ID_TIME@@@0@PAUEVENT_ID_TIME@@ABU2@@Z ; std::_Cons_val<std::allocator<EVENT_ID_TIME>,EVENT_ID_TIME,EVENT_ID_TIME const &>
PUBLIC	??$_Cons_val@V?$allocator@UEVENT_ID_TIME@@@std@@UEVENT_ID_TIME@@AAU3@@std@@YAXAAV?$allocator@UEVENT_ID_TIME@@@0@PAUEVENT_ID_TIME@@AAU2@@Z ; std::_Cons_val<std::allocator<EVENT_ID_TIME>,EVENT_ID_TIME,EVENT_ID_TIME &>
PUBLIC	?_Orphan_range@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@IBEXPAUEVENT_ID_TIME@@0@Z ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::_Orphan_range
PUBLIC	?_Reserve@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@IAEXI@Z ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::_Reserve
PUBLIC	?_Inside@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@IBE_NPBUEVENT_ID_TIME@@@Z ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::_Inside
PUBLIC	??$addressof@$$CBUEVENT_ID_TIME@@@std@@YAPBUEVENT_ID_TIME@@ABU1@@Z ; std::addressof<EVENT_ID_TIME const >
; Function compile flags: /Odtp /ZI
;	COMDAT ?push_back@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAEXABUEVENT_ID_TIME@@@Z
_TEXT	SEGMENT
__Idx$224829 = -8					; size = 4
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAEXABUEVENT_ID_TIME@@@Z PROC ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$addressof@$$CBUEVENT_ID_TIME@@@std@@YAPBUEVENT_ID_TIME@@ABU1@@Z ; std::addressof<EVENT_ID_TIME const >
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Inside@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@IBE_NPBUEVENT_ID_TIME@@@Z ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::_Inside
  00021	0f b6 c8	 movzx	 ecx, al
  00024	85 c9		 test	 ecx, ecx
  00026	74 78		 je	 SHORT $LN4@push_back

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$addressof@$$CBUEVENT_ID_TIME@@@std@@YAPBUEVENT_ID_TIME@@ABU1@@Z ; std::addressof<EVENT_ID_TIME const >
  00031	83 c4 04	 add	 esp, 4
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	2b 01		 sub	 eax, DWORD PTR [ecx]
  00039	c1 f8 04	 sar	 eax, 4
  0003c	89 45 f8	 mov	 DWORD PTR __Idx$224829[ebp], eax

; 980  : 			if (this->_Mylast == this->_Myend)

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00048	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0004b	75 0a		 jne	 SHORT $LN3@push_back

; 981  : 				_Reserve(1);

  0004d	6a 01		 push	 1
  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@IAEXI@Z ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::_Reserve
$LN3@push_back:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  00057	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005d	51		 push	 ecx
  0005e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00061	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00064	50		 push	 eax
  00065	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@IBEXPAUEVENT_ID_TIME@@0@Z ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::_Orphan_range

; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  0006d	8b 45 f8	 mov	 eax, DWORD PTR __Idx$224829[ebp]
  00070	c1 e0 04	 shl	 eax, 4
  00073	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	03 01		 add	 eax, DWORD PTR [ecx]
  00078	50		 push	 eax
  00079	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0007c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0007f	50		 push	 eax
  00080	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00083	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00086	51		 push	 ecx
  00087	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UEVENT_ID_TIME@@@std@@UEVENT_ID_TIME@@AAU3@@std@@YAXAAV?$allocator@UEVENT_ID_TIME@@@0@PAUEVENT_ID_TIME@@AAU2@@Z ; std::_Cons_val<std::allocator<EVENT_ID_TIME>,EVENT_ID_TIME,EVENT_ID_TIME &>
  0008c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 986  : 			++this->_Mylast;

  0008f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00092	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00095	83 c1 10	 add	 ecx, 16			; 00000010H
  00098	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0009b	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 987  : 			}
; 988  : 		else

  0009e	eb 57		 jmp	 SHORT $LN5@push_back
$LN4@push_back:

; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  000a0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a9	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  000ac	75 0a		 jne	 SHORT $LN1@push_back

; 991  : 				_Reserve(1);

  000ae	6a 01		 push	 1
  000b0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b3	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@IAEXI@Z ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::_Reserve
$LN1@push_back:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  000b8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000bb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000be	51		 push	 ecx
  000bf	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c2	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000c5	50		 push	 eax
  000c6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c9	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@IBEXPAUEVENT_ID_TIME@@0@Z ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::_Orphan_range

; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  000ce	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  000d1	50		 push	 eax
  000d2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d5	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000d8	52		 push	 edx
  000d9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000dc	83 c0 0c	 add	 eax, 12			; 0000000cH
  000df	50		 push	 eax
  000e0	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UEVENT_ID_TIME@@@std@@UEVENT_ID_TIME@@ABU3@@std@@YAXAAV?$allocator@UEVENT_ID_TIME@@@0@PAUEVENT_ID_TIME@@ABU2@@Z ; std::_Cons_val<std::allocator<EVENT_ID_TIME>,EVENT_ID_TIME,EVENT_ID_TIME const &>
  000e5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  000e8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000eb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ee	83 c1 10	 add	 ecx, 16			; 00000010H
  000f1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000f4	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN5@push_back:

; 997  : 			}
; 998  : 		}

  000f7	5f		 pop	 edi
  000f8	5e		 pop	 esi
  000f9	5b		 pop	 ebx
  000fa	8b e5		 mov	 esp, ebp
  000fc	5d		 pop	 ebp
  000fd	c2 04 00	 ret	 4
?push_back@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAEXABUEVENT_ID_TIME@@@Z ENDP ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::push_back
_TEXT	ENDS
PUBLIC	?erase@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@2@0@Z ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::erase
; Function compile flags: /Odtp /ZI
;	COMDAT ?clear@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T227303 = -88						; size = 4
$T227304 = -84						; size = 4
$T227305 = -80						; size = 4
$T227306 = -76						; size = 4
$T227307 = -72						; size = 4
_this$ = -4						; size = 4
?clear@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAEXXZ PROC ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::clear, COMDAT
; _this$ = ecx

; 1217 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1218 : 		erase(begin(), end());

  0000c	8d 45 ac	 lea	 eax, DWORD PTR $T227304[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?end@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@2@XZ ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::end
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d a8	 mov	 DWORD PTR $T227303[ebp], ecx
  0001d	8d 55 b4	 lea	 edx, DWORD PTR $T227306[ebp]
  00020	52		 push	 edx
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?begin@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@2@XZ ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::begin
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 b0	 mov	 DWORD PTR $T227305[ebp], eax
  0002e	8b 4d a8	 mov	 ecx, DWORD PTR $T227303[ebp]
  00031	51		 push	 ecx
  00032	8b 55 b0	 mov	 edx, DWORD PTR $T227305[ebp]
  00035	52		 push	 edx
  00036	8d 45 b8	 lea	 eax, DWORD PTR $T227307[ebp]
  00039	50		 push	 eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?erase@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@2@0@Z ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::erase

; 1219 : 		}

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?clear@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAEXXZ ENDP ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::clear
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAX@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >
PUBLIC	??0?$allocator@U?$pair@$$CBHPAX@std@@@std@@QAE@XZ ; std::allocator<std::pair<int const ,void *> >::allocator<std::pair<int const ,void *> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\map
;	COMDAT ??0?$map@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T227310 = -70						; size = 1
$T227311 = -69						; size = 1
_this$ = -4						; size = 4
??0?$map@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@QAE@XZ PROC ; std::map<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> > >::map<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> > >, COMDAT
; _this$ = ecx

; 106  : 		{	// construct empty map from defaults

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 4d ba	 lea	 ecx, DWORD PTR $T227310[ebp]
  0000f	e8 00 00 00 00	 call	 ??0?$allocator@U?$pair@$$CBHPAX@std@@@std@@QAE@XZ ; std::allocator<std::pair<int const ,void *> >::allocator<std::pair<int const ,void *> >
  00014	50		 push	 eax
  00015	8d 45 bb	 lea	 eax, DWORD PTR $T227311[ebp]
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAX@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >

; 107  : 		}

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??0?$map@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@QAE@XZ ENDP ; std::map<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> > >::map<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> > >
_TEXT	ENDS
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::~_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Tidy
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xtree
xdata$x	SEGMENT
__unwindtable$??1?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::~_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >, COMDAT
; _this$ = ecx

; 790  : 		{	// destroy tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 791  : 		_Tidy();

  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?_Tidy@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Tidy

; 792  : 		}

  0003a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??1?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::~_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >
  00049	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::~_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >
__ehhandler$??1?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::~_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::end, COMDAT
; _this$ = ecx

; 816  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 817  : 		return (iterator(this->_Myhead, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	52		 push	 edx
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >
  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 818  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::end
_TEXT	ENDS
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Rmost
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Lmost
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Erase
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Root
; Function compile flags: /Odtp /ZI
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?clear@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::clear, COMDAT
; _this$ = ecx

; 1410 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		this->_Orphan_ptr(*this, 0);
; 1413 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1414 : 
; 1415 : 		_Erase(_Root());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Root
  00014	8b 00		 mov	 eax, DWORD PTR [eax]
  00016	50		 push	 eax
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Erase

; 1416 : 		_Root() = this->_Myhead;

  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Root
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002d	89 10		 mov	 DWORD PTR [eax], edx

; 1417 : 		_Lmost() = this->_Myhead;

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Lmost
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0003d	89 10		 mov	 DWORD PTR [eax], edx

; 1418 : 		_Rmost() = this->_Myhead;

  0003f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Rmost
  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0004d	89 10		 mov	 DWORD PTR [eax], edx

; 1419 : 		this->_Mysize = 0;

  0004f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00052	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 1420 : 		}

  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::clear
_TEXT	ENDS
PUBLIC	??R?$less@H@std@@QBE_NABH0@Z			; std::less<int>::operator()
PUBLIC	?_Key@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Key
PUBLIC	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >,std::_Iterator_base0>::_Mynode
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator==
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::lower_bound
; Function compile flags: /Odtp /ZI
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@ABH@Z
_TEXT	SEGMENT
tv137 = -88						; size = 4
$T227328 = -84						; size = 4
$T227329 = -80						; size = 4
$T227331 = -76						; size = 4
__Where$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::find, COMDAT
; _this$ = ecx

; 1423 : 		{	// find an element in mutable sequence that matches _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1424 : 		iterator _Where = lower_bound(_Keyval);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Keyval$[ebp]
  0000f	50		 push	 eax
  00010	8d 4d f8	 lea	 ecx, DWORD PTR __Where$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?lower_bound@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::lower_bound

; 1425 : 		return (_Where == end()
; 1426 : 			|| _DEBUG_LT_PRED(this->comp,
; 1427 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1428 : 					? end() : _Where);

  0001c	8d 45 b0	 lea	 eax, DWORD PTR $T227329[ebp]
  0001f	50		 push	 eax
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::end
  00028	50		 push	 eax
  00029	8d 4d f8	 lea	 ecx, DWORD PTR __Where$[ebp]
  0002c	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator==
  00031	0f b6 c8	 movzx	 ecx, al
  00034	85 c9		 test	 ecx, ecx
  00036	75 2d		 jne	 SHORT $LN3@find
  00038	8d 4d f8	 lea	 ecx, DWORD PTR __Where$[ebp]
  0003b	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >,std::_Iterator_base0>::_Mynode
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ?_Key@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Key
  00046	83 c4 04	 add	 esp, 4
  00049	50		 push	 eax
  0004a	8b 55 0c	 mov	 edx, DWORD PTR __Keyval$[ebp]
  0004d	52		 push	 edx
  0004e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  00056	0f b6 c0	 movzx	 eax, al
  00059	85 c0		 test	 eax, eax
  0005b	75 08		 jne	 SHORT $LN3@find
  0005d	8d 4d f8	 lea	 ecx, DWORD PTR __Where$[ebp]
  00060	89 4d a8	 mov	 DWORD PTR tv137[ebp], ecx
  00063	eb 0f		 jmp	 SHORT $LN4@find
$LN3@find:
  00065	8d 55 b4	 lea	 edx, DWORD PTR $T227331[ebp]
  00068	52		 push	 edx
  00069	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::end
  00071	89 45 a8	 mov	 DWORD PTR tv137[ebp], eax
$LN4@find:
  00074	8b 45 a8	 mov	 eax, DWORD PTR tv137[ebp]
  00077	89 45 ac	 mov	 DWORD PTR $T227328[ebp], eax
  0007a	8b 4d ac	 mov	 ecx, DWORD PTR $T227328[ebp]
  0007d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00082	89 10		 mov	 DWORD PTR [eax], edx
  00084	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1429 : 		}

  00087	5f		 pop	 edi
  00088	5e		 pop	 esi
  00089	5b		 pop	 ebx
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c2 08 00	 ret	 8
?find@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::find
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAE@V?$allocator@UEVENT_ID_ITEM_LIST@@@1@@Z ; std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >
PUBLIC	??0?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAE@XZ ; std::allocator<EVENT_ID_ITEM_LIST>::allocator<EVENT_ID_ITEM_LIST>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T227335 = -72						; size = 4
_this$ = -4						; size = 4
??0?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAE@XZ PROC ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	51		 push	 ecx
  0000d	8b cc		 mov	 ecx, esp
  0000f	89 65 b8	 mov	 DWORD PTR $T227335[ebp], esp
  00012	e8 00 00 00 00	 call	 ??0?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAE@XZ ; std::allocator<EVENT_ID_ITEM_LIST>::allocator<EVENT_ID_ITEM_LIST>
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAE@V?$allocator@UEVENT_ID_ITEM_LIST@@@1@@Z ; std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >

; 508  : 		}

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAE@XZ ENDP ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAE@XZ ; std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::~_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >
PUBLIC	?_Tidy@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@IAEXXZ ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??1?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAE@XZ PROC ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::~vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >, COMDAT
; _this$ = ecx

; 704  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 705  : 		_Tidy();

  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@IAEXXZ ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::_Tidy

; 706  : 		}

  0003a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??1?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAE@XZ ; std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::~_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >
  00049	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAE@XZ ; std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::~_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >
__ehhandler$??1?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAE@XZ ENDP ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::~vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QAE@PAUEVENT_ID_ITEM_LIST@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::_Vector_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ?begin@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@2@XZ PROC ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 782  : 		return (iterator(this->_Myfirst, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	52		 push	 edx
  00016	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00019	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QAE@PAUEVENT_ID_ITEM_LIST@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::_Vector_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >
  0001e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 783  : 		}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?begin@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@2@XZ ENDP ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::begin
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?end@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@2@XZ PROC ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 792  : 		return (iterator(this->_Mylast, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	52		 push	 edx
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QAE@PAUEVENT_ID_ITEM_LIST@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::_Vector_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >
  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 793  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?end@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@2@XZ ENDP ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::end
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@UEVENT_ID_ITEM_LIST@@ABU3@@std@@YAXAAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@PAUEVENT_ID_ITEM_LIST@@ABU2@@Z ; std::_Cons_val<std::allocator<EVENT_ID_ITEM_LIST>,EVENT_ID_ITEM_LIST,EVENT_ID_ITEM_LIST const &>
PUBLIC	??$_Cons_val@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@UEVENT_ID_ITEM_LIST@@AAU3@@std@@YAXAAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@PAUEVENT_ID_ITEM_LIST@@AAU2@@Z ; std::_Cons_val<std::allocator<EVENT_ID_ITEM_LIST>,EVENT_ID_ITEM_LIST,EVENT_ID_ITEM_LIST &>
PUBLIC	?_Orphan_range@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@IBEXPAUEVENT_ID_ITEM_LIST@@0@Z ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::_Orphan_range
PUBLIC	?_Reserve@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@IAEXI@Z ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::_Reserve
PUBLIC	?_Inside@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@IBE_NPBUEVENT_ID_ITEM_LIST@@@Z ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::_Inside
PUBLIC	??$addressof@$$CBUEVENT_ID_ITEM_LIST@@@std@@YAPBUEVENT_ID_ITEM_LIST@@ABU1@@Z ; std::addressof<EVENT_ID_ITEM_LIST const >
; Function compile flags: /Odtp /ZI
;	COMDAT ?push_back@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAEXABUEVENT_ID_ITEM_LIST@@@Z
_TEXT	SEGMENT
__Idx$224903 = -8					; size = 4
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAEXABUEVENT_ID_ITEM_LIST@@@Z PROC ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$addressof@$$CBUEVENT_ID_ITEM_LIST@@@std@@YAPBUEVENT_ID_ITEM_LIST@@ABU1@@Z ; std::addressof<EVENT_ID_ITEM_LIST const >
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Inside@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@IBE_NPBUEVENT_ID_ITEM_LIST@@@Z ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::_Inside
  00021	0f b6 c8	 movzx	 ecx, al
  00024	85 c9		 test	 ecx, ecx
  00026	74 7d		 je	 SHORT $LN4@push_back@2

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$addressof@$$CBUEVENT_ID_ITEM_LIST@@@std@@YAPBUEVENT_ID_ITEM_LIST@@ABU1@@Z ; std::addressof<EVENT_ID_ITEM_LIST const >
  00031	83 c4 04	 add	 esp, 4
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	2b 01		 sub	 eax, DWORD PTR [ecx]
  00039	99		 cdq
  0003a	b9 05 00 00 00	 mov	 ecx, 5
  0003f	f7 f9		 idiv	 ecx
  00041	89 45 f8	 mov	 DWORD PTR __Idx$224903[ebp], eax

; 980  : 			if (this->_Mylast == this->_Myend)

  00044	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0004d	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00050	75 0a		 jne	 SHORT $LN3@push_back@2

; 981  : 				_Reserve(1);

  00052	6a 01		 push	 1
  00054	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@IAEXI@Z ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::_Reserve
$LN3@push_back@2:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  0005c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00062	51		 push	 ecx
  00063	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00066	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00069	50		 push	 eax
  0006a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006d	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@IBEXPAUEVENT_ID_ITEM_LIST@@0@Z ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::_Orphan_range

; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  00072	8b 45 f8	 mov	 eax, DWORD PTR __Idx$224903[ebp]
  00075	6b c0 05	 imul	 eax, 5
  00078	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	03 01		 add	 eax, DWORD PTR [ecx]
  0007d	50		 push	 eax
  0007e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00081	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00084	50		 push	 eax
  00085	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00088	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0008b	51		 push	 ecx
  0008c	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@UEVENT_ID_ITEM_LIST@@AAU3@@std@@YAXAAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@PAUEVENT_ID_ITEM_LIST@@AAU2@@Z ; std::_Cons_val<std::allocator<EVENT_ID_ITEM_LIST>,EVENT_ID_ITEM_LIST,EVENT_ID_ITEM_LIST &>
  00091	83 c4 0c	 add	 esp, 12			; 0000000cH

; 986  : 			++this->_Mylast;

  00094	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00097	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0009a	83 c1 05	 add	 ecx, 5
  0009d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000a0	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 987  : 			}
; 988  : 		else

  000a3	eb 57		 jmp	 SHORT $LN5@push_back@2
$LN4@push_back@2:

; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  000a5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ab	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000ae	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  000b1	75 0a		 jne	 SHORT $LN1@push_back@2

; 991  : 				_Reserve(1);

  000b3	6a 01		 push	 1
  000b5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b8	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@IAEXI@Z ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::_Reserve
$LN1@push_back@2:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  000bd	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000c3	51		 push	 ecx
  000c4	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c7	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000ca	50		 push	 eax
  000cb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ce	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@IBEXPAUEVENT_ID_ITEM_LIST@@0@Z ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::_Orphan_range

; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  000d3	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  000d6	50		 push	 eax
  000d7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000da	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000dd	52		 push	 edx
  000de	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000e1	83 c0 0c	 add	 eax, 12			; 0000000cH
  000e4	50		 push	 eax
  000e5	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@UEVENT_ID_ITEM_LIST@@ABU3@@std@@YAXAAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@PAUEVENT_ID_ITEM_LIST@@ABU2@@Z ; std::_Cons_val<std::allocator<EVENT_ID_ITEM_LIST>,EVENT_ID_ITEM_LIST,EVENT_ID_ITEM_LIST const &>
  000ea	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  000ed	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000f0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000f3	83 c1 05	 add	 ecx, 5
  000f6	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000f9	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN5@push_back@2:

; 997  : 			}
; 998  : 		}

  000fc	5f		 pop	 edi
  000fd	5e		 pop	 esi
  000fe	5b		 pop	 ebx
  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c2 04 00	 ret	 4
?push_back@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAEXABUEVENT_ID_ITEM_LIST@@@Z ENDP ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::push_back
_TEXT	ENDS
PUBLIC	?erase@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@2@0@Z ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::erase
; Function compile flags: /Odtp /ZI
;	COMDAT ?clear@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T227354 = -88						; size = 4
$T227355 = -84						; size = 4
$T227356 = -80						; size = 4
$T227357 = -76						; size = 4
$T227358 = -72						; size = 4
_this$ = -4						; size = 4
?clear@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAEXXZ PROC ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::clear, COMDAT
; _this$ = ecx

; 1217 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1218 : 		erase(begin(), end());

  0000c	8d 45 ac	 lea	 eax, DWORD PTR $T227355[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?end@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@2@XZ ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::end
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d a8	 mov	 DWORD PTR $T227354[ebp], ecx
  0001d	8d 55 b4	 lea	 edx, DWORD PTR $T227357[ebp]
  00020	52		 push	 edx
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?begin@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@2@XZ ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::begin
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 b0	 mov	 DWORD PTR $T227356[ebp], eax
  0002e	8b 4d a8	 mov	 ecx, DWORD PTR $T227354[ebp]
  00031	51		 push	 ecx
  00032	8b 55 b0	 mov	 edx, DWORD PTR $T227356[ebp]
  00035	52		 push	 edx
  00036	8d 45 b8	 lea	 eax, DWORD PTR $T227358[ebp]
  00039	50		 push	 eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?erase@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@2@0@Z ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::erase

; 1219 : 		}

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?clear@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAEXXZ ENDP ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::clear
_TEXT	ENDS
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAE@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >, COMDAT
; _this$ = ecx

; 372  : 	_Tree_iterator()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAE@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >

; 373  : 		{	// construct with null node
; 374  : 		}

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >
_TEXT	ENDS
PUBLIC	??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHPAX@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator*
; Function compile flags: /Odtp /ZI
;	COMDAT ??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHPAX@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHPAX@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator->, COMDAT
; _this$ = ecx

; 400  : 		{	// return pointer to class object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 401  : 		return (&**this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHPAX@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator*

; 402  : 		}

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHPAX@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator->
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator!=, COMDAT
; _this$ = ecx

; 334  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 335  : 		return (!(*this == _Right));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator==
  00018	0f b6 c0	 movzx	 eax, al
  0001b	f7 d8		 neg	 eax
  0001d	1b c0		 sbb	 eax, eax
  0001f	83 c0 01	 add	 eax, 1

; 336  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator!=
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::_Vector_const_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >, COMDAT
; _this$ = ecx

; 298  : 	_Vector_iterator()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::_Vector_const_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >

; 299  : 		{	// construct with null vector pointer
; 300  : 		}

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QBEABUEVENT_ID_TIME@@XZ ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator*
; Function compile flags: /Odtp /ZI
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QBEAAUEVENT_ID_TIME@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QBEAAUEVENT_ID_TIME@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator*, COMDAT
; _this$ = ecx

; 321  : 		{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 322  : 		return ((reference)**(_Mybase *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QBEABUEVENT_ID_TIME@@XZ ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator*

; 323  : 		}

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QBEAAUEVENT_ID_TIME@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator++
; Function compile flags: /Odtp /ZI
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator++, COMDAT
; _this$ = ecx

; 337  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 338  : 		_Myiter _Tmp = *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	89 4d f8	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 339  : 		++*this;

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator++

; 340  : 		return (_Tmp);

  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Tmp$[ebp]
  00022	89 08		 mov	 DWORD PTR [eax], ecx
  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 341  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
??E?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator==
; Function compile flags: /Odtp /ZI
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 208  : 		return (!(*this == _Right));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??8?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator==
  00018	0f b6 c0	 movzx	 eax, al
  0001b	f7 d8		 neg	 eax
  0001d	1b c0		 sbb	 eax, eax
  0001f	83 c0 01	 add	 eax, 1

; 209  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator!=
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::_Vector_const_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::_Vector_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >, COMDAT
; _this$ = ecx

; 298  : 	_Vector_iterator()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::_Vector_const_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >

; 299  : 		{	// construct with null vector pointer
; 300  : 		}

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::_Vector_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QBEABUEVENT_ID_ITEM_LIST@@XZ ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::operator*
; Function compile flags: /Odtp /ZI
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QBEAAUEVENT_ID_ITEM_LIST@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QBEAAUEVENT_ID_ITEM_LIST@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::operator*, COMDAT
; _this$ = ecx

; 321  : 		{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 322  : 		return ((reference)**(_Mybase *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QBEABUEVENT_ID_ITEM_LIST@@XZ ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::operator*

; 323  : 		}

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QBEAAUEVENT_ID_ITEM_LIST@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::operator++
; Function compile flags: /Odtp /ZI
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::operator++, COMDAT
; _this$ = ecx

; 331  : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 332  : 		++*(_Mybase *)this;

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??E?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::operator++

; 333  : 		return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 334  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??E?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::operator==
; Function compile flags: /Odtp /ZI
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 208  : 		return (!(*this == _Right));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??8?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::operator==
  00018	0f b6 c0	 movzx	 eax, al
  0001b	f7 d8		 neg	 eax
  0001d	1b c0		 sbb	 eax, eax
  0001f	83 c0 01	 add	 eax, 1

; 209  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::operator!=
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@IAEXPAUEVENT_ID_TIME@@0@Z ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::_Destroy
PUBLIC	??$_Move@PAUEVENT_ID_TIME@@PAU1@@std@@YAPAUEVENT_ID_TIME@@PAU1@00@Z ; std::_Move<EVENT_ID_TIME *,EVENT_ID_TIME *>
PUBLIC	?_Make_iter@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@2@@Z ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::_Make_iter
; Function compile flags: /Odtp /ZI
;	COMDAT ?erase@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T227383 = -84						; size = 4
__Ptr$225015 = -16					; size = 4
__Last$ = -12						; size = 4
__First$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@2@0@Z PROC ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::erase, COMDAT
; _this$ = ecx

; 1190 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1191 : 		iterator _First = _Make_iter(_First_arg);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __First_arg$[ebp]
  0000f	50		 push	 eax
  00010	8d 4d f8	 lea	 ecx, DWORD PTR __First$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@2@@Z ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::_Make_iter

; 1192 : 		iterator _Last = _Make_iter(_Last_arg);

  0001c	8b 45 10	 mov	 eax, DWORD PTR __Last_arg$[ebp]
  0001f	50		 push	 eax
  00020	8d 4d f4	 lea	 ecx, DWORD PTR __Last$[ebp]
  00023	51		 push	 ecx
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@2@@Z ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::_Make_iter

; 1193 : 
; 1194 : 		if (_First != _Last)

  0002c	8d 45 f4	 lea	 eax, DWORD PTR __Last$[ebp]
  0002f	50		 push	 eax
  00030	8d 4d f8	 lea	 ecx, DWORD PTR __First$[ebp]
  00033	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator!=
  00038	0f b6 c8	 movzx	 ecx, al
  0003b	85 c9		 test	 ecx, ecx
  0003d	74 36		 je	 SHORT $LN1@erase

; 1195 : 			{	// worth doing, copy down over hole
; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 			if (_Last < _First || _VICONT(_First) != this
; 1198 : 				|| _VIPTR(_First) < this->_Myfirst
; 1199 : 				|| this->_Mylast < _VIPTR(_Last))
; 1200 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1201 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1202 : 				_VIPTR(_First));
; 1203 : 			_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1204 : 
; 1205 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1206 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1207 : 				_VIPTR(_First));

  0003f	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00042	50		 push	 eax
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00049	52		 push	 edx
  0004a	8b 45 f4	 mov	 eax, DWORD PTR __Last$[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ??$_Move@PAUEVENT_ID_TIME@@PAU1@@std@@YAPAUEVENT_ID_TIME@@PAU1@00@Z ; std::_Move<EVENT_ID_TIME *,EVENT_ID_TIME *>
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH
  00056	89 45 f0	 mov	 DWORD PTR __Ptr$225015[ebp], eax

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 			_Destroy(_Ptr, this->_Mylast);

  00059	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005f	51		 push	 ecx
  00060	8b 55 f0	 mov	 edx, DWORD PTR __Ptr$225015[ebp]
  00063	52		 push	 edx
  00064	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@IAEXPAUEVENT_ID_TIME@@0@Z ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::_Destroy

; 1211 : 			this->_Mylast = _Ptr;

  0006c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006f	8b 4d f0	 mov	 ecx, DWORD PTR __Ptr$225015[ebp]
  00072	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@erase:

; 1212 : 			}
; 1213 : 		return (_Make_iter(_First));

  00075	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00078	89 45 ac	 mov	 DWORD PTR $T227383[ebp], eax
  0007b	8b 4d ac	 mov	 ecx, DWORD PTR $T227383[ebp]
  0007e	51		 push	 ecx
  0007f	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00082	52		 push	 edx
  00083	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@2@@Z ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::_Make_iter
  0008b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1214 : 		}

  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@2@0@Z ENDP ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::erase
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Inside@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@IBE_NPBUEVENT_ID_TIME@@@Z
_TEXT	SEGMENT
tv76 = -72						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@IBE_NPBUEVENT_ID_TIME@@@Z PROC ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00012	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00015	73 13		 jae	 SHORT $LN3@Inside
  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	3b 45 08	 cmp	 eax, DWORD PTR __Ptr$[ebp]
  0001f	77 09		 ja	 SHORT $LN3@Inside
  00021	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  00028	eb 07		 jmp	 SHORT $LN4@Inside
$LN3@Inside:
  0002a	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN4@Inside:
  00031	8a 45 b8	 mov	 al, BYTE PTR tv76[ebp]

; 1287 : 		}

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?_Inside@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@IBE_NPBUEVENT_ID_TIME@@@Z ENDP ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::_Inside
_TEXT	ENDS
PUBLIC	?reserve@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAEXI@Z ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::reserve
PUBLIC	?_Grow_to@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@IBEII@Z ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::_Grow_to
PUBLIC	?capacity@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QBEIXZ ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::capacity
PUBLIC	?_Xlen@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@IBEXXZ ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::_Xlen
PUBLIC	?max_size@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QBEIXZ ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::max_size
PUBLIC	?size@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QBEIXZ ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::size
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Reserve@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$ = -8						; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@IAEXI@Z PROC ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1291 : 		size_type _Size = size();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?size@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QBEIXZ ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::size
  00014	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax

; 1292 : 		if (max_size() - _Count < _Size)

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QBEIXZ ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::max_size
  0001f	2b 45 08	 sub	 eax, DWORD PTR __Count$[ebp]
  00022	3b 45 f8	 cmp	 eax, DWORD PTR __Size$[ebp]
  00025	73 0a		 jae	 SHORT $LN4@Reserve

; 1293 : 			_Xlen();

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@IBEXXZ ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::_Xlen
  0002f	eb 2d		 jmp	 SHORT $LN6@Reserve
$LN4@Reserve:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00031	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  00034	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]
  00037	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?capacity@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QBEIXZ ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::capacity
  00042	39 45 f8	 cmp	 DWORD PTR __Size$[ebp], eax
  00045	77 02		 ja	 SHORT $LN2@Reserve

; 1295 : 			;
; 1296 : 		else

  00047	eb 15		 jmp	 SHORT $LN6@Reserve
$LN2@Reserve:

; 1297 : 			reserve(_Grow_to(_Size));

  00049	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?_Grow_to@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@IBEII@Z ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::_Grow_to
  00055	50		 push	 eax
  00056	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ?reserve@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAEXI@Z ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::reserve
$LN6@Reserve:

; 1298 : 		}

  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?_Reserve@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@IAEXI@Z ENDP ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::_Reserve
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UEVENT_ID_TIME@@@std@@QAEXPAUEVENT_ID_TIME@@I@Z ; std::allocator<EVENT_ID_TIME>::deallocate
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Tidy@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@IAEXXZ PROC ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1302 : 		if (this->_Myfirst != 0)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00012	74 3d		 je	 SHORT $LN1@Tidy

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00022	51		 push	 ecx
  00023	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00026	8b 02		 mov	 eax, DWORD PTR [edx]
  00028	50		 push	 eax
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@IAEXPAUEVENT_ID_TIME@@0@Z ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::_Destroy

; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0003a	2b 11		 sub	 edx, DWORD PTR [ecx]
  0003c	c1 fa 04	 sar	 edx, 4
  0003f	52		 push	 edx
  00040	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b 08		 mov	 ecx, DWORD PTR [eax]
  00045	51		 push	 ecx
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0004c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UEVENT_ID_TIME@@@std@@QAEXPAUEVENT_ID_TIME@@I@Z ; std::allocator<EVENT_ID_TIME>::deallocate
$LN1@Tidy:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00051	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00054	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1310 : 		this->_Mylast = 0;

  0005a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1311 : 		this->_Myend = 0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 1312 : 		}

  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
?_Tidy@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@IAEXXZ ENDP ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::_Tidy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Orphan_range@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@IBEXPAUEVENT_ID_TIME@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@IBEXPAUEVENT_ID_TIME@@0@Z PROC ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1453 : 		{	// orphan iterators within specified (inclusive) range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1454 : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@IBEXPAUEVENT_ID_TIME@@0@Z ENDP ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??0?$allocator@UEVENT_ID_TIME@@@std@@QAE@ABV01@@Z ; std::allocator<EVENT_ID_TIME>::allocator<EVENT_ID_TIME>
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE@V?$allocator@UEVENT_ID_TIME@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE@V?$allocator@UEVENT_ID_TIME@@@1@@Z PROC ; std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00016	e8 00 00 00 00	 call	 ??0?$allocator@UEVENT_ID_TIME@@@std@@QAE@ABV01@@Z ; std::allocator<EVENT_ID_TIME>::allocator<EVENT_ID_TIME>

; 427  : 		_Myfirst = 0;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 428  : 		_Mylast = 0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 429  : 		_Myend = 0;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 430  : 		}

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
??0?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE@V?$allocator@UEVENT_ID_TIME@@@1@@Z ENDP ; std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::~_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >, COMDAT
; _this$ = ecx

; 433  : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 434  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::~_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UEVENT_ID_TIME@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@UEVENT_ID_TIME@@@std@@QAE@XZ PROC	; std::allocator<EVENT_ID_TIME>::allocator<EVENT_ID_TIME>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@UEVENT_ID_TIME@@@std@@QAE@XZ ENDP	; std::allocator<EVENT_ID_TIME>::allocator<EVENT_ID_TIME>
_TEXT	ENDS
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAX@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >
PUBLIC	??0?$allocator@U?$pair@$$CBHPAX@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,void *> >::allocator<std::pair<int const ,void *> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAX@std@@@1@@Z
_TEXT	SEGMENT
$T227402 = -72						; size = 4
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAX@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >, COMDAT
; _this$ = ecx

; 698  : 		{	// construct empty tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	51		 push	 ecx
  0000d	8b cc		 mov	 ecx, esp
  0000f	89 65 b8	 mov	 DWORD PTR $T227402[ebp], esp
  00012	8b 45 0c	 mov	 eax, DWORD PTR __Al$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??0?$allocator@U?$pair@$$CBHPAX@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,void *> >::allocator<std::pair<int const ,void *> >
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ??0?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAX@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >

; 699  : 		}

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8
??0?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAX@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >
_TEXT	ENDS
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Lbound
; Function compile flags: /Odtp /ZI
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@ABH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1449 : 		{	// find leftmost node not less than _Keyval in mutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1450 : 		return (iterator(_Lbound(_Keyval), this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Keyval$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Lbound
  0001c	50		 push	 eax
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00020	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >
  00025	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1451 : 		}

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
?lower_bound@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Node>::deallocate
PUBLIC	??$_Dest_val@V?$allocator@U?$pair@$$CBHPAX@std@@@std@@U?$pair@$$CBHPAX@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHPAX@std@@@0@PAU?$pair@$$CBHPAX@0@@Z ; std::_Dest_val<std::allocator<std::pair<int const ,void *> >,std::pair<int const ,void *> >
PUBLIC	??$addressof@U?$pair@$$CBHPAX@std@@@std@@YAPAU?$pair@$$CBHPAX@0@AAU10@@Z ; std::addressof<std::pair<int const ,void *> >
PUBLIC	?_Myval@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHPAX@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Myval
PUBLIC	?_Left@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Left
PUBLIC	?_Right@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Right
PUBLIC	?_Isnil@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Isnil
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$225059 = -8					; size = 4
_this$ = -4						; size = 4
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1610 : 		{	// free entire subtree, recursively

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1611 : 		for (_Nodeptr _Pnode = _Rootnode;

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __Pnode$225059[ebp], eax
  00012	eb 06		 jmp	 SHORT $LN3@Erase
$LN2@Erase:

; 1612 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  00014	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$225059[ebp]
  00017	89 45 08	 mov	 DWORD PTR __Rootnode$[ebp], eax
$LN3@Erase:
  0001a	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$225059[ebp]
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Isnil
  00023	83 c4 04	 add	 esp, 4
  00026	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00029	85 c9		 test	 ecx, ecx
  0002b	75 60		 jne	 SHORT $LN4@Erase

; 1613 : 			{	// free subtrees, then node
; 1614 : 			_Erase(this->_Right(_Pnode));

  0002d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$225059[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Right
  00036	83 c4 04	 add	 esp, 4
  00039	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003b	51		 push	 ecx
  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Erase

; 1615 : 			_Pnode = this->_Left(_Pnode);

  00044	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$225059[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Left
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 08		 mov	 ecx, DWORD PTR [eax]
  00052	89 4d f8	 mov	 DWORD PTR __Pnode$225059[ebp], ecx

; 1616 : 			_Dest_val(this->_Alval,
; 1617 : 				_STD addressof(this->_Myval(_Rootnode)));

  00055	8b 45 08	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHPAX@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Myval
  0005e	83 c4 04	 add	 esp, 4
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ??$addressof@U?$pair@$$CBHPAX@std@@@std@@YAPAU?$pair@$$CBHPAX@0@AAU10@@Z ; std::addressof<std::pair<int const ,void *> >
  00067	83 c4 04	 add	 esp, 4
  0006a	50		 push	 eax
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006e	83 c1 0d	 add	 ecx, 13			; 0000000dH
  00071	51		 push	 ecx
  00072	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBHPAX@std@@@std@@U?$pair@$$CBHPAX@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHPAX@std@@@0@PAU?$pair@$$CBHPAX@0@@Z ; std::_Dest_val<std::allocator<std::pair<int const ,void *> >,std::pair<int const ,void *> >
  00077	83 c4 08	 add	 esp, 8

; 1618 : 
; 1619 : 			this->_Alnod.deallocate(_Rootnode, 1);

  0007a	6a 01		 push	 1
  0007c	8b 45 08	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  0007f	50		 push	 eax
  00080	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00083	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00086	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Node>::deallocate

; 1620 : 			}

  0008b	eb 87		 jmp	 SHORT $LN2@Erase
$LN4@Erase:

; 1621 : 		}

  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	5b		 pop	 ebx
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c2 04 00	 ret	 4
?_Erase@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Erase
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Lmost@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1758 : 		{	// return leftmost node in nonmutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1759 : 		return (this->_Left(this->_Myhead));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Left
  00018	83 c4 04	 add	 esp, 4

; 1760 : 		}

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Lmost
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Rmost@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1783 : 		{	// return rightmost node in nonmutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1784 : 		return (this->_Right(this->_Myhead));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Right
  00018	83 c4 04	 add	 esp, 4

; 1785 : 		}

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?_Rmost@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Rmost
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Root@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Root, COMDAT
; _this$ = ecx

; 1788 : 		{	// return root of nonmutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1789 : 		return (this->_Parent(this->_Myhead));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  00018	83 c4 04	 add	 esp, 4

; 1790 : 		}

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Root
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::erase
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::begin
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T227416 = -88						; size = 4
$T227417 = -84						; size = 4
$T227418 = -80						; size = 4
$T227419 = -76						; size = 4
$T227420 = -72						; size = 4
_this$ = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1865 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1866 : 		erase(begin(), end());

  0000c	8d 45 ac	 lea	 eax, DWORD PTR $T227417[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::end
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d a8	 mov	 DWORD PTR $T227416[ebp], ecx
  0001d	8d 55 b4	 lea	 edx, DWORD PTR $T227419[ebp]
  00020	52		 push	 edx
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::begin
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 b0	 mov	 DWORD PTR $T227418[ebp], eax
  0002e	8b 4d a8	 mov	 ecx, DWORD PTR $T227416[ebp]
  00031	51		 push	 ecx
  00032	8b 55 b0	 mov	 edx, DWORD PTR $T227418[ebp]
  00035	52		 push	 edx
  00036	8d 45 b8	 lea	 eax, DWORD PTR $T227420[ebp]
  00039	50		 push	 eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::erase

; 1867 : 		}

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?_Tidy@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Tidy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::~_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >, COMDAT
; _this$ = ecx

; 554  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 555  : 		this->_Alnod.deallocate(this->_Myhead, 1);

  0000c	6a 01		 push	 1
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00014	51		 push	 ecx
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0001b	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Node>::deallocate

; 556  : 		}

  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??1?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::~_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >
_TEXT	ENDS
PUBLIC	??$_Kfn@$$CBHPAX@?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHPAX@1@@Z ; std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0>::_Kfn<int const ,void *>
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Key@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Key, COMDAT

; 616  : 		{	// return reference to key in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 617  : 		return ((key_type&)_Traits::_Kfn(_Myval(_Pnode)));

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHPAX@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Myval
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??$_Kfn@$$CBHPAX@?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHPAX@1@@Z ; std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0>::_Kfn<int const ,void *>
  0001b	83 c4 04	 add	 esp, 4

; 618  : 		}

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
?_Key@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Key
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHPAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@U?$pair@$$CBHPAX@std@@@std@@QAE@XZ PROC	; std::allocator<std::pair<int const ,void *> >::allocator<std::pair<int const ,void *> >, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@U?$pair@$$CBHPAX@std@@@std@@QAE@XZ ENDP	; std::allocator<std::pair<int const ,void *> >::allocator<std::pair<int const ,void *> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xfunctional
_TEXT	ENDS
;	COMDAT ??R?$less@H@std@@QBE_NABH0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@H@std@@QBE_NABH0@Z PROC			; std::less<int>::operator(), COMDAT
; _this$ = ecx

; 124  : 		{	// apply operator< to operands

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 125  : 		return (_Left < _Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0000f	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00012	8b 10		 mov	 edx, DWORD PTR [eax]
  00014	33 c0		 xor	 eax, eax
  00016	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00018	0f 9c c0	 setl	 al

; 126  : 		}

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
??R?$less@H@std@@QBE_NABH0@Z ENDP			; std::less<int>::operator()
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@IAEXPAUEVENT_ID_ITEM_LIST@@0@Z ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::_Destroy
PUBLIC	??$_Move@PAUEVENT_ID_ITEM_LIST@@PAU1@@std@@YAPAUEVENT_ID_ITEM_LIST@@PAU1@00@Z ; std::_Move<EVENT_ID_ITEM_LIST *,EVENT_ID_ITEM_LIST *>
PUBLIC	?_Make_iter@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@2@@Z ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::_Make_iter
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?erase@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T227431 = -84						; size = 4
__Ptr$225108 = -16					; size = 4
__Last$ = -12						; size = 4
__First$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@2@0@Z PROC ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::erase, COMDAT
; _this$ = ecx

; 1190 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1191 : 		iterator _First = _Make_iter(_First_arg);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __First_arg$[ebp]
  0000f	50		 push	 eax
  00010	8d 4d f8	 lea	 ecx, DWORD PTR __First$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@2@@Z ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::_Make_iter

; 1192 : 		iterator _Last = _Make_iter(_Last_arg);

  0001c	8b 45 10	 mov	 eax, DWORD PTR __Last_arg$[ebp]
  0001f	50		 push	 eax
  00020	8d 4d f4	 lea	 ecx, DWORD PTR __Last$[ebp]
  00023	51		 push	 ecx
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@2@@Z ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::_Make_iter

; 1193 : 
; 1194 : 		if (_First != _Last)

  0002c	8d 45 f4	 lea	 eax, DWORD PTR __Last$[ebp]
  0002f	50		 push	 eax
  00030	8d 4d f8	 lea	 ecx, DWORD PTR __First$[ebp]
  00033	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::operator!=
  00038	0f b6 c8	 movzx	 ecx, al
  0003b	85 c9		 test	 ecx, ecx
  0003d	74 36		 je	 SHORT $LN1@erase@2

; 1195 : 			{	// worth doing, copy down over hole
; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 			if (_Last < _First || _VICONT(_First) != this
; 1198 : 				|| _VIPTR(_First) < this->_Myfirst
; 1199 : 				|| this->_Mylast < _VIPTR(_Last))
; 1200 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1201 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1202 : 				_VIPTR(_First));
; 1203 : 			_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1204 : 
; 1205 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1206 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1207 : 				_VIPTR(_First));

  0003f	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00042	50		 push	 eax
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00049	52		 push	 edx
  0004a	8b 45 f4	 mov	 eax, DWORD PTR __Last$[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ??$_Move@PAUEVENT_ID_ITEM_LIST@@PAU1@@std@@YAPAUEVENT_ID_ITEM_LIST@@PAU1@00@Z ; std::_Move<EVENT_ID_ITEM_LIST *,EVENT_ID_ITEM_LIST *>
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH
  00056	89 45 f0	 mov	 DWORD PTR __Ptr$225108[ebp], eax

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 			_Destroy(_Ptr, this->_Mylast);

  00059	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005f	51		 push	 ecx
  00060	8b 55 f0	 mov	 edx, DWORD PTR __Ptr$225108[ebp]
  00063	52		 push	 edx
  00064	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@IAEXPAUEVENT_ID_ITEM_LIST@@0@Z ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::_Destroy

; 1211 : 			this->_Mylast = _Ptr;

  0006c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006f	8b 4d f0	 mov	 ecx, DWORD PTR __Ptr$225108[ebp]
  00072	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@erase@2:

; 1212 : 			}
; 1213 : 		return (_Make_iter(_First));

  00075	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00078	89 45 ac	 mov	 DWORD PTR $T227431[ebp], eax
  0007b	8b 4d ac	 mov	 ecx, DWORD PTR $T227431[ebp]
  0007e	51		 push	 ecx
  0007f	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00082	52		 push	 edx
  00083	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@2@@Z ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::_Make_iter
  0008b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1214 : 		}

  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@2@0@Z ENDP ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::erase
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Inside@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@IBE_NPBUEVENT_ID_ITEM_LIST@@@Z
_TEXT	SEGMENT
tv76 = -72						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@IBE_NPBUEVENT_ID_ITEM_LIST@@@Z PROC ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00012	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00015	73 13		 jae	 SHORT $LN3@Inside@2
  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	3b 45 08	 cmp	 eax, DWORD PTR __Ptr$[ebp]
  0001f	77 09		 ja	 SHORT $LN3@Inside@2
  00021	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  00028	eb 07		 jmp	 SHORT $LN4@Inside@2
$LN3@Inside@2:
  0002a	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN4@Inside@2:
  00031	8a 45 b8	 mov	 al, BYTE PTR tv76[ebp]

; 1287 : 		}

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?_Inside@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@IBE_NPBUEVENT_ID_ITEM_LIST@@@Z ENDP ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::_Inside
_TEXT	ENDS
PUBLIC	?reserve@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAEXI@Z ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::reserve
PUBLIC	?_Grow_to@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@IBEII@Z ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::_Grow_to
PUBLIC	?capacity@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QBEIXZ ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::capacity
PUBLIC	?_Xlen@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@IBEXXZ ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::_Xlen
PUBLIC	?max_size@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QBEIXZ ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::max_size
PUBLIC	?size@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QBEIXZ ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::size
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Reserve@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$ = -8						; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@IAEXI@Z PROC ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1291 : 		size_type _Size = size();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?size@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QBEIXZ ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::size
  00014	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax

; 1292 : 		if (max_size() - _Count < _Size)

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QBEIXZ ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::max_size
  0001f	2b 45 08	 sub	 eax, DWORD PTR __Count$[ebp]
  00022	3b 45 f8	 cmp	 eax, DWORD PTR __Size$[ebp]
  00025	73 0a		 jae	 SHORT $LN4@Reserve@2

; 1293 : 			_Xlen();

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@IBEXXZ ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::_Xlen
  0002f	eb 2d		 jmp	 SHORT $LN6@Reserve@2
$LN4@Reserve@2:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00031	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  00034	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]
  00037	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?capacity@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QBEIXZ ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::capacity
  00042	39 45 f8	 cmp	 DWORD PTR __Size$[ebp], eax
  00045	77 02		 ja	 SHORT $LN2@Reserve@2

; 1295 : 			;
; 1296 : 		else

  00047	eb 15		 jmp	 SHORT $LN6@Reserve@2
$LN2@Reserve@2:

; 1297 : 			reserve(_Grow_to(_Size));

  00049	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?_Grow_to@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@IBEII@Z ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::_Grow_to
  00055	50		 push	 eax
  00056	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ?reserve@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAEXI@Z ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::reserve
$LN6@Reserve@2:

; 1298 : 		}

  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?_Reserve@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@IAEXI@Z ENDP ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::_Reserve
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAEXPAUEVENT_ID_ITEM_LIST@@I@Z ; std::allocator<EVENT_ID_ITEM_LIST>::deallocate
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Tidy@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@IAEXXZ PROC ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1302 : 		if (this->_Myfirst != 0)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00012	74 42		 je	 SHORT $LN1@Tidy@2

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00022	51		 push	 ecx
  00023	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00026	8b 02		 mov	 eax, DWORD PTR [edx]
  00028	50		 push	 eax
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@IAEXPAUEVENT_ID_ITEM_LIST@@0@Z ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::_Destroy

; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0003a	2b 01		 sub	 eax, DWORD PTR [ecx]
  0003c	99		 cdq
  0003d	b9 05 00 00 00	 mov	 ecx, 5
  00042	f7 f9		 idiv	 ecx
  00044	50		 push	 eax
  00045	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00048	8b 02		 mov	 eax, DWORD PTR [edx]
  0004a	50		 push	 eax
  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00051	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAEXPAUEVENT_ID_ITEM_LIST@@I@Z ; std::allocator<EVENT_ID_ITEM_LIST>::deallocate
$LN1@Tidy@2:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00056	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00059	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1310 : 		this->_Mylast = 0;

  0005f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00062	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1311 : 		this->_Myend = 0;

  00069	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 1312 : 		}

  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	5b		 pop	 ebx
  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
?_Tidy@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@IAEXXZ ENDP ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::_Tidy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Orphan_range@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@IBEXPAUEVENT_ID_ITEM_LIST@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@IBEXPAUEVENT_ID_ITEM_LIST@@0@Z PROC ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1453 : 		{	// orphan iterators within specified (inclusive) range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1454 : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@IBEXPAUEVENT_ID_ITEM_LIST@@0@Z ENDP ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??0?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAE@ABV01@@Z ; std::allocator<EVENT_ID_ITEM_LIST>::allocator<EVENT_ID_ITEM_LIST>
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAE@V?$allocator@UEVENT_ID_ITEM_LIST@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAE@V?$allocator@UEVENT_ID_ITEM_LIST@@@1@@Z PROC ; std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00016	e8 00 00 00 00	 call	 ??0?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAE@ABV01@@Z ; std::allocator<EVENT_ID_ITEM_LIST>::allocator<EVENT_ID_ITEM_LIST>

; 427  : 		_Myfirst = 0;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 428  : 		_Mylast = 0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 429  : 		_Myend = 0;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 430  : 		}

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
??0?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAE@V?$allocator@UEVENT_ID_ITEM_LIST@@@1@@Z ENDP ; std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::~_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >, COMDAT
; _this$ = ecx

; 433  : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 434  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::~_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAE@XZ PROC	; std::allocator<EVENT_ID_ITEM_LIST>::allocator<EVENT_ID_ITEM_LIST>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAE@XZ ENDP	; std::allocator<EVENT_ID_ITEM_LIST>::allocator<EVENT_ID_ITEM_LIST>
_TEXT	ENDS
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >, COMDAT
; _this$ = ecx

; 378  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Plist$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >

; 379  : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >
_TEXT	ENDS
PUBLIC	??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHPAX@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator*
; Function compile flags: /Odtp /ZI
;	COMDAT ??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHPAX@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHPAX@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator*, COMDAT
; _this$ = ecx

; 395  : 		{	// return designated value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 396  : 		return ((reference)**(_Mybase *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHPAX@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator*

; 397  : 		}

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHPAX@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator*
_TEXT	ENDS
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >,std::_Iterator_base0>
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >, COMDAT
; _this$ = ecx

; 208  : 		{	// construct with null node pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >,std::_Iterator_base0>

; 209  : 		}

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator==, COMDAT
; _this$ = ecx

; 316  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 317  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 318  : 		if (this->_Getcont() == 0
; 319  : 			|| this->_Getcont() != _Right._Getcont())
; 320  : 			{	// report error
; 321  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 322  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 323  : 			}
; 324  : 
; 325  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 326  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 327  : 			&& this->_Getcont() == _Right._Getcont());
; 328  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 329  : 
; 330  : 		return (this->_Ptr == _Right._Ptr);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00012	8b 10		 mov	 edx, DWORD PTR [eax]
  00014	33 c0		 xor	 eax, eax
  00016	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00018	0f 94 c0	 sete	 al

; 331  : 		}

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator==
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 121  : 		{	// return node pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 122  : 		return (_Ptr);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]

; 123  : 		}

  00011	5f		 pop	 edi
  00012	5e		 pop	 esi
  00013	5b		 pop	 ebx
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QAE@PAUEVENT_ID_TIME@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::_Vector_const_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QAE@PAUEVENT_ID_TIME@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QAE@PAUEVENT_ID_TIME@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QAE@PAUEVENT_ID_TIME@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::_Vector_const_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >

; 305  : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QAE@PAUEVENT_ID_TIME@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator++
; Function compile flags: /Odtp /ZI
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator++, COMDAT
; _this$ = ecx

; 331  : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 332  : 		++*(_Mybase *)this;

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??E?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator++

; 333  : 		return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 334  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??E?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator++
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::_Vector_const_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >, COMDAT
; _this$ = ecx

; 40   : 		{	// construct with null pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 41   : 		}

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::_Vector_const_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QBEABUEVENT_ID_TIME@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QBEABUEVENT_ID_TIME@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator*, COMDAT
; _this$ = ecx

; 63   : 		{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
$LN2@operator:

; 64   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 65   : 		if (this->_Getcont() == 0
; 66   : 			|| this->_Ptr == 0
; 67   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 68   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 69   : 			{	// report error
; 70   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 71   : 			_SCL_SECURE_OUT_OF_RANGE;
; 72   : 			}
; 73   : 
; 74   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 75   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 76   : 		_SCL_SECURE_VALIDATE_RANGE(
; 77   : 			this->_Ptr != 0
; 78   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 79   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 80   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 81   : 
; 82   : 		__analysis_assume(this->_Ptr != 0);

  0000c	33 c0		 xor	 eax, eax
  0000e	75 fc		 jne	 SHORT $LN2@operator

; 83   : 
; 84   : 		return (*this->_Ptr);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 00		 mov	 eax, DWORD PTR [eax]

; 85   : 		}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QBEABUEVENT_ID_TIME@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator*
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::_Compat
; Function compile flags: /Odtp /ZI
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		_Compat(_Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::_Compat

; 203  : 		return (this->_Ptr == _Right._Ptr);

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001e	8b 10		 mov	 edx, DWORD PTR [eax]
  00020	33 c0		 xor	 eax, eax
  00022	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00024	0f 94 c0	 sete	 al

; 204  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator==
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QAE@PAUEVENT_ID_ITEM_LIST@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::_Vector_const_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QAE@PAUEVENT_ID_ITEM_LIST@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QAE@PAUEVENT_ID_ITEM_LIST@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::_Vector_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QAE@PAUEVENT_ID_ITEM_LIST@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::_Vector_const_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >

; 305  : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QAE@PAUEVENT_ID_ITEM_LIST@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::_Vector_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::_Vector_const_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >, COMDAT
; _this$ = ecx

; 40   : 		{	// construct with null pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 41   : 		}

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::_Vector_const_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QBEABUEVENT_ID_ITEM_LIST@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QBEABUEVENT_ID_ITEM_LIST@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::operator*, COMDAT
; _this$ = ecx

; 63   : 		{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
$LN2@operator@2:

; 64   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 65   : 		if (this->_Getcont() == 0
; 66   : 			|| this->_Ptr == 0
; 67   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 68   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 69   : 			{	// report error
; 70   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 71   : 			_SCL_SECURE_OUT_OF_RANGE;
; 72   : 			}
; 73   : 
; 74   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 75   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 76   : 		_SCL_SECURE_VALIDATE_RANGE(
; 77   : 			this->_Ptr != 0
; 78   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 79   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 80   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 81   : 
; 82   : 		__analysis_assume(this->_Ptr != 0);

  0000c	33 c0		 xor	 eax, eax
  0000e	75 fc		 jne	 SHORT $LN2@operator@2

; 83   : 
; 84   : 		return (*this->_Ptr);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 00		 mov	 eax, DWORD PTR [eax]

; 85   : 		}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QBEABUEVENT_ID_ITEM_LIST@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::operator*
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::operator++, COMDAT
; _this$ = ecx

; 93   : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 94   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 95   : 		if (this->_Getcont() == 0
; 96   : 			|| this->_Ptr == 0
; 97   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 98   : 			{	// report error
; 99   : 			_DEBUG_ERROR("vector iterator not incrementable");
; 100  : 			_SCL_SECURE_OUT_OF_RANGE;
; 101  : 			}
; 102  : 
; 103  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 104  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 105  : 		_SCL_SECURE_VALIDATE_RANGE(
; 106  : 			this->_Ptr != 0
; 107  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 108  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 109  : 
; 110  : 		++this->_Ptr;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	83 c1 05	 add	 ecx, 5
  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	89 0a		 mov	 DWORD PTR [edx], ecx

; 111  : 		return (*this);

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 112  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::operator++
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::_Compat
; Function compile flags: /Odtp /ZI
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		_Compat(_Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::_Compat

; 203  : 		return (this->_Ptr == _Right._Ptr);

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001e	8b 10		 mov	 edx, DWORD PTR [eax]
  00020	33 c0		 xor	 eax, eax
  00022	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00024	0f 94 c0	 sete	 al

; 204  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::operator==
_TEXT	ENDS
PUBLIC	??$_Umove@PAUEVENT_ID_TIME@@@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@IAEPAUEVENT_ID_TIME@@PAU2@00@Z ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::_Umove<EVENT_ID_TIME *>
PUBLIC	?allocate@?$allocator@UEVENT_ID_TIME@@@std@@QAEPAUEVENT_ID_TIME@@I@Z ; std::allocator<EVENT_ID_TIME>::allocate
EXTRN	__CxxThrowException@8:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Size$225189 = -28					; size = 4
__Ptr$225182 = -24					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?reserve@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAEXI@Z PROC ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?reserve@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 747  : 		if (max_size() < _Count)

  0002f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?max_size@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QBEIXZ ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::max_size
  00037	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0003a	73 0d		 jae	 SHORT $LN5@reserve

; 748  : 			_Xlen();	// result too long

  0003c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@IBEXXZ ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::_Xlen
  00044	e9 eb 00 00 00	 jmp	 $LN7@reserve
$LN5@reserve:

; 749  : 		else if (capacity() < _Count)

  00049	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?capacity@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QBEIXZ ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::capacity
  00051	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  00054	0f 83 da 00 00
	00		 jae	 $LN7@reserve

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  0005a	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00064	e8 00 00 00 00	 call	 ?allocate@?$allocator@UEVENT_ID_TIME@@@std@@QAEPAUEVENT_ID_TIME@@I@Z ; std::allocator<EVENT_ID_TIME>::allocate
  00069	89 45 e8	 mov	 DWORD PTR __Ptr$225182[ebp], eax

; 752  : 
; 753  : 			_TRY_BEGIN

  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00073	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$225182[ebp]
  00076	50		 push	 eax
  00077	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007d	52		 push	 edx
  0007e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 08		 mov	 ecx, DWORD PTR [eax]
  00083	51		 push	 ecx
  00084	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	e8 00 00 00 00	 call	 ??$_Umove@PAUEVENT_ID_TIME@@@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@IAEPAUEVENT_ID_TIME@@PAU2@00@Z ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::_Umove<EVENT_ID_TIME *>
  0008c	eb 29		 jmp	 SHORT $LN8@reserve
__catch$?reserve@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  0008e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00091	50		 push	 eax
  00092	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$225182[ebp]
  00095	51		 push	 ecx
  00096	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0009c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UEVENT_ID_TIME@@@std@@QAEXPAUEVENT_ID_TIME@@I@Z ; std::allocator<EVENT_ID_TIME>::deallocate

; 757  : 			_RERAISE;

  000a1	6a 00		 push	 0
  000a3	6a 00		 push	 0
  000a5	e8 00 00 00 00	 call	 __CxxThrowException@8

; 758  : 			_CATCH_END

  000aa	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000b1	b8 00 00 00 00	 mov	 eax, __tryend$?reserve@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAEXI@Z$1
  000b6	c3		 ret	 0
$LN8@reserve:
  000b7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?reserve@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAEXI@Z$1:

; 759  : 
; 760  : 			size_type _Size = size();

  000be	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	e8 00 00 00 00	 call	 ?size@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QBEIXZ ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::size
  000c6	89 45 e4	 mov	 DWORD PTR __Size$225189[ebp], eax

; 761  : 			if (this->_Myfirst != 0)

  000c9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000cc	83 38 00	 cmp	 DWORD PTR [eax], 0
  000cf	74 35		 je	 SHORT $LN1@reserve

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);

  000d1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d7	51		 push	 ecx
  000d8	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000db	8b 02		 mov	 eax, DWORD PTR [edx]
  000dd	50		 push	 eax
  000de	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@IAEXPAUEVENT_ID_TIME@@0@Z ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::_Destroy

; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  000e6	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000ef	2b 11		 sub	 edx, DWORD PTR [ecx]
  000f1	c1 fa 04	 sar	 edx, 4
  000f4	52		 push	 edx
  000f5	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000f8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fa	51		 push	 ecx
  000fb	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000fe	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00101	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UEVENT_ID_TIME@@@std@@QAEXPAUEVENT_ID_TIME@@I@Z ; std::allocator<EVENT_ID_TIME>::deallocate
$LN1@reserve:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();

  00106	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 769  : 			this->_Myend = _Ptr + _Count;

  0010e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00111	c1 e0 04	 shl	 eax, 4
  00114	03 45 e8	 add	 eax, DWORD PTR __Ptr$225182[ebp]
  00117	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0011a	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 770  : 			this->_Mylast = _Ptr + _Size;

  0011d	8b 45 e4	 mov	 eax, DWORD PTR __Size$225189[ebp]
  00120	c1 e0 04	 shl	 eax, 4
  00123	03 45 e8	 add	 eax, DWORD PTR __Ptr$225182[ebp]
  00126	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00129	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 771  : 			this->_Myfirst = _Ptr;

  0012c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0012f	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$225182[ebp]
  00132	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@reserve:

; 772  : 			}
; 773  : 		}

  00134	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00137	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0013e	59		 pop	 ecx
  0013f	5f		 pop	 edi
  00140	5e		 pop	 esi
  00141	5b		 pop	 ebx
  00142	8b e5		 mov	 esp, ebp
  00144	5d		 pop	 ebp
  00145	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QAEXI@Z ENDP ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::reserve
; Function compile flags: /Odtp /ZI
;	COMDAT ?capacity@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?capacity@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QBEIXZ PROC ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::capacity, COMDAT
; _this$ = ecx

; 776  : 		{	// return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	c1 f8 04	 sar	 eax, 4

; 778  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?capacity@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QBEIXZ ENDP ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::capacity
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@2@@Z PROC ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::_Make_iter, COMDAT
; _this$ = ecx

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  : 		return (iterator(_Where._Ptr, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QAE@PAUEVENT_ID_TIME@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::_Vector_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 803  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
?_Make_iter@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@2@@Z ENDP ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::_Make_iter
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?size@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QBEIXZ PROC ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::size, COMDAT
; _this$ = ecx

; 878  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	c1 f8 04	 sar	 eax, 4

; 880  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?size@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QBEIXZ ENDP ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UEVENT_ID_TIME@@@std@@QBEIXZ ; std::allocator<EVENT_ID_TIME>::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?max_size@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QBEIXZ PROC ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::max_size, COMDAT
; _this$ = ecx

; 883  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		return (this->_Alval.max_size());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00012	e8 00 00 00 00	 call	 ?max_size@?$allocator@UEVENT_ID_TIME@@@std@@QBEIXZ ; std::allocator<EVENT_ID_TIME>::max_size

; 885  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?max_size@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QBEIXZ ENDP ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@YAXPAUEVENT_ID_TIME@@0AAV?$allocator@UEVENT_ID_TIME@@@0@@Z ; std::_Destroy_range<std::allocator<EVENT_ID_TIME> >
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Destroy@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@IAEXPAUEVENT_ID_TIME@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@IAEXPAUEVENT_ID_TIME@@0@Z PROC ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::_Destroy, COMDAT
; _this$ = ecx

; 1269 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@YAXPAUEVENT_ID_TIME@@0AAV?$allocator@UEVENT_ID_TIME@@@0@@Z ; std::_Destroy_range<std::allocator<EVENT_ID_TIME> >
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1271 : 		}

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
?_Destroy@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@IAEXPAUEVENT_ID_TIME@@0@Z ENDP ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::_Destroy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Grow_to@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -76						; size = 4
__Capacity$ = -8					; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@IBEII@Z PROC ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1275 : 		size_type _Capacity = capacity();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?capacity@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QBEIXZ ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::capacity
  00014	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@QBEIXZ ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::max_size
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  00022	d1 e9		 shr	 ecx, 1
  00024	2b c1		 sub	 eax, ecx
  00026	3b 45 f8	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  00029	73 09		 jae	 SHORT $LN4@Grow_to
  0002b	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  00032	eb 0b		 jmp	 SHORT $LN5@Grow_to
$LN4@Grow_to:
  00034	8b 55 f8	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00037	d1 ea		 shr	 edx, 1
  00039	03 55 f8	 add	 edx, DWORD PTR __Capacity$[ebp]
  0003c	89 55 b4	 mov	 DWORD PTR tv73[ebp], edx
$LN5@Grow_to:
  0003f	8b 45 b4	 mov	 eax, DWORD PTR tv73[ebp]
  00042	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1279 : 		if (_Capacity < _Count)

  00045	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00048	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0004b	73 06		 jae	 SHORT $LN1@Grow_to

; 1280 : 			_Capacity = _Count;

  0004d	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00050	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax
$LN1@Grow_to:

; 1281 : 		return (_Capacity);

  00053	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]

; 1282 : 		}

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
?_Grow_to@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@IBEII@Z ENDP ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::_Grow_to
_TEXT	ENDS
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ?_Xlen@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@IBEXXZ PROC ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::_Xlen, COMDAT
; _this$ = ecx

; 1426 : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00011	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen:

; 1428 : 		}

  00016	5f		 pop	 edi
  00017	5e		 pop	 esi
  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Xlen@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@IBEXXZ ENDP ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::_Xlen
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UEVENT_ID_TIME@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@UEVENT_ID_TIME@@@std@@QAE@ABV01@@Z PROC	; std::allocator<EVENT_ID_TIME>::allocator<EVENT_ID_TIME>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$allocator@UEVENT_ID_TIME@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<EVENT_ID_TIME>::allocator<EVENT_ID_TIME>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UEVENT_ID_TIME@@@std@@QAEXPAUEVENT_ID_TIME@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UEVENT_ID_TIME@@@std@@QAEXPAUEVENT_ID_TIME@@I@Z PROC ; std::allocator<EVENT_ID_TIME>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 182  : 		::operator delete(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4

; 183  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?deallocate@?$allocator@UEVENT_ID_TIME@@@std@@QAEXPAUEVENT_ID_TIME@@I@Z ENDP ; std::allocator<EVENT_ID_TIME>::deallocate
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::begin, COMDAT
; _this$ = ecx

; 806  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 807  : 		return (iterator(_Lmost(), this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Lmost
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	51		 push	 ecx
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001e	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >
  00023	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 808  : 		}

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::begin
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::erase
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator++
; Function compile flags: /Odtp /ZI
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T227518 = -84						; size = 4
$T227519 = -80						; size = 4
$T227520 = -76						; size = 4
$T227521 = -72						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::erase, COMDAT
; _this$ = ecx

; 1379 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1380 : 		if (_First == begin() && _Last == end())

  0000c	8d 45 ac	 lea	 eax, DWORD PTR $T227518[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::begin
  00018	50		 push	 eax
  00019	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  0001c	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator==
  00021	0f b6 c8	 movzx	 ecx, al
  00024	85 c9		 test	 ecx, ecx
  00026	74 37		 je	 SHORT $LN2@erase@3
  00028	8d 45 b0	 lea	 eax, DWORD PTR $T227519[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::end
  00034	50		 push	 eax
  00035	8d 4d 10	 lea	 ecx, DWORD PTR __Last$[ebp]
  00038	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator==
  0003d	0f b6 c8	 movzx	 ecx, al
  00040	85 c9		 test	 ecx, ecx
  00042	74 1b		 je	 SHORT $LN2@erase@3

; 1381 : 			{	// erase all
; 1382 : 			clear();

  00044	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::clear

; 1383 : 			return (begin());

  0004c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0004f	50		 push	 eax
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::begin
  00058	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0005b	eb 47		 jmp	 SHORT $LN5@erase@3

; 1384 : 			}
; 1385 : 		else

  0005d	eb 45		 jmp	 SHORT $LN5@erase@3
$LN2@erase@3:

; 1386 : 			{	// partial erase, one at a time
; 1387 : 			while (_First != _Last)

  0005f	8d 45 10	 lea	 eax, DWORD PTR __Last$[ebp]
  00062	50		 push	 eax
  00063	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  00066	e8 00 00 00 00	 call	 ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator!=
  0006b	0f b6 c8	 movzx	 ecx, al
  0006e	85 c9		 test	 ecx, ecx
  00070	74 1f		 je	 SHORT $LN1@erase@3

; 1388 : 				erase(_First++);

  00072	6a 00		 push	 0
  00074	8d 45 b4	 lea	 eax, DWORD PTR $T227520[ebp]
  00077	50		 push	 eax
  00078	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  0007b	e8 00 00 00 00	 call	 ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator++
  00080	8b 08		 mov	 ecx, DWORD PTR [eax]
  00082	51		 push	 ecx
  00083	8d 55 b8	 lea	 edx, DWORD PTR $T227521[ebp]
  00086	52		 push	 edx
  00087	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008a	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::erase
  0008f	eb ce		 jmp	 SHORT $LN2@erase@3
$LN1@erase@3:

; 1389 : 			return (iterator(_First._Ptr, this));

  00091	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00094	50		 push	 eax
  00095	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  00098	51		 push	 ecx
  00099	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0009c	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >
  000a1	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN5@erase@3:

; 1390 : 			}
; 1391 : 		}

  000a4	5f		 pop	 edi
  000a5	5e		 pop	 esi
  000a6	5b		 pop	 ebx
  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::erase
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT
__Wherenode$ = -12					; size = 4
__Pnode$ = -8						; size = 4
_this$ = -4						; size = 4
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 1741 : 		{	// find leftmost node not less than _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1742 : 		_Nodeptr _Pnode = _Root();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Root
  00014	8b 00		 mov	 eax, DWORD PTR [eax]
  00016	89 45 f8	 mov	 DWORD PTR __Pnode$[ebp], eax

; 1743 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001f	89 4d f4	 mov	 DWORD PTR __Wherenode$[ebp], ecx
$LN4@Lbound:

; 1744 : 
; 1745 : 		while (!this->_Isnil(_Pnode))

  00022	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Isnil
  0002b	83 c4 04	 add	 esp, 4
  0002e	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00031	85 c9		 test	 ecx, ecx
  00033	75 4c		 jne	 SHORT $LN3@Lbound

; 1746 : 			if (_DEBUG_LT_PRED(this->comp, this->_Key(_Pnode), _Keyval))

  00035	8b 45 08	 mov	 eax, DWORD PTR __Keyval$[ebp]
  00038	50		 push	 eax
  00039	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0003c	51		 push	 ecx
  0003d	e8 00 00 00 00	 call	 ?_Key@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Key
  00042	83 c4 04	 add	 esp, 4
  00045	50		 push	 eax
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  0004e	0f b6 d0	 movzx	 edx, al
  00051	85 d2		 test	 edx, edx
  00053	74 13		 je	 SHORT $LN2@Lbound

; 1747 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00055	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Right
  0005e	83 c4 04	 add	 esp, 4
  00061	8b 08		 mov	 ecx, DWORD PTR [eax]
  00063	89 4d f8	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 1748 : 			else

  00066	eb 17		 jmp	 SHORT $LN1@Lbound
$LN2@Lbound:

; 1749 : 				{	// _Pnode not less than _Keyval, remember it
; 1750 : 				_Wherenode = _Pnode;

  00068	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0006b	89 45 f4	 mov	 DWORD PTR __Wherenode$[ebp], eax

; 1751 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  0006e	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Left
  00077	83 c4 04	 add	 esp, 4
  0007a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007c	89 4d f8	 mov	 DWORD PTR __Pnode$[ebp], ecx
$LN1@Lbound:

; 1752 : 				}

  0007f	eb a1		 jmp	 SHORT $LN4@Lbound
$LN3@Lbound:

; 1753 : 
; 1754 : 		return (_Wherenode);	// return best remembered candidate

  00081	8b 45 f4	 mov	 eax, DWORD PTR __Wherenode$[ebp]

; 1755 : 		}

  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c2 04 00	 ret	 4
?_Lbound@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Lbound
_TEXT	ENDS
PUBLIC	?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Node>::allocate
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAX@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Tree_nod<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAX@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAX@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >, COMDAT
; _this$ = ecx

; 542  : 		{	// construct base, and allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	51		 push	 ecx
  0000d	8b cc		 mov	 ecx, esp
  0000f	8d 45 0c	 lea	 eax, DWORD PTR __Al$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??0?$allocator@U?$pair@$$CBHPAX@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,void *> >::allocator<std::pair<int const ,void *> >
  00018	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  0001b	51		 push	 ecx
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ??0?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAX@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Tree_nod<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >

; 543  : 		this->_Mysize = 0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 544  : 		this->_Myhead = this->_Alnod.allocate(1);

  0002e	6a 01		 push	 1
  00030	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00036	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Node>::allocate
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 545  : 
; 546  : 		this->_Left(this->_Myhead) = this->_Myhead;

  00041	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00044	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Left
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00053	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00056	89 08		 mov	 DWORD PTR [eax], ecx

; 547  : 		this->_Parent(this->_Myhead) = this->_Myhead;

  00058	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005e	51		 push	 ecx
  0005f	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  00064	83 c4 04	 add	 esp, 4
  00067	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0006a	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0006d	89 08		 mov	 DWORD PTR [eax], ecx

; 548  : 		this->_Right(this->_Myhead) = this->_Myhead;

  0006f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00072	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00075	51		 push	 ecx
  00076	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Right
  0007b	83 c4 04	 add	 esp, 4
  0007e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00081	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00084	89 08		 mov	 DWORD PTR [eax], ecx

; 549  : 		this->_Color(this->_Myhead) = this->_Black;

  00086	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00089	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0008c	51		 push	 ecx
  0008d	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
  00092	83 c4 04	 add	 esp, 4
  00095	c6 00 01	 mov	 BYTE PTR [eax], 1

; 550  : 		this->_Isnil(this->_Myhead) = true;

  00098	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0009e	51		 push	 ecx
  0009f	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Isnil
  000a4	83 c4 04	 add	 esp, 4
  000a7	c6 00 01	 mov	 BYTE PTR [eax], 1

; 551  : 		}

  000aa	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ad	5f		 pop	 edi
  000ae	5e		 pop	 esi
  000af	5b		 pop	 ebx
  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c2 08 00	 ret	 8
??0?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAX@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Isnil, COMDAT

; 611  : 		{	// return reference to nil flag in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 612  : 		return ((char&)(*_Pnode)._Isnil);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	83 c0 15	 add	 eax, 21			; 00000015H

; 613  : 		}

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Isnil@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Isnil
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Left, COMDAT

; 621  : 		{	// return reference to left pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 622  : 		return ((_Nodepref)(*_Pnode)._Left);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 623  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Left@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Left
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent, COMDAT

; 626  : 		{	// return reference to parent pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 627  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	83 c0 04	 add	 eax, 4

; 628  : 		}

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Right, COMDAT

; 631  : 		{	// return reference to right pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 632  : 		return ((_Nodepref)(*_Pnode)._Right);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	83 c0 08	 add	 eax, 8

; 633  : 		}

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Right@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Right
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHPAX@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHPAX@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Myval, COMDAT

; 636  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 637  : 		return ((reference)(*_Pnode)._Myval);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	83 c0 0c	 add	 eax, 12			; 0000000cH

; 638  : 		}

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Myval@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHPAX@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Myval
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHPAX@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@$$CBHPAX@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<int const ,void *> >::allocator<std::pair<int const ,void *> >, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$allocator@U?$pair@$$CBHPAX@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<int const ,void *> >::allocator<std::pair<int const ,void *> >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 182  : 		::operator delete(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4

; 183  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??$_Umove@PAUEVENT_ID_ITEM_LIST@@@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@IAEPAUEVENT_ID_ITEM_LIST@@PAU2@00@Z ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::_Umove<EVENT_ID_ITEM_LIST *>
PUBLIC	?allocate@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAEPAUEVENT_ID_ITEM_LIST@@I@Z ; std::allocator<EVENT_ID_ITEM_LIST>::allocate
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\vector
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Size$225288 = -28					; size = 4
__Ptr$225281 = -24					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?reserve@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAEXI@Z PROC ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?reserve@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 747  : 		if (max_size() < _Count)

  0002f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?max_size@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QBEIXZ ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::max_size
  00037	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0003a	73 0d		 jae	 SHORT $LN5@reserve@2

; 748  : 			_Xlen();	// result too long

  0003c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@IBEXXZ ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::_Xlen
  00044	e9 f0 00 00 00	 jmp	 $LN7@reserve@2
$LN5@reserve@2:

; 749  : 		else if (capacity() < _Count)

  00049	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?capacity@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QBEIXZ ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::capacity
  00051	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  00054	0f 83 df 00 00
	00		 jae	 $LN7@reserve@2

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  0005a	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00064	e8 00 00 00 00	 call	 ?allocate@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAEPAUEVENT_ID_ITEM_LIST@@I@Z ; std::allocator<EVENT_ID_ITEM_LIST>::allocate
  00069	89 45 e8	 mov	 DWORD PTR __Ptr$225281[ebp], eax

; 752  : 
; 753  : 			_TRY_BEGIN

  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00073	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$225281[ebp]
  00076	50		 push	 eax
  00077	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007d	52		 push	 edx
  0007e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 08		 mov	 ecx, DWORD PTR [eax]
  00083	51		 push	 ecx
  00084	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	e8 00 00 00 00	 call	 ??$_Umove@PAUEVENT_ID_ITEM_LIST@@@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@IAEPAUEVENT_ID_ITEM_LIST@@PAU2@00@Z ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::_Umove<EVENT_ID_ITEM_LIST *>
  0008c	eb 29		 jmp	 SHORT $LN8@reserve@2
__catch$?reserve@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  0008e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00091	50		 push	 eax
  00092	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$225281[ebp]
  00095	51		 push	 ecx
  00096	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0009c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAEXPAUEVENT_ID_ITEM_LIST@@I@Z ; std::allocator<EVENT_ID_ITEM_LIST>::deallocate

; 757  : 			_RERAISE;

  000a1	6a 00		 push	 0
  000a3	6a 00		 push	 0
  000a5	e8 00 00 00 00	 call	 __CxxThrowException@8

; 758  : 			_CATCH_END

  000aa	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000b1	b8 00 00 00 00	 mov	 eax, __tryend$?reserve@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAEXI@Z$1
  000b6	c3		 ret	 0
$LN8@reserve@2:
  000b7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?reserve@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAEXI@Z$1:

; 759  : 
; 760  : 			size_type _Size = size();

  000be	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	e8 00 00 00 00	 call	 ?size@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QBEIXZ ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::size
  000c6	89 45 e4	 mov	 DWORD PTR __Size$225288[ebp], eax

; 761  : 			if (this->_Myfirst != 0)

  000c9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000cc	83 38 00	 cmp	 DWORD PTR [eax], 0
  000cf	74 3a		 je	 SHORT $LN1@reserve@2

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);

  000d1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d7	51		 push	 ecx
  000d8	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000db	8b 02		 mov	 eax, DWORD PTR [edx]
  000dd	50		 push	 eax
  000de	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@IAEXPAUEVENT_ID_ITEM_LIST@@0@Z ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::_Destroy

; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  000e6	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000ef	2b 01		 sub	 eax, DWORD PTR [ecx]
  000f1	99		 cdq
  000f2	b9 05 00 00 00	 mov	 ecx, 5
  000f7	f7 f9		 idiv	 ecx
  000f9	50		 push	 eax
  000fa	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000fd	8b 02		 mov	 eax, DWORD PTR [edx]
  000ff	50		 push	 eax
  00100	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00103	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00106	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAEXPAUEVENT_ID_ITEM_LIST@@I@Z ; std::allocator<EVENT_ID_ITEM_LIST>::deallocate
$LN1@reserve@2:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();

  0010b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0010e	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 769  : 			this->_Myend = _Ptr + _Count;

  00113	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00116	6b c0 05	 imul	 eax, 5
  00119	03 45 e8	 add	 eax, DWORD PTR __Ptr$225281[ebp]
  0011c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0011f	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 770  : 			this->_Mylast = _Ptr + _Size;

  00122	8b 45 e4	 mov	 eax, DWORD PTR __Size$225288[ebp]
  00125	6b c0 05	 imul	 eax, 5
  00128	03 45 e8	 add	 eax, DWORD PTR __Ptr$225281[ebp]
  0012b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0012e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 771  : 			this->_Myfirst = _Ptr;

  00131	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00134	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$225281[ebp]
  00137	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@reserve@2:

; 772  : 			}
; 773  : 		}

  00139	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0013c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00143	59		 pop	 ecx
  00144	5f		 pop	 edi
  00145	5e		 pop	 esi
  00146	5b		 pop	 ebx
  00147	8b e5		 mov	 esp, ebp
  00149	5d		 pop	 ebp
  0014a	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QAEXI@Z ENDP ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::reserve
; Function compile flags: /Odtp /ZI
;	COMDAT ?capacity@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?capacity@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QBEIXZ PROC ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::capacity, COMDAT
; _this$ = ecx

; 776  : 		{	// return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	99		 cdq
  00018	b9 05 00 00 00	 mov	 ecx, 5
  0001d	f7 f9		 idiv	 ecx

; 778  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?capacity@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QBEIXZ ENDP ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::capacity
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@2@@Z PROC ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::_Make_iter, COMDAT
; _this$ = ecx

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  : 		return (iterator(_Where._Ptr, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QAE@PAUEVENT_ID_ITEM_LIST@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::_Vector_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 803  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
?_Make_iter@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@2@@Z ENDP ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::_Make_iter
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?size@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QBEIXZ PROC ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::size, COMDAT
; _this$ = ecx

; 878  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	99		 cdq
  00018	b9 05 00 00 00	 mov	 ecx, 5
  0001d	f7 f9		 idiv	 ecx

; 880  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?size@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QBEIXZ ENDP ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QBEIXZ ; std::allocator<EVENT_ID_ITEM_LIST>::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?max_size@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QBEIXZ PROC ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::max_size, COMDAT
; _this$ = ecx

; 883  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		return (this->_Alval.max_size());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00012	e8 00 00 00 00	 call	 ?max_size@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QBEIXZ ; std::allocator<EVENT_ID_ITEM_LIST>::max_size

; 885  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?max_size@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QBEIXZ ENDP ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@YAXPAUEVENT_ID_ITEM_LIST@@0AAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@@Z ; std::_Destroy_range<std::allocator<EVENT_ID_ITEM_LIST> >
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Destroy@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@IAEXPAUEVENT_ID_ITEM_LIST@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@IAEXPAUEVENT_ID_ITEM_LIST@@0@Z PROC ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::_Destroy, COMDAT
; _this$ = ecx

; 1269 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@YAXPAUEVENT_ID_ITEM_LIST@@0AAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@@Z ; std::_Destroy_range<std::allocator<EVENT_ID_ITEM_LIST> >
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1271 : 		}

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
?_Destroy@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@IAEXPAUEVENT_ID_ITEM_LIST@@0@Z ENDP ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::_Destroy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Grow_to@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -76						; size = 4
__Capacity$ = -8					; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@IBEII@Z PROC ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1275 : 		size_type _Capacity = capacity();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?capacity@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QBEIXZ ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::capacity
  00014	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@QBEIXZ ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::max_size
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  00022	d1 e9		 shr	 ecx, 1
  00024	2b c1		 sub	 eax, ecx
  00026	3b 45 f8	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  00029	73 09		 jae	 SHORT $LN4@Grow_to@2
  0002b	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  00032	eb 0b		 jmp	 SHORT $LN5@Grow_to@2
$LN4@Grow_to@2:
  00034	8b 55 f8	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00037	d1 ea		 shr	 edx, 1
  00039	03 55 f8	 add	 edx, DWORD PTR __Capacity$[ebp]
  0003c	89 55 b4	 mov	 DWORD PTR tv73[ebp], edx
$LN5@Grow_to@2:
  0003f	8b 45 b4	 mov	 eax, DWORD PTR tv73[ebp]
  00042	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1279 : 		if (_Capacity < _Count)

  00045	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00048	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0004b	73 06		 jae	 SHORT $LN1@Grow_to@2

; 1280 : 			_Capacity = _Count;

  0004d	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00050	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax
$LN1@Grow_to@2:

; 1281 : 		return (_Capacity);

  00053	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]

; 1282 : 		}

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
?_Grow_to@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@IBEII@Z ENDP ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::_Grow_to
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@IBEXXZ PROC ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::_Xlen, COMDAT
; _this$ = ecx

; 1426 : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00011	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen@2:

; 1428 : 		}

  00016	5f		 pop	 edi
  00017	5e		 pop	 esi
  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Xlen@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@IBEXXZ ENDP ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::_Xlen
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAE@ABV01@@Z PROC ; std::allocator<EVENT_ID_ITEM_LIST>::allocator<EVENT_ID_ITEM_LIST>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<EVENT_ID_ITEM_LIST>::allocator<EVENT_ID_ITEM_LIST>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAEXPAUEVENT_ID_ITEM_LIST@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAEXPAUEVENT_ID_ITEM_LIST@@I@Z PROC ; std::allocator<EVENT_ID_ITEM_LIST>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 182  : 		::operator delete(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4

; 183  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?deallocate@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAEXPAUEVENT_ID_ITEM_LIST@@I@Z ENDP ; std::allocator<EVENT_ID_ITEM_LIST>::deallocate
_TEXT	ENDS
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >,std::_Iterator_base0>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >, COMDAT
; _this$ = ecx

; 213  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Plist$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >,std::_Iterator_base0>

; 214  : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHPAX@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHPAX@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator*, COMDAT
; _this$ = ecx

; 230  : 		{	// return designated value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 231  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 232  : 		if (this->_Getcont() == 0
; 233  : 			|| this->_Ptr == 0
; 234  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 235  : 			{	// report error
; 236  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 237  : 			_SCL_SECURE_OUT_OF_RANGE;
; 238  : 			}
; 239  : 
; 240  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 241  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 242  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 243  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 244  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 245  : 
; 246  : 		return (_Mytree::_Myval(this->_Ptr));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHPAX@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Myval
  00017	83 c4 04	 add	 esp, 4

; 247  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHPAX@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator*
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 38   : 		{	// construct with null node pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 39   : 		}

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >,std::_Iterator_base0>
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QAE@PAUEVENT_ID_TIME@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QAE@PAUEVENT_ID_TIME@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::_Vector_const_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 47   : 		}

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QAE@PAUEVENT_ID_TIME@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::_Vector_const_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator++, COMDAT
; _this$ = ecx

; 93   : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 94   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 95   : 		if (this->_Getcont() == 0
; 96   : 			|| this->_Ptr == 0
; 97   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 98   : 			{	// report error
; 99   : 			_DEBUG_ERROR("vector iterator not incrementable");
; 100  : 			_SCL_SECURE_OUT_OF_RANGE;
; 101  : 			}
; 102  : 
; 103  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 104  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 105  : 		_SCL_SECURE_VALIDATE_RANGE(
; 106  : 			this->_Ptr != 0
; 107  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 108  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 109  : 
; 110  : 		++this->_Ptr;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	83 c1 10	 add	 ecx, 16			; 00000010H
  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	89 0a		 mov	 DWORD PTR [edx], ecx

; 111  : 		return (*this);

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 112  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::operator++
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::_Compat, COMDAT
; _this$ = ecx

; 252  : 		{	// test for compatible iterator pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 253  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> > >::_Compat
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QAE@PAUEVENT_ID_ITEM_LIST@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QAE@PAUEVENT_ID_ITEM_LIST@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::_Vector_const_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 47   : 		}

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QAE@PAUEVENT_ID_ITEM_LIST@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::_Vector_const_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::_Compat, COMDAT
; _this$ = ecx

; 252  : 		{	// test for compatible iterator pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 253  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> > >::_Compat
_TEXT	ENDS
PUBLIC	??$_Allocate@UEVENT_ID_TIME@@@std@@YAPAUEVENT_ID_TIME@@IPAU1@@Z ; std::_Allocate<EVENT_ID_TIME>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@UEVENT_ID_TIME@@@std@@QAEPAUEVENT_ID_TIME@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UEVENT_ID_TIME@@@std@@QAEPAUEVENT_ID_TIME@@I@Z PROC ; std::allocator<EVENT_ID_TIME>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 187  : 		return (_Allocate(_Count, (pointer)0));

  0000c	6a 00		 push	 0
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Allocate@UEVENT_ID_TIME@@@std@@YAPAUEVENT_ID_TIME@@IPAU1@@Z ; std::_Allocate<EVENT_ID_TIME>
  00017	83 c4 08	 add	 esp, 8

; 188  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?allocate@?$allocator@UEVENT_ID_TIME@@@std@@QAEPAUEVENT_ID_TIME@@I@Z ENDP ; std::allocator<EVENT_ID_TIME>::allocate
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UEVENT_ID_TIME@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -76						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@UEVENT_ID_TIME@@@std@@QBEIXZ PROC	; std::allocator<EVENT_ID_TIME>::max_size, COMDAT
; _this$ = ecx

; 217  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  0000c	c7 45 f8 ff ff
	ff 0f		 mov	 DWORD PTR __Count$[ebp], 268435455 ; 0fffffffH

; 219  : 		return (0 < _Count ? _Count : 1);

  00013	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00017	76 08		 jbe	 SHORT $LN3@max_size
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0001c	89 45 b4	 mov	 DWORD PTR tv65[ebp], eax
  0001f	eb 07		 jmp	 SHORT $LN4@max_size
$LN3@max_size:
  00021	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$LN4@max_size:
  00028	8b 45 b4	 mov	 eax, DWORD PTR tv65[ebp]

; 220  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?max_size@?$allocator@UEVENT_ID_TIME@@@std@@QBEIXZ ENDP	; std::allocator<EVENT_ID_TIME>::max_size
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Rrotate
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Lrotate
PUBLIC	??$swap@D@std@@YAXAAD0@Z			; std::swap<char>
PUBLIC	?_Max@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Max
PUBLIC	?_Min@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Min
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator++
PUBLIC	??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ ; `string'
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
;	COMDAT ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
; File d:\microsoft visual studio 10.0\vc\include\xtree
CONST	SEGMENT
??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ DB 'invalid '
	DB	'map/set<T> iterator', 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@@Z
_TEXT	SEGMENT
tv182 = -88						; size = 4
tv170 = -88						; size = 4
__Pnode$ = -20						; size = 4
__Fixnodeparent$ = -16					; size = 4
__Fixnode$ = -12					; size = 4
__Erasednode$ = -8					; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::erase, COMDAT
; _this$ = ecx

; 1195 : 		{	// erase element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1198 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1199 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1200 : 		++_Where;	// save successor iterator for return
; 1201 : 		_Orphan_ptr(*this, _Erasednode);
; 1202 : 
; 1203 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1204 : 		if (this->_Isnil(_Where._Mynode()))

  0000c	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >,std::_Iterator_base0>::_Mynode
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Isnil
  0001a	83 c4 04	 add	 esp, 4
  0001d	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00020	85 c0		 test	 eax, eax
  00022	74 0a		 je	 SHORT $LN40@erase@4

; 1205 : 			_Xout_of_range("invalid map/set<T> iterator");

  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
  00029	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN40@erase@4:

; 1206 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

  0002e	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  00031	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >,std::_Iterator_base0>::_Mynode
  00036	89 45 f8	 mov	 DWORD PTR __Erasednode$[ebp], eax

; 1207 : 		++_Where;	// save successor iterator for return

  00039	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  0003c	e8 00 00 00 00	 call	 ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator++

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1211 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1212 : 		_Nodeptr _Pnode = _Erasednode;

  00041	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00044	89 45 ec	 mov	 DWORD PTR __Pnode$[ebp], eax

; 1213 : 
; 1214 : 		if (this->_Isnil(this->_Left(_Pnode)))

  00047	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Left
  00050	83 c4 04	 add	 esp, 4
  00053	8b 08		 mov	 ecx, DWORD PTR [eax]
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Isnil
  0005b	83 c4 04	 add	 esp, 4
  0005e	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00061	85 d2		 test	 edx, edx
  00063	74 13		 je	 SHORT $LN39@erase@4

; 1215 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree

  00065	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Right
  0006e	83 c4 04	 add	 esp, 4
  00071	8b 08		 mov	 ecx, DWORD PTR [eax]
  00073	89 4d f4	 mov	 DWORD PTR __Fixnode$[ebp], ecx
  00076	eb 4d		 jmp	 SHORT $LN38@erase@4
$LN39@erase@4:

; 1216 : 		else if (this->_Isnil(this->_Right(_Pnode)))

  00078	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Right
  00081	83 c4 04	 add	 esp, 4
  00084	8b 08		 mov	 ecx, DWORD PTR [eax]
  00086	51		 push	 ecx
  00087	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Isnil
  0008c	83 c4 04	 add	 esp, 4
  0008f	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00092	85 d2		 test	 edx, edx
  00094	74 13		 je	 SHORT $LN37@erase@4

; 1217 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree

  00096	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Left
  0009f	83 c4 04	 add	 esp, 4
  000a2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a4	89 4d f4	 mov	 DWORD PTR __Fixnode$[ebp], ecx

; 1218 : 		else

  000a7	eb 1c		 jmp	 SHORT $LN38@erase@4
$LN37@erase@4:

; 1219 : 			{	// two subtrees, must lift successor node to replace erased
; 1220 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

  000a9	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  000ac	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >,std::_Iterator_base0>::_Mynode
  000b1	89 45 ec	 mov	 DWORD PTR __Pnode$[ebp], eax

; 1221 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree

  000b4	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Right
  000bd	83 c4 04	 add	 esp, 4
  000c0	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c2	89 4d f4	 mov	 DWORD PTR __Fixnode$[ebp], ecx
$LN38@erase@4:

; 1222 : 			}
; 1223 : 
; 1224 : 		if (_Pnode == _Erasednode)

  000c5	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  000c8	3b 45 f8	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  000cb	0f 85 1b 01 00
	00		 jne	 $LN35@erase@4

; 1225 : 			{	// at most one subtree, relink it
; 1226 : 			_Fixnodeparent = this->_Parent(_Erasednode);

  000d1	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  000d4	50		 push	 eax
  000d5	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  000da	83 c4 04	 add	 esp, 4
  000dd	8b 08		 mov	 ecx, DWORD PTR [eax]
  000df	89 4d f0	 mov	 DWORD PTR __Fixnodeparent$[ebp], ecx

; 1227 : 			if (!this->_Isnil(_Fixnode))

  000e2	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Isnil
  000eb	83 c4 04	 add	 esp, 4
  000ee	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000f1	85 c9		 test	 ecx, ecx
  000f3	75 11		 jne	 SHORT $LN34@erase@4

; 1228 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up

  000f5	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  000f8	50		 push	 eax
  000f9	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  000fe	83 c4 04	 add	 esp, 4
  00101	8b 4d f0	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  00104	89 08		 mov	 DWORD PTR [eax], ecx
$LN34@erase@4:

; 1229 : 
; 1230 : 			if (_Root() == _Erasednode)

  00106	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Root
  0010e	8b 00		 mov	 eax, DWORD PTR [eax]
  00110	3b 45 f8	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  00113	75 0f		 jne	 SHORT $LN33@erase@4

; 1231 : 				_Root() = _Fixnode;	// link down from root

  00115	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00118	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Root
  0011d	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  00120	89 08		 mov	 DWORD PTR [eax], ecx
  00122	eb 37		 jmp	 SHORT $LN32@erase@4
$LN33@erase@4:

; 1232 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)

  00124	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00127	50		 push	 eax
  00128	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Left
  0012d	83 c4 04	 add	 esp, 4
  00130	8b 08		 mov	 ecx, DWORD PTR [eax]
  00132	3b 4d f8	 cmp	 ecx, DWORD PTR __Erasednode$[ebp]
  00135	75 13		 jne	 SHORT $LN31@erase@4

; 1233 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left

  00137	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0013a	50		 push	 eax
  0013b	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Left
  00140	83 c4 04	 add	 esp, 4
  00143	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  00146	89 08		 mov	 DWORD PTR [eax], ecx

; 1234 : 			else

  00148	eb 11		 jmp	 SHORT $LN32@erase@4
$LN31@erase@4:

; 1235 : 				this->_Right(_Fixnodeparent) =
; 1236 : 					_Fixnode;	// link down to right

  0014a	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0014d	50		 push	 eax
  0014e	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Right
  00153	83 c4 04	 add	 esp, 4
  00156	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  00159	89 08		 mov	 DWORD PTR [eax], ecx
$LN32@erase@4:

; 1237 : 
; 1238 : 			if (_Lmost() == _Erasednode)

  0015b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0015e	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Lmost
  00163	8b 00		 mov	 eax, DWORD PTR [eax]
  00165	3b 45 f8	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  00168	75 37		 jne	 SHORT $LN29@erase@4

; 1239 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1240 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1241 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree

  0016a	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  0016d	50		 push	 eax
  0016e	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Isnil
  00173	83 c4 04	 add	 esp, 4
  00176	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00179	85 c9		 test	 ecx, ecx
  0017b	74 08		 je	 SHORT $LN43@erase@4
  0017d	8b 55 f0	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  00180	89 55 a8	 mov	 DWORD PTR tv170[ebp], edx
  00183	eb 0f		 jmp	 SHORT $LN44@erase@4
$LN43@erase@4:
  00185	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00188	50		 push	 eax
  00189	e8 00 00 00 00	 call	 ?_Min@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Min
  0018e	83 c4 04	 add	 esp, 4
  00191	89 45 a8	 mov	 DWORD PTR tv170[ebp], eax
$LN44@erase@4:
  00194	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00197	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Lmost
  0019c	8b 4d a8	 mov	 ecx, DWORD PTR tv170[ebp]
  0019f	89 08		 mov	 DWORD PTR [eax], ecx
$LN29@erase@4:

; 1242 : 
; 1243 : 			if (_Rmost() == _Erasednode)

  001a1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001a4	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Rmost
  001a9	8b 00		 mov	 eax, DWORD PTR [eax]
  001ab	3b 45 f8	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  001ae	75 37		 jne	 SHORT $LN28@erase@4

; 1244 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1245 : 					? _Fixnodeparent	// largest is parent of erased node
; 1246 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  001b0	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  001b3	50		 push	 eax
  001b4	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Isnil
  001b9	83 c4 04	 add	 esp, 4
  001bc	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  001bf	85 c9		 test	 ecx, ecx
  001c1	74 08		 je	 SHORT $LN45@erase@4
  001c3	8b 55 f0	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  001c6	89 55 a8	 mov	 DWORD PTR tv182[ebp], edx
  001c9	eb 0f		 jmp	 SHORT $LN46@erase@4
$LN45@erase@4:
  001cb	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  001ce	50		 push	 eax
  001cf	e8 00 00 00 00	 call	 ?_Max@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Max
  001d4	83 c4 04	 add	 esp, 4
  001d7	89 45 a8	 mov	 DWORD PTR tv182[ebp], eax
$LN46@erase@4:
  001da	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001dd	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Rmost
  001e2	8b 4d a8	 mov	 ecx, DWORD PTR tv182[ebp]
  001e5	89 08		 mov	 DWORD PTR [eax], ecx
$LN28@erase@4:

; 1247 : 			}
; 1248 : 		else

  001e7	e9 8e 01 00 00	 jmp	 $LN27@erase@4
$LN35@erase@4:

; 1249 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1250 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1251 : 				_Pnode;	// link left up

  001ec	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  001ef	50		 push	 eax
  001f0	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Left
  001f5	83 c4 04	 add	 esp, 4
  001f8	8b 08		 mov	 ecx, DWORD PTR [eax]
  001fa	51		 push	 ecx
  001fb	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  00200	83 c4 04	 add	 esp, 4
  00203	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00206	89 10		 mov	 DWORD PTR [eax], edx

; 1252 : 			this->_Left(_Pnode) =
; 1253 : 				this->_Left(_Erasednode);	// link successor down

  00208	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0020b	50		 push	 eax
  0020c	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Left
  00211	83 c4 04	 add	 esp, 4
  00214	8b f0		 mov	 esi, eax
  00216	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00219	51		 push	 ecx
  0021a	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Left
  0021f	83 c4 04	 add	 esp, 4
  00222	8b 16		 mov	 edx, DWORD PTR [esi]
  00224	89 10		 mov	 DWORD PTR [eax], edx

; 1254 : 
; 1255 : 			if (_Pnode == this->_Right(_Erasednode))

  00226	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00229	50		 push	 eax
  0022a	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Right
  0022f	83 c4 04	 add	 esp, 4
  00232	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00235	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00237	75 0b		 jne	 SHORT $LN26@erase@4

; 1256 : 				_Fixnodeparent = _Pnode;	// successor is next to erased

  00239	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0023c	89 45 f0	 mov	 DWORD PTR __Fixnodeparent$[ebp], eax

; 1257 : 			else

  0023f	e9 80 00 00 00	 jmp	 $LN25@erase@4
$LN26@erase@4:

; 1258 : 				{	// successor further down, link in place of erased
; 1259 : 				_Fixnodeparent =
; 1260 : 					this->_Parent(_Pnode);	// parent is successor's

  00244	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00247	50		 push	 eax
  00248	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  0024d	83 c4 04	 add	 esp, 4
  00250	8b 08		 mov	 ecx, DWORD PTR [eax]
  00252	89 4d f0	 mov	 DWORD PTR __Fixnodeparent$[ebp], ecx

; 1261 : 				if (!this->_Isnil(_Fixnode))

  00255	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00258	50		 push	 eax
  00259	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Isnil
  0025e	83 c4 04	 add	 esp, 4
  00261	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00264	85 c9		 test	 ecx, ecx
  00266	75 11		 jne	 SHORT $LN24@erase@4

; 1262 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

  00268	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  0026b	50		 push	 eax
  0026c	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  00271	83 c4 04	 add	 esp, 4
  00274	8b 4d f0	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  00277	89 08		 mov	 DWORD PTR [eax], ecx
$LN24@erase@4:

; 1263 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down

  00279	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0027c	50		 push	 eax
  0027d	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Left
  00282	83 c4 04	 add	 esp, 4
  00285	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  00288	89 08		 mov	 DWORD PTR [eax], ecx

; 1264 : 				this->_Right(_Pnode) =
; 1265 : 					this->_Right(_Erasednode);	// link next down

  0028a	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0028d	50		 push	 eax
  0028e	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Right
  00293	83 c4 04	 add	 esp, 4
  00296	8b f0		 mov	 esi, eax
  00298	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0029b	51		 push	 ecx
  0029c	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Right
  002a1	83 c4 04	 add	 esp, 4
  002a4	8b 16		 mov	 edx, DWORD PTR [esi]
  002a6	89 10		 mov	 DWORD PTR [eax], edx

; 1266 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1267 : 					_Pnode;	// right up

  002a8	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  002ab	50		 push	 eax
  002ac	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Right
  002b1	83 c4 04	 add	 esp, 4
  002b4	8b 08		 mov	 ecx, DWORD PTR [eax]
  002b6	51		 push	 ecx
  002b7	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  002bc	83 c4 04	 add	 esp, 4
  002bf	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$[ebp]
  002c2	89 10		 mov	 DWORD PTR [eax], edx
$LN25@erase@4:

; 1268 : 				}
; 1269 : 
; 1270 : 			if (_Root() == _Erasednode)

  002c4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002c7	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Root
  002cc	8b 00		 mov	 eax, DWORD PTR [eax]
  002ce	3b 45 f8	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  002d1	75 0f		 jne	 SHORT $LN23@erase@4

; 1271 : 				_Root() = _Pnode;	// link down from root

  002d3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002d6	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Root
  002db	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  002de	89 08		 mov	 DWORD PTR [eax], ecx
  002e0	eb 58		 jmp	 SHORT $LN22@erase@4
$LN23@erase@4:

; 1272 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

  002e2	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  002e5	50		 push	 eax
  002e6	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  002eb	83 c4 04	 add	 esp, 4
  002ee	8b 08		 mov	 ecx, DWORD PTR [eax]
  002f0	51		 push	 ecx
  002f1	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Left
  002f6	83 c4 04	 add	 esp, 4
  002f9	8b 10		 mov	 edx, DWORD PTR [eax]
  002fb	3b 55 f8	 cmp	 edx, DWORD PTR __Erasednode$[ebp]
  002fe	75 1e		 jne	 SHORT $LN21@erase@4

; 1273 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1274 : 					_Pnode;	// link down to left

  00300	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00303	50		 push	 eax
  00304	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  00309	83 c4 04	 add	 esp, 4
  0030c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0030e	51		 push	 ecx
  0030f	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Left
  00314	83 c4 04	 add	 esp, 4
  00317	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$[ebp]
  0031a	89 10		 mov	 DWORD PTR [eax], edx

; 1275 : 			else

  0031c	eb 1c		 jmp	 SHORT $LN22@erase@4
$LN21@erase@4:

; 1276 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1277 : 					_Pnode;	// link down to right

  0031e	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00321	50		 push	 eax
  00322	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  00327	83 c4 04	 add	 esp, 4
  0032a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0032c	51		 push	 ecx
  0032d	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Right
  00332	83 c4 04	 add	 esp, 4
  00335	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00338	89 10		 mov	 DWORD PTR [eax], edx
$LN22@erase@4:

; 1278 : 
; 1279 : 			this->_Parent(_Pnode) =
; 1280 : 				this->_Parent(_Erasednode);	// link successor up

  0033a	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0033d	50		 push	 eax
  0033e	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  00343	83 c4 04	 add	 esp, 4
  00346	8b f0		 mov	 esi, eax
  00348	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0034b	51		 push	 ecx
  0034c	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  00351	83 c4 04	 add	 esp, 4
  00354	8b 16		 mov	 edx, DWORD PTR [esi]
  00356	89 10		 mov	 DWORD PTR [eax], edx

; 1281 : 			_STD swap(this->_Color(_Pnode),
; 1282 : 				this->_Color(_Erasednode));	// recolor it

  00358	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0035b	50		 push	 eax
  0035c	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
  00361	83 c4 04	 add	 esp, 4
  00364	50		 push	 eax
  00365	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00368	51		 push	 ecx
  00369	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
  0036e	83 c4 04	 add	 esp, 4
  00371	50		 push	 eax
  00372	e8 00 00 00 00	 call	 ??$swap@D@std@@YAXAAD0@Z ; std::swap<char>
  00377	83 c4 08	 add	 esp, 8
$LN27@erase@4:

; 1283 : 			}
; 1284 : 
; 1285 : 		if (this->_Color(_Erasednode) == this->_Black)

  0037a	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0037d	50		 push	 eax
  0037e	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
  00383	83 c4 04	 add	 esp, 4
  00386	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00389	83 f9 01	 cmp	 ecx, 1
  0038c	0f 85 8f 03 00
	00		 jne	 $LN19@erase@4
  00392	eb 11		 jmp	 SHORT $LN18@erase@4
$LN17@erase@4:

; 1286 : 			{	// erasing black link, must recolor/rebalance tree
; 1287 : 			for (; _Fixnode != _Root()
; 1288 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1289 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  00394	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00397	50		 push	 eax
  00398	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  0039d	83 c4 04	 add	 esp, 4
  003a0	8b 08		 mov	 ecx, DWORD PTR [eax]
  003a2	89 4d f0	 mov	 DWORD PTR __Fixnodeparent$[ebp], ecx
$LN18@erase@4:
  003a5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003a8	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Root
  003ad	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  003b0	3b 08		 cmp	 ecx, DWORD PTR [eax]
  003b2	0f 84 5a 03 00
	00		 je	 $LN16@erase@4
  003b8	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  003bb	50		 push	 eax
  003bc	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
  003c1	83 c4 04	 add	 esp, 4
  003c4	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  003c7	83 f9 01	 cmp	 ecx, 1
  003ca	0f 85 42 03 00
	00		 jne	 $LN16@erase@4

; 1290 : 				if (_Fixnode == this->_Left(_Fixnodeparent))

  003d0	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  003d3	50		 push	 eax
  003d4	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Left
  003d9	83 c4 04	 add	 esp, 4
  003dc	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  003df	3b 08		 cmp	 ecx, DWORD PTR [eax]
  003e1	0f 85 97 01 00
	00		 jne	 $LN15@erase@4

; 1291 : 					{	// fixup left subtree
; 1292 : 					_Pnode = this->_Right(_Fixnodeparent);

  003e7	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  003ea	50		 push	 eax
  003eb	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Right
  003f0	83 c4 04	 add	 esp, 4
  003f3	8b 08		 mov	 ecx, DWORD PTR [eax]
  003f5	89 4d ec	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 1293 : 					if (this->_Color(_Pnode) == this->_Red)

  003f8	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  003fb	50		 push	 eax
  003fc	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
  00401	83 c4 04	 add	 esp, 4
  00404	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00407	85 c9		 test	 ecx, ecx
  00409	75 3b		 jne	 SHORT $LN14@erase@4

; 1294 : 						{	// rotate red up from right subtree
; 1295 : 						this->_Color(_Pnode) = this->_Black;

  0040b	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0040e	50		 push	 eax
  0040f	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
  00414	83 c4 04	 add	 esp, 4
  00417	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1296 : 						this->_Color(_Fixnodeparent) = this->_Red;

  0041a	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0041d	50		 push	 eax
  0041e	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
  00423	83 c4 04	 add	 esp, 4
  00426	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1297 : 						_Lrotate(_Fixnodeparent);

  00429	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0042c	50		 push	 eax
  0042d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00430	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Lrotate

; 1298 : 						_Pnode = this->_Right(_Fixnodeparent);

  00435	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00438	50		 push	 eax
  00439	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Right
  0043e	83 c4 04	 add	 esp, 4
  00441	8b 08		 mov	 ecx, DWORD PTR [eax]
  00443	89 4d ec	 mov	 DWORD PTR __Pnode$[ebp], ecx
$LN14@erase@4:

; 1299 : 						}
; 1300 : 
; 1301 : 					if (this->_Isnil(_Pnode))

  00446	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00449	50		 push	 eax
  0044a	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Isnil
  0044f	83 c4 04	 add	 esp, 4
  00452	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00455	85 c9		 test	 ecx, ecx
  00457	74 0b		 je	 SHORT $LN13@erase@4

; 1302 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

  00459	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0045c	89 45 f4	 mov	 DWORD PTR __Fixnode$[ebp], eax

; 1303 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black

  0045f	e9 15 01 00 00	 jmp	 $LN12@erase@4
$LN13@erase@4:

; 1304 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)

  00464	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00467	50		 push	 eax
  00468	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Left
  0046d	83 c4 04	 add	 esp, 4
  00470	8b 08		 mov	 ecx, DWORD PTR [eax]
  00472	51		 push	 ecx
  00473	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
  00478	83 c4 04	 add	 esp, 4
  0047b	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0047e	83 fa 01	 cmp	 edx, 1
  00481	75 39		 jne	 SHORT $LN11@erase@4
  00483	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00486	50		 push	 eax
  00487	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Right
  0048c	83 c4 04	 add	 esp, 4
  0048f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00491	51		 push	 ecx
  00492	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
  00497	83 c4 04	 add	 esp, 4
  0049a	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0049d	83 fa 01	 cmp	 edx, 1
  004a0	75 1a		 jne	 SHORT $LN11@erase@4

; 1305 : 						{	// redden right subtree with black children
; 1306 : 						this->_Color(_Pnode) = this->_Red;

  004a2	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  004a5	50		 push	 eax
  004a6	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
  004ab	83 c4 04	 add	 esp, 4
  004ae	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1307 : 						_Fixnode = _Fixnodeparent;

  004b1	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  004b4	89 45 f4	 mov	 DWORD PTR __Fixnode$[ebp], eax

; 1308 : 						}
; 1309 : 					else

  004b7	e9 bd 00 00 00	 jmp	 $LN12@erase@4
$LN11@erase@4:

; 1310 : 						{	// must rearrange right subtree
; 1311 : 						if (this->_Color(this->_Right(_Pnode))
; 1312 : 							== this->_Black)

  004bc	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  004bf	50		 push	 eax
  004c0	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Right
  004c5	83 c4 04	 add	 esp, 4
  004c8	8b 08		 mov	 ecx, DWORD PTR [eax]
  004ca	51		 push	 ecx
  004cb	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
  004d0	83 c4 04	 add	 esp, 4
  004d3	0f be 10	 movsx	 edx, BYTE PTR [eax]
  004d6	83 fa 01	 cmp	 edx, 1
  004d9	75 46		 jne	 SHORT $LN9@erase@4

; 1313 : 							{	// rotate red up from left sub-subtree
; 1314 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;

  004db	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  004de	50		 push	 eax
  004df	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Left
  004e4	83 c4 04	 add	 esp, 4
  004e7	8b 08		 mov	 ecx, DWORD PTR [eax]
  004e9	51		 push	 ecx
  004ea	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
  004ef	83 c4 04	 add	 esp, 4
  004f2	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1315 : 							this->_Color(_Pnode) = this->_Red;

  004f5	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  004f8	50		 push	 eax
  004f9	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
  004fe	83 c4 04	 add	 esp, 4
  00501	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1316 : 							_Rrotate(_Pnode);

  00504	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00507	50		 push	 eax
  00508	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0050b	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Rrotate

; 1317 : 							_Pnode = this->_Right(_Fixnodeparent);

  00510	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00513	50		 push	 eax
  00514	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Right
  00519	83 c4 04	 add	 esp, 4
  0051c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0051e	89 4d ec	 mov	 DWORD PTR __Pnode$[ebp], ecx
$LN9@erase@4:

; 1318 : 							}
; 1319 : 
; 1320 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  00521	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00524	50		 push	 eax
  00525	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
  0052a	83 c4 04	 add	 esp, 4
  0052d	8b f0		 mov	 esi, eax
  0052f	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00532	51		 push	 ecx
  00533	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
  00538	83 c4 04	 add	 esp, 4
  0053b	8a 16		 mov	 dl, BYTE PTR [esi]
  0053d	88 10		 mov	 BYTE PTR [eax], dl

; 1321 : 						this->_Color(_Fixnodeparent) = this->_Black;

  0053f	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00542	50		 push	 eax
  00543	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
  00548	83 c4 04	 add	 esp, 4
  0054b	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1322 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;

  0054e	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00551	50		 push	 eax
  00552	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Right
  00557	83 c4 04	 add	 esp, 4
  0055a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0055c	51		 push	 ecx
  0055d	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
  00562	83 c4 04	 add	 esp, 4
  00565	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1323 : 						_Lrotate(_Fixnodeparent);

  00568	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0056b	50		 push	 eax
  0056c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0056f	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Lrotate

; 1324 : 						break;	// tree now recolored/rebalanced

  00574	e9 99 01 00 00	 jmp	 $LN16@erase@4
$LN12@erase@4:

; 1325 : 						}
; 1326 : 					}
; 1327 : 				else

  00579	e9 8f 01 00 00	 jmp	 $LN8@erase@4
$LN15@erase@4:

; 1328 : 					{	// fixup right subtree
; 1329 : 					_Pnode = this->_Left(_Fixnodeparent);

  0057e	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00581	50		 push	 eax
  00582	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Left
  00587	83 c4 04	 add	 esp, 4
  0058a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0058c	89 4d ec	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 1330 : 					if (this->_Color(_Pnode) == this->_Red)

  0058f	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00592	50		 push	 eax
  00593	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
  00598	83 c4 04	 add	 esp, 4
  0059b	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0059e	85 c9		 test	 ecx, ecx
  005a0	75 3b		 jne	 SHORT $LN7@erase@4

; 1331 : 						{	// rotate red up from left subtree
; 1332 : 						this->_Color(_Pnode) = this->_Black;

  005a2	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  005a5	50		 push	 eax
  005a6	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
  005ab	83 c4 04	 add	 esp, 4
  005ae	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1333 : 						this->_Color(_Fixnodeparent) = this->_Red;

  005b1	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  005b4	50		 push	 eax
  005b5	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
  005ba	83 c4 04	 add	 esp, 4
  005bd	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1334 : 						_Rrotate(_Fixnodeparent);

  005c0	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  005c3	50		 push	 eax
  005c4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  005c7	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Rrotate

; 1335 : 						_Pnode = this->_Left(_Fixnodeparent);

  005cc	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  005cf	50		 push	 eax
  005d0	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Left
  005d5	83 c4 04	 add	 esp, 4
  005d8	8b 08		 mov	 ecx, DWORD PTR [eax]
  005da	89 4d ec	 mov	 DWORD PTR __Pnode$[ebp], ecx
$LN7@erase@4:

; 1336 : 						}
; 1337 : 					if (this->_Isnil(_Pnode))

  005dd	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  005e0	50		 push	 eax
  005e1	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Isnil
  005e6	83 c4 04	 add	 esp, 4
  005e9	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  005ec	85 c9		 test	 ecx, ecx
  005ee	74 0b		 je	 SHORT $LN6@erase@4

; 1338 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

  005f0	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  005f3	89 45 f4	 mov	 DWORD PTR __Fixnode$[ebp], eax

; 1339 : 					else if (this->_Color(this->_Right(_Pnode)) ==

  005f6	e9 12 01 00 00	 jmp	 $LN8@erase@4
$LN6@erase@4:

; 1340 : 						this->_Black
; 1341 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)

  005fb	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  005fe	50		 push	 eax
  005ff	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Right
  00604	83 c4 04	 add	 esp, 4
  00607	8b 08		 mov	 ecx, DWORD PTR [eax]
  00609	51		 push	 ecx
  0060a	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
  0060f	83 c4 04	 add	 esp, 4
  00612	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00615	83 fa 01	 cmp	 edx, 1
  00618	75 39		 jne	 SHORT $LN4@erase@4
  0061a	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0061d	50		 push	 eax
  0061e	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Left
  00623	83 c4 04	 add	 esp, 4
  00626	8b 08		 mov	 ecx, DWORD PTR [eax]
  00628	51		 push	 ecx
  00629	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
  0062e	83 c4 04	 add	 esp, 4
  00631	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00634	83 fa 01	 cmp	 edx, 1
  00637	75 1a		 jne	 SHORT $LN4@erase@4

; 1342 : 						{	// redden left subtree with black children
; 1343 : 						this->_Color(_Pnode) = this->_Red;

  00639	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0063c	50		 push	 eax
  0063d	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
  00642	83 c4 04	 add	 esp, 4
  00645	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1344 : 						_Fixnode = _Fixnodeparent;

  00648	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0064b	89 45 f4	 mov	 DWORD PTR __Fixnode$[ebp], eax

; 1345 : 						}
; 1346 : 					else

  0064e	e9 ba 00 00 00	 jmp	 $LN8@erase@4
$LN4@erase@4:

; 1347 : 						{	// must rearrange left subtree
; 1348 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)

  00653	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00656	50		 push	 eax
  00657	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Left
  0065c	83 c4 04	 add	 esp, 4
  0065f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00661	51		 push	 ecx
  00662	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
  00667	83 c4 04	 add	 esp, 4
  0066a	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0066d	83 fa 01	 cmp	 edx, 1
  00670	75 46		 jne	 SHORT $LN2@erase@4

; 1349 : 							{	// rotate red up from right sub-subtree
; 1350 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;

  00672	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00675	50		 push	 eax
  00676	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Right
  0067b	83 c4 04	 add	 esp, 4
  0067e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00680	51		 push	 ecx
  00681	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
  00686	83 c4 04	 add	 esp, 4
  00689	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1351 : 							this->_Color(_Pnode) = this->_Red;

  0068c	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0068f	50		 push	 eax
  00690	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
  00695	83 c4 04	 add	 esp, 4
  00698	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1352 : 							_Lrotate(_Pnode);

  0069b	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0069e	50		 push	 eax
  0069f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  006a2	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Lrotate

; 1353 : 							_Pnode = this->_Left(_Fixnodeparent);

  006a7	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  006aa	50		 push	 eax
  006ab	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Left
  006b0	83 c4 04	 add	 esp, 4
  006b3	8b 08		 mov	 ecx, DWORD PTR [eax]
  006b5	89 4d ec	 mov	 DWORD PTR __Pnode$[ebp], ecx
$LN2@erase@4:

; 1354 : 							}
; 1355 : 
; 1356 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  006b8	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  006bb	50		 push	 eax
  006bc	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
  006c1	83 c4 04	 add	 esp, 4
  006c4	8b f0		 mov	 esi, eax
  006c6	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  006c9	51		 push	 ecx
  006ca	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
  006cf	83 c4 04	 add	 esp, 4
  006d2	8a 16		 mov	 dl, BYTE PTR [esi]
  006d4	88 10		 mov	 BYTE PTR [eax], dl

; 1357 : 						this->_Color(_Fixnodeparent) = this->_Black;

  006d6	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  006d9	50		 push	 eax
  006da	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
  006df	83 c4 04	 add	 esp, 4
  006e2	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1358 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;

  006e5	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  006e8	50		 push	 eax
  006e9	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Left
  006ee	83 c4 04	 add	 esp, 4
  006f1	8b 08		 mov	 ecx, DWORD PTR [eax]
  006f3	51		 push	 ecx
  006f4	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
  006f9	83 c4 04	 add	 esp, 4
  006fc	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1359 : 						_Rrotate(_Fixnodeparent);

  006ff	8b 45 f0	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00702	50		 push	 eax
  00703	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00706	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Rrotate

; 1360 : 						break;	// tree now recolored/rebalanced

  0070b	eb 05		 jmp	 SHORT $LN16@erase@4
$LN8@erase@4:

; 1361 : 						}
; 1362 : 					}

  0070d	e9 82 fc ff ff	 jmp	 $LN17@erase@4
$LN16@erase@4:

; 1363 : 
; 1364 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black

  00712	8b 45 f4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00715	50		 push	 eax
  00716	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
  0071b	83 c4 04	 add	 esp, 4
  0071e	c6 00 01	 mov	 BYTE PTR [eax], 1
$LN19@erase@4:

; 1365 : 			}
; 1366 : 
; 1367 : 		_Dest_val(this->_Alval,
; 1368 : 			_STD addressof(this->_Myval(_Erasednode)));	// delete erased node

  00721	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00724	50		 push	 eax
  00725	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHPAX@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Myval
  0072a	83 c4 04	 add	 esp, 4
  0072d	50		 push	 eax
  0072e	e8 00 00 00 00	 call	 ??$addressof@U?$pair@$$CBHPAX@std@@@std@@YAPAU?$pair@$$CBHPAX@0@AAU10@@Z ; std::addressof<std::pair<int const ,void *> >
  00733	83 c4 04	 add	 esp, 4
  00736	50		 push	 eax
  00737	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0073a	83 c1 0d	 add	 ecx, 13			; 0000000dH
  0073d	51		 push	 ecx
  0073e	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBHPAX@std@@@std@@U?$pair@$$CBHPAX@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHPAX@std@@@0@PAU?$pair@$$CBHPAX@0@@Z ; std::_Dest_val<std::allocator<std::pair<int const ,void *> >,std::pair<int const ,void *> >
  00743	83 c4 08	 add	 esp, 8

; 1369 : 
; 1370 : 		this->_Alnod.deallocate(_Erasednode, 1);

  00746	6a 01		 push	 1
  00748	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0074b	50		 push	 eax
  0074c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0074f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00752	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Node>::deallocate

; 1371 : 
; 1372 : 		if (0 < this->_Mysize)

  00757	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0075a	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0075e	76 0f		 jbe	 SHORT $LN1@erase@4

; 1373 : 			--this->_Mysize;

  00760	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00763	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00766	83 e9 01	 sub	 ecx, 1
  00769	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0076c	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
$LN1@erase@4:

; 1374 : 
; 1375 : 		return (iterator(_Where._Ptr, this));	// return successor iterator

  0076f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00772	50		 push	 eax
  00773	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00776	51		 push	 ecx
  00777	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0077a	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >
  0077f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN42@erase@4:

; 1376 : 		}

  00782	5f		 pop	 edi
  00783	5e		 pop	 esi
  00784	5b		 pop	 ebx
  00785	8b e5		 mov	 esp, ebp
  00787	5d		 pop	 ebp
  00788	c2 08 00	 ret	 8
?erase@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::erase
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color, COMDAT

; 606  : 		{	// return reference to color in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 607  : 		return ((char&)(*_Pnode)._Color);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	83 c0 14	 add	 eax, 20			; 00000014H

; 608  : 		}

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBHPAX@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAX@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Node><std::pair<int const ,void *> >
PUBLIC	??0?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@QAE@U?$less@H@1@@Z ; std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0>::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0>
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAX@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAX@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Tree_nod<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >, COMDAT
; _this$ = ecx

; 482  : 		{	// construct traits from _Parg and allocators from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  0000f	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00012	51		 push	 ecx
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ??0?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@QAE@U?$less@H@1@@Z ; std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0>::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0>
  0001b	8d 45 0c	 lea	 eax, DWORD PTR __Al$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00025	e8 00 00 00 00	 call	 ??$?0U?$pair@$$CBHPAX@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAX@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Node><std::pair<int const ,void *> >
  0002a	8d 45 0c	 lea	 eax, DWORD PTR __Al$[ebp]
  0002d	50		 push	 eax
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	83 c1 0d	 add	 ecx, 13			; 0000000dH
  00034	e8 00 00 00 00	 call	 ??0?$allocator@U?$pair@$$CBHPAX@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,void *> >::allocator<std::pair<int const ,void *> >

; 483  : 		}

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 08 00	 ret	 8
??0?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAX@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Tree_nod<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Node>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 187  : 		return (_Allocate(_Count, (pointer)0));

  0000c	6a 00		 push	 0
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Node>
  00017	83 c4 08	 add	 esp, 8

; 188  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	??$_Allocate@UEVENT_ID_ITEM_LIST@@@std@@YAPAUEVENT_ID_ITEM_LIST@@IPAU1@@Z ; std::_Allocate<EVENT_ID_ITEM_LIST>
; Function compile flags: /Odtp /ZI
;	COMDAT ?allocate@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAEPAUEVENT_ID_ITEM_LIST@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAEPAUEVENT_ID_ITEM_LIST@@I@Z PROC ; std::allocator<EVENT_ID_ITEM_LIST>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 187  : 		return (_Allocate(_Count, (pointer)0));

  0000c	6a 00		 push	 0
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Allocate@UEVENT_ID_ITEM_LIST@@@std@@YAPAUEVENT_ID_ITEM_LIST@@IPAU1@@Z ; std::_Allocate<EVENT_ID_ITEM_LIST>
  00017	83 c4 08	 add	 esp, 8

; 188  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?allocate@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAEPAUEVENT_ID_ITEM_LIST@@I@Z ENDP ; std::allocator<EVENT_ID_ITEM_LIST>::allocate
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -76						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QBEIXZ PROC ; std::allocator<EVENT_ID_ITEM_LIST>::max_size, COMDAT
; _this$ = ecx

; 217  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  0000c	c7 45 f8 33 33
	33 33		 mov	 DWORD PTR __Count$[ebp], 858993459 ; 33333333H

; 219  : 		return (0 < _Count ? _Count : 1);

  00013	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00017	76 08		 jbe	 SHORT $LN3@max_size@2
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0001c	89 45 b4	 mov	 DWORD PTR tv65[ebp], eax
  0001f	eb 07		 jmp	 SHORT $LN4@max_size@2
$LN3@max_size@2:
  00021	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$LN4@max_size@2:
  00028	8b 45 b4	 mov	 eax, DWORD PTR tv65[ebp]

; 220  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?max_size@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QBEIXZ ENDP ; std::allocator<EVENT_ID_ITEM_LIST>::max_size
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator++, COMDAT
; _this$ = ecx

; 270  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 271  : 		_Myiter _Tmp = *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	89 4d f8	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 272  : 		++*this;

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator++

; 273  : 		return (_Tmp);

  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Tmp$[ebp]
  00022	89 08		 mov	 DWORD PTR [eax], ecx
  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 274  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator++
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 43   : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 44   : 		this->_Adopt(_Plist);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Plist$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 45   : 		}

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >,std::_Iterator_base0>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = -8						; size = 4
_this$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1763 : 		{	// promote right node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1764 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Right
  00015	83 c4 04	 add	 esp, 4
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d f8	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 1765 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

  0001d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Left
  00026	83 c4 04	 add	 esp, 4
  00029	8b f0		 mov	 esi, eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Right
  00034	83 c4 04	 add	 esp, 4
  00037	8b 16		 mov	 edx, DWORD PTR [esi]
  00039	89 10		 mov	 DWORD PTR [eax], edx

; 1766 : 
; 1767 : 		if (!this->_Isnil(this->_Left(_Pnode)))

  0003b	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Left
  00044	83 c4 04	 add	 esp, 4
  00047	8b 08		 mov	 ecx, DWORD PTR [eax]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Isnil
  0004f	83 c4 04	 add	 esp, 4
  00052	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00055	85 d2		 test	 edx, edx
  00057	75 1c		 jne	 SHORT $LN5@Lrotate

; 1768 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

  00059	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Left
  00062	83 c4 04	 add	 esp, 4
  00065	8b 08		 mov	 ecx, DWORD PTR [eax]
  00067	51		 push	 ecx
  00068	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  0006d	83 c4 04	 add	 esp, 4
  00070	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00073	89 10		 mov	 DWORD PTR [eax], edx
$LN5@Lrotate:

; 1769 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  00075	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  0007e	83 c4 04	 add	 esp, 4
  00081	8b f0		 mov	 esi, eax
  00083	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00086	51		 push	 ecx
  00087	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  0008c	83 c4 04	 add	 esp, 4
  0008f	8b 16		 mov	 edx, DWORD PTR [esi]
  00091	89 10		 mov	 DWORD PTR [eax], edx

; 1770 : 
; 1771 : 		if (_Wherenode == _Root())

  00093	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Root
  0009b	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0009e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000a0	75 0f		 jne	 SHORT $LN4@Lrotate

; 1772 : 			_Root() = _Pnode;

  000a2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Root
  000aa	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  000ad	89 08		 mov	 DWORD PTR [eax], ecx
  000af	eb 58		 jmp	 SHORT $LN3@Lrotate
$LN4@Lrotate:

; 1773 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  000b1	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000b4	50		 push	 eax
  000b5	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  000ba	83 c4 04	 add	 esp, 4
  000bd	8b 08		 mov	 ecx, DWORD PTR [eax]
  000bf	51		 push	 ecx
  000c0	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Left
  000c5	83 c4 04	 add	 esp, 4
  000c8	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  000cb	3b 10		 cmp	 edx, DWORD PTR [eax]
  000cd	75 1e		 jne	 SHORT $LN2@Lrotate

; 1774 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  000cf	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000d2	50		 push	 eax
  000d3	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  000d8	83 c4 04	 add	 esp, 4
  000db	8b 08		 mov	 ecx, DWORD PTR [eax]
  000dd	51		 push	 ecx
  000de	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Left
  000e3	83 c4 04	 add	 esp, 4
  000e6	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  000e9	89 10		 mov	 DWORD PTR [eax], edx

; 1775 : 		else

  000eb	eb 1c		 jmp	 SHORT $LN3@Lrotate
$LN2@Lrotate:

; 1776 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  000ed	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000f0	50		 push	 eax
  000f1	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  000f6	83 c4 04	 add	 esp, 4
  000f9	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fb	51		 push	 ecx
  000fc	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Right
  00101	83 c4 04	 add	 esp, 4
  00104	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00107	89 10		 mov	 DWORD PTR [eax], edx
$LN3@Lrotate:

; 1777 : 
; 1778 : 		this->_Left(_Pnode) = _Wherenode;

  00109	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0010c	50		 push	 eax
  0010d	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Left
  00112	83 c4 04	 add	 esp, 4
  00115	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00118	89 08		 mov	 DWORD PTR [eax], ecx

; 1779 : 		this->_Parent(_Wherenode) = _Pnode;

  0011a	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0011d	50		 push	 eax
  0011e	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  00123	83 c4 04	 add	 esp, 4
  00126	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00129	89 08		 mov	 DWORD PTR [eax], ecx

; 1780 : 		}

  0012b	5f		 pop	 edi
  0012c	5e		 pop	 esi
  0012d	5b		 pop	 ebx
  0012e	8b e5		 mov	 esp, ebp
  00130	5d		 pop	 ebp
  00131	c2 04 00	 ret	 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Lrotate
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = -8						; size = 4
_this$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1793 : 		{	// promote left node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1794 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Left
  00015	83 c4 04	 add	 esp, 4
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d f8	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 1795 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

  0001d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Right
  00026	83 c4 04	 add	 esp, 4
  00029	8b f0		 mov	 esi, eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Left
  00034	83 c4 04	 add	 esp, 4
  00037	8b 16		 mov	 edx, DWORD PTR [esi]
  00039	89 10		 mov	 DWORD PTR [eax], edx

; 1796 : 
; 1797 : 		if (!this->_Isnil(this->_Right(_Pnode)))

  0003b	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Right
  00044	83 c4 04	 add	 esp, 4
  00047	8b 08		 mov	 ecx, DWORD PTR [eax]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Isnil
  0004f	83 c4 04	 add	 esp, 4
  00052	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00055	85 d2		 test	 edx, edx
  00057	75 1c		 jne	 SHORT $LN5@Rrotate

; 1798 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

  00059	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Right
  00062	83 c4 04	 add	 esp, 4
  00065	8b 08		 mov	 ecx, DWORD PTR [eax]
  00067	51		 push	 ecx
  00068	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  0006d	83 c4 04	 add	 esp, 4
  00070	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00073	89 10		 mov	 DWORD PTR [eax], edx
$LN5@Rrotate:

; 1799 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  00075	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  0007e	83 c4 04	 add	 esp, 4
  00081	8b f0		 mov	 esi, eax
  00083	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00086	51		 push	 ecx
  00087	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  0008c	83 c4 04	 add	 esp, 4
  0008f	8b 16		 mov	 edx, DWORD PTR [esi]
  00091	89 10		 mov	 DWORD PTR [eax], edx

; 1800 : 
; 1801 : 		if (_Wherenode == _Root())

  00093	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Root
  0009b	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0009e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000a0	75 0f		 jne	 SHORT $LN4@Rrotate

; 1802 : 			_Root() = _Pnode;

  000a2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Root
  000aa	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  000ad	89 08		 mov	 DWORD PTR [eax], ecx
  000af	eb 58		 jmp	 SHORT $LN3@Rrotate
$LN4@Rrotate:

; 1803 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

  000b1	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000b4	50		 push	 eax
  000b5	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  000ba	83 c4 04	 add	 esp, 4
  000bd	8b 08		 mov	 ecx, DWORD PTR [eax]
  000bf	51		 push	 ecx
  000c0	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Right
  000c5	83 c4 04	 add	 esp, 4
  000c8	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  000cb	3b 10		 cmp	 edx, DWORD PTR [eax]
  000cd	75 1e		 jne	 SHORT $LN2@Rrotate

; 1804 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  000cf	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000d2	50		 push	 eax
  000d3	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  000d8	83 c4 04	 add	 esp, 4
  000db	8b 08		 mov	 ecx, DWORD PTR [eax]
  000dd	51		 push	 ecx
  000de	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Right
  000e3	83 c4 04	 add	 esp, 4
  000e6	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  000e9	89 10		 mov	 DWORD PTR [eax], edx

; 1805 : 		else

  000eb	eb 1c		 jmp	 SHORT $LN3@Rrotate
$LN2@Rrotate:

; 1806 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  000ed	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000f0	50		 push	 eax
  000f1	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  000f6	83 c4 04	 add	 esp, 4
  000f9	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fb	51		 push	 ecx
  000fc	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Left
  00101	83 c4 04	 add	 esp, 4
  00104	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00107	89 10		 mov	 DWORD PTR [eax], edx
$LN3@Rrotate:

; 1807 : 
; 1808 : 		this->_Right(_Pnode) = _Wherenode;

  00109	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0010c	50		 push	 eax
  0010d	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Right
  00112	83 c4 04	 add	 esp, 4
  00115	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00118	89 08		 mov	 DWORD PTR [eax], ecx

; 1809 : 		this->_Parent(_Wherenode) = _Pnode;

  0011a	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0011d	50		 push	 eax
  0011e	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  00123	83 c4 04	 add	 esp, 4
  00126	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00129	89 08		 mov	 DWORD PTR [eax], ecx

; 1810 : 		}

  0012b	5f		 pop	 edi
  0012c	5e		 pop	 esi
  0012d	5b		 pop	 ebx
  0012e	8b e5		 mov	 esp, ebp
  00130	5d		 pop	 ebp
  00131	c2 04 00	 ret	 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Rrotate
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Max, COMDAT

; 641  : 		{	// return rightmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@Max:

; 642  : 		while (!_Isnil(_Right(_Pnode)))

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Right
  00012	83 c4 04	 add	 esp, 4
  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Isnil
  0001d	83 c4 04	 add	 esp, 4
  00020	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00023	85 d2		 test	 edx, edx
  00025	75 13		 jne	 SHORT $LN1@Max

; 643  : 			_Pnode = _Right(_Pnode);

  00027	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Right
  00030	83 c4 04	 add	 esp, 4
  00033	8b 08		 mov	 ecx, DWORD PTR [eax]
  00035	89 4d 08	 mov	 DWORD PTR __Pnode$[ebp], ecx
  00038	eb cf		 jmp	 SHORT $LN2@Max
$LN1@Max:

; 644  : 		return (_Pnode);

  0003a	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 645  : 		}

  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
  0003f	5b		 pop	 ebx
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?_Max@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Max
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Min, COMDAT

; 648  : 		{	// return leftmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@Min:

; 649  : 		while (!_Isnil(_Left(_Pnode)))

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Left
  00012	83 c4 04	 add	 esp, 4
  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Isnil
  0001d	83 c4 04	 add	 esp, 4
  00020	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00023	85 d2		 test	 edx, edx
  00025	75 13		 jne	 SHORT $LN1@Min

; 650  : 			_Pnode = _Left(_Pnode);

  00027	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Left
  00030	83 c4 04	 add	 esp, 4
  00033	8b 08		 mov	 ecx, DWORD PTR [eax]
  00035	89 4d 08	 mov	 DWORD PTR __Pnode$[ebp], ecx
  00038	eb cf		 jmp	 SHORT $LN2@Min
$LN1@Min:

; 651  : 		return (_Pnode);

  0003a	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 652  : 		}

  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
  0003f	5b		 pop	 ebx
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?_Min@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Min
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\map
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@QAE@U?$less@H@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 1
??0?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@QAE@U?$less@H@1@@Z PROC ; std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0>::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0>, COMDAT
; _this$ = ecx

; 40   : 		{	// construct with specified comparator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 41   : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@QAE@U?$less@H@1@@Z ENDP ; std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0>::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0>
_TEXT	ENDS
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >,std::_Iterator_base0>::operator++
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator++, COMDAT
; _this$ = ecx

; 250  : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 251  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 252  : 		if (this->_Getcont() == 0
; 253  : 			|| this->_Ptr == 0
; 254  : 			|| _Mytree::_Isnil(this->_Ptr))
; 255  : 			{	// report error
; 256  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 257  : 			_SCL_SECURE_OUT_OF_RANGE;
; 258  : 			}
; 259  : 
; 260  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 261  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 262  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 263  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 264  : 
; 265  : 		++(*(_Mybase *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >,std::_Iterator_base0>::operator++

; 266  : 		return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 267  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator++
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
__Pnode$225488 = -8					; size = 4
_this$ = -4						; size = 4
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 58   : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 59   : 		if (_Mytree::_Isnil(_Ptr))

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Isnil
  00017	83 c4 04	 add	 esp, 4
  0001a	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0001d	85 d2		 test	 edx, edx
  0001f	74 05		 je	 SHORT $LN6@operator@3
  00021	e9 8d 00 00 00	 jmp	 $LN5@operator@3
$LN6@operator@3:

; 60   : 			;	// end() shouldn't be incremented, don't move
; 61   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002b	51		 push	 ecx
  0002c	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Right
  00031	83 c4 04	 add	 esp, 4
  00034	8b 10		 mov	 edx, DWORD PTR [eax]
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Isnil
  0003c	83 c4 04	 add	 esp, 4
  0003f	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00042	85 c0		 test	 eax, eax
  00044	75 20		 jne	 SHORT $LN2@operator@3

; 62   : 			_Ptr = _Mytree::_Min(
; 63   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

  00046	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00049	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Right
  00051	83 c4 04	 add	 esp, 4
  00054	8b 10		 mov	 edx, DWORD PTR [eax]
  00056	52		 push	 edx
  00057	e8 00 00 00 00	 call	 ?_Min@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Min
  0005c	83 c4 04	 add	 esp, 4
  0005f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00062	89 01		 mov	 DWORD PTR [ecx], eax

; 64   : 		else

  00064	eb 4d		 jmp	 SHORT $LN5@operator@3
$LN2@operator@3:

; 65   : 			{	// climb looking for right subtree
; 66   : 			_Nodeptr _Pnode;
; 67   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 68   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  00066	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00069	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006b	51		 push	 ecx
  0006c	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  00071	83 c4 04	 add	 esp, 4
  00074	8b 10		 mov	 edx, DWORD PTR [eax]
  00076	89 55 f8	 mov	 DWORD PTR __Pnode$225488[ebp], edx
  00079	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$225488[ebp]
  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Isnil
  00082	83 c4 04	 add	 esp, 4
  00085	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00088	85 c9		 test	 ecx, ecx
  0008a	75 1f		 jne	 SHORT $LN1@operator@3
  0008c	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$225488[ebp]
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Right
  00095	83 c4 04	 add	 esp, 4
  00098	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0009d	3b 10		 cmp	 edx, DWORD PTR [eax]
  0009f	75 0a		 jne	 SHORT $LN1@operator@3

; 69   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  000a1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a4	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$225488[ebp]
  000a7	89 08		 mov	 DWORD PTR [eax], ecx
  000a9	eb bb		 jmp	 SHORT $LN2@operator@3
$LN1@operator@3:

; 70   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  000ab	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$225488[ebp]
  000b1	89 08		 mov	 DWORD PTR [eax], ecx
$LN5@operator@3:

; 71   : 			}
; 72   : 		return (*this);

  000b3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 73   : 		}

  000b6	5f		 pop	 edi
  000b7	5e		 pop	 esi
  000b8	5b		 pop	 ebx
  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c3		 ret	 0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >,std::_Iterator_base0>::operator++
_TEXT	ENDS
PUBLIC	??$?0AAHAAPAX@?$_Pair_base@HPAX@std@@QAE@AAHAAPAX@Z ; std::_Pair_base<int,void *>::_Pair_base<int,void *><int &,void * &>
PUBLIC	??$forward@AAH@std@@YAAAHAAH@Z			; std::forward<int &>
PUBLIC	??$forward@AAPAX@std@@YAAAPAXAAPAX@Z		; std::forward<void * &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$?0AAHAAPAX@?$pair@HPAX@std@@QAE@AAHAAPAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAHAAPAX@?$pair@HPAX@std@@QAE@AAHAAPAX@Z PROC	; std::pair<int,void *>::pair<int,void *><int &,void * &>, COMDAT
; _this$ = ecx

; 247  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$forward@AAPAX@std@@YAAAPAXAAPAX@Z ; std::forward<void * &>
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>
  00022	83 c4 04	 add	 esp, 4
  00025	50		 push	 eax
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ??$?0AAHAAPAX@?$_Pair_base@HPAX@std@@QAE@AAHAAPAX@Z ; std::_Pair_base<int,void *>::_Pair_base<int,void *><int &,void * &>

; 248  : 		}

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
??$?0AAHAAPAX@?$pair@HPAX@std@@QAE@AAHAAPAX@Z ENDP	; std::pair<int,void *>::pair<int,void *><int &,void * &>
_TEXT	ENDS
PUBLIC	?_Linsert@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Linsert
PUBLIC	??$_Buynode@U?$pair@HPAX@std@@@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@$$QAU?$pair@HPAX@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Buynode<std::pair<int,void *> >
PUBLIC	??$forward@U?$pair@HPAX@std@@@std@@YA$$QAU?$pair@HPAX@0@AAU10@@Z ; std::forward<std::pair<int,void *> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??$insert@U?$pair@HPAX@std@@@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HPAX@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
??$insert@U?$pair@HPAX@std@@@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HPAX@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::insert<std::pair<int,void *> >, COMDAT
; _this$ = ecx

; 753  : 		_Pairib insert(_Valty&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 754  : 		{	// try to insert node with value _Val, favoring right side
; 755  : 		return (_Linsert(this->_Buynode(_STD forward<_Valty>(_Val)),
; 756  : 			false));

  0000c	6a 00		 push	 0
  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$forward@U?$pair@HPAX@std@@@std@@YA$$QAU?$pair@HPAX@0@AAU10@@Z ; std::forward<std::pair<int,void *> >
  00017	83 c4 04	 add	 esp, 4
  0001a	50		 push	 eax
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@HPAX@std@@@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@$$QAU?$pair@HPAX@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Buynode<std::pair<int,void *> >
  00023	50		 push	 eax
  00024	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00027	51		 push	 ecx
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ?_Linsert@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Linsert
  00030	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 757  : 		}

  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
??$insert@U?$pair@HPAX@std@@@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HPAX@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::insert<std::pair<int,void *> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$addressof@$$CBUEVENT_ID_TIME@@@std@@YAPBUEVENT_ID_TIME@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUEVENT_ID_TIME@@@std@@YAPBUEVENT_ID_TIME@@ABU1@@Z PROC ; std::addressof<EVENT_ID_TIME const >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 111  : 	return ((_Ty *) &(char&)_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@$$CBUEVENT_ID_TIME@@@std@@YAPBUEVENT_ID_TIME@@ABU1@@Z ENDP ; std::addressof<EVENT_ID_TIME const >
_TEXT	ENDS
PUBLIC	??$construct@AAUEVENT_ID_TIME@@@?$allocator@UEVENT_ID_TIME@@@std@@QAEXPAUEVENT_ID_TIME@@AAU2@@Z ; std::allocator<EVENT_ID_TIME>::construct<EVENT_ID_TIME &>
PUBLIC	??$forward@AAUEVENT_ID_TIME@@@std@@YAAAUEVENT_ID_TIME@@AAU1@@Z ; std::forward<EVENT_ID_TIME &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UEVENT_ID_TIME@@@std@@UEVENT_ID_TIME@@AAU3@@std@@YAXAAV?$allocator@UEVENT_ID_TIME@@@0@PAUEVENT_ID_TIME@@AAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UEVENT_ID_TIME@@@std@@UEVENT_ID_TIME@@AAU3@@std@@YAXAAV?$allocator@UEVENT_ID_TIME@@@0@PAUEVENT_ID_TIME@@AAU2@@Z PROC ; std::_Cons_val<std::allocator<EVENT_ID_TIME>,EVENT_ID_TIME,EVENT_ID_TIME &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@AAUEVENT_ID_TIME@@@std@@YAAAUEVENT_ID_TIME@@AAU1@@Z ; std::forward<EVENT_ID_TIME &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ??$construct@AAUEVENT_ID_TIME@@@?$allocator@UEVENT_ID_TIME@@@std@@QAEXPAUEVENT_ID_TIME@@AAU2@@Z ; std::allocator<EVENT_ID_TIME>::construct<EVENT_ID_TIME &>

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UEVENT_ID_TIME@@@std@@UEVENT_ID_TIME@@AAU3@@std@@YAXAAV?$allocator@UEVENT_ID_TIME@@@0@PAUEVENT_ID_TIME@@AAU2@@Z ENDP ; std::_Cons_val<std::allocator<EVENT_ID_TIME>,EVENT_ID_TIME,EVENT_ID_TIME &>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UEVENT_ID_TIME@@@std@@QAEXPAUEVENT_ID_TIME@@ABU3@@Z ; std::allocator<EVENT_ID_TIME>::construct
PUBLIC	??$forward@ABUEVENT_ID_TIME@@@std@@YAABUEVENT_ID_TIME@@ABU1@@Z ; std::forward<EVENT_ID_TIME const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UEVENT_ID_TIME@@@std@@UEVENT_ID_TIME@@ABU3@@std@@YAXAAV?$allocator@UEVENT_ID_TIME@@@0@PAUEVENT_ID_TIME@@ABU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UEVENT_ID_TIME@@@std@@UEVENT_ID_TIME@@ABU3@@std@@YAXAAV?$allocator@UEVENT_ID_TIME@@@0@PAUEVENT_ID_TIME@@ABU2@@Z PROC ; std::_Cons_val<std::allocator<EVENT_ID_TIME>,EVENT_ID_TIME,EVENT_ID_TIME const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@ABUEVENT_ID_TIME@@@std@@YAABUEVENT_ID_TIME@@ABU1@@Z ; std::forward<EVENT_ID_TIME const &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@UEVENT_ID_TIME@@@std@@QAEXPAUEVENT_ID_TIME@@ABU3@@Z ; std::allocator<EVENT_ID_TIME>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UEVENT_ID_TIME@@@std@@UEVENT_ID_TIME@@ABU3@@std@@YAXAAV?$allocator@UEVENT_ID_TIME@@@0@PAUEVENT_ID_TIME@@ABU2@@Z ENDP ; std::_Cons_val<std::allocator<EVENT_ID_TIME>,EVENT_ID_TIME,EVENT_ID_TIME const &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$addressof@$$CBUEVENT_ID_ITEM_LIST@@@std@@YAPBUEVENT_ID_ITEM_LIST@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUEVENT_ID_ITEM_LIST@@@std@@YAPBUEVENT_ID_ITEM_LIST@@ABU1@@Z PROC ; std::addressof<EVENT_ID_ITEM_LIST const >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 111  : 	return ((_Ty *) &(char&)_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@$$CBUEVENT_ID_ITEM_LIST@@@std@@YAPBUEVENT_ID_ITEM_LIST@@ABU1@@Z ENDP ; std::addressof<EVENT_ID_ITEM_LIST const >
_TEXT	ENDS
PUBLIC	??$construct@AAUEVENT_ID_ITEM_LIST@@@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAEXPAUEVENT_ID_ITEM_LIST@@AAU2@@Z ; std::allocator<EVENT_ID_ITEM_LIST>::construct<EVENT_ID_ITEM_LIST &>
PUBLIC	??$forward@AAUEVENT_ID_ITEM_LIST@@@std@@YAAAUEVENT_ID_ITEM_LIST@@AAU1@@Z ; std::forward<EVENT_ID_ITEM_LIST &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@UEVENT_ID_ITEM_LIST@@AAU3@@std@@YAXAAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@PAUEVENT_ID_ITEM_LIST@@AAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@UEVENT_ID_ITEM_LIST@@AAU3@@std@@YAXAAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@PAUEVENT_ID_ITEM_LIST@@AAU2@@Z PROC ; std::_Cons_val<std::allocator<EVENT_ID_ITEM_LIST>,EVENT_ID_ITEM_LIST,EVENT_ID_ITEM_LIST &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@AAUEVENT_ID_ITEM_LIST@@@std@@YAAAUEVENT_ID_ITEM_LIST@@AAU1@@Z ; std::forward<EVENT_ID_ITEM_LIST &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ??$construct@AAUEVENT_ID_ITEM_LIST@@@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAEXPAUEVENT_ID_ITEM_LIST@@AAU2@@Z ; std::allocator<EVENT_ID_ITEM_LIST>::construct<EVENT_ID_ITEM_LIST &>

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@UEVENT_ID_ITEM_LIST@@AAU3@@std@@YAXAAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@PAUEVENT_ID_ITEM_LIST@@AAU2@@Z ENDP ; std::_Cons_val<std::allocator<EVENT_ID_ITEM_LIST>,EVENT_ID_ITEM_LIST,EVENT_ID_ITEM_LIST &>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAEXPAUEVENT_ID_ITEM_LIST@@ABU3@@Z ; std::allocator<EVENT_ID_ITEM_LIST>::construct
PUBLIC	??$forward@ABUEVENT_ID_ITEM_LIST@@@std@@YAABUEVENT_ID_ITEM_LIST@@ABU1@@Z ; std::forward<EVENT_ID_ITEM_LIST const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@UEVENT_ID_ITEM_LIST@@ABU3@@std@@YAXAAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@PAUEVENT_ID_ITEM_LIST@@ABU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@UEVENT_ID_ITEM_LIST@@ABU3@@std@@YAXAAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@PAUEVENT_ID_ITEM_LIST@@ABU2@@Z PROC ; std::_Cons_val<std::allocator<EVENT_ID_ITEM_LIST>,EVENT_ID_ITEM_LIST,EVENT_ID_ITEM_LIST const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@ABUEVENT_ID_ITEM_LIST@@@std@@YAABUEVENT_ID_ITEM_LIST@@ABU1@@Z ; std::forward<EVENT_ID_ITEM_LIST const &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAEXPAUEVENT_ID_ITEM_LIST@@ABU3@@Z ; std::allocator<EVENT_ID_ITEM_LIST>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@UEVENT_ID_ITEM_LIST@@ABU3@@std@@YAXAAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@PAUEVENT_ID_ITEM_LIST@@ABU2@@Z ENDP ; std::_Cons_val<std::allocator<EVENT_ID_ITEM_LIST>,EVENT_ID_ITEM_LIST,EVENT_ID_ITEM_LIST const &>
_TEXT	ENDS
PUBLIC	??$_Move@PAUEVENT_ID_TIME@@PAU1@@std@@YAPAUEVENT_ID_TIME@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<EVENT_ID_TIME *,EVENT_ID_TIME *>
PUBLIC	??$_Ptr_cat@UEVENT_ID_TIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUEVENT_ID_TIME@@0@Z ; std::_Ptr_cat<EVENT_ID_TIME,EVENT_ID_TIME>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAUEVENT_ID_TIME@@PAU1@@std@@YAPAUEVENT_ID_TIME@@PAU1@00@Z
_TEXT	SEGMENT
$T227652 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAUEVENT_ID_TIME@@PAU1@@std@@YAPAUEVENT_ID_TIME@@PAU1@00@Z PROC ; std::_Move<EVENT_ID_TIME *,EVENT_ID_TIME *>, COMDAT

; 2533 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2534 : 	return (_Move(_First, _Last,
; 2535 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UEVENT_ID_TIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUEVENT_ID_TIME@@0@Z ; std::_Ptr_cat<EVENT_ID_TIME,EVENT_ID_TIME>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T227652[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T227652[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Move@PAUEVENT_ID_TIME@@PAU1@@std@@YAPAUEVENT_ID_TIME@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<EVENT_ID_TIME *,EVENT_ID_TIME *>
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 2536 : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Move@PAUEVENT_ID_TIME@@PAU1@@std@@YAPAUEVENT_ID_TIME@@PAU1@00@Z ENDP ; std::_Move<EVENT_ID_TIME *,EVENT_ID_TIME *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$addressof@U?$pair@$$CBHPAX@std@@@std@@YAPAU?$pair@$$CBHPAX@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U?$pair@$$CBHPAX@std@@@std@@YAPAU?$pair@$$CBHPAX@0@AAU10@@Z PROC ; std::addressof<std::pair<int const ,void *> >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 111  : 	return ((_Ty *) &(char&)_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@U?$pair@$$CBHPAX@std@@@std@@YAPAU?$pair@$$CBHPAX@0@AAU10@@Z ENDP ; std::addressof<std::pair<int const ,void *> >
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U?$pair@$$CBHPAX@std@@@std@@QAEXPAU?$pair@$$CBHPAX@2@@Z ; std::allocator<std::pair<int const ,void *> >::destroy
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Dest_val@V?$allocator@U?$pair@$$CBHPAX@std@@@std@@U?$pair@$$CBHPAX@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHPAX@std@@@0@PAU?$pair@$$CBHPAX@0@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@U?$pair@$$CBHPAX@std@@@std@@U?$pair@$$CBHPAX@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHPAX@std@@@0@PAU?$pair@$$CBHPAX@0@@Z PROC ; std::_Dest_val<std::allocator<std::pair<int const ,void *> >,std::pair<int const ,void *> >, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 287  : 	_Alval.destroy(_Pdest);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  00010	e8 00 00 00 00	 call	 ?destroy@?$allocator@U?$pair@$$CBHPAX@std@@@std@@QAEXPAU?$pair@$$CBHPAX@2@@Z ; std::allocator<std::pair<int const ,void *> >::destroy

; 288  : 	}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Dest_val@V?$allocator@U?$pair@$$CBHPAX@std@@@std@@U?$pair@$$CBHPAX@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHPAX@std@@@0@PAU?$pair@$$CBHPAX@0@@Z ENDP ; std::_Dest_val<std::allocator<std::pair<int const ,void *> >,std::pair<int const ,void *> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\map
_TEXT	ENDS
;	COMDAT ??$_Kfn@$$CBHPAX@?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHPAX@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Kfn@$$CBHPAX@?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHPAX@1@@Z PROC ; std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0>::_Kfn<int const ,void *>, COMDAT

; 66   : 		static const _Kty& _Kfn(const _STD pair<_Ty1, _Ty2>& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 67   : 		{	// extract key from element value
; 68   : 		return (_Val.first);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 69   : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Kfn@$$CBHPAX@?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHPAX@1@@Z ENDP ; std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0>::_Kfn<int const ,void *>
_TEXT	ENDS
PUBLIC	??$_Move@PAUEVENT_ID_ITEM_LIST@@PAU1@@std@@YAPAUEVENT_ID_ITEM_LIST@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<EVENT_ID_ITEM_LIST *,EVENT_ID_ITEM_LIST *>
PUBLIC	??$_Ptr_cat@UEVENT_ID_ITEM_LIST@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUEVENT_ID_ITEM_LIST@@0@Z ; std::_Ptr_cat<EVENT_ID_ITEM_LIST,EVENT_ID_ITEM_LIST>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAUEVENT_ID_ITEM_LIST@@PAU1@@std@@YAPAUEVENT_ID_ITEM_LIST@@PAU1@00@Z
_TEXT	SEGMENT
$T227661 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAUEVENT_ID_ITEM_LIST@@PAU1@@std@@YAPAUEVENT_ID_ITEM_LIST@@PAU1@00@Z PROC ; std::_Move<EVENT_ID_ITEM_LIST *,EVENT_ID_ITEM_LIST *>, COMDAT

; 2533 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2534 : 	return (_Move(_First, _Last,
; 2535 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UEVENT_ID_ITEM_LIST@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUEVENT_ID_ITEM_LIST@@0@Z ; std::_Ptr_cat<EVENT_ID_ITEM_LIST,EVENT_ID_ITEM_LIST>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T227661[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T227661[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Move@PAUEVENT_ID_ITEM_LIST@@PAU1@@std@@YAPAUEVENT_ID_ITEM_LIST@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<EVENT_ID_ITEM_LIST *,EVENT_ID_ITEM_LIST *>
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 2536 : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Move@PAUEVENT_ID_ITEM_LIST@@PAU1@@std@@YAPAUEVENT_ID_ITEM_LIST@@PAU1@00@Z ENDP ; std::_Move<EVENT_ID_ITEM_LIST *,EVENT_ID_ITEM_LIST *>
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAUEVENT_ID_TIME@@PAU1@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@YAPAUEVENT_ID_TIME@@PAU1@00AAV?$allocator@UEVENT_ID_TIME@@@0@@Z ; std::_Uninitialized_move<EVENT_ID_TIME *,EVENT_ID_TIME *,std::allocator<EVENT_ID_TIME> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??$_Umove@PAUEVENT_ID_TIME@@@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@IAEPAUEVENT_ID_TIME@@PAU2@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAUEVENT_ID_TIME@@@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@IAEPAUEVENT_ID_TIME@@PAU2@00@Z PROC ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::_Umove<EVENT_ID_TIME *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUEVENT_ID_TIME@@PAU1@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@YAPAUEVENT_ID_TIME@@PAU1@00AAV?$allocator@UEVENT_ID_TIME@@@0@@Z ; std::_Uninitialized_move<EVENT_ID_TIME *,EVENT_ID_TIME *,std::allocator<EVENT_ID_TIME> >
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 1326 : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUEVENT_ID_TIME@@@?$vector@UEVENT_ID_TIME@@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@IAEPAUEVENT_ID_TIME@@PAU2@00@Z ENDP ; std::vector<EVENT_ID_TIME,std::allocator<EVENT_ID_TIME> >::_Umove<EVENT_ID_TIME *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@YAXPAUEVENT_ID_TIME@@0AAV?$allocator@UEVENT_ID_TIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<EVENT_ID_TIME> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@YAXPAUEVENT_ID_TIME@@0AAV?$allocator@UEVENT_ID_TIME@@@0@@Z
_TEXT	SEGMENT
$T227666 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@YAXPAUEVENT_ID_TIME@@0AAV?$allocator@UEVENT_ID_TIME@@@0@@Z PROC ; std::_Destroy_range<std::allocator<EVENT_ID_TIME> >, COMDAT

; 87   : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UEVENT_ID_TIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUEVENT_ID_TIME@@0@Z ; std::_Ptr_cat<EVENT_ID_TIME,EVENT_ID_TIME>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T227666[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T227666[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@YAXPAUEVENT_ID_TIME@@0AAV?$allocator@UEVENT_ID_TIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<EVENT_ID_TIME> >
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 89   : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Destroy_range@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@YAXPAUEVENT_ID_TIME@@0AAV?$allocator@UEVENT_ID_TIME@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<EVENT_ID_TIME> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAUEVENT_ID_ITEM_LIST@@PAU1@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@YAPAUEVENT_ID_ITEM_LIST@@PAU1@00AAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@@Z ; std::_Uninitialized_move<EVENT_ID_ITEM_LIST *,EVENT_ID_ITEM_LIST *,std::allocator<EVENT_ID_ITEM_LIST> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??$_Umove@PAUEVENT_ID_ITEM_LIST@@@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@IAEPAUEVENT_ID_ITEM_LIST@@PAU2@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAUEVENT_ID_ITEM_LIST@@@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@IAEPAUEVENT_ID_ITEM_LIST@@PAU2@00@Z PROC ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::_Umove<EVENT_ID_ITEM_LIST *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUEVENT_ID_ITEM_LIST@@PAU1@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@YAPAUEVENT_ID_ITEM_LIST@@PAU1@00AAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@@Z ; std::_Uninitialized_move<EVENT_ID_ITEM_LIST *,EVENT_ID_ITEM_LIST *,std::allocator<EVENT_ID_ITEM_LIST> >
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 1326 : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUEVENT_ID_ITEM_LIST@@@?$vector@UEVENT_ID_ITEM_LIST@@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@IAEPAUEVENT_ID_ITEM_LIST@@PAU2@00@Z ENDP ; std::vector<EVENT_ID_ITEM_LIST,std::allocator<EVENT_ID_ITEM_LIST> >::_Umove<EVENT_ID_ITEM_LIST *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@YAXPAUEVENT_ID_ITEM_LIST@@0AAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<EVENT_ID_ITEM_LIST> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@YAXPAUEVENT_ID_ITEM_LIST@@0AAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@@Z
_TEXT	SEGMENT
$T227671 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@YAXPAUEVENT_ID_ITEM_LIST@@0AAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@@Z PROC ; std::_Destroy_range<std::allocator<EVENT_ID_ITEM_LIST> >, COMDAT

; 87   : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UEVENT_ID_ITEM_LIST@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUEVENT_ID_ITEM_LIST@@0@Z ; std::_Ptr_cat<EVENT_ID_ITEM_LIST,EVENT_ID_ITEM_LIST>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T227671[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T227671[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@YAXPAUEVENT_ID_ITEM_LIST@@0AAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<EVENT_ID_ITEM_LIST> >
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 89   : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Destroy_range@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@YAXPAUEVENT_ID_ITEM_LIST@@0AAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<EVENT_ID_ITEM_LIST> >
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Allocate@UEVENT_ID_TIME@@@std@@YAPAUEVENT_ID_TIME@@IPAU1@@Z
_TEXT	SEGMENT
$T227674 = -80						; size = 12
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UEVENT_ID_TIME@@@std@@YAPAUEVENT_ID_TIME@@IPAU1@@Z PROC ; std::_Allocate<EVENT_ID_TIME>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 31   : 	void *_Ptr = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 32   : 
; 33   : 	if (_Count <= 0)

  00010	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	77 09		 ja	 SHORT $LN4@Allocate

; 34   : 		_Count = 0;

  00016	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __Count$[ebp], 0

; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0001d	eb 39		 jmp	 SHORT $LN3@Allocate
$LN4@Allocate:

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0001f	81 7d 08 ff ff
	ff 0f		 cmp	 DWORD PTR __Count$[ebp], 268435455 ; 0fffffffH
  00026	77 18		 ja	 SHORT $LN1@Allocate
  00028	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002b	c1 e0 04	 shl	 eax, 4
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 fc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0003a	83 7d fc 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  0003e	75 18		 jne	 SHORT $LN3@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00040	6a 00		 push	 0
  00042	8d 4d b0	 lea	 ecx, DWORD PTR $T227674[ebp]
  00045	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0004a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0004f	8d 45 b0	 lea	 eax, DWORD PTR $T227674[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Allocate:

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00058	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 40   : 	}

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
??$_Allocate@UEVENT_ID_TIME@@@std@@YAPAUEVENT_ID_TIME@@IPAU1@@Z ENDP ; std::_Allocate<EVENT_ID_TIME>
_TEXT	ENDS
PUBLIC	??$_Move@AAD@std@@YA$$QADAAD@Z			; std::_Move<char &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$swap@D@std@@YAXAAD0@Z
_TEXT	SEGMENT
__Tmp$ = -1						; size = 1
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@D@std@@YAXAAD0@Z PROC				; std::swap<char>, COMDAT

; 101  : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 102  : 	_Ty _Tmp = _Move(_Left);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$_Move@AAD@std@@YA$$QADAAD@Z ; std::_Move<char &>
  00012	83 c4 04	 add	 esp, 4
  00015	8a 08		 mov	 cl, BYTE PTR [eax]
  00017	88 4d ff	 mov	 BYTE PTR __Tmp$[ebp], cl

; 103  : 	_Left = _Move(_Right);

  0001a	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??$_Move@AAD@std@@YA$$QADAAD@Z ; std::_Move<char &>
  00023	83 c4 04	 add	 esp, 4
  00026	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00029	8a 10		 mov	 dl, BYTE PTR [eax]
  0002b	88 11		 mov	 BYTE PTR [ecx], dl

; 104  : 	_Right = _Move(_Tmp);

  0002d	8d 45 ff	 lea	 eax, DWORD PTR __Tmp$[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ??$_Move@AAD@std@@YA$$QADAAD@Z ; std::_Move<char &>
  00036	83 c4 04	 add	 esp, 4
  00039	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  0003c	8a 10		 mov	 dl, BYTE PTR [eax]
  0003e	88 11		 mov	 BYTE PTR [ecx], dl

; 105  : 	}

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
??$swap@D@std@@YAXAAD0@Z ENDP				; std::swap<char>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHPAX@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAX@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBHPAX@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAX@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Node><std::pair<int const ,void *> >, COMDAT
; _this$ = ecx

; 170  : 		_ALLOCATOR(const _ALLOCATOR<_Other>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 171  : 		{	// construct from a related allocator (do nothing)
; 172  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??$?0U?$pair@$$CBHPAX@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAX@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Node><std::pair<int const ,void *> >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T227681 = -80						; size = 12
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Node>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 31   : 	void *_Ptr = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 32   : 
; 33   : 	if (_Count <= 0)

  00010	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	77 09		 ja	 SHORT $LN4@Allocate@2

; 34   : 		_Count = 0;

  00016	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __Count$[ebp], 0

; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0001d	eb 39		 jmp	 SHORT $LN3@Allocate@2
$LN4@Allocate@2:

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0001f	81 7d 08 aa aa
	aa 0a		 cmp	 DWORD PTR __Count$[ebp], 178956970 ; 0aaaaaaaH
  00026	77 18		 ja	 SHORT $LN1@Allocate@2
  00028	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002b	6b c0 18	 imul	 eax, 24			; 00000018H
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 fc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0003a	83 7d fc 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  0003e	75 18		 jne	 SHORT $LN3@Allocate@2
$LN1@Allocate@2:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00040	6a 00		 push	 0
  00042	8d 4d b0	 lea	 ecx, DWORD PTR $T227681[ebp]
  00045	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0004a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0004f	8d 45 b0	 lea	 eax, DWORD PTR $T227681[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Allocate@2:

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00058	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate@2:

; 40   : 	}

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Node>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Allocate@UEVENT_ID_ITEM_LIST@@@std@@YAPAUEVENT_ID_ITEM_LIST@@IPAU1@@Z
_TEXT	SEGMENT
$T227684 = -80						; size = 12
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UEVENT_ID_ITEM_LIST@@@std@@YAPAUEVENT_ID_ITEM_LIST@@IPAU1@@Z PROC ; std::_Allocate<EVENT_ID_ITEM_LIST>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 31   : 	void *_Ptr = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 32   : 
; 33   : 	if (_Count <= 0)

  00010	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	77 09		 ja	 SHORT $LN4@Allocate@3

; 34   : 		_Count = 0;

  00016	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __Count$[ebp], 0

; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0001d	eb 39		 jmp	 SHORT $LN3@Allocate@3
$LN4@Allocate@3:

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0001f	81 7d 08 33 33
	33 33		 cmp	 DWORD PTR __Count$[ebp], 858993459 ; 33333333H
  00026	77 18		 ja	 SHORT $LN1@Allocate@3
  00028	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002b	6b c0 05	 imul	 eax, 5
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 fc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0003a	83 7d fc 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  0003e	75 18		 jne	 SHORT $LN3@Allocate@3
$LN1@Allocate@3:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00040	6a 00		 push	 0
  00042	8d 4d b0	 lea	 ecx, DWORD PTR $T227684[ebp]
  00045	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0004a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0004f	8d 45 b0	 lea	 eax, DWORD PTR $T227684[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Allocate@3:

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00058	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate@3:

; 40   : 	}

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
??$_Allocate@UEVENT_ID_ITEM_LIST@@@std@@YAPAUEVENT_ID_ITEM_LIST@@IPAU1@@Z ENDP ; std::_Allocate<EVENT_ID_ITEM_LIST>
_TEXT	ENDS
PUBLIC	??$_Construct@UEVENT_ID_TIME@@ABU1@@std@@YAXPAUEVENT_ID_TIME@@ABU1@@Z ; std::_Construct<EVENT_ID_TIME,EVENT_ID_TIME const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ?construct@?$allocator@UEVENT_ID_TIME@@@std@@QAEXPAUEVENT_ID_TIME@@ABU3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UEVENT_ID_TIME@@@std@@QAEXPAUEVENT_ID_TIME@@ABU3@@Z PROC ; std::allocator<EVENT_ID_TIME>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 197  : 		_Construct(_Ptr, _Val);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ??$_Construct@UEVENT_ID_TIME@@ABU1@@std@@YAXPAUEVENT_ID_TIME@@ABU1@@Z ; std::_Construct<EVENT_ID_TIME,EVENT_ID_TIME const &>
  00019	83 c4 08	 add	 esp, 8

; 198  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
?construct@?$allocator@UEVENT_ID_TIME@@@std@@QAEXPAUEVENT_ID_TIME@@ABU3@@Z ENDP ; std::allocator<EVENT_ID_TIME>::construct
_TEXT	ENDS
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > > &,bool>
PUBLIC	??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator--
PUBLIC	??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >,bool>
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Insert
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Linsert@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@_N@Z
_TEXT	SEGMENT
tv147 = -124						; size = 4
$T227691 = -117						; size = 1
$T227692 = -116						; size = 4
$T227693 = -112						; size = 4
$T227694 = -105						; size = 1
$T227695 = -104						; size = 4
$T227696 = -97						; size = 1
$T227697 = -96						; size = 4
$T227698 = -89						; size = 1
__Where$226252 = -24					; size = 4
__Addleft$ = -17					; size = 1
__Wherenode$ = -16					; size = 4
__Trynode$ = -12					; size = 4
__Val$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Node$ = 12						; size = 4
__Leftish$ = 16						; size = 1
?_Linsert@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@_N@Z PROC ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Linsert, COMDAT
; _this$ = ecx

; 944  : 		{	// try to insert node at _Node, on left if _Leftish

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 7c	 sub	 esp, 124		; 0000007cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 945  : 		const value_type& _Val = this->_Myval(_Node);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Node$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHPAX@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Myval
  00015	83 c4 04	 add	 esp, 4
  00018	89 45 f8	 mov	 DWORD PTR __Val$[ebp], eax

; 946  : 
; 947  : 		_Nodeptr _Trynode = _Root();

  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Root
  00023	8b 00		 mov	 eax, DWORD PTR [eax]
  00025	89 45 f4	 mov	 DWORD PTR __Trynode$[ebp], eax

; 948  : 		_Nodeptr _Wherenode = this->_Myhead;

  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002e	89 4d f0	 mov	 DWORD PTR __Wherenode$[ebp], ecx

; 949  : 		bool _Addleft = true;	// add to left of head if tree empty

  00031	c6 45 ef 01	 mov	 BYTE PTR __Addleft$[ebp], 1
$LN12@Linsert:

; 950  : 		while (!this->_Isnil(_Trynode))

  00035	8b 45 f4	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Isnil
  0003e	83 c4 04	 add	 esp, 4
  00041	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00044	85 c9		 test	 ecx, ecx
  00046	0f 85 9b 00 00
	00		 jne	 $LN11@Linsert

; 951  : 			{	// look for leaf to insert before (_Addleft) or after
; 952  : 			_Wherenode = _Trynode;

  0004c	8b 45 f4	 mov	 eax, DWORD PTR __Trynode$[ebp]
  0004f	89 45 f0	 mov	 DWORD PTR __Wherenode$[ebp], eax

; 953  : 			if (_Leftish)

  00052	0f b6 45 10	 movzx	 eax, BYTE PTR __Leftish$[ebp]
  00056	85 c0		 test	 eax, eax
  00058	74 31		 je	 SHORT $LN10@Linsert

; 954  : 				_Addleft = !_DEBUG_LT_PRED(this->comp,

  0005a	8b 45 f8	 mov	 eax, DWORD PTR __Val$[ebp]
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 ??$_Kfn@$$CBHPAX@?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHPAX@1@@Z ; std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0>::_Kfn<int const ,void *>
  00063	83 c4 04	 add	 esp, 4
  00066	50		 push	 eax
  00067	8b 4d f4	 mov	 ecx, DWORD PTR __Trynode$[ebp]
  0006a	51		 push	 ecx
  0006b	e8 00 00 00 00	 call	 ?_Key@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Key
  00070	83 c4 04	 add	 esp, 4
  00073	50		 push	 eax
  00074	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  0007c	0f b6 d0	 movzx	 edx, al
  0007f	f7 da		 neg	 edx
  00081	1b d2		 sbb	 edx, edx
  00083	83 c2 01	 add	 edx, 1
  00086	88 55 ef	 mov	 BYTE PTR __Addleft$[ebp], dl

; 955  : 					this->_Key(_Trynode),
; 956  : 					this->_Kfn(_Val));	// favor left end
; 957  : 			else

  00089	eb 25		 jmp	 SHORT $LN9@Linsert
$LN10@Linsert:

; 958  : 				_Addleft = _DEBUG_LT_PRED(this->comp,

  0008b	8b 45 f4	 mov	 eax, DWORD PTR __Trynode$[ebp]
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 ?_Key@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Key
  00094	83 c4 04	 add	 esp, 4
  00097	50		 push	 eax
  00098	8b 4d f8	 mov	 ecx, DWORD PTR __Val$[ebp]
  0009b	51		 push	 ecx
  0009c	e8 00 00 00 00	 call	 ??$_Kfn@$$CBHPAX@?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHPAX@1@@Z ; std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0>::_Kfn<int const ,void *>
  000a1	83 c4 04	 add	 esp, 4
  000a4	50		 push	 eax
  000a5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a8	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  000ad	88 45 ef	 mov	 BYTE PTR __Addleft$[ebp], al
$LN9@Linsert:

; 959  : 					this->_Kfn(_Val),
; 960  : 					this->_Key(_Trynode));	// favor right end
; 961  : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 962  : 				: this->_Right(_Trynode);

  000b0	0f b6 45 ef	 movzx	 eax, BYTE PTR __Addleft$[ebp]
  000b4	85 c0		 test	 eax, eax
  000b6	74 13		 je	 SHORT $LN15@Linsert
  000b8	8b 4d f4	 mov	 ecx, DWORD PTR __Trynode$[ebp]
  000bb	51		 push	 ecx
  000bc	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Left
  000c1	83 c4 04	 add	 esp, 4
  000c4	8b 10		 mov	 edx, DWORD PTR [eax]
  000c6	89 55 84	 mov	 DWORD PTR tv147[ebp], edx
  000c9	eb 11		 jmp	 SHORT $LN16@Linsert
$LN15@Linsert:
  000cb	8b 45 f4	 mov	 eax, DWORD PTR __Trynode$[ebp]
  000ce	50		 push	 eax
  000cf	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Right
  000d4	83 c4 04	 add	 esp, 4
  000d7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d9	89 4d 84	 mov	 DWORD PTR tv147[ebp], ecx
$LN16@Linsert:
  000dc	8b 55 84	 mov	 edx, DWORD PTR tv147[ebp]
  000df	89 55 f4	 mov	 DWORD PTR __Trynode$[ebp], edx

; 963  : 			}

  000e2	e9 4e ff ff ff	 jmp	 $LN12@Linsert
$LN11@Linsert:

; 964  : 
; 965  : 		if (this->_Multi)

  000e7	33 c0		 xor	 eax, eax
  000e9	74 37		 je	 SHORT $LN8@Linsert

; 966  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Node), true));

  000eb	c6 45 8b 01	 mov	 BYTE PTR $T227691[ebp], 1
  000ef	8d 45 8b	 lea	 eax, DWORD PTR $T227691[ebp]
  000f2	50		 push	 eax
  000f3	8b 4d 0c	 mov	 ecx, DWORD PTR __Node$[ebp]
  000f6	51		 push	 ecx
  000f7	8b 55 f0	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  000fa	52		 push	 edx
  000fb	0f b6 45 ef	 movzx	 eax, BYTE PTR __Addleft$[ebp]
  000ff	50		 push	 eax
  00100	8d 4d 8c	 lea	 ecx, DWORD PTR $T227692[ebp]
  00103	51		 push	 ecx
  00104	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00107	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Insert
  0010c	50		 push	 eax
  0010d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00110	e8 00 00 00 00	 call	 ??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >,bool>
  00115	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00118	e9 20 01 00 00	 jmp	 $LN13@Linsert

; 967  : 		else

  0011d	e9 1b 01 00 00	 jmp	 $LN13@Linsert
$LN8@Linsert:

; 968  : 			{	// insert only if unique
; 969  : 			iterator _Where = iterator(_Wherenode, this);

  00122	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00125	50		 push	 eax
  00126	8b 4d f0	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00129	51		 push	 ecx
  0012a	8d 4d e8	 lea	 ecx, DWORD PTR __Where$226252[ebp]
  0012d	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >

; 970  : 			if (!_Addleft)

  00132	0f b6 45 ef	 movzx	 eax, BYTE PTR __Addleft$[ebp]
  00136	85 c0		 test	 eax, eax
  00138	75 02		 jne	 SHORT $LN6@Linsert
  0013a	eb 55		 jmp	 SHORT $LN5@Linsert
$LN6@Linsert:

; 971  : 				;	// need to test if insert after is okay
; 972  : 			else if (_Where == begin())

  0013c	8d 45 90	 lea	 eax, DWORD PTR $T227693[ebp]
  0013f	50		 push	 eax
  00140	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00143	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::begin
  00148	50		 push	 eax
  00149	8d 4d e8	 lea	 ecx, DWORD PTR __Where$226252[ebp]
  0014c	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator==
  00151	0f b6 c8	 movzx	 ecx, al
  00154	85 c9		 test	 ecx, ecx
  00156	74 31		 je	 SHORT $LN4@Linsert

; 973  : 				return (_Pairib(_Insert(true, _Wherenode, _Node), true));

  00158	c6 45 97 01	 mov	 BYTE PTR $T227694[ebp], 1
  0015c	8d 45 97	 lea	 eax, DWORD PTR $T227694[ebp]
  0015f	50		 push	 eax
  00160	8b 4d 0c	 mov	 ecx, DWORD PTR __Node$[ebp]
  00163	51		 push	 ecx
  00164	8b 55 f0	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00167	52		 push	 edx
  00168	6a 01		 push	 1
  0016a	8d 45 98	 lea	 eax, DWORD PTR $T227695[ebp]
  0016d	50		 push	 eax
  0016e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00171	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Insert
  00176	50		 push	 eax
  00177	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0017a	e8 00 00 00 00	 call	 ??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >,bool>
  0017f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00182	e9 b6 00 00 00	 jmp	 $LN13@Linsert

; 974  : 			else

  00187	eb 08		 jmp	 SHORT $LN5@Linsert
$LN4@Linsert:

; 975  : 				--_Where;	// need to test if insert before is okay

  00189	8d 4d e8	 lea	 ecx, DWORD PTR __Where$226252[ebp]
  0018c	e8 00 00 00 00	 call	 ??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator--
$LN5@Linsert:

; 976  : 
; 977  : 			if (_DEBUG_LT_PRED(this->comp,

  00191	8b 45 f8	 mov	 eax, DWORD PTR __Val$[ebp]
  00194	50		 push	 eax
  00195	e8 00 00 00 00	 call	 ??$_Kfn@$$CBHPAX@?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHPAX@1@@Z ; std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0>::_Kfn<int const ,void *>
  0019a	83 c4 04	 add	 esp, 4
  0019d	50		 push	 eax
  0019e	8d 4d e8	 lea	 ecx, DWORD PTR __Where$226252[ebp]
  001a1	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >,std::_Iterator_base0>::_Mynode
  001a6	50		 push	 eax
  001a7	e8 00 00 00 00	 call	 ?_Key@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Key
  001ac	83 c4 04	 add	 esp, 4
  001af	50		 push	 eax
  001b0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001b3	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  001b8	0f b6 c8	 movzx	 ecx, al
  001bb	85 c9		 test	 ecx, ecx
  001bd	74 31		 je	 SHORT $LN2@Linsert

; 978  : 				this->_Key(_Where._Mynode()),
; 979  : 				this->_Kfn(_Val)))
; 980  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Node), true));

  001bf	c6 45 9f 01	 mov	 BYTE PTR $T227696[ebp], 1
  001c3	8d 45 9f	 lea	 eax, DWORD PTR $T227696[ebp]
  001c6	50		 push	 eax
  001c7	8b 4d 0c	 mov	 ecx, DWORD PTR __Node$[ebp]
  001ca	51		 push	 ecx
  001cb	8b 55 f0	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  001ce	52		 push	 edx
  001cf	0f b6 45 ef	 movzx	 eax, BYTE PTR __Addleft$[ebp]
  001d3	50		 push	 eax
  001d4	8d 4d a0	 lea	 ecx, DWORD PTR $T227697[ebp]
  001d7	51		 push	 ecx
  001d8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001db	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Insert
  001e0	50		 push	 eax
  001e1	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  001e4	e8 00 00 00 00	 call	 ??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >,bool>
  001e9	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  001ec	eb 4f		 jmp	 SHORT $LN13@Linsert

; 981  : 			else

  001ee	eb 4d		 jmp	 SHORT $LN13@Linsert
$LN2@Linsert:

; 982  : 				{	// duplicate, don't insert
; 983  : 				_Dest_val(this->_Alval,
; 984  : 					_STD addressof(this->_Myval(_Node)));

  001f0	8b 45 0c	 mov	 eax, DWORD PTR __Node$[ebp]
  001f3	50		 push	 eax
  001f4	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHPAX@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Myval
  001f9	83 c4 04	 add	 esp, 4
  001fc	50		 push	 eax
  001fd	e8 00 00 00 00	 call	 ??$addressof@U?$pair@$$CBHPAX@std@@@std@@YAPAU?$pair@$$CBHPAX@0@AAU10@@Z ; std::addressof<std::pair<int const ,void *> >
  00202	83 c4 04	 add	 esp, 4
  00205	50		 push	 eax
  00206	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00209	83 c1 0d	 add	 ecx, 13			; 0000000dH
  0020c	51		 push	 ecx
  0020d	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBHPAX@std@@@std@@U?$pair@$$CBHPAX@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHPAX@std@@@0@PAU?$pair@$$CBHPAX@0@@Z ; std::_Dest_val<std::allocator<std::pair<int const ,void *> >,std::pair<int const ,void *> >
  00212	83 c4 08	 add	 esp, 8

; 985  : 
; 986  : 				this->_Alnod.deallocate(_Node, 1);

  00215	6a 01		 push	 1
  00217	8b 45 0c	 mov	 eax, DWORD PTR __Node$[ebp]
  0021a	50		 push	 eax
  0021b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0021e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00221	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Node>::deallocate

; 987  : 
; 988  : 				return (_Pairib(_Where, false));

  00226	c6 45 a7 00	 mov	 BYTE PTR $T227698[ebp], 0
  0022a	8d 45 a7	 lea	 eax, DWORD PTR $T227698[ebp]
  0022d	50		 push	 eax
  0022e	8d 4d e8	 lea	 ecx, DWORD PTR __Where$226252[ebp]
  00231	51		 push	 ecx
  00232	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00235	e8 00 00 00 00	 call	 ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > > &,bool>
  0023a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN13@Linsert:

; 989  : 				}
; 990  : 			}
; 991  : 		}

  0023d	5f		 pop	 edi
  0023e	5e		 pop	 esi
  0023f	5b		 pop	 ebx
  00240	8b e5		 mov	 esp, ebp
  00242	5d		 pop	 ebp
  00243	c2 0c 00	 ret	 12			; 0000000cH
?_Linsert@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@_N@Z ENDP ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Linsert
_TEXT	ENDS
PUBLIC	??$_Destroy@U?$pair@$$CBHPAX@std@@@std@@YAXPAU?$pair@$$CBHPAX@0@@Z ; std::_Destroy<std::pair<int const ,void *> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@U?$pair@$$CBHPAX@std@@@std@@QAEXPAU?$pair@$$CBHPAX@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U?$pair@$$CBHPAX@std@@@std@@QAEXPAU?$pair@$$CBHPAX@2@@Z PROC ; std::allocator<std::pair<int const ,void *> >::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 213  : 		_Destroy(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Destroy@U?$pair@$$CBHPAX@std@@@std@@YAXPAU?$pair@$$CBHPAX@0@@Z ; std::_Destroy<std::pair<int const ,void *> >
  00015	83 c4 04	 add	 esp, 4

; 214  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?destroy@?$allocator@U?$pair@$$CBHPAX@std@@@std@@QAEXPAU?$pair@$$CBHPAX@2@@Z ENDP ; std::allocator<std::pair<int const ,void *> >::destroy
_TEXT	ENDS
PUBLIC	??$_Construct@UEVENT_ID_ITEM_LIST@@ABU1@@std@@YAXPAUEVENT_ID_ITEM_LIST@@ABU1@@Z ; std::_Construct<EVENT_ID_ITEM_LIST,EVENT_ID_ITEM_LIST const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ?construct@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAEXPAUEVENT_ID_ITEM_LIST@@ABU3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAEXPAUEVENT_ID_ITEM_LIST@@ABU3@@Z PROC ; std::allocator<EVENT_ID_ITEM_LIST>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 197  : 		_Construct(_Ptr, _Val);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ??$_Construct@UEVENT_ID_ITEM_LIST@@ABU1@@std@@YAXPAUEVENT_ID_ITEM_LIST@@ABU1@@Z ; std::_Construct<EVENT_ID_ITEM_LIST,EVENT_ID_ITEM_LIST const &>
  00019	83 c4 08	 add	 esp, 8

; 198  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
?construct@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAEXPAUEVENT_ID_ITEM_LIST@@ABU3@@Z ENDP ; std::allocator<EVENT_ID_ITEM_LIST>::construct
_TEXT	ENDS
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::max_size
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
; File d:\microsoft visual studio 10.0\vc\include\xtree
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@1@Z
_TEXT	SEGMENT
__Pnode$226299 = -8					; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Newnode$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@1@Z PROC ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Insert, COMDAT
; _this$ = ecx

; 1631 : 		{	// add node with value next to _Wherenode, to left if _Addleft

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1632 : 		if (max_size() - 1 <= this->_Mysize)

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?max_size@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::max_size
  00014	83 e8 01	 sub	 eax, 1
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  0001d	77 40		 ja	 SHORT $LN17@Insert

; 1633 : 			{	// tree would get too big, fail
; 1634 : 			_Dest_val(this->_Alval,
; 1635 : 				_STD addressof(this->_Myval(_Newnode)));

  0001f	8b 45 14	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHPAX@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Myval
  00028	83 c4 04	 add	 esp, 4
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$addressof@U?$pair@$$CBHPAX@std@@@std@@YAPAU?$pair@$$CBHPAX@0@AAU10@@Z ; std::addressof<std::pair<int const ,void *> >
  00031	83 c4 04	 add	 esp, 4
  00034	50		 push	 eax
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	83 c1 0d	 add	 ecx, 13			; 0000000dH
  0003b	51		 push	 ecx
  0003c	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U?$pair@$$CBHPAX@std@@@std@@U?$pair@$$CBHPAX@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHPAX@std@@@0@PAU?$pair@$$CBHPAX@0@@Z ; std::_Dest_val<std::allocator<std::pair<int const ,void *> >,std::pair<int const ,void *> >
  00041	83 c4 08	 add	 esp, 8

; 1636 : 
; 1637 : 			this->_Alnod.deallocate(_Newnode, 1);

  00044	6a 01		 push	 1
  00046	8b 45 14	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00049	50		 push	 eax
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00050	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Node>::deallocate

; 1638 : 
; 1639 : 			_Xlength_error("map/set<T> too long");

  00055	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
  0005a	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN17@Insert:

; 1640 : 			}
; 1641 : 		++this->_Mysize;

  0005f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00062	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00065	83 c1 01	 add	 ecx, 1
  00068	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0006b	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1642 : 		_Newnode->_Parent = _Wherenode;

  0006e	8b 45 14	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00071	8b 4d 10	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00074	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1643 : 
; 1644 : 		if (_Wherenode == this->_Myhead)

  00077	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007a	8b 4d 10	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0007d	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00080	75 29		 jne	 SHORT $LN16@Insert

; 1645 : 			{	// first node in tree, just set head values
; 1646 : 			_Root() = _Newnode;

  00082	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00085	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Root
  0008a	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  0008d	89 08		 mov	 DWORD PTR [eax], ecx

; 1647 : 			_Lmost() = _Newnode;

  0008f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00092	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Lmost
  00097	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  0009a	89 08		 mov	 DWORD PTR [eax], ecx

; 1648 : 			_Rmost() = _Newnode;

  0009c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009f	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Rmost
  000a4	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  000a7	89 08		 mov	 DWORD PTR [eax], ecx
  000a9	eb 64		 jmp	 SHORT $LN15@Insert
$LN16@Insert:

; 1649 : 			}
; 1650 : 		else if (_Addleft)

  000ab	0f b6 45 0c	 movzx	 eax, BYTE PTR __Addleft$[ebp]
  000af	85 c0		 test	 eax, eax
  000b1	74 2f		 je	 SHORT $LN14@Insert

; 1651 : 			{	// add to left of _Wherenode
; 1652 : 			this->_Left(_Wherenode) = _Newnode;

  000b3	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000b6	50		 push	 eax
  000b7	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Left
  000bc	83 c4 04	 add	 esp, 4
  000bf	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  000c2	89 08		 mov	 DWORD PTR [eax], ecx

; 1653 : 			if (_Wherenode == _Lmost())

  000c4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c7	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Lmost
  000cc	8b 4d 10	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  000cf	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000d1	75 0d		 jne	 SHORT $LN13@Insert

; 1654 : 				_Lmost() = _Newnode;

  000d3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d6	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Lmost
  000db	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  000de	89 08		 mov	 DWORD PTR [eax], ecx
$LN13@Insert:

; 1655 : 			}
; 1656 : 		else

  000e0	eb 2d		 jmp	 SHORT $LN15@Insert
$LN14@Insert:

; 1657 : 			{	// add to right of _Wherenode
; 1658 : 			this->_Right(_Wherenode) = _Newnode;

  000e2	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Right
  000eb	83 c4 04	 add	 esp, 4
  000ee	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  000f1	89 08		 mov	 DWORD PTR [eax], ecx

; 1659 : 			if (_Wherenode == _Rmost())

  000f3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f6	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Rmost
  000fb	8b 4d 10	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  000fe	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00100	75 0d		 jne	 SHORT $LN15@Insert

; 1660 : 				_Rmost() = _Newnode;

  00102	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00105	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Rmost
  0010a	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  0010d	89 08		 mov	 DWORD PTR [eax], ecx
$LN15@Insert:

; 1661 : 			}
; 1662 : 
; 1663 : 		for (_Nodeptr _Pnode = _Newnode;

  0010f	8b 45 14	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00112	89 45 f8	 mov	 DWORD PTR __Pnode$226299[ebp], eax
$LN10@Insert:

; 1664 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  00115	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$226299[ebp]
  00118	50		 push	 eax
  00119	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  0011e	83 c4 04	 add	 esp, 4
  00121	8b 08		 mov	 ecx, DWORD PTR [eax]
  00123	51		 push	 ecx
  00124	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
  00129	83 c4 04	 add	 esp, 4
  0012c	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0012f	85 d2		 test	 edx, edx
  00131	0f 85 ce 02 00
	00		 jne	 $LN9@Insert

; 1665 : 			if (this->_Parent(_Pnode)
; 1666 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))

  00137	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$226299[ebp]
  0013a	50		 push	 eax
  0013b	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  00140	83 c4 04	 add	 esp, 4
  00143	8b f0		 mov	 esi, eax
  00145	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$226299[ebp]
  00148	51		 push	 ecx
  00149	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  0014e	83 c4 04	 add	 esp, 4
  00151	8b 10		 mov	 edx, DWORD PTR [eax]
  00153	52		 push	 edx
  00154	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  00159	83 c4 04	 add	 esp, 4
  0015c	8b 00		 mov	 eax, DWORD PTR [eax]
  0015e	50		 push	 eax
  0015f	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Left
  00164	83 c4 04	 add	 esp, 4
  00167	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00169	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0016b	0f 85 4a 01 00
	00		 jne	 $LN8@Insert

; 1667 : 				{	// fixup red-red in left subtree
; 1668 : 				_Wherenode =
; 1669 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));

  00171	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$226299[ebp]
  00174	50		 push	 eax
  00175	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  0017a	83 c4 04	 add	 esp, 4
  0017d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0017f	51		 push	 ecx
  00180	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  00185	83 c4 04	 add	 esp, 4
  00188	8b 10		 mov	 edx, DWORD PTR [eax]
  0018a	52		 push	 edx
  0018b	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Right
  00190	83 c4 04	 add	 esp, 4
  00193	8b 00		 mov	 eax, DWORD PTR [eax]
  00195	89 45 10	 mov	 DWORD PTR __Wherenode$[ebp], eax

; 1670 : 				if (this->_Color(_Wherenode) == this->_Red)

  00198	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0019b	50		 push	 eax
  0019c	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
  001a1	83 c4 04	 add	 esp, 4
  001a4	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  001a7	85 c9		 test	 ecx, ecx
  001a9	75 6f		 jne	 SHORT $LN7@Insert

; 1671 : 					{	// parent has two red children, blacken both
; 1672 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  001ab	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$226299[ebp]
  001ae	50		 push	 eax
  001af	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  001b4	83 c4 04	 add	 esp, 4
  001b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b9	51		 push	 ecx
  001ba	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
  001bf	83 c4 04	 add	 esp, 4
  001c2	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1673 : 					this->_Color(_Wherenode) = this->_Black;

  001c5	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  001c8	50		 push	 eax
  001c9	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
  001ce	83 c4 04	 add	 esp, 4
  001d1	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1674 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1675 : 						= this->_Red;

  001d4	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$226299[ebp]
  001d7	50		 push	 eax
  001d8	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  001dd	83 c4 04	 add	 esp, 4
  001e0	8b 08		 mov	 ecx, DWORD PTR [eax]
  001e2	51		 push	 ecx
  001e3	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  001e8	83 c4 04	 add	 esp, 4
  001eb	8b 10		 mov	 edx, DWORD PTR [eax]
  001ed	52		 push	 edx
  001ee	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
  001f3	83 c4 04	 add	 esp, 4
  001f6	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1676 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  001f9	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$226299[ebp]
  001fc	50		 push	 eax
  001fd	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  00202	83 c4 04	 add	 esp, 4
  00205	8b 08		 mov	 ecx, DWORD PTR [eax]
  00207	51		 push	 ecx
  00208	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  0020d	83 c4 04	 add	 esp, 4
  00210	8b 10		 mov	 edx, DWORD PTR [eax]
  00212	89 55 f8	 mov	 DWORD PTR __Pnode$226299[ebp], edx

; 1677 : 					}
; 1678 : 				else

  00215	e9 9c 00 00 00	 jmp	 $LN6@Insert
$LN7@Insert:

; 1679 : 					{	// parent has red and black children
; 1680 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))

  0021a	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$226299[ebp]
  0021d	50		 push	 eax
  0021e	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  00223	83 c4 04	 add	 esp, 4
  00226	8b 08		 mov	 ecx, DWORD PTR [eax]
  00228	51		 push	 ecx
  00229	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Right
  0022e	83 c4 04	 add	 esp, 4
  00231	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$226299[ebp]
  00234	3b 10		 cmp	 edx, DWORD PTR [eax]
  00236	75 1d		 jne	 SHORT $LN5@Insert

; 1681 : 						{	// rotate right child to left
; 1682 : 						_Pnode = this->_Parent(_Pnode);

  00238	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$226299[ebp]
  0023b	50		 push	 eax
  0023c	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  00241	83 c4 04	 add	 esp, 4
  00244	8b 08		 mov	 ecx, DWORD PTR [eax]
  00246	89 4d f8	 mov	 DWORD PTR __Pnode$226299[ebp], ecx

; 1683 : 						_Lrotate(_Pnode);

  00249	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$226299[ebp]
  0024c	50		 push	 eax
  0024d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00250	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Lrotate
$LN5@Insert:

; 1684 : 						}
; 1685 : 					this->_Color(this->_Parent(_Pnode)) =
; 1686 : 						this->_Black;	// propagate red up

  00255	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$226299[ebp]
  00258	50		 push	 eax
  00259	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  0025e	83 c4 04	 add	 esp, 4
  00261	8b 08		 mov	 ecx, DWORD PTR [eax]
  00263	51		 push	 ecx
  00264	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
  00269	83 c4 04	 add	 esp, 4
  0026c	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1687 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1688 : 						this->_Red;

  0026f	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$226299[ebp]
  00272	50		 push	 eax
  00273	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  00278	83 c4 04	 add	 esp, 4
  0027b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0027d	51		 push	 ecx
  0027e	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  00283	83 c4 04	 add	 esp, 4
  00286	8b 10		 mov	 edx, DWORD PTR [eax]
  00288	52		 push	 edx
  00289	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
  0028e	83 c4 04	 add	 esp, 4
  00291	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1689 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

  00294	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$226299[ebp]
  00297	50		 push	 eax
  00298	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  0029d	83 c4 04	 add	 esp, 4
  002a0	8b 08		 mov	 ecx, DWORD PTR [eax]
  002a2	51		 push	 ecx
  002a3	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  002a8	83 c4 04	 add	 esp, 4
  002ab	8b 10		 mov	 edx, DWORD PTR [eax]
  002ad	52		 push	 edx
  002ae	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002b1	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Rrotate
$LN6@Insert:

; 1690 : 					}
; 1691 : 				}
; 1692 : 			else

  002b6	e9 45 01 00 00	 jmp	 $LN4@Insert
$LN8@Insert:

; 1693 : 				{	// fixup red-red in right subtree
; 1694 : 				_Wherenode =
; 1695 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));

  002bb	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$226299[ebp]
  002be	50		 push	 eax
  002bf	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  002c4	83 c4 04	 add	 esp, 4
  002c7	8b 08		 mov	 ecx, DWORD PTR [eax]
  002c9	51		 push	 ecx
  002ca	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  002cf	83 c4 04	 add	 esp, 4
  002d2	8b 10		 mov	 edx, DWORD PTR [eax]
  002d4	52		 push	 edx
  002d5	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Left
  002da	83 c4 04	 add	 esp, 4
  002dd	8b 00		 mov	 eax, DWORD PTR [eax]
  002df	89 45 10	 mov	 DWORD PTR __Wherenode$[ebp], eax

; 1696 : 				if (this->_Color(_Wherenode) == this->_Red)

  002e2	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  002e5	50		 push	 eax
  002e6	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
  002eb	83 c4 04	 add	 esp, 4
  002ee	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  002f1	85 c9		 test	 ecx, ecx
  002f3	75 6f		 jne	 SHORT $LN3@Insert

; 1697 : 					{	// parent has two red children, blacken both
; 1698 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  002f5	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$226299[ebp]
  002f8	50		 push	 eax
  002f9	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  002fe	83 c4 04	 add	 esp, 4
  00301	8b 08		 mov	 ecx, DWORD PTR [eax]
  00303	51		 push	 ecx
  00304	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
  00309	83 c4 04	 add	 esp, 4
  0030c	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1699 : 					this->_Color(_Wherenode) = this->_Black;

  0030f	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00312	50		 push	 eax
  00313	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
  00318	83 c4 04	 add	 esp, 4
  0031b	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1700 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1701 : 						this->_Red;

  0031e	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$226299[ebp]
  00321	50		 push	 eax
  00322	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  00327	83 c4 04	 add	 esp, 4
  0032a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0032c	51		 push	 ecx
  0032d	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  00332	83 c4 04	 add	 esp, 4
  00335	8b 10		 mov	 edx, DWORD PTR [eax]
  00337	52		 push	 edx
  00338	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
  0033d	83 c4 04	 add	 esp, 4
  00340	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1702 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  00343	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$226299[ebp]
  00346	50		 push	 eax
  00347	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  0034c	83 c4 04	 add	 esp, 4
  0034f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00351	51		 push	 ecx
  00352	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  00357	83 c4 04	 add	 esp, 4
  0035a	8b 10		 mov	 edx, DWORD PTR [eax]
  0035c	89 55 f8	 mov	 DWORD PTR __Pnode$226299[ebp], edx

; 1703 : 					}
; 1704 : 				else

  0035f	e9 9c 00 00 00	 jmp	 $LN4@Insert
$LN3@Insert:

; 1705 : 					{	// parent has red and black children
; 1706 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))

  00364	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$226299[ebp]
  00367	50		 push	 eax
  00368	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  0036d	83 c4 04	 add	 esp, 4
  00370	8b 08		 mov	 ecx, DWORD PTR [eax]
  00372	51		 push	 ecx
  00373	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Left
  00378	83 c4 04	 add	 esp, 4
  0037b	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$226299[ebp]
  0037e	3b 10		 cmp	 edx, DWORD PTR [eax]
  00380	75 1d		 jne	 SHORT $LN1@Insert

; 1707 : 						{	// rotate left child to right
; 1708 : 						_Pnode = this->_Parent(_Pnode);

  00382	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$226299[ebp]
  00385	50		 push	 eax
  00386	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  0038b	83 c4 04	 add	 esp, 4
  0038e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00390	89 4d f8	 mov	 DWORD PTR __Pnode$226299[ebp], ecx

; 1709 : 						_Rrotate(_Pnode);

  00393	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$226299[ebp]
  00396	50		 push	 eax
  00397	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0039a	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Rrotate
$LN1@Insert:

; 1710 : 						}
; 1711 : 					this->_Color(this->_Parent(_Pnode)) =
; 1712 : 						this->_Black;	// propagate red up

  0039f	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$226299[ebp]
  003a2	50		 push	 eax
  003a3	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  003a8	83 c4 04	 add	 esp, 4
  003ab	8b 08		 mov	 ecx, DWORD PTR [eax]
  003ad	51		 push	 ecx
  003ae	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
  003b3	83 c4 04	 add	 esp, 4
  003b6	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1713 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1714 : 						this->_Red;

  003b9	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$226299[ebp]
  003bc	50		 push	 eax
  003bd	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  003c2	83 c4 04	 add	 esp, 4
  003c5	8b 08		 mov	 ecx, DWORD PTR [eax]
  003c7	51		 push	 ecx
  003c8	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  003cd	83 c4 04	 add	 esp, 4
  003d0	8b 10		 mov	 edx, DWORD PTR [eax]
  003d2	52		 push	 edx
  003d3	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
  003d8	83 c4 04	 add	 esp, 4
  003db	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1715 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));

  003de	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$226299[ebp]
  003e1	50		 push	 eax
  003e2	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  003e7	83 c4 04	 add	 esp, 4
  003ea	8b 08		 mov	 ecx, DWORD PTR [eax]
  003ec	51		 push	 ecx
  003ed	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  003f2	83 c4 04	 add	 esp, 4
  003f5	8b 10		 mov	 edx, DWORD PTR [eax]
  003f7	52		 push	 edx
  003f8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003fb	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Lrotate
$LN4@Insert:

; 1716 : 					}
; 1717 : 				}

  00400	e9 10 fd ff ff	 jmp	 $LN10@Insert
$LN9@Insert:

; 1718 : 
; 1719 : 		this->_Color(_Root()) = this->_Black;	// root is always black

  00405	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00408	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Root
  0040d	8b 00		 mov	 eax, DWORD PTR [eax]
  0040f	50		 push	 eax
  00410	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
  00415	83 c4 04	 add	 esp, 4
  00418	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1720 : 		return (iterator(_Newnode, this));

  0041b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0041e	50		 push	 eax
  0041f	8b 4d 14	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00422	51		 push	 ecx
  00423	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00426	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >
  0042b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN19@Insert:

; 1721 : 		}

  0042e	5f		 pop	 edi
  0042f	5e		 pop	 esi
  00430	5b		 pop	 ebx
  00431	8b e5		 mov	 esp, ebp
  00433	5d		 pop	 ebp
  00434	c2 10 00	 ret	 16			; 00000010H
?_Insert@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@1@Z ENDP ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Insert
_TEXT	ENDS
PUBLIC	??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator--
; Function compile flags: /Odtp /ZI
;	COMDAT ??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator--, COMDAT
; _this$ = ecx

; 418  : 		{	// predecrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 419  : 		--(*(_Mybase *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator--

; 420  : 		return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 421  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator--
_TEXT	ENDS
PUBLIC	??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >,bool>
PUBLIC	??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > > &>
PUBLIC	??$move@AA_N@std@@YA$$QA_NAA_N@Z		; std::move<bool &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >,bool>, COMDAT
; _this$ = ecx

; 227  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$move@AA_N@std@@YA$$QA_NAA_N@Z ; std::move<bool &>
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > > &>
  00022	83 c4 04	 add	 esp, 4
  00025	50		 push	 eax
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >,bool>

; 228  : 		}

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >,bool>
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U?$pair@$$CBHPAX@std@@@std@@QBEIXZ ; std::allocator<std::pair<int const ,void *> >::max_size
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::max_size, COMDAT
; _this$ = ecx

; 873  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 874  : 		return (this->_Alval.max_size());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 0d	 add	 ecx, 13			; 0000000dH
  00012	e8 00 00 00 00	 call	 ?max_size@?$allocator@U?$pair@$$CBHPAX@std@@@std@@QBEIXZ ; std::allocator<std::pair<int const ,void *> >::max_size

; 875  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::max_size
_TEXT	ENDS
PUBLIC	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >,std::_Iterator_base0>::operator--
; Function compile flags: /Odtp /ZI
;	COMDAT ??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator--, COMDAT
; _this$ = ecx

; 277  : 		{	// predecrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 278  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 279  : 		if (this->_Getcont() == 0
; 280  : 			|| this->_Ptr == 0)
; 281  : 			{	// report error
; 282  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 283  : 			_SCL_SECURE_OUT_OF_RANGE;
; 284  : 			}
; 285  : 
; 286  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 287  : 		--(*(_Mybase *)this);
; 288  : 		if (_Ptrsav == this->_Ptr)
; 289  : 			{	// report error
; 290  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 291  : 			_SCL_SECURE_OUT_OF_RANGE;
; 292  : 			}
; 293  : 
; 294  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 295  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 296  : 
; 297  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 298  : 		--(*(_Mybase *)this);
; 299  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 300  : 
; 301  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 302  : 		--(*(_Mybase *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >,std::_Iterator_base0>::operator--

; 303  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 304  : 
; 305  : 		return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 306  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >::operator--
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >,bool>, COMDAT
; _this$ = ecx

; 145  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > > &>
  00015	83 c4 04	 add	 esp, 4
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	89 0a		 mov	 DWORD PTR [edx], ecx
  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??$move@AA_N@std@@YA$$QA_NAA_N@Z ; std::move<bool &>
  00028	83 c4 04	 add	 esp, 4
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	8a 10		 mov	 dl, BYTE PTR [eax]
  00030	88 51 04	 mov	 BYTE PTR [ecx+4], dl

; 146  : 		}

  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >,bool>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBHPAX@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -76						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@U?$pair@$$CBHPAX@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<int const ,void *> >::max_size, COMDAT
; _this$ = ecx

; 217  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  0000c	c7 45 f8 ff ff
	ff 1f		 mov	 DWORD PTR __Count$[ebp], 536870911 ; 1fffffffH

; 219  : 		return (0 < _Count ? _Count : 1);

  00013	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00017	76 08		 jbe	 SHORT $LN3@max_size@3
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0001c	89 45 b4	 mov	 DWORD PTR tv65[ebp], eax
  0001f	eb 07		 jmp	 SHORT $LN4@max_size@3
$LN3@max_size@3:
  00021	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$LN4@max_size@3:
  00028	8b 45 b4	 mov	 eax, DWORD PTR tv65[ebp]

; 220  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?max_size@?$allocator@U?$pair@$$CBHPAX@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<int const ,void *> >::max_size
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
__Pnode$226368 = -8					; size = 4
_this$ = -4						; size = 4
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = ecx

; 83   : 		{	// predecrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 84   : 		if (_Mytree::_Isnil(_Ptr))

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Isnil
  00017	83 c4 04	 add	 esp, 4
  0001a	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0001d	85 d2		 test	 edx, edx
  0001f	74 1a		 je	 SHORT $LN8@operator@4

; 85   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b 08		 mov	 ecx, DWORD PTR [eax]
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Right
  0002c	83 c4 04	 add	 esp, 4
  0002f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 02		 mov	 DWORD PTR [edx], eax
  00036	e9 a4 00 00 00	 jmp	 $LN7@operator@4
$LN8@operator@4:

; 86   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00040	51		 push	 ecx
  00041	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Left
  00046	83 c4 04	 add	 esp, 4
  00049	8b 10		 mov	 edx, DWORD PTR [eax]
  0004b	52		 push	 edx
  0004c	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Isnil
  00051	83 c4 04	 add	 esp, 4
  00054	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00057	85 c0		 test	 eax, eax
  00059	75 20		 jne	 SHORT $LN4@operator@4

; 87   : 			_Ptr = _Mytree::_Max(
; 88   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree

  0005b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00060	51		 push	 ecx
  00061	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Left
  00066	83 c4 04	 add	 esp, 4
  00069	8b 10		 mov	 edx, DWORD PTR [eax]
  0006b	52		 push	 edx
  0006c	e8 00 00 00 00	 call	 ?_Max@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Max
  00071	83 c4 04	 add	 esp, 4
  00074	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	89 01		 mov	 DWORD PTR [ecx], eax

; 89   : 		else

  00079	eb 64		 jmp	 SHORT $LN7@operator@4
$LN4@operator@4:

; 90   : 			{	// climb looking for left subtree
; 91   : 			_Nodeptr _Pnode;
; 92   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 93   : 				&& _Ptr == _Mytree::_Left(_Pnode))

  0007b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00080	51		 push	 ecx
  00081	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  00086	83 c4 04	 add	 esp, 4
  00089	8b 10		 mov	 edx, DWORD PTR [eax]
  0008b	89 55 f8	 mov	 DWORD PTR __Pnode$226368[ebp], edx
  0008e	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$226368[ebp]
  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Isnil
  00097	83 c4 04	 add	 esp, 4
  0009a	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0009d	85 c9		 test	 ecx, ecx
  0009f	75 1f		 jne	 SHORT $LN3@operator@4
  000a1	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$226368[ebp]
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Left
  000aa	83 c4 04	 add	 esp, 4
  000ad	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b0	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b2	3b 10		 cmp	 edx, DWORD PTR [eax]
  000b4	75 0a		 jne	 SHORT $LN3@operator@4

; 94   : 				_Ptr = _Pnode;	// ==> parent while left subtree

  000b6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b9	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$226368[ebp]
  000bc	89 08		 mov	 DWORD PTR [eax], ecx
  000be	eb bb		 jmp	 SHORT $LN4@operator@4
$LN3@operator@4:

; 95   : 			if (_Mytree::_Isnil(_Ptr))

  000c0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c5	51		 push	 ecx
  000c6	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Isnil
  000cb	83 c4 04	 add	 esp, 4
  000ce	0f be 10	 movsx	 edx, BYTE PTR [eax]
  000d1	85 d2		 test	 edx, edx
  000d3	74 02		 je	 SHORT $LN2@operator@4

; 96   : 				;	// begin() shouldn't be decremented, don't move
; 97   : 			else

  000d5	eb 08		 jmp	 SHORT $LN7@operator@4
$LN2@operator@4:

; 98   : 				_Ptr = _Pnode;	// ==> parent if not head

  000d7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000da	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$226368[ebp]
  000dd	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@operator@4:

; 99   : 			}
; 100  : 		return (*this);

  000df	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 101  : 		}

  000e2	5f		 pop	 edi
  000e3	5e		 pop	 esi
  000e4	5b		 pop	 ebx
  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c3		 ret	 0
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >,std::_Iterator_base0>::operator--
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@AAH@std@@YAAAHAAH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAH@std@@YAAAHAAH@Z PROC			; std::forward<int &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAH@std@@YAAAHAAH@Z ENDP			; std::forward<int &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@AAPAX@std@@YAAAPAXAAPAX@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAX@std@@YAAAPAXAAPAX@Z PROC		; std::forward<void * &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAPAX@std@@YAAAPAXAAPAX@Z ENDP		; std::forward<void * &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$?0AAHAAPAX@?$_Pair_base@HPAX@std@@QAE@AAHAAPAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAHAAPAX@?$_Pair_base@HPAX@std@@QAE@AAHAAPAX@Z PROC ; std::_Pair_base<int,void *>::_Pair_base<int,void *><int &,void * &>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>
  00015	83 c4 04	 add	 esp, 4
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 10		 mov	 edx, DWORD PTR [eax]
  0001d	89 11		 mov	 DWORD PTR [ecx], edx
  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??$forward@AAPAX@std@@YAAAPAXAAPAX@Z ; std::forward<void * &>
  00028	83 c4 04	 add	 esp, 4
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	8b 10		 mov	 edx, DWORD PTR [eax]
  00030	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 164  : 		}

  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
??$?0AAHAAPAX@?$_Pair_base@HPAX@std@@QAE@AAHAAPAX@Z ENDP ; std::_Pair_base<int,void *>::_Pair_base<int,void *><int &,void * &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@U?$pair@HPAX@std@@@std@@YA$$QAU?$pair@HPAX@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$pair@HPAX@std@@@std@@YA$$QAU?$pair@HPAX@0@AAU10@@Z PROC ; std::forward<std::pair<int,void *> >, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@U?$pair@HPAX@std@@@std@@YA$$QAU?$pair@HPAX@0@AAU10@@Z ENDP ; std::forward<std::pair<int,void *> >
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@U?$pair@$$CBHPAX@std@@@std@@U?$pair@$$CBHPAX@2@U?$pair@HPAX@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHPAX@std@@@0@PAU?$pair@$$CBHPAX@0@$$QAU?$pair@HPAX@0@@Z ; std::_Cons_val<std::allocator<std::pair<int const ,void *> >,std::pair<int const ,void *>,std::pair<int,void *> >
PUBLIC	?_Buynode@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Buynode
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xtree
xdata$x	SEGMENT
__catchsym$??$_Buynode@U?$pair@HPAX@std@@@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@$$QAU?$pair@HPAX@1@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Buynode@U?$pair@HPAX@std@@@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@$$QAU?$pair@HPAX@1@@Z$0
__unwindtable$??$_Buynode@U?$pair@HPAX@std@@@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@$$QAU?$pair@HPAX@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Buynode@U?$pair@HPAX@std@@@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@$$QAU?$pair@HPAX@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Buynode@U?$pair@HPAX@std@@@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@$$QAU?$pair@HPAX@1@@Z$2
__ehfuncinfo$??$_Buynode@U?$pair@HPAX@std@@@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@$$QAU?$pair@HPAX@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Buynode@U?$pair@HPAX@std@@@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@$$QAU?$pair@HPAX@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Buynode@U?$pair@HPAX@std@@@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@$$QAU?$pair@HPAX@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Buynode@U?$pair@HPAX@std@@@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@$$QAU?$pair@HPAX@1@@Z
_TEXT	SEGMENT
tv93 = -100						; size = 4
tv92 = -96						; size = 4
tv91 = -92						; size = 4
__Wherenode$ = -24					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Val$ = 8						; size = 4
??$_Buynode@U?$pair@HPAX@std@@@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@$$QAU?$pair@HPAX@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Buynode<std::pair<int,void *> >, COMDAT
; _this$ = ecx

; 586  : 		_Nodeptr _Buynode(_Valty&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Buynode@U?$pair@HPAX@std@@@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@$$QAU?$pair@HPAX@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 54	 sub	 esp, 84			; 00000054H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 587  : 		{	// allocate a node with defaults
; 588  : 		_Nodeptr _Wherenode = _Buynode();

  0002f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?_Buynode@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Buynode
  00037	89 45 e8	 mov	 DWORD PTR __Wherenode$[ebp], eax

; 589  : 
; 590  : 		_TRY_BEGIN

  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 591  : 		_Cons_val(this->_Alval, _STD addressof(this->_Myval(_Wherenode)),
; 592  : 			_STD forward<_Valty>(_Val));

  00041	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 ??$forward@U?$pair@HPAX@std@@@std@@YA$$QAU?$pair@HPAX@0@AAU10@@Z ; std::forward<std::pair<int,void *> >
  0004a	83 c4 04	 add	 esp, 4
  0004d	89 45 a4	 mov	 DWORD PTR tv91[ebp], eax
  00050	8b 4d e8	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00053	51		 push	 ecx
  00054	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBHPAX@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Myval
  00059	83 c4 04	 add	 esp, 4
  0005c	89 45 a0	 mov	 DWORD PTR tv92[ebp], eax
  0005f	8b 55 a0	 mov	 edx, DWORD PTR tv92[ebp]
  00062	52		 push	 edx
  00063	e8 00 00 00 00	 call	 ??$addressof@U?$pair@$$CBHPAX@std@@@std@@YAPAU?$pair@$$CBHPAX@0@AAU10@@Z ; std::addressof<std::pair<int const ,void *> >
  00068	83 c4 04	 add	 esp, 4
  0006b	89 45 9c	 mov	 DWORD PTR tv93[ebp], eax
  0006e	8b 45 a4	 mov	 eax, DWORD PTR tv91[ebp]
  00071	50		 push	 eax
  00072	8b 4d 9c	 mov	 ecx, DWORD PTR tv93[ebp]
  00075	51		 push	 ecx
  00076	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00079	83 c2 0d	 add	 edx, 13			; 0000000dH
  0007c	52		 push	 edx
  0007d	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@U?$pair@$$CBHPAX@std@@@std@@U?$pair@$$CBHPAX@2@U?$pair@HPAX@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHPAX@std@@@0@PAU?$pair@$$CBHPAX@0@$$QAU?$pair@HPAX@0@@Z ; std::_Cons_val<std::allocator<std::pair<int const ,void *> >,std::pair<int const ,void *>,std::pair<int,void *> >
  00082	83 c4 0c	 add	 esp, 12			; 0000000cH
  00085	eb 27		 jmp	 SHORT $LN4@Buynode
__catch$??$_Buynode@U?$pair@HPAX@std@@@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@$$QAU?$pair@HPAX@1@@Z$0:

; 593  : 		_CATCH_ALL
; 594  : 		this->_Alnod.deallocate(_Wherenode, 1);

  00087	6a 01		 push	 1
  00089	8b 45 e8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0008c	50		 push	 eax
  0008d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00090	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00093	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Node>::deallocate

; 595  : 		_RERAISE;

  00098	6a 00		 push	 0
  0009a	6a 00		 push	 0
  0009c	e8 00 00 00 00	 call	 __CxxThrowException@8

; 596  : 		_CATCH_END

  000a1	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000a8	b8 00 00 00 00	 mov	 eax, __tryend$??$_Buynode@U?$pair@HPAX@std@@@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@$$QAU?$pair@HPAX@1@@Z$1
  000ad	c3		 ret	 0
$LN4@Buynode:
  000ae	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Buynode@U?$pair@HPAX@std@@@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@$$QAU?$pair@HPAX@1@@Z$1:

; 597  : 
; 598  : 		return (_Wherenode);

  000b5	8b 45 e8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
$LN3@Buynode:

; 599  : 		}

  000b8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000bb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c2	59		 pop	 ecx
  000c3	5f		 pop	 edi
  000c4	5e		 pop	 esi
  000c5	5b		 pop	 ebx
  000c6	8b e5		 mov	 esp, ebp
  000c8	5d		 pop	 ebp
  000c9	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Buynode@U?$pair@HPAX@std@@@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@$$QAU?$pair@HPAX@1@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a 98	 mov	 ecx, DWORD PTR [edx-104]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Buynode@U?$pair@HPAX@std@@@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@$$QAU?$pair@HPAX@1@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Buynode@U?$pair@HPAX@std@@@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@1@$$QAU?$pair@HPAX@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Buynode<std::pair<int,void *> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@AAUEVENT_ID_TIME@@@std@@YAAAUEVENT_ID_TIME@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUEVENT_ID_TIME@@@std@@YAAAUEVENT_ID_TIME@@AAU1@@Z PROC ; std::forward<EVENT_ID_TIME &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAUEVENT_ID_TIME@@@std@@YAAAUEVENT_ID_TIME@@AAU1@@Z ENDP ; std::forward<EVENT_ID_TIME &>
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??2@YAPAXIPAX@Z					; operator new
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$construct@AAUEVENT_ID_TIME@@@?$allocator@UEVENT_ID_TIME@@@std@@QAEXPAUEVENT_ID_TIME@@AAU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@AAUEVENT_ID_TIME@@@?$allocator@UEVENT_ID_TIME@@@std@@QAEXPAUEVENT_ID_TIME@@AAU2@@Z$0
__ehfuncinfo$??$construct@AAUEVENT_ID_TIME@@@?$allocator@UEVENT_ID_TIME@@@std@@QAEXPAUEVENT_ID_TIME@@AAU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@AAUEVENT_ID_TIME@@@?$allocator@UEVENT_ID_TIME@@@std@@QAEXPAUEVENT_ID_TIME@@AAU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$construct@AAUEVENT_ID_TIME@@@?$allocator@UEVENT_ID_TIME@@@std@@QAEXPAUEVENT_ID_TIME@@AAU2@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T227748 = -88						; size = 4
$T227749 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAUEVENT_ID_TIME@@@?$allocator@UEVENT_ID_TIME@@@std@@QAEXPAUEVENT_ID_TIME@@AAU2@@Z PROC ; std::allocator<EVENT_ID_TIME>::construct<EVENT_ID_TIME &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@AAUEVENT_ID_TIME@@@?$allocator@UEVENT_ID_TIME@@@std@@QAEXPAUEVENT_ID_TIME@@AAU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 10		 push	 16			; 00000010H
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T227749[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T227749[ebp], 0
  00047	74 2d		 je	 SHORT $LN3@construct
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@AAUEVENT_ID_TIME@@@std@@YAAAUEVENT_ID_TIME@@AAU1@@Z ; std::forward<EVENT_ID_TIME &>
  00052	83 c4 04	 add	 esp, 4
  00055	8b 55 ac	 mov	 edx, DWORD PTR $T227749[ebp]
  00058	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005a	89 0a		 mov	 DWORD PTR [edx], ecx
  0005c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005f	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00062	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00065	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00068	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0006b	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  0006e	8b 4d ac	 mov	 ecx, DWORD PTR $T227749[ebp]
  00071	89 4d a4	 mov	 DWORD PTR tv74[ebp], ecx
  00074	eb 07		 jmp	 SHORT $LN4@construct
$LN3@construct:
  00076	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct:
  0007d	8b 55 a4	 mov	 edx, DWORD PTR tv74[ebp]
  00080	89 55 a8	 mov	 DWORD PTR $T227748[ebp], edx
  00083	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 209  : 		}

  0008a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0008d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00094	59		 pop	 ecx
  00095	5f		 pop	 edi
  00096	5e		 pop	 esi
  00097	5b		 pop	 ebx
  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@AAUEVENT_ID_TIME@@@?$allocator@UEVENT_ID_TIME@@@std@@QAEXPAUEVENT_ID_TIME@@AAU2@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T227749[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@AAUEVENT_ID_TIME@@@?$allocator@UEVENT_ID_TIME@@@std@@QAEXPAUEVENT_ID_TIME@@AAU2@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@AAUEVENT_ID_TIME@@@?$allocator@UEVENT_ID_TIME@@@std@@QAEXPAUEVENT_ID_TIME@@AAU2@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@AAUEVENT_ID_TIME@@@?$allocator@UEVENT_ID_TIME@@@std@@QAEXPAUEVENT_ID_TIME@@AAU2@@Z ENDP ; std::allocator<EVENT_ID_TIME>::construct<EVENT_ID_TIME &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 81   :         {return (_Where); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 83   :         {return; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@ABUEVENT_ID_TIME@@@std@@YAABUEVENT_ID_TIME@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUEVENT_ID_TIME@@@std@@YAABUEVENT_ID_TIME@@ABU1@@Z PROC ; std::forward<EVENT_ID_TIME const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@ABUEVENT_ID_TIME@@@std@@YAABUEVENT_ID_TIME@@ABU1@@Z ENDP ; std::forward<EVENT_ID_TIME const &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@AAUEVENT_ID_ITEM_LIST@@@std@@YAAAUEVENT_ID_ITEM_LIST@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUEVENT_ID_ITEM_LIST@@@std@@YAAAUEVENT_ID_ITEM_LIST@@AAU1@@Z PROC ; std::forward<EVENT_ID_ITEM_LIST &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAUEVENT_ID_ITEM_LIST@@@std@@YAAAUEVENT_ID_ITEM_LIST@@AAU1@@Z ENDP ; std::forward<EVENT_ID_ITEM_LIST &>
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$construct@AAUEVENT_ID_ITEM_LIST@@@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAEXPAUEVENT_ID_ITEM_LIST@@AAU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@AAUEVENT_ID_ITEM_LIST@@@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAEXPAUEVENT_ID_ITEM_LIST@@AAU2@@Z$0
__ehfuncinfo$??$construct@AAUEVENT_ID_ITEM_LIST@@@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAEXPAUEVENT_ID_ITEM_LIST@@AAU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@AAUEVENT_ID_ITEM_LIST@@@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAEXPAUEVENT_ID_ITEM_LIST@@AAU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$construct@AAUEVENT_ID_ITEM_LIST@@@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAEXPAUEVENT_ID_ITEM_LIST@@AAU2@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T227769 = -88						; size = 4
$T227770 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAUEVENT_ID_ITEM_LIST@@@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAEXPAUEVENT_ID_ITEM_LIST@@AAU2@@Z PROC ; std::allocator<EVENT_ID_ITEM_LIST>::construct<EVENT_ID_ITEM_LIST &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@AAUEVENT_ID_ITEM_LIST@@@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAEXPAUEVENT_ID_ITEM_LIST@@AAU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 05		 push	 5
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T227770[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T227770[ebp], 0
  00047	74 21		 je	 SHORT $LN3@construct@2
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@AAUEVENT_ID_ITEM_LIST@@@std@@YAAAUEVENT_ID_ITEM_LIST@@AAU1@@Z ; std::forward<EVENT_ID_ITEM_LIST &>
  00052	83 c4 04	 add	 esp, 4
  00055	8b 55 ac	 mov	 edx, DWORD PTR $T227770[ebp]
  00058	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005a	89 0a		 mov	 DWORD PTR [edx], ecx
  0005c	8a 40 04	 mov	 al, BYTE PTR [eax+4]
  0005f	88 42 04	 mov	 BYTE PTR [edx+4], al
  00062	8b 4d ac	 mov	 ecx, DWORD PTR $T227770[ebp]
  00065	89 4d a4	 mov	 DWORD PTR tv74[ebp], ecx
  00068	eb 07		 jmp	 SHORT $LN4@construct@2
$LN3@construct@2:
  0006a	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct@2:
  00071	8b 55 a4	 mov	 edx, DWORD PTR tv74[ebp]
  00074	89 55 a8	 mov	 DWORD PTR $T227769[ebp], edx
  00077	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 209  : 		}

  0007e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00081	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00088	59		 pop	 ecx
  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@AAUEVENT_ID_ITEM_LIST@@@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAEXPAUEVENT_ID_ITEM_LIST@@AAU2@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T227770[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@AAUEVENT_ID_ITEM_LIST@@@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAEXPAUEVENT_ID_ITEM_LIST@@AAU2@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@AAUEVENT_ID_ITEM_LIST@@@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAEXPAUEVENT_ID_ITEM_LIST@@AAU2@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@AAUEVENT_ID_ITEM_LIST@@@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAEXPAUEVENT_ID_ITEM_LIST@@AAU2@@Z ENDP ; std::allocator<EVENT_ID_ITEM_LIST>::construct<EVENT_ID_ITEM_LIST &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@ABUEVENT_ID_ITEM_LIST@@@std@@YAABUEVENT_ID_ITEM_LIST@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUEVENT_ID_ITEM_LIST@@@std@@YAABUEVENT_ID_ITEM_LIST@@ABU1@@Z PROC ; std::forward<EVENT_ID_ITEM_LIST const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@ABUEVENT_ID_ITEM_LIST@@@std@@YAABUEVENT_ID_ITEM_LIST@@ABU1@@Z ENDP ; std::forward<EVENT_ID_ITEM_LIST const &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@UEVENT_ID_TIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUEVENT_ID_TIME@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UEVENT_ID_TIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUEVENT_ID_TIME@@0@Z PROC ; std::_Ptr_cat<EVENT_ID_TIME,EVENT_ID_TIME>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00009	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Ptr_cat@UEVENT_ID_TIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUEVENT_ID_TIME@@0@Z ENDP ; std::_Ptr_cat<EVENT_ID_TIME,EVENT_ID_TIME>
_TEXT	ENDS
PUBLIC	??$move@AAUEVENT_ID_TIME@@@std@@YA$$QAUEVENT_ID_TIME@@AAU1@@Z ; std::move<EVENT_ID_TIME &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Move@PAUEVENT_ID_TIME@@PAU1@@std@@YAPAUEVENT_ID_TIME@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAUEVENT_ID_TIME@@PAU1@@std@@YAPAUEVENT_ID_TIME@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<EVENT_ID_TIME *,EVENT_ID_TIME *>, COMDAT

; 2512 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2513 : 	for (; _First != _Last; ++_Dest, ++_First)

  00009	eb 12		 jmp	 SHORT $LN3@Move
$LN2@Move:
  0000b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000e	83 c0 10	 add	 eax, 16			; 00000010H
  00011	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00017	83 c1 10	 add	 ecx, 16			; 00000010H
  0001a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN3@Move:
  0001d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00020	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00023	74 27		 je	 SHORT $LN1@Move

; 2514 : 		*_Dest = _STD move(*_First);

  00025	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??$move@AAUEVENT_ID_TIME@@@std@@YA$$QAUEVENT_ID_TIME@@AAU1@@Z ; std::move<EVENT_ID_TIME &>
  0002e	83 c4 04	 add	 esp, 4
  00031	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00034	8b 10		 mov	 edx, DWORD PTR [eax]
  00036	89 11		 mov	 DWORD PTR [ecx], edx
  00038	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0003b	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0003e	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00041	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00044	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00047	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  0004a	eb bf		 jmp	 SHORT $LN2@Move
$LN1@Move:

; 2515 : 	return (_Dest);

  0004c	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 2516 : 	}

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
??$_Move@PAUEVENT_ID_TIME@@PAU1@@std@@YAPAUEVENT_ID_TIME@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<EVENT_ID_TIME *,EVENT_ID_TIME *>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@UEVENT_ID_ITEM_LIST@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUEVENT_ID_ITEM_LIST@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UEVENT_ID_ITEM_LIST@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUEVENT_ID_ITEM_LIST@@0@Z PROC ; std::_Ptr_cat<EVENT_ID_ITEM_LIST,EVENT_ID_ITEM_LIST>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00009	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Ptr_cat@UEVENT_ID_ITEM_LIST@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUEVENT_ID_ITEM_LIST@@0@Z ENDP ; std::_Ptr_cat<EVENT_ID_ITEM_LIST,EVENT_ID_ITEM_LIST>
_TEXT	ENDS
PUBLIC	??$move@AAUEVENT_ID_ITEM_LIST@@@std@@YA$$QAUEVENT_ID_ITEM_LIST@@AAU1@@Z ; std::move<EVENT_ID_ITEM_LIST &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Move@PAUEVENT_ID_ITEM_LIST@@PAU1@@std@@YAPAUEVENT_ID_ITEM_LIST@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAUEVENT_ID_ITEM_LIST@@PAU1@@std@@YAPAUEVENT_ID_ITEM_LIST@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<EVENT_ID_ITEM_LIST *,EVENT_ID_ITEM_LIST *>, COMDAT

; 2512 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2513 : 	for (; _First != _Last; ++_Dest, ++_First)

  00009	eb 12		 jmp	 SHORT $LN3@Move@2
$LN2@Move@2:
  0000b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000e	83 c0 05	 add	 eax, 5
  00011	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00017	83 c1 05	 add	 ecx, 5
  0001a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN3@Move@2:
  0001d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00020	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00023	74 1b		 je	 SHORT $LN1@Move@2

; 2514 : 		*_Dest = _STD move(*_First);

  00025	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??$move@AAUEVENT_ID_ITEM_LIST@@@std@@YA$$QAUEVENT_ID_ITEM_LIST@@AAU1@@Z ; std::move<EVENT_ID_ITEM_LIST &>
  0002e	83 c4 04	 add	 esp, 4
  00031	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00034	8b 10		 mov	 edx, DWORD PTR [eax]
  00036	89 11		 mov	 DWORD PTR [ecx], edx
  00038	8a 40 04	 mov	 al, BYTE PTR [eax+4]
  0003b	88 41 04	 mov	 BYTE PTR [ecx+4], al
  0003e	eb cb		 jmp	 SHORT $LN2@Move@2
$LN1@Move@2:

; 2515 : 	return (_Dest);

  00040	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 2516 : 	}

  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
??$_Move@PAUEVENT_ID_ITEM_LIST@@PAU1@@std@@YAPAUEVENT_ID_ITEM_LIST@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<EVENT_ID_ITEM_LIST *,EVENT_ID_ITEM_LIST *>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUEVENT_ID_TIME@@PAU1@V?$allocator@UEVENT_ID_TIME@@@std@@U1@@std@@YAPAUEVENT_ID_TIME@@PAU1@00AAV?$allocator@UEVENT_ID_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<EVENT_ID_TIME *,EVENT_ID_TIME *,std::allocator<EVENT_ID_TIME>,EVENT_ID_TIME>
PUBLIC	??$_Val_type@PAUEVENT_ID_TIME@@@std@@YAPAUEVENT_ID_TIME@@PAU1@@Z ; std::_Val_type<EVENT_ID_TIME *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_move@PAUEVENT_ID_TIME@@PAU1@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@YAPAUEVENT_ID_TIME@@PAU1@00AAV?$allocator@UEVENT_ID_TIME@@@0@@Z
_TEXT	SEGMENT
$T227792 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUEVENT_ID_TIME@@PAU1@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@YAPAUEVENT_ID_TIME@@PAU1@00AAV?$allocator@UEVENT_ID_TIME@@@0@@Z PROC ; std::_Uninitialized_move<EVENT_ID_TIME *,EVENT_ID_TIME *,std::allocator<EVENT_ID_TIME> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UEVENT_ID_TIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUEVENT_ID_TIME@@0@Z ; std::_Ptr_cat<EVENT_ID_TIME,EVENT_ID_TIME>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T227792[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T227792[ebp]
  00020	52		 push	 edx
  00021	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??$_Val_type@PAUEVENT_ID_TIME@@@std@@YAPAUEVENT_ID_TIME@@PAU1@@Z ; std::_Val_type<EVENT_ID_TIME *>
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00031	51		 push	 ecx
  00032	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00035	52		 push	 edx
  00036	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUEVENT_ID_TIME@@PAU1@V?$allocator@UEVENT_ID_TIME@@@std@@U1@@std@@YAPAUEVENT_ID_TIME@@PAU1@00AAV?$allocator@UEVENT_ID_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<EVENT_ID_TIME *,EVENT_ID_TIME *,std::allocator<EVENT_ID_TIME>,EVENT_ID_TIME>
  00043	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
??$_Uninitialized_move@PAUEVENT_ID_TIME@@PAU1@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@YAPAUEVENT_ID_TIME@@PAU1@00AAV?$allocator@UEVENT_ID_TIME@@@0@@Z ENDP ; std::_Uninitialized_move<EVENT_ID_TIME *,EVENT_ID_TIME *,std::allocator<EVENT_ID_TIME> >
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@UEVENT_ID_TIME@@@std@@UEVENT_ID_TIME@@@std@@YAXAAV?$allocator@UEVENT_ID_TIME@@@0@PAUEVENT_ID_TIME@@@Z ; std::_Dest_val<std::allocator<EVENT_ID_TIME>,EVENT_ID_TIME>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@YAXPAUEVENT_ID_TIME@@0AAV?$allocator@UEVENT_ID_TIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@YAXPAUEVENT_ID_TIME@@0AAV?$allocator@UEVENT_ID_TIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<EVENT_ID_TIME> >, COMDAT

; 95   : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 96   : 	for (; _First != _Last; ++_First)

  00009	eb 09		 jmp	 SHORT $LN3@Destroy_ra
$LN2@Destroy_ra:
  0000b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000e	83 c0 10	 add	 eax, 16			; 00000010H
  00011	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra:
  00014	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00017	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0001a	74 12		 je	 SHORT $LN4@Destroy_ra

; 97   : 		_Dest_val(_Al, _First);

  0001c	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@UEVENT_ID_TIME@@@std@@UEVENT_ID_TIME@@@std@@YAXAAV?$allocator@UEVENT_ID_TIME@@@0@PAUEVENT_ID_TIME@@@Z ; std::_Dest_val<std::allocator<EVENT_ID_TIME>,EVENT_ID_TIME>
  00029	83 c4 08	 add	 esp, 8
  0002c	eb dd		 jmp	 SHORT $LN2@Destroy_ra
$LN4@Destroy_ra:

; 98   : 	}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$_Destroy_range@V?$allocator@UEVENT_ID_TIME@@@std@@@std@@YAXPAUEVENT_ID_TIME@@0AAV?$allocator@UEVENT_ID_TIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<EVENT_ID_TIME> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUEVENT_ID_ITEM_LIST@@PAU1@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@U1@@std@@YAPAUEVENT_ID_ITEM_LIST@@PAU1@00AAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<EVENT_ID_ITEM_LIST *,EVENT_ID_ITEM_LIST *,std::allocator<EVENT_ID_ITEM_LIST>,EVENT_ID_ITEM_LIST>
PUBLIC	??$_Val_type@PAUEVENT_ID_ITEM_LIST@@@std@@YAPAUEVENT_ID_ITEM_LIST@@PAU1@@Z ; std::_Val_type<EVENT_ID_ITEM_LIST *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_move@PAUEVENT_ID_ITEM_LIST@@PAU1@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@YAPAUEVENT_ID_ITEM_LIST@@PAU1@00AAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@@Z
_TEXT	SEGMENT
$T227797 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUEVENT_ID_ITEM_LIST@@PAU1@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@YAPAUEVENT_ID_ITEM_LIST@@PAU1@00AAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@@Z PROC ; std::_Uninitialized_move<EVENT_ID_ITEM_LIST *,EVENT_ID_ITEM_LIST *,std::allocator<EVENT_ID_ITEM_LIST> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UEVENT_ID_ITEM_LIST@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUEVENT_ID_ITEM_LIST@@0@Z ; std::_Ptr_cat<EVENT_ID_ITEM_LIST,EVENT_ID_ITEM_LIST>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T227797[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T227797[ebp]
  00020	52		 push	 edx
  00021	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??$_Val_type@PAUEVENT_ID_ITEM_LIST@@@std@@YAPAUEVENT_ID_ITEM_LIST@@PAU1@@Z ; std::_Val_type<EVENT_ID_ITEM_LIST *>
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00031	51		 push	 ecx
  00032	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00035	52		 push	 edx
  00036	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUEVENT_ID_ITEM_LIST@@PAU1@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@U1@@std@@YAPAUEVENT_ID_ITEM_LIST@@PAU1@00AAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<EVENT_ID_ITEM_LIST *,EVENT_ID_ITEM_LIST *,std::allocator<EVENT_ID_ITEM_LIST>,EVENT_ID_ITEM_LIST>
  00043	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
??$_Uninitialized_move@PAUEVENT_ID_ITEM_LIST@@PAU1@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@YAPAUEVENT_ID_ITEM_LIST@@PAU1@00AAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@@Z ENDP ; std::_Uninitialized_move<EVENT_ID_ITEM_LIST *,EVENT_ID_ITEM_LIST *,std::allocator<EVENT_ID_ITEM_LIST> >
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@UEVENT_ID_ITEM_LIST@@@std@@YAXAAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@PAUEVENT_ID_ITEM_LIST@@@Z ; std::_Dest_val<std::allocator<EVENT_ID_ITEM_LIST>,EVENT_ID_ITEM_LIST>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@YAXPAUEVENT_ID_ITEM_LIST@@0AAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@YAXPAUEVENT_ID_ITEM_LIST@@0AAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<EVENT_ID_ITEM_LIST> >, COMDAT

; 95   : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 96   : 	for (; _First != _Last; ++_First)

  00009	eb 09		 jmp	 SHORT $LN3@Destroy_ra@2
$LN2@Destroy_ra@2:
  0000b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000e	83 c0 05	 add	 eax, 5
  00011	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra@2:
  00014	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00017	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0001a	74 12		 je	 SHORT $LN4@Destroy_ra@2

; 97   : 		_Dest_val(_Al, _First);

  0001c	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@UEVENT_ID_ITEM_LIST@@@std@@YAXAAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@PAUEVENT_ID_ITEM_LIST@@@Z ; std::_Dest_val<std::allocator<EVENT_ID_ITEM_LIST>,EVENT_ID_ITEM_LIST>
  00029	83 c4 08	 add	 esp, 8
  0002c	eb dd		 jmp	 SHORT $LN2@Destroy_ra@2
$LN4@Destroy_ra@2:

; 98   : 	}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$_Destroy_range@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@@std@@YAXPAUEVENT_ID_ITEM_LIST@@0AAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<EVENT_ID_ITEM_LIST> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$_Move@AAD@std@@YA$$QADAAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$_Move@AAD@std@@YA$$QADAAD@Z PROC			; std::_Move<char &>, COMDAT

; 94   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 95   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 96   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Move@AAD@std@@YA$$QADAAD@Z ENDP			; std::_Move<char &>
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$_Construct@UEVENT_ID_TIME@@ABU1@@std@@YAXPAUEVENT_ID_TIME@@ABU1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@UEVENT_ID_TIME@@ABU1@@std@@YAXPAUEVENT_ID_TIME@@ABU1@@Z$0
__ehfuncinfo$??$_Construct@UEVENT_ID_TIME@@ABU1@@std@@YAXPAUEVENT_ID_TIME@@ABU1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@UEVENT_ID_TIME@@ABU1@@std@@YAXPAUEVENT_ID_TIME@@ABU1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Construct@UEVENT_ID_TIME@@ABU1@@std@@YAXPAUEVENT_ID_TIME@@ABU1@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T227804 = -88						; size = 4
$T227805 = -84						; size = 4
__Vptr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UEVENT_ID_TIME@@ABU1@@std@@YAXPAUEVENT_ID_TIME@@ABU1@@Z PROC ; std::_Construct<EVENT_ID_TIME,EVENT_ID_TIME const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Construct@UEVENT_ID_TIME@@ABU1@@std@@YAXPAUEVENT_ID_TIME@@ABU1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 47   : 	void _FARQ *_Vptr = _Ptr;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002b	89 45 f0	 mov	 DWORD PTR __Vptr$[ebp], eax

; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  0002e	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00031	50		 push	 eax
  00032	6a 10		 push	 16			; 00000010H
  00034	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00039	83 c4 08	 add	 esp, 8
  0003c	89 45 ac	 mov	 DWORD PTR $T227805[ebp], eax
  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00046	83 7d ac 00	 cmp	 DWORD PTR $T227805[ebp], 0
  0004a	74 2d		 je	 SHORT $LN3@Construct
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ??$forward@ABUEVENT_ID_TIME@@@std@@YAABUEVENT_ID_TIME@@ABU1@@Z ; std::forward<EVENT_ID_TIME const &>
  00055	83 c4 04	 add	 esp, 4
  00058	8b 55 ac	 mov	 edx, DWORD PTR $T227805[ebp]
  0005b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005d	89 0a		 mov	 DWORD PTR [edx], ecx
  0005f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00062	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00065	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00068	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  0006b	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0006e	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  00071	8b 4d ac	 mov	 ecx, DWORD PTR $T227805[ebp]
  00074	89 4d a4	 mov	 DWORD PTR tv74[ebp], ecx
  00077	eb 07		 jmp	 SHORT $LN4@Construct
$LN3@Construct:
  00079	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@Construct:
  00080	8b 55 a4	 mov	 edx, DWORD PTR tv74[ebp]
  00083	89 55 a8	 mov	 DWORD PTR $T227804[ebp], edx
  00086	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 49   : 	}

  0008d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00090	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00097	59		 pop	 ecx
  00098	5f		 pop	 edi
  00099	5e		 pop	 esi
  0009a	5b		 pop	 ebx
  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@UEVENT_ID_TIME@@ABU1@@std@@YAXPAUEVENT_ID_TIME@@ABU1@@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T227805[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Construct@UEVENT_ID_TIME@@ABU1@@std@@YAXPAUEVENT_ID_TIME@@ABU1@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Construct@UEVENT_ID_TIME@@ABU1@@std@@YAXPAUEVENT_ID_TIME@@ABU1@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Construct@UEVENT_ID_TIME@@ABU1@@std@@YAXPAUEVENT_ID_TIME@@ABU1@@Z ENDP ; std::_Construct<EVENT_ID_TIME,EVENT_ID_TIME const &>
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > > &,bool>
PUBLIC	??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > > &>
PUBLIC	??$forward@_N@std@@YA$$QA_NAA_N@Z		; std::forward<bool>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > > &,bool>, COMDAT
; _this$ = ecx

; 247  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$forward@_N@std@@YA$$QA_NAA_N@Z ; std::forward<bool>
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > > &>
  00022	83 c4 04	 add	 esp, 4
  00025	50		 push	 eax
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > > &,bool>

; 248  : 		}

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > > &,bool>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy@U?$pair@$$CBHPAX@std@@@std@@YAXPAU?$pair@$$CBHPAX@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U?$pair@$$CBHPAX@std@@@std@@YAXPAU?$pair@$$CBHPAX@0@@Z PROC ; std::_Destroy<std::pair<int const ,void *> >, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Destroy@U?$pair@$$CBHPAX@std@@@std@@YAXPAU?$pair@$$CBHPAX@0@@Z ENDP ; std::_Destroy<std::pair<int const ,void *> >
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Construct@UEVENT_ID_ITEM_LIST@@ABU1@@std@@YAXPAUEVENT_ID_ITEM_LIST@@ABU1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@UEVENT_ID_ITEM_LIST@@ABU1@@std@@YAXPAUEVENT_ID_ITEM_LIST@@ABU1@@Z$0
__ehfuncinfo$??$_Construct@UEVENT_ID_ITEM_LIST@@ABU1@@std@@YAXPAUEVENT_ID_ITEM_LIST@@ABU1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@UEVENT_ID_ITEM_LIST@@ABU1@@std@@YAXPAUEVENT_ID_ITEM_LIST@@ABU1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Construct@UEVENT_ID_ITEM_LIST@@ABU1@@std@@YAXPAUEVENT_ID_ITEM_LIST@@ABU1@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T227821 = -88						; size = 4
$T227822 = -84						; size = 4
__Vptr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UEVENT_ID_ITEM_LIST@@ABU1@@std@@YAXPAUEVENT_ID_ITEM_LIST@@ABU1@@Z PROC ; std::_Construct<EVENT_ID_ITEM_LIST,EVENT_ID_ITEM_LIST const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Construct@UEVENT_ID_ITEM_LIST@@ABU1@@std@@YAXPAUEVENT_ID_ITEM_LIST@@ABU1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 47   : 	void _FARQ *_Vptr = _Ptr;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002b	89 45 f0	 mov	 DWORD PTR __Vptr$[ebp], eax

; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  0002e	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00031	50		 push	 eax
  00032	6a 05		 push	 5
  00034	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00039	83 c4 08	 add	 esp, 8
  0003c	89 45 ac	 mov	 DWORD PTR $T227822[ebp], eax
  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00046	83 7d ac 00	 cmp	 DWORD PTR $T227822[ebp], 0
  0004a	74 21		 je	 SHORT $LN3@Construct@2
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ??$forward@ABUEVENT_ID_ITEM_LIST@@@std@@YAABUEVENT_ID_ITEM_LIST@@ABU1@@Z ; std::forward<EVENT_ID_ITEM_LIST const &>
  00055	83 c4 04	 add	 esp, 4
  00058	8b 55 ac	 mov	 edx, DWORD PTR $T227822[ebp]
  0005b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005d	89 0a		 mov	 DWORD PTR [edx], ecx
  0005f	8a 40 04	 mov	 al, BYTE PTR [eax+4]
  00062	88 42 04	 mov	 BYTE PTR [edx+4], al
  00065	8b 4d ac	 mov	 ecx, DWORD PTR $T227822[ebp]
  00068	89 4d a4	 mov	 DWORD PTR tv74[ebp], ecx
  0006b	eb 07		 jmp	 SHORT $LN4@Construct@2
$LN3@Construct@2:
  0006d	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@Construct@2:
  00074	8b 55 a4	 mov	 edx, DWORD PTR tv74[ebp]
  00077	89 55 a8	 mov	 DWORD PTR $T227821[ebp], edx
  0007a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 49   : 	}

  00081	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00084	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008b	59		 pop	 ecx
  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi
  0008e	5b		 pop	 ebx
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@UEVENT_ID_ITEM_LIST@@ABU1@@std@@YAXPAUEVENT_ID_ITEM_LIST@@ABU1@@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T227822[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Construct@UEVENT_ID_ITEM_LIST@@ABU1@@std@@YAXPAUEVENT_ID_ITEM_LIST@@ABU1@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Construct@UEVENT_ID_ITEM_LIST@@ABU1@@std@@YAXPAUEVENT_ID_ITEM_LIST@@ABU1@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Construct@UEVENT_ID_ITEM_LIST@@ABU1@@std@@YAXPAUEVENT_ID_ITEM_LIST@@ABU1@@Z ENDP ; std::_Construct<EVENT_ID_ITEM_LIST,EVENT_ID_ITEM_LIST const &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z PROC ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > > &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z ENDP ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > > &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$move@AA_N@std@@YA$$QA_NAA_N@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AA_N@std@@YA$$QA_NAA_N@Z PROC			; std::move<bool &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$move@AA_N@std@@YA$$QA_NAA_N@Z ENDP			; std::move<bool &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
__Wherenode$ = -8					; size = 4
_this$ = -4						; size = 4
?_Buynode@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 559  : 		{	// allocate a node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 560  : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

  0000c	6a 01		 push	 1
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00014	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Node>::allocate
  00019	89 45 f8	 mov	 DWORD PTR __Wherenode$[ebp], eax

; 561  : 
; 562  : 		this->_Left(_Wherenode) = this->_Myhead;

  0001c	8b 45 f8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Left
  00025	83 c4 04	 add	 esp, 4
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002e	89 10		 mov	 DWORD PTR [eax], edx

; 563  : 		this->_Parent(_Wherenode) = this->_Myhead;

  00030	8b 45 f8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Parent
  00039	83 c4 04	 add	 esp, 4
  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00042	89 10		 mov	 DWORD PTR [eax], edx

; 564  : 		this->_Right(_Wherenode) = this->_Myhead;

  00044	8b 45 f8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Right
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00056	89 10		 mov	 DWORD PTR [eax], edx

; 565  : 		this->_Color(_Wherenode) = this->_Red;

  00058	8b 45 f8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Color
  00061	83 c4 04	 add	 esp, 4
  00064	c6 00 00	 mov	 BYTE PTR [eax], 0

; 566  : 		this->_Isnil(_Wherenode) = false;

  00067	8b 45 f8	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0006a	50		 push	 eax
  0006b	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Isnil
  00070	83 c4 04	 add	 esp, 4
  00073	c6 00 00	 mov	 BYTE PTR [eax], 0

; 567  : 		return (_Wherenode);

  00076	8b 45 f8	 mov	 eax, DWORD PTR __Wherenode$[ebp]

; 568  : 		}

  00079	5f		 pop	 edi
  0007a	5e		 pop	 esi
  0007b	5b		 pop	 ebx
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
?_Buynode@?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Buynode
_TEXT	ENDS
PUBLIC	??$construct@U?$pair@HPAX@std@@@?$allocator@U?$pair@$$CBHPAX@std@@@std@@QAEXPAU?$pair@$$CBHPAX@1@$$QAU?$pair@HPAX@1@@Z ; std::allocator<std::pair<int const ,void *> >::construct<std::pair<int,void *> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Cons_val@V?$allocator@U?$pair@$$CBHPAX@std@@@std@@U?$pair@$$CBHPAX@2@U?$pair@HPAX@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHPAX@std@@@0@PAU?$pair@$$CBHPAX@0@$$QAU?$pair@HPAX@0@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@U?$pair@$$CBHPAX@std@@@std@@U?$pair@$$CBHPAX@2@U?$pair@HPAX@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHPAX@std@@@0@PAU?$pair@$$CBHPAX@0@$$QAU?$pair@HPAX@0@@Z PROC ; std::_Cons_val<std::allocator<std::pair<int const ,void *> >,std::pair<int const ,void *>,std::pair<int,void *> >, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@U?$pair@HPAX@std@@@std@@YA$$QAU?$pair@HPAX@0@AAU10@@Z ; std::forward<std::pair<int,void *> >
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ??$construct@U?$pair@HPAX@std@@@?$allocator@U?$pair@$$CBHPAX@std@@@std@@QAEXPAU?$pair@$$CBHPAX@1@$$QAU?$pair@HPAX@1@@Z ; std::allocator<std::pair<int const ,void *> >::construct<std::pair<int,void *> >

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@U?$pair@$$CBHPAX@std@@@std@@U?$pair@$$CBHPAX@2@U?$pair@HPAX@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHPAX@std@@@0@PAU?$pair@$$CBHPAX@0@$$QAU?$pair@HPAX@0@@Z ENDP ; std::_Cons_val<std::allocator<std::pair<int const ,void *> >,std::pair<int const ,void *>,std::pair<int,void *> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$move@AAUEVENT_ID_TIME@@@std@@YA$$QAUEVENT_ID_TIME@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAUEVENT_ID_TIME@@@std@@YA$$QAUEVENT_ID_TIME@@AAU1@@Z PROC ; std::move<EVENT_ID_TIME &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$move@AAUEVENT_ID_TIME@@@std@@YA$$QAUEVENT_ID_TIME@@AAU1@@Z ENDP ; std::move<EVENT_ID_TIME &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$move@AAUEVENT_ID_ITEM_LIST@@@std@@YA$$QAUEVENT_ID_ITEM_LIST@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAUEVENT_ID_ITEM_LIST@@@std@@YA$$QAUEVENT_ID_ITEM_LIST@@AAU1@@Z PROC ; std::move<EVENT_ID_ITEM_LIST &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$move@AAUEVENT_ID_ITEM_LIST@@@std@@YA$$QAUEVENT_ID_ITEM_LIST@@AAU1@@Z ENDP ; std::move<EVENT_ID_ITEM_LIST &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Val_type@PAUEVENT_ID_TIME@@@std@@YAPAUEVENT_ID_TIME@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUEVENT_ID_TIME@@@std@@YAPAUEVENT_ID_TIME@@PAU1@@Z PROC ; std::_Val_type<EVENT_ID_TIME *>, COMDAT

; 789  : 	{	// return value type from arbitrary argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 790  : 	return (0);

  00009	33 c0		 xor	 eax, eax

; 791  : 	}

  0000b	5f		 pop	 edi
  0000c	5e		 pop	 esi
  0000d	5b		 pop	 ebx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Val_type@PAUEVENT_ID_TIME@@@std@@YAPAUEVENT_ID_TIME@@PAU1@@Z ENDP ; std::_Val_type<EVENT_ID_TIME *>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UEVENT_ID_TIME@@@std@@UEVENT_ID_TIME@@U3@@std@@YAXAAV?$allocator@UEVENT_ID_TIME@@@0@PAUEVENT_ID_TIME@@$$QAU2@@Z ; std::_Cons_val<std::allocator<EVENT_ID_TIME>,EVENT_ID_TIME,EVENT_ID_TIME>
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_move@PAUEVENT_ID_TIME@@PAU1@V?$allocator@UEVENT_ID_TIME@@@std@@U1@@std@@YAPAUEVENT_ID_TIME@@PAU1@00AAV?$allocator@UEVENT_ID_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_move@PAUEVENT_ID_TIME@@PAU1@V?$allocator@UEVENT_ID_TIME@@@std@@U1@@std@@YAPAUEVENT_ID_TIME@@PAU1@00AAV?$allocator@UEVENT_ID_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_move@PAUEVENT_ID_TIME@@PAU1@V?$allocator@UEVENT_ID_TIME@@@std@@U1@@std@@YAPAUEVENT_ID_TIME@@PAU1@00AAV?$allocator@UEVENT_ID_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_move@PAUEVENT_ID_TIME@@PAU1@V?$allocator@UEVENT_ID_TIME@@@std@@U1@@std@@YAPAUEVENT_ID_TIME@@PAU1@00AAV?$allocator@UEVENT_ID_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_move@PAUEVENT_ID_TIME@@PAU1@V?$allocator@UEVENT_ID_TIME@@@std@@U1@@std@@YAPAUEVENT_ID_TIME@@PAU1@00AAV?$allocator@UEVENT_ID_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_move@PAUEVENT_ID_TIME@@PAU1@V?$allocator@UEVENT_ID_TIME@@@std@@U1@@std@@YAPAUEVENT_ID_TIME@@PAU1@00AAV?$allocator@UEVENT_ID_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_move@PAUEVENT_ID_TIME@@PAU1@V?$allocator@UEVENT_ID_TIME@@@std@@U1@@std@@YAPAUEVENT_ID_TIME@@PAU1@00AAV?$allocator@UEVENT_ID_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_move@PAUEVENT_ID_TIME@@PAU1@V?$allocator@UEVENT_ID_TIME@@@std@@U1@@std@@YAPAUEVENT_ID_TIME@@PAU1@00AAV?$allocator@UEVENT_ID_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Uninit_move@PAUEVENT_ID_TIME@@PAU1@V?$allocator@UEVENT_ID_TIME@@@std@@U1@@std@@YAPAUEVENT_ID_TIME@@PAU1@00AAV?$allocator@UEVENT_ID_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUEVENT_ID_TIME@@PAU1@V?$allocator@UEVENT_ID_TIME@@@std@@U1@@std@@YAPAUEVENT_ID_TIME@@PAU1@00AAV?$allocator@UEVENT_ID_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<EVENT_ID_TIME *,EVENT_ID_TIME *,std::allocator<EVENT_ID_TIME>,EVENT_ID_TIME>, COMDAT

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_move@PAUEVENT_ID_TIME@@PAU1@V?$allocator@UEVENT_ID_TIME@@@std@@U1@@std@@YAPAUEVENT_ID_TIME@@PAU1@00AAV?$allocator@UEVENT_ID_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 44	 sub	 esp, 68			; 00000044H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;

  0002c	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0002f	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 428  : 
; 429  : 	_TRY_BEGIN

  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00039	eb 12		 jmp	 SHORT $LN6@Uninit_mov
$LN5@Uninit_mov:

; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  0003b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00044	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00047	83 c1 10	 add	 ecx, 16			; 00000010H
  0004a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN6@Uninit_mov:
  0004d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00050	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00053	74 16		 je	 SHORT $LN4@Uninit_mov

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

  00055	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00058	50		 push	 eax
  00059	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0005c	51		 push	 ecx
  0005d	8b 55 14	 mov	 edx, DWORD PTR __Al$[ebp]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UEVENT_ID_TIME@@@std@@UEVENT_ID_TIME@@U3@@std@@YAXAAV?$allocator@UEVENT_ID_TIME@@@0@PAUEVENT_ID_TIME@@$$QAU2@@Z ; std::_Cons_val<std::allocator<EVENT_ID_TIME>,EVENT_ID_TIME,EVENT_ID_TIME>
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
  00069	eb d0		 jmp	 SHORT $LN5@Uninit_mov
$LN4@Uninit_mov:
  0006b	eb 3b		 jmp	 SHORT $LN10@Uninit_mov
__catch$??$_Uninit_move@PAUEVENT_ID_TIME@@PAU1@V?$allocator@UEVENT_ID_TIME@@@std@@U1@@std@@YAPAUEVENT_ID_TIME@@PAU1@00AAV?$allocator@UEVENT_ID_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 432  : 	_CATCH_ALL

  0006d	eb 09		 jmp	 SHORT $LN3@Uninit_mov
$LN2@Uninit_mov:

; 433  : 	for (; _Next != _Dest; ++_Next)

  0006f	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00072	83 c0 10	 add	 eax, 16			; 00000010H
  00075	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax
$LN3@Uninit_mov:
  00078	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  0007b	3b 45 10	 cmp	 eax, DWORD PTR __Dest$[ebp]
  0007e	74 12		 je	 SHORT $LN1@Uninit_mov

; 434  : 		_Dest_val(_Al, _Next);

  00080	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00083	50		 push	 eax
  00084	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@UEVENT_ID_TIME@@@std@@UEVENT_ID_TIME@@@std@@YAXAAV?$allocator@UEVENT_ID_TIME@@@0@PAUEVENT_ID_TIME@@@Z ; std::_Dest_val<std::allocator<EVENT_ID_TIME>,EVENT_ID_TIME>
  0008d	83 c4 08	 add	 esp, 8
  00090	eb dd		 jmp	 SHORT $LN2@Uninit_mov
$LN1@Uninit_mov:

; 435  : 	_RERAISE;

  00092	6a 00		 push	 0
  00094	6a 00		 push	 0
  00096	e8 00 00 00 00	 call	 __CxxThrowException@8

; 436  : 	_CATCH_END

  0009b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000a2	b8 00 00 00 00	 mov	 eax, __tryend$??$_Uninit_move@PAUEVENT_ID_TIME@@PAU1@V?$allocator@UEVENT_ID_TIME@@@std@@U1@@std@@YAPAUEVENT_ID_TIME@@PAU1@00AAV?$allocator@UEVENT_ID_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1
  000a7	c3		 ret	 0
$LN10@Uninit_mov:
  000a8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_move@PAUEVENT_ID_TIME@@PAU1@V?$allocator@UEVENT_ID_TIME@@@std@@U1@@std@@YAPAUEVENT_ID_TIME@@PAU1@00AAV?$allocator@UEVENT_ID_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1:

; 437  : 	return (_Dest);

  000af	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_mov:

; 438  : 	}

  000b2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000b5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000bc	59		 pop	 ecx
  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_move@PAUEVENT_ID_TIME@@PAU1@V?$allocator@UEVENT_ID_TIME@@@std@@U1@@std@@YAPAUEVENT_ID_TIME@@PAU1@00AAV?$allocator@UEVENT_ID_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninit_move@PAUEVENT_ID_TIME@@PAU1@V?$allocator@UEVENT_ID_TIME@@@std@@U1@@std@@YAPAUEVENT_ID_TIME@@PAU1@00AAV?$allocator@UEVENT_ID_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninit_move@PAUEVENT_ID_TIME@@PAU1@V?$allocator@UEVENT_ID_TIME@@@std@@U1@@std@@YAPAUEVENT_ID_TIME@@PAU1@00AAV?$allocator@UEVENT_ID_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<EVENT_ID_TIME *,EVENT_ID_TIME *,std::allocator<EVENT_ID_TIME>,EVENT_ID_TIME>
PUBLIC	?destroy@?$allocator@UEVENT_ID_TIME@@@std@@QAEXPAUEVENT_ID_TIME@@@Z ; std::allocator<EVENT_ID_TIME>::destroy
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Dest_val@V?$allocator@UEVENT_ID_TIME@@@std@@UEVENT_ID_TIME@@@std@@YAXAAV?$allocator@UEVENT_ID_TIME@@@0@PAUEVENT_ID_TIME@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@UEVENT_ID_TIME@@@std@@UEVENT_ID_TIME@@@std@@YAXAAV?$allocator@UEVENT_ID_TIME@@@0@PAUEVENT_ID_TIME@@@Z PROC ; std::_Dest_val<std::allocator<EVENT_ID_TIME>,EVENT_ID_TIME>, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 287  : 	_Alval.destroy(_Pdest);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  00010	e8 00 00 00 00	 call	 ?destroy@?$allocator@UEVENT_ID_TIME@@@std@@QAEXPAUEVENT_ID_TIME@@@Z ; std::allocator<EVENT_ID_TIME>::destroy

; 288  : 	}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Dest_val@V?$allocator@UEVENT_ID_TIME@@@std@@UEVENT_ID_TIME@@@std@@YAXAAV?$allocator@UEVENT_ID_TIME@@@0@PAUEVENT_ID_TIME@@@Z ENDP ; std::_Dest_val<std::allocator<EVENT_ID_TIME>,EVENT_ID_TIME>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Val_type@PAUEVENT_ID_ITEM_LIST@@@std@@YAPAUEVENT_ID_ITEM_LIST@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUEVENT_ID_ITEM_LIST@@@std@@YAPAUEVENT_ID_ITEM_LIST@@PAU1@@Z PROC ; std::_Val_type<EVENT_ID_ITEM_LIST *>, COMDAT

; 789  : 	{	// return value type from arbitrary argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 790  : 	return (0);

  00009	33 c0		 xor	 eax, eax

; 791  : 	}

  0000b	5f		 pop	 edi
  0000c	5e		 pop	 esi
  0000d	5b		 pop	 ebx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Val_type@PAUEVENT_ID_ITEM_LIST@@@std@@YAPAUEVENT_ID_ITEM_LIST@@PAU1@@Z ENDP ; std::_Val_type<EVENT_ID_ITEM_LIST *>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@UEVENT_ID_ITEM_LIST@@U3@@std@@YAXAAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@PAUEVENT_ID_ITEM_LIST@@$$QAU2@@Z ; std::_Cons_val<std::allocator<EVENT_ID_ITEM_LIST>,EVENT_ID_ITEM_LIST,EVENT_ID_ITEM_LIST>
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_move@PAUEVENT_ID_ITEM_LIST@@PAU1@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@U1@@std@@YAPAUEVENT_ID_ITEM_LIST@@PAU1@00AAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_move@PAUEVENT_ID_ITEM_LIST@@PAU1@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@U1@@std@@YAPAUEVENT_ID_ITEM_LIST@@PAU1@00AAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_move@PAUEVENT_ID_ITEM_LIST@@PAU1@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@U1@@std@@YAPAUEVENT_ID_ITEM_LIST@@PAU1@00AAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_move@PAUEVENT_ID_ITEM_LIST@@PAU1@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@U1@@std@@YAPAUEVENT_ID_ITEM_LIST@@PAU1@00AAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_move@PAUEVENT_ID_ITEM_LIST@@PAU1@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@U1@@std@@YAPAUEVENT_ID_ITEM_LIST@@PAU1@00AAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_move@PAUEVENT_ID_ITEM_LIST@@PAU1@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@U1@@std@@YAPAUEVENT_ID_ITEM_LIST@@PAU1@00AAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_move@PAUEVENT_ID_ITEM_LIST@@PAU1@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@U1@@std@@YAPAUEVENT_ID_ITEM_LIST@@PAU1@00AAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_move@PAUEVENT_ID_ITEM_LIST@@PAU1@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@U1@@std@@YAPAUEVENT_ID_ITEM_LIST@@PAU1@00AAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Uninit_move@PAUEVENT_ID_ITEM_LIST@@PAU1@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@U1@@std@@YAPAUEVENT_ID_ITEM_LIST@@PAU1@00AAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUEVENT_ID_ITEM_LIST@@PAU1@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@U1@@std@@YAPAUEVENT_ID_ITEM_LIST@@PAU1@00AAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<EVENT_ID_ITEM_LIST *,EVENT_ID_ITEM_LIST *,std::allocator<EVENT_ID_ITEM_LIST>,EVENT_ID_ITEM_LIST>, COMDAT

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_move@PAUEVENT_ID_ITEM_LIST@@PAU1@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@U1@@std@@YAPAUEVENT_ID_ITEM_LIST@@PAU1@00AAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 44	 sub	 esp, 68			; 00000044H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;

  0002c	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0002f	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 428  : 
; 429  : 	_TRY_BEGIN

  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00039	eb 12		 jmp	 SHORT $LN6@Uninit_mov@2
$LN5@Uninit_mov@2:

; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  0003b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0003e	83 c0 05	 add	 eax, 5
  00041	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00044	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00047	83 c1 05	 add	 ecx, 5
  0004a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN6@Uninit_mov@2:
  0004d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00050	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00053	74 16		 je	 SHORT $LN4@Uninit_mov@2

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

  00055	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00058	50		 push	 eax
  00059	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0005c	51		 push	 ecx
  0005d	8b 55 14	 mov	 edx, DWORD PTR __Al$[ebp]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@UEVENT_ID_ITEM_LIST@@U3@@std@@YAXAAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@PAUEVENT_ID_ITEM_LIST@@$$QAU2@@Z ; std::_Cons_val<std::allocator<EVENT_ID_ITEM_LIST>,EVENT_ID_ITEM_LIST,EVENT_ID_ITEM_LIST>
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
  00069	eb d0		 jmp	 SHORT $LN5@Uninit_mov@2
$LN4@Uninit_mov@2:
  0006b	eb 3b		 jmp	 SHORT $LN10@Uninit_mov@2
__catch$??$_Uninit_move@PAUEVENT_ID_ITEM_LIST@@PAU1@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@U1@@std@@YAPAUEVENT_ID_ITEM_LIST@@PAU1@00AAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 432  : 	_CATCH_ALL

  0006d	eb 09		 jmp	 SHORT $LN3@Uninit_mov@2
$LN2@Uninit_mov@2:

; 433  : 	for (; _Next != _Dest; ++_Next)

  0006f	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00072	83 c0 05	 add	 eax, 5
  00075	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax
$LN3@Uninit_mov@2:
  00078	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  0007b	3b 45 10	 cmp	 eax, DWORD PTR __Dest$[ebp]
  0007e	74 12		 je	 SHORT $LN1@Uninit_mov@2

; 434  : 		_Dest_val(_Al, _Next);

  00080	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00083	50		 push	 eax
  00084	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@UEVENT_ID_ITEM_LIST@@@std@@YAXAAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@PAUEVENT_ID_ITEM_LIST@@@Z ; std::_Dest_val<std::allocator<EVENT_ID_ITEM_LIST>,EVENT_ID_ITEM_LIST>
  0008d	83 c4 08	 add	 esp, 8
  00090	eb dd		 jmp	 SHORT $LN2@Uninit_mov@2
$LN1@Uninit_mov@2:

; 435  : 	_RERAISE;

  00092	6a 00		 push	 0
  00094	6a 00		 push	 0
  00096	e8 00 00 00 00	 call	 __CxxThrowException@8

; 436  : 	_CATCH_END

  0009b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000a2	b8 00 00 00 00	 mov	 eax, __tryend$??$_Uninit_move@PAUEVENT_ID_ITEM_LIST@@PAU1@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@U1@@std@@YAPAUEVENT_ID_ITEM_LIST@@PAU1@00AAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1
  000a7	c3		 ret	 0
$LN10@Uninit_mov@2:
  000a8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_move@PAUEVENT_ID_ITEM_LIST@@PAU1@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@U1@@std@@YAPAUEVENT_ID_ITEM_LIST@@PAU1@00AAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1:

; 437  : 	return (_Dest);

  000af	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_mov@2:

; 438  : 	}

  000b2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000b5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000bc	59		 pop	 ecx
  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_move@PAUEVENT_ID_ITEM_LIST@@PAU1@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@U1@@std@@YAPAUEVENT_ID_ITEM_LIST@@PAU1@00AAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninit_move@PAUEVENT_ID_ITEM_LIST@@PAU1@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@U1@@std@@YAPAUEVENT_ID_ITEM_LIST@@PAU1@00AAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninit_move@PAUEVENT_ID_ITEM_LIST@@PAU1@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@U1@@std@@YAPAUEVENT_ID_ITEM_LIST@@PAU1@00AAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<EVENT_ID_ITEM_LIST *,EVENT_ID_ITEM_LIST *,std::allocator<EVENT_ID_ITEM_LIST>,EVENT_ID_ITEM_LIST>
PUBLIC	?destroy@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAEXPAUEVENT_ID_ITEM_LIST@@@Z ; std::allocator<EVENT_ID_ITEM_LIST>::destroy
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Dest_val@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@UEVENT_ID_ITEM_LIST@@@std@@YAXAAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@PAUEVENT_ID_ITEM_LIST@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@UEVENT_ID_ITEM_LIST@@@std@@YAXAAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@PAUEVENT_ID_ITEM_LIST@@@Z PROC ; std::_Dest_val<std::allocator<EVENT_ID_ITEM_LIST>,EVENT_ID_ITEM_LIST>, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 287  : 	_Alval.destroy(_Pdest);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  00010	e8 00 00 00 00	 call	 ?destroy@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAEXPAUEVENT_ID_ITEM_LIST@@@Z ; std::allocator<EVENT_ID_ITEM_LIST>::destroy

; 288  : 	}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Dest_val@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@UEVENT_ID_ITEM_LIST@@@std@@YAXAAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@PAUEVENT_ID_ITEM_LIST@@@Z ENDP ; std::_Dest_val<std::allocator<EVENT_ID_ITEM_LIST>,EVENT_ID_ITEM_LIST>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > > &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > > &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@_N@std@@YA$$QA_NAA_N@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@_N@std@@YA$$QA_NAA_N@Z PROC			; std::forward<bool>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@_N@std@@YA$$QA_NAA_N@Z ENDP			; std::forward<bool>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > > &,bool>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > > &>
  00015	83 c4 04	 add	 esp, 4
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	89 0a		 mov	 DWORD PTR [edx], ecx
  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??$forward@_N@std@@YA$$QA_NAA_N@Z ; std::forward<bool>
  00028	83 c4 04	 add	 esp, 4
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	8a 10		 mov	 dl, BYTE PTR [eax]
  00030	88 51 04	 mov	 BYTE PTR [ecx+4], dl

; 164  : 		}

  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> > > &,bool>
_TEXT	ENDS
PUBLIC	??$_Destroy@UEVENT_ID_TIME@@@std@@YAXPAUEVENT_ID_TIME@@@Z ; std::_Destroy<EVENT_ID_TIME>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@UEVENT_ID_TIME@@@std@@QAEXPAUEVENT_ID_TIME@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UEVENT_ID_TIME@@@std@@QAEXPAUEVENT_ID_TIME@@@Z PROC ; std::allocator<EVENT_ID_TIME>::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 213  : 		_Destroy(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Destroy@UEVENT_ID_TIME@@@std@@YAXPAUEVENT_ID_TIME@@@Z ; std::_Destroy<EVENT_ID_TIME>
  00015	83 c4 04	 add	 esp, 4

; 214  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?destroy@?$allocator@UEVENT_ID_TIME@@@std@@QAEXPAUEVENT_ID_TIME@@@Z ENDP ; std::allocator<EVENT_ID_TIME>::destroy
_TEXT	ENDS
PUBLIC	??$_Destroy@UEVENT_ID_ITEM_LIST@@@std@@YAXPAUEVENT_ID_ITEM_LIST@@@Z ; std::_Destroy<EVENT_ID_ITEM_LIST>
; Function compile flags: /Odtp /ZI
;	COMDAT ?destroy@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAEXPAUEVENT_ID_ITEM_LIST@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAEXPAUEVENT_ID_ITEM_LIST@@@Z PROC ; std::allocator<EVENT_ID_ITEM_LIST>::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 213  : 		_Destroy(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Destroy@UEVENT_ID_ITEM_LIST@@@std@@YAXPAUEVENT_ID_ITEM_LIST@@@Z ; std::_Destroy<EVENT_ID_ITEM_LIST>
  00015	83 c4 04	 add	 esp, 4

; 214  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?destroy@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAEXPAUEVENT_ID_ITEM_LIST@@@Z ENDP ; std::allocator<EVENT_ID_ITEM_LIST>::destroy
_TEXT	ENDS
PUBLIC	??$?0HPAX@?$pair@$$CBHPAX@std@@QAE@$$QAU?$pair@HPAX@1@@Z ; std::pair<int const ,void *>::pair<int const ,void *><int,void *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@U?$pair@HPAX@std@@@?$allocator@U?$pair@$$CBHPAX@std@@@std@@QAEXPAU?$pair@$$CBHPAX@1@$$QAU?$pair@HPAX@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@U?$pair@HPAX@std@@@?$allocator@U?$pair@$$CBHPAX@std@@@std@@QAEXPAU?$pair@$$CBHPAX@1@$$QAU?$pair@HPAX@1@@Z$0
__ehfuncinfo$??$construct@U?$pair@HPAX@std@@@?$allocator@U?$pair@$$CBHPAX@std@@@std@@QAEXPAU?$pair@$$CBHPAX@1@$$QAU?$pair@HPAX@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@U?$pair@HPAX@std@@@?$allocator@U?$pair@$$CBHPAX@std@@@std@@QAEXPAU?$pair@$$CBHPAX@1@$$QAU?$pair@HPAX@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$construct@U?$pair@HPAX@std@@@?$allocator@U?$pair@$$CBHPAX@std@@@std@@QAEXPAU?$pair@$$CBHPAX@1@$$QAU?$pair@HPAX@1@@Z
_TEXT	SEGMENT
tv76 = -92						; size = 4
$T227894 = -88						; size = 4
$T227895 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@U?$pair@HPAX@std@@@?$allocator@U?$pair@$$CBHPAX@std@@@std@@QAEXPAU?$pair@$$CBHPAX@1@$$QAU?$pair@HPAX@1@@Z PROC ; std::allocator<std::pair<int const ,void *> >::construct<std::pair<int,void *> >, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@U?$pair@HPAX@std@@@?$allocator@U?$pair@$$CBHPAX@std@@@std@@QAEXPAU?$pair@$$CBHPAX@1@$$QAU?$pair@HPAX@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 08		 push	 8
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T227895[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T227895[ebp], 0
  00047	74 1a		 je	 SHORT $LN3@construct@3
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@U?$pair@HPAX@std@@@std@@YA$$QAU?$pair@HPAX@0@AAU10@@Z ; std::forward<std::pair<int,void *> >
  00052	83 c4 04	 add	 esp, 4
  00055	50		 push	 eax
  00056	8b 4d ac	 mov	 ecx, DWORD PTR $T227895[ebp]
  00059	e8 00 00 00 00	 call	 ??$?0HPAX@?$pair@$$CBHPAX@std@@QAE@$$QAU?$pair@HPAX@1@@Z ; std::pair<int const ,void *>::pair<int const ,void *><int,void *>
  0005e	89 45 a4	 mov	 DWORD PTR tv76[ebp], eax
  00061	eb 07		 jmp	 SHORT $LN4@construct@3
$LN3@construct@3:
  00063	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN4@construct@3:
  0006a	8b 55 a4	 mov	 edx, DWORD PTR tv76[ebp]
  0006d	89 55 a8	 mov	 DWORD PTR $T227894[ebp], edx
  00070	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 209  : 		}

  00077	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00081	59		 pop	 ecx
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@U?$pair@HPAX@std@@@?$allocator@U?$pair@$$CBHPAX@std@@@std@@QAEXPAU?$pair@$$CBHPAX@1@$$QAU?$pair@HPAX@1@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T227895[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@U?$pair@HPAX@std@@@?$allocator@U?$pair@$$CBHPAX@std@@@std@@QAEXPAU?$pair@$$CBHPAX@1@$$QAU?$pair@HPAX@1@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@U?$pair@HPAX@std@@@?$allocator@U?$pair@$$CBHPAX@std@@@std@@QAEXPAU?$pair@$$CBHPAX@1@$$QAU?$pair@HPAX@1@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@U?$pair@HPAX@std@@@?$allocator@U?$pair@$$CBHPAX@std@@@std@@QAEXPAU?$pair@$$CBHPAX@1@$$QAU?$pair@HPAX@1@@Z ENDP ; std::allocator<std::pair<int const ,void *> >::construct<std::pair<int,void *> >
PUBLIC	?construct@?$allocator@UEVENT_ID_TIME@@@std@@QAEXPAUEVENT_ID_TIME@@$$QAU3@@Z ; std::allocator<EVENT_ID_TIME>::construct
PUBLIC	??$forward@UEVENT_ID_TIME@@@std@@YA$$QAUEVENT_ID_TIME@@AAU1@@Z ; std::forward<EVENT_ID_TIME>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UEVENT_ID_TIME@@@std@@UEVENT_ID_TIME@@U3@@std@@YAXAAV?$allocator@UEVENT_ID_TIME@@@0@PAUEVENT_ID_TIME@@$$QAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UEVENT_ID_TIME@@@std@@UEVENT_ID_TIME@@U3@@std@@YAXAAV?$allocator@UEVENT_ID_TIME@@@0@PAUEVENT_ID_TIME@@$$QAU2@@Z PROC ; std::_Cons_val<std::allocator<EVENT_ID_TIME>,EVENT_ID_TIME,EVENT_ID_TIME>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@UEVENT_ID_TIME@@@std@@YA$$QAUEVENT_ID_TIME@@AAU1@@Z ; std::forward<EVENT_ID_TIME>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@UEVENT_ID_TIME@@@std@@QAEXPAUEVENT_ID_TIME@@$$QAU3@@Z ; std::allocator<EVENT_ID_TIME>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UEVENT_ID_TIME@@@std@@UEVENT_ID_TIME@@U3@@std@@YAXAAV?$allocator@UEVENT_ID_TIME@@@0@PAUEVENT_ID_TIME@@$$QAU2@@Z ENDP ; std::_Cons_val<std::allocator<EVENT_ID_TIME>,EVENT_ID_TIME,EVENT_ID_TIME>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAEXPAUEVENT_ID_ITEM_LIST@@$$QAU3@@Z ; std::allocator<EVENT_ID_ITEM_LIST>::construct
PUBLIC	??$forward@UEVENT_ID_ITEM_LIST@@@std@@YA$$QAUEVENT_ID_ITEM_LIST@@AAU1@@Z ; std::forward<EVENT_ID_ITEM_LIST>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@UEVENT_ID_ITEM_LIST@@U3@@std@@YAXAAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@PAUEVENT_ID_ITEM_LIST@@$$QAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@UEVENT_ID_ITEM_LIST@@U3@@std@@YAXAAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@PAUEVENT_ID_ITEM_LIST@@$$QAU2@@Z PROC ; std::_Cons_val<std::allocator<EVENT_ID_ITEM_LIST>,EVENT_ID_ITEM_LIST,EVENT_ID_ITEM_LIST>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@UEVENT_ID_ITEM_LIST@@@std@@YA$$QAUEVENT_ID_ITEM_LIST@@AAU1@@Z ; std::forward<EVENT_ID_ITEM_LIST>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAEXPAUEVENT_ID_ITEM_LIST@@$$QAU3@@Z ; std::allocator<EVENT_ID_ITEM_LIST>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UEVENT_ID_ITEM_LIST@@@std@@UEVENT_ID_ITEM_LIST@@U3@@std@@YAXAAV?$allocator@UEVENT_ID_ITEM_LIST@@@0@PAUEVENT_ID_ITEM_LIST@@$$QAU2@@Z ENDP ; std::_Cons_val<std::allocator<EVENT_ID_ITEM_LIST>,EVENT_ID_ITEM_LIST,EVENT_ID_ITEM_LIST>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Destroy@UEVENT_ID_TIME@@@std@@YAXPAUEVENT_ID_TIME@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UEVENT_ID_TIME@@@std@@YAXPAUEVENT_ID_TIME@@@Z PROC ; std::_Destroy<EVENT_ID_TIME>, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Destroy@UEVENT_ID_TIME@@@std@@YAXPAUEVENT_ID_TIME@@@Z ENDP ; std::_Destroy<EVENT_ID_TIME>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Destroy@UEVENT_ID_ITEM_LIST@@@std@@YAXPAUEVENT_ID_ITEM_LIST@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UEVENT_ID_ITEM_LIST@@@std@@YAXPAUEVENT_ID_ITEM_LIST@@@Z PROC ; std::_Destroy<EVENT_ID_ITEM_LIST>, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Destroy@UEVENT_ID_ITEM_LIST@@@std@@YAXPAUEVENT_ID_ITEM_LIST@@@Z ENDP ; std::_Destroy<EVENT_ID_ITEM_LIST>
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@UEVENT_ID_TIME@@@std@@QAEXPAUEVENT_ID_TIME@@$$QAU3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@UEVENT_ID_TIME@@@std@@QAEXPAUEVENT_ID_TIME@@$$QAU3@@Z$0
__ehfuncinfo$?construct@?$allocator@UEVENT_ID_TIME@@@std@@QAEXPAUEVENT_ID_TIME@@$$QAU3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@UEVENT_ID_TIME@@@std@@QAEXPAUEVENT_ID_TIME@@$$QAU3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@UEVENT_ID_TIME@@@std@@QAEXPAUEVENT_ID_TIME@@$$QAU3@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T227915 = -88						; size = 4
$T227916 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UEVENT_ID_TIME@@@std@@QAEXPAUEVENT_ID_TIME@@$$QAU3@@Z PROC ; std::allocator<EVENT_ID_TIME>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?construct@?$allocator@UEVENT_ID_TIME@@@std@@QAEXPAUEVENT_ID_TIME@@$$QAU3@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 10		 push	 16			; 00000010H
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T227916[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T227916[ebp], 0
  00047	74 2d		 je	 SHORT $LN3@construct@4
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@UEVENT_ID_TIME@@@std@@YA$$QAUEVENT_ID_TIME@@AAU1@@Z ; std::forward<EVENT_ID_TIME>
  00052	83 c4 04	 add	 esp, 4
  00055	8b 55 ac	 mov	 edx, DWORD PTR $T227916[ebp]
  00058	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005a	89 0a		 mov	 DWORD PTR [edx], ecx
  0005c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005f	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00062	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00065	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00068	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0006b	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  0006e	8b 4d ac	 mov	 ecx, DWORD PTR $T227916[ebp]
  00071	89 4d a4	 mov	 DWORD PTR tv74[ebp], ecx
  00074	eb 07		 jmp	 SHORT $LN4@construct@4
$LN3@construct@4:
  00076	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct@4:
  0007d	8b 55 a4	 mov	 edx, DWORD PTR tv74[ebp]
  00080	89 55 a8	 mov	 DWORD PTR $T227915[ebp], edx
  00083	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 203  : 		}

  0008a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0008d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00094	59		 pop	 ecx
  00095	5f		 pop	 edi
  00096	5e		 pop	 esi
  00097	5b		 pop	 ebx
  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@UEVENT_ID_TIME@@@std@@QAEXPAUEVENT_ID_TIME@@$$QAU3@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T227916[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$?construct@?$allocator@UEVENT_ID_TIME@@@std@@QAEXPAUEVENT_ID_TIME@@$$QAU3@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?construct@?$allocator@UEVENT_ID_TIME@@@std@@QAEXPAUEVENT_ID_TIME@@$$QAU3@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@UEVENT_ID_TIME@@@std@@QAEXPAUEVENT_ID_TIME@@$$QAU3@@Z ENDP ; std::allocator<EVENT_ID_TIME>::construct
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAEXPAUEVENT_ID_ITEM_LIST@@$$QAU3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAEXPAUEVENT_ID_ITEM_LIST@@$$QAU3@@Z$0
__ehfuncinfo$?construct@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAEXPAUEVENT_ID_ITEM_LIST@@$$QAU3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAEXPAUEVENT_ID_ITEM_LIST@@$$QAU3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAEXPAUEVENT_ID_ITEM_LIST@@$$QAU3@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T227928 = -88						; size = 4
$T227929 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAEXPAUEVENT_ID_ITEM_LIST@@$$QAU3@@Z PROC ; std::allocator<EVENT_ID_ITEM_LIST>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?construct@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAEXPAUEVENT_ID_ITEM_LIST@@$$QAU3@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 05		 push	 5
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T227929[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T227929[ebp], 0
  00047	74 21		 je	 SHORT $LN3@construct@5
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@UEVENT_ID_ITEM_LIST@@@std@@YA$$QAUEVENT_ID_ITEM_LIST@@AAU1@@Z ; std::forward<EVENT_ID_ITEM_LIST>
  00052	83 c4 04	 add	 esp, 4
  00055	8b 55 ac	 mov	 edx, DWORD PTR $T227929[ebp]
  00058	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005a	89 0a		 mov	 DWORD PTR [edx], ecx
  0005c	8a 40 04	 mov	 al, BYTE PTR [eax+4]
  0005f	88 42 04	 mov	 BYTE PTR [edx+4], al
  00062	8b 4d ac	 mov	 ecx, DWORD PTR $T227929[ebp]
  00065	89 4d a4	 mov	 DWORD PTR tv74[ebp], ecx
  00068	eb 07		 jmp	 SHORT $LN4@construct@5
$LN3@construct@5:
  0006a	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct@5:
  00071	8b 55 a4	 mov	 edx, DWORD PTR tv74[ebp]
  00074	89 55 a8	 mov	 DWORD PTR $T227928[ebp], edx
  00077	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 203  : 		}

  0007e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00081	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00088	59		 pop	 ecx
  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAEXPAUEVENT_ID_ITEM_LIST@@$$QAU3@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T227929[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$?construct@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAEXPAUEVENT_ID_ITEM_LIST@@$$QAU3@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?construct@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAEXPAUEVENT_ID_ITEM_LIST@@$$QAU3@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@UEVENT_ID_ITEM_LIST@@@std@@QAEXPAUEVENT_ID_ITEM_LIST@@$$QAU3@@Z ENDP ; std::allocator<EVENT_ID_ITEM_LIST>::construct
PUBLIC	??$?0HPAX@?$_Pair_base@$$CBHPAX@std@@QAE@$$QAH$$QAPAX@Z ; std::_Pair_base<int const ,void *>::_Pair_base<int const ,void *><int,void *>
PUBLIC	??$forward@H@std@@YA$$QAHAAH@Z			; std::forward<int>
PUBLIC	??$forward@PAX@std@@YA$$QAPAXAAPAX@Z		; std::forward<void *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$?0HPAX@?$pair@$$CBHPAX@std@@QAE@$$QAU?$pair@HPAX@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??$?0HPAX@?$pair@$$CBHPAX@std@@QAE@$$QAU?$pair@HPAX@1@@Z PROC ; std::pair<int const ,void *>::pair<int const ,void *><int,void *>, COMDAT
; _this$ = ecx

; 255  : 		{	// construct from moved compatible pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	83 c0 04	 add	 eax, 4
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??$forward@PAX@std@@YA$$QAPAXAAPAX@Z ; std::forward<void *>
  00018	83 c4 04	 add	 esp, 4
  0001b	50		 push	 eax
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ??$forward@H@std@@YA$$QAHAAH@Z ; std::forward<int>
  00025	83 c4 04	 add	 esp, 4
  00028	50		 push	 eax
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ??$?0HPAX@?$_Pair_base@$$CBHPAX@std@@QAE@$$QAH$$QAPAX@Z ; std::_Pair_base<int const ,void *>::_Pair_base<int const ,void *><int,void *>

; 256  : 		}

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
??$?0HPAX@?$pair@$$CBHPAX@std@@QAE@$$QAU?$pair@HPAX@1@@Z ENDP ; std::pair<int const ,void *>::pair<int const ,void *><int,void *>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@UEVENT_ID_TIME@@@std@@YA$$QAUEVENT_ID_TIME@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UEVENT_ID_TIME@@@std@@YA$$QAUEVENT_ID_TIME@@AAU1@@Z PROC ; std::forward<EVENT_ID_TIME>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@UEVENT_ID_TIME@@@std@@YA$$QAUEVENT_ID_TIME@@AAU1@@Z ENDP ; std::forward<EVENT_ID_TIME>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@UEVENT_ID_ITEM_LIST@@@std@@YA$$QAUEVENT_ID_ITEM_LIST@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UEVENT_ID_ITEM_LIST@@@std@@YA$$QAUEVENT_ID_ITEM_LIST@@AAU1@@Z PROC ; std::forward<EVENT_ID_ITEM_LIST>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@UEVENT_ID_ITEM_LIST@@@std@@YA$$QAUEVENT_ID_ITEM_LIST@@AAU1@@Z ENDP ; std::forward<EVENT_ID_ITEM_LIST>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@H@std@@YA$$QAHAAH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@H@std@@YA$$QAHAAH@Z PROC			; std::forward<int>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@H@std@@YA$$QAHAAH@Z ENDP			; std::forward<int>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@PAX@std@@YA$$QAPAXAAPAX@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@PAX@std@@YA$$QAPAXAAPAX@Z PROC		; std::forward<void *>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@PAX@std@@YA$$QAPAXAAPAX@Z ENDP		; std::forward<void *>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$?0HPAX@?$_Pair_base@$$CBHPAX@std@@QAE@$$QAH$$QAPAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0HPAX@?$_Pair_base@$$CBHPAX@std@@QAE@$$QAH$$QAPAX@Z PROC ; std::_Pair_base<int const ,void *>::_Pair_base<int const ,void *><int,void *>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$forward@H@std@@YA$$QAHAAH@Z ; std::forward<int>
  00015	83 c4 04	 add	 esp, 4
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 10		 mov	 edx, DWORD PTR [eax]
  0001d	89 11		 mov	 DWORD PTR [ecx], edx
  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??$forward@PAX@std@@YA$$QAPAXAAPAX@Z ; std::forward<void *>
  00028	83 c4 04	 add	 esp, 4
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	8b 10		 mov	 edx, DWORD PTR [eax]
  00030	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 164  : 		}

  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
??$?0HPAX@?$_Pair_base@$$CBHPAX@std@@QAE@$$QAH$$QAPAX@Z ENDP ; std::_Pair_base<int const ,void *>::_Pair_base<int const ,void *><int,void *>
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File d:\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
; Function compile flags: /Odtp /ZI
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ ; std::bad_alloc::~bad_alloc
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar@2
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar@2:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 37   : 		{	// orphan all iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 38   : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 48   : 		{	// adopt this iterator by parent

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 49   : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\eventmanagement.cpp
;	COMDAT ??__Eg_EventManager@@YAXXZ
text$yc	SEGMENT
??__Eg_EventManager@@YAXXZ PROC				; `dynamic initializer for 'g_EventManager'', COMDAT

; 12   : CEventManagement g_EventManager;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_EventManager@@3VCEventManagement@@A ; g_EventManager
  0000e	e8 00 00 00 00	 call	 ??0CEventManagement@@QAE@XZ ; CEventManagement::CEventManagement
  00013	68 00 00 00 00	 push	 OFFSET ??__Fg_EventManager@@YAXXZ ; `dynamic atexit destructor for 'g_EventManager''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??__Eg_EventManager@@YAXXZ ENDP				; `dynamic initializer for 'g_EventManager''
; Function compile flags: /Odtp /ZI
text$yc	ENDS
;	COMDAT ??__Eg_EventItemList@@YAXXZ
text$yc	SEGMENT
??__Eg_EventItemList@@YAXXZ PROC			; `dynamic initializer for 'g_EventItemList'', COMDAT

; 13   : CEventItemList	g_EventItemList; //nice position wz

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_EventItemList@@3VCEventItemList@@A ; g_EventItemList
  0000e	e8 00 00 00 00	 call	 ??0CEventItemList@@QAE@XZ ; CEventItemList::CEventItemList
  00013	68 00 00 00 00	 push	 OFFSET ??__Fg_EventItemList@@YAXXZ ; `dynamic atexit destructor for 'g_EventItemList''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??__Eg_EventItemList@@YAXXZ ENDP			; `dynamic initializer for 'g_EventItemList''
; Function compile flags: /Odtp /ZI
text$yc	ENDS
;	COMDAT ??__Fg_EventManager@@YAXXZ
text$yd	SEGMENT
??__Fg_EventManager@@YAXXZ PROC				; `dynamic atexit destructor for 'g_EventManager'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_EventManager@@3VCEventManagement@@A ; g_EventManager
  0000e	e8 00 00 00 00	 call	 ??1CEventManagement@@UAE@XZ ; CEventManagement::~CEventManagement
  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__Fg_EventManager@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_EventManager''
; Function compile flags: /Odtp /ZI
text$yd	ENDS
;	COMDAT ??__Fg_EventItemList@@YAXXZ
text$yd	SEGMENT
??__Fg_EventItemList@@YAXXZ PROC			; `dynamic atexit destructor for 'g_EventItemList'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_EventItemList@@3VCEventItemList@@A ; g_EventItemList
  0000e	e8 00 00 00 00	 call	 ??1CEventItemList@@QAE@XZ ; CEventItemList::~CEventItemList
  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__Fg_EventItemList@@YAXXZ ENDP			; `dynamic atexit destructor for 'g_EventItemList''
text$yd	ENDS
PUBLIC	?g_EventItemList@@3VCEventItemList@@A		; g_EventItemList
PUBLIC	?g_EventManager@@3VCEventManagement@@A		; g_EventManager
_BSS	SEGMENT
?g_EventItemList@@3VCEventItemList@@A DB 010H DUP (?)	; g_EventItemList
?g_EventManager@@3VCEventManagement@@A DB 034H DUP (?)	; g_EventManager
_BSS	ENDS
CRT$XCU	SEGMENT
_g_EventManager$initializer$ DD FLAT:??__Eg_EventManager@@YAXXZ
_g_EventItemList$initializer$ DD FLAT:??__Eg_EventItemList@@YAXXZ
CRT$XCU	ENDS
END
