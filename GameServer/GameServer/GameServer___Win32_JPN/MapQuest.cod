; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	D:\Projects\ExTeam6.3\Source\GameServer\GameServer\MapQuest.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
_DATA	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Odtp /ZI
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@vector:
  00009	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000c	83 e8 01	 sub	 eax, 1
  0000f	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00012	78 11		 js	 SHORT $LN3@vector
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00017	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  0001d	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00020	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00023	eb e4		 jmp	 SHORT $LN2@vector
$LN3@vector:
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??1?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAE@XZ ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::~vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >
PUBLIC	?clear@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAEXXZ ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::clear
PUBLIC	??0?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAE@XZ ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >
PUBLIC	??0CMapQuest@@QAE@XZ				; CMapQuest::CMapQuest
EXTRN	_memset:PROC
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
xdata$x	SEGMENT
__unwindtable$??0CMapQuest@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CMapQuest@@QAE@XZ$0
__ehfuncinfo$??0CMapQuest@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CMapQuest@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\mapquest.cpp
xdata$x	ENDS
_TEXT	SEGMENT
_i$228408 = -24						; size = 4
_m$228404 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CMapQuest@@QAE@XZ PROC				; CMapQuest::CMapQuest
; _this$ = ecx

; 16   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CMapQuest@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ??0?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAE@XZ ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >
  00033	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 17   : 	this->m_Data.clear();

  0003a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?clear@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAEXXZ ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::clear

; 18   : 	memset(this->m_MapKillCount, 0, sizeof(this->m_MapKillCount));

  00042	68 68 01 00 00	 push	 360			; 00000168H
  00047	6a 00		 push	 0
  00049	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	83 c0 10	 add	 eax, 16			; 00000010H
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 _memset
  00055	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19   : 	memset(this->m_BossStart, 0, sizeof(this->m_BossStart));

  00058	6a 5a		 push	 90			; 0000005aH
  0005a	6a 00		 push	 0
  0005c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	05 78 01 00 00	 add	 eax, 376		; 00000178H
  00064	50		 push	 eax
  00065	e8 00 00 00 00	 call	 _memset
  0006a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 20   : 
; 21   : 	for(int m = 0; m < MAX_NUMBER_MAP; m++)

  0006d	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _m$228404[ebp], 0
  00074	eb 09		 jmp	 SHORT $LN6@CMapQuest
$LN5@CMapQuest:
  00076	8b 45 ec	 mov	 eax, DWORD PTR _m$228404[ebp]
  00079	83 c0 01	 add	 eax, 1
  0007c	89 45 ec	 mov	 DWORD PTR _m$228404[ebp], eax
$LN6@CMapQuest:
  0007f	83 7d ec 5a	 cmp	 DWORD PTR _m$228404[ebp], 90 ; 0000005aH
  00083	0f 8d 88 00 00
	00		 jge	 $LN7@CMapQuest

; 22   : 	{
; 23   : 		this->m_Boss[m].sPos = -1;

  00089	8b 45 ec	 mov	 eax, DWORD PTR _m$228404[ebp]
  0008c	6b c0 06	 imul	 eax, 6
  0008f	83 c9 ff	 or	 ecx, -1
  00092	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00095	66 89 8c 02 d4
	01 00 00	 mov	 WORD PTR [edx+eax+468], cx

; 24   : 		this->m_Boss[m].sIndex = -1;

  0009d	8b 45 ec	 mov	 eax, DWORD PTR _m$228404[ebp]
  000a0	6b c0 06	 imul	 eax, 6
  000a3	83 c9 ff	 or	 ecx, -1
  000a6	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000a9	66 89 8c 02 d2
	01 00 00	 mov	 WORD PTR [edx+eax+466], cx

; 25   : 
; 26   : 		for(int i = 0; i < 100; i++)

  000b1	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$228408[ebp], 0
  000b8	eb 09		 jmp	 SHORT $LN3@CMapQuest
$LN2@CMapQuest:
  000ba	8b 45 e8	 mov	 eax, DWORD PTR _i$228408[ebp]
  000bd	83 c0 01	 add	 eax, 1
  000c0	89 45 e8	 mov	 DWORD PTR _i$228408[ebp], eax
$LN3@CMapQuest:
  000c3	83 7d e8 64	 cmp	 DWORD PTR _i$228408[ebp], 100 ; 00000064H
  000c7	7d 43		 jge	 SHORT $LN1@CMapQuest

; 27   : 		{
; 28   : 			this->m_Monster[m][i].sPos = -1;

  000c9	8b 45 ec	 mov	 eax, DWORD PTR _m$228404[ebp]
  000cc	69 c0 58 02 00
	00		 imul	 eax, 600		; 00000258H
  000d2	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000d5	8d 94 01 ee 03
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1006]
  000dc	8b 45 e8	 mov	 eax, DWORD PTR _i$228408[ebp]
  000df	6b c0 06	 imul	 eax, 6
  000e2	83 c9 ff	 or	 ecx, -1
  000e5	66 89 4c 02 02	 mov	 WORD PTR [edx+eax+2], cx

; 29   : 			this->m_Monster[m][i].sIndex = -1;

  000ea	8b 45 ec	 mov	 eax, DWORD PTR _m$228404[ebp]
  000ed	69 c0 58 02 00
	00		 imul	 eax, 600		; 00000258H
  000f3	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000f6	8d 94 01 ee 03
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1006]
  000fd	8b 45 e8	 mov	 eax, DWORD PTR _i$228408[ebp]
  00100	6b c0 06	 imul	 eax, 6
  00103	83 c9 ff	 or	 ecx, -1
  00106	66 89 0c 02	 mov	 WORD PTR [edx+eax], cx

; 30   : 		}

  0010a	eb ae		 jmp	 SHORT $LN2@CMapQuest
$LN1@CMapQuest:

; 31   : 	}

  0010c	e9 65 ff ff ff	 jmp	 $LN5@CMapQuest
$LN7@CMapQuest:

; 32   : }

  00111	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00118	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0011b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0011e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00125	59		 pop	 ecx
  00126	5f		 pop	 edi
  00127	5e		 pop	 esi
  00128	5b		 pop	 ebx
  00129	8b e5		 mov	 esp, ebp
  0012b	5d		 pop	 ebp
  0012c	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0CMapQuest@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAE@XZ ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::~vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >
__ehhandler$??0CMapQuest@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a a4	 mov	 ecx, DWORD PTR [edx-92]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CMapQuest@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CMapQuest@@QAE@XZ ENDP				; CMapQuest::CMapQuest
PUBLIC	??1CMapQuest@@QAE@XZ				; CMapQuest::~CMapQuest
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CMapQuest@@QAE@XZ PROC				; CMapQuest::~CMapQuest
; _this$ = ecx

; 35   : {

  00130	55		 push	 ebp
  00131	8b ec		 mov	 ebp, esp
  00133	83 ec 44	 sub	 esp, 68			; 00000044H
  00136	53		 push	 ebx
  00137	56		 push	 esi
  00138	57		 push	 edi
  00139	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 36   : }

  0013c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0013f	e8 00 00 00 00	 call	 ??1?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAE@XZ ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::~vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >
  00144	5f		 pop	 edi
  00145	5e		 pop	 esi
  00146	5b		 pop	 ebx
  00147	8b e5		 mov	 esp, ebp
  00149	5d		 pop	 ebp
  0014a	c3		 ret	 0
??1CMapQuest@@QAE@XZ ENDP				; CMapQuest::~CMapQuest
_TEXT	ENDS
PUBLIC	?Read@CMapQuest@@QAEXPAD@Z			; CMapQuest::Read
PUBLIC	??_C@_0BE@GHDKHEPN@ExData?2MapQuest?4ini?$AA@	; `string'
PUBLIC	?Load@CMapQuest@@QAEXXZ				; CMapQuest::Load
EXTRN	?GetNewPath@CDirPath@@QAEPADPAD@Z:PROC		; CDirPath::GetNewPath
EXTRN	?gDirPath@@3VCDirPath@@A:BYTE			; gDirPath
EXTRN	?g_ExLicense@@3VCExLicense@@A:BYTE		; g_ExLicense
;	COMDAT ??_C@_0BE@GHDKHEPN@ExData?2MapQuest?4ini?$AA@
CONST	SEGMENT
??_C@_0BE@GHDKHEPN@ExData?2MapQuest?4ini?$AA@ DB 'ExData\MapQuest.ini', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Load@CMapQuest@@QAEXXZ PROC				; CMapQuest::Load
; _this$ = ecx

; 39   : {

  00150	55		 push	 ebp
  00151	8b ec		 mov	 ebp, esp
  00153	83 ec 44	 sub	 esp, 68			; 00000044H
  00156	53		 push	 ebx
  00157	56		 push	 esi
  00158	57		 push	 edi
  00159	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 40   : 	if(!g_ExLicense.user.MapQuest)

  0015c	0f b6 05 e7 00
	00 00		 movzx	 eax, BYTE PTR ?g_ExLicense@@3VCExLicense@@A+231
  00163	85 c0		 test	 eax, eax
  00165	75 02		 jne	 SHORT $LN1@Load

; 41   : 	{
; 42   : 		return;

  00167	eb 20		 jmp	 SHORT $LN2@Load
$LN1@Load:

; 43   : 	}
; 44   : 
; 45   : 
; 46   : 
; 47   : 	this->m_Data.clear();

  00169	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0016c	e8 00 00 00 00	 call	 ?clear@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAEXXZ ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::clear

; 48   : 	this->Read(gDirPath.GetNewPath("ExData\\MapQuest.ini"));

  00171	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@GHDKHEPN@ExData?2MapQuest?4ini?$AA@
  00176	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  0017b	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00180	50		 push	 eax
  00181	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00184	e8 00 00 00 00	 call	 ?Read@CMapQuest@@QAEXPAD@Z ; CMapQuest::Read
$LN2@Load:

; 49   : }

  00189	5f		 pop	 edi
  0018a	5e		 pop	 esi
  0018b	5b		 pop	 ebx
  0018c	8b e5		 mov	 esp, ebp
  0018e	5d		 pop	 ebp
  0018f	c3		 ret	 0
?Load@CMapQuest@@QAEXXZ ENDP				; CMapQuest::Load
_TEXT	ENDS
PUBLIC	??_C@_0CH@OECLMHKE@?$FLMapQuest?$FN?5?$FL?$CFd?$FN?5Quest?5loaded?5fro@ ; `string'
PUBLIC	?size@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QBEIXZ ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::size
PUBLIC	?push_back@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAEXABUMAPQUEST_DATA@@@Z ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::push_back
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	__$ArrayPad$
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	_fclose:PROC
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	?Get@CMsg@@QAEPADH@Z:PROC			; CMsg::Get
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
EXTRN	_fopen:PROC
EXTRN	__ftol2_sse:PROC
_BSS	SEGMENT
_TokenNumber DD	01H DUP (?)
_SMDFile DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0CH@OECLMHKE@?$FLMapQuest?$FN?5?$FL?$CFd?$FN?5Quest?5loaded?5fro@
CONST	SEGMENT
??_C@_0CH@OECLMHKE@?$FLMapQuest?$FN?5?$FL?$CFd?$FN?5Quest?5loaded?5fro@ DB '['
	DB	'MapQuest] [%d] Quest loaded from list', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_list$228432 = -40					; size = 28
_Token$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
?Read@CMapQuest@@QAEXPAD@Z PROC				; CMapQuest::Read
; _this$ = ecx

; 52   : {

  00190	55		 push	 ebp
  00191	8b ec		 mov	 ebp, esp
  00193	83 ec 68	 sub	 esp, 104		; 00000068H
  00196	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0019b	33 c5		 xor	 eax, ebp
  0019d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  001a0	53		 push	 ebx
  001a1	56		 push	 esi
  001a2	57		 push	 edi
  001a3	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 53   : 	int Token;
; 54   : 
; 55   : 	SMDFile = fopen(filename, "r");

  001a6	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  001ab	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  001ae	50		 push	 eax
  001af	e8 00 00 00 00	 call	 _fopen
  001b4	83 c4 08	 add	 esp, 8
  001b7	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax

; 56   : 
; 57   : 	if( SMDFile == NULL )

  001bc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SMDFile, 0
  001c3	75 1e		 jne	 SHORT $LN5@Read

; 58   : 	{
; 59   : 		MsgBox(lMsg.Get(MSGGET(0, 112)), filename);

  001c5	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  001c8	50		 push	 eax
  001c9	6a 70		 push	 112			; 00000070H
  001cb	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  001d0	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  001d5	50		 push	 eax
  001d6	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  001db	83 c4 08	 add	 esp, 8

; 60   : 		return;

  001de	e9 f0 00 00 00	 jmp	 $LN6@Read
$LN5@Read:

; 61   : 	}
; 62   : 
; 63   : 	while(true) 

  001e3	b8 01 00 00 00	 mov	 eax, 1
  001e8	85 c0		 test	 eax, eax
  001ea	0f 84 be 00 00
	00		 je	 $LN3@Read

; 64   : 	{
; 65   : 		Token = GetToken();

  001f0	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  001f5	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 66   : 
; 67   : 		if( Token == END)

  001f8	83 7d f4 02	 cmp	 DWORD PTR _Token$[ebp], 2
  001fc	75 05		 jne	 SHORT $LN2@Read

; 68   : 		{
; 69   : 			break;

  001fe	e9 ab 00 00 00	 jmp	 $LN3@Read
$LN2@Read:

; 70   : 		}
; 71   : 
; 72   : 		if( Token != NUMBER )

  00203	83 7d f4 01	 cmp	 DWORD PTR _Token$[ebp], 1
  00207	74 02		 je	 SHORT $LN1@Read

; 73   : 		{
; 74   : 			continue;

  00209	eb d8		 jmp	 SHORT $LN5@Read
$LN1@Read:

; 75   : 		}
; 76   : 
; 77   : 		MAPQUEST_DATA list;
; 78   : 		
; 79   : 		list.MapNum = TokenNumber;

  0020b	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00211	e8 00 00 00 00	 call	 __ftol2_sse
  00216	89 45 d8	 mov	 DWORD PTR _list$228432[ebp], eax

; 80   : 
; 81   : 		Token = GetToken();

  00219	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0021e	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 82   : 		list.MonsterCount = TokenNumber;

  00221	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00227	e8 00 00 00 00	 call	 __ftol2_sse
  0022c	89 45 dc	 mov	 DWORD PTR _list$228432[ebp+4], eax

; 83   : 
; 84   : 		Token = GetToken();

  0022f	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00234	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 85   : 		list.BossClass = TokenNumber;

  00237	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0023d	e8 00 00 00 00	 call	 __ftol2_sse
  00242	89 45 e0	 mov	 DWORD PTR _list$228432[ebp+8], eax

; 86   : 
; 87   : 		Token = GetToken();

  00245	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0024a	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 88   : 		list.BossX = TokenNumber;

  0024d	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00253	e8 00 00 00 00	 call	 __ftol2_sse
  00258	89 45 e4	 mov	 DWORD PTR _list$228432[ebp+12], eax

; 89   : 
; 90   : 		Token = GetToken();

  0025b	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00260	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 91   : 		list.BossY = TokenNumber;

  00263	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00269	e8 00 00 00 00	 call	 __ftol2_sse
  0026e	89 45 e8	 mov	 DWORD PTR _list$228432[ebp+16], eax

; 92   : 
; 93   : 		Token = GetToken();

  00271	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00276	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 94   : 		list.OrcClass = TokenNumber;

  00279	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0027f	e8 00 00 00 00	 call	 __ftol2_sse
  00284	89 45 ec	 mov	 DWORD PTR _list$228432[ebp+20], eax

; 95   : 
; 96   : 		Token = GetToken();

  00287	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0028c	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 97   : 		list.OrcCount = TokenNumber;

  0028f	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00295	e8 00 00 00 00	 call	 __ftol2_sse
  0029a	89 45 f0	 mov	 DWORD PTR _list$228432[ebp+24], eax

; 98   : 
; 99   : 		this->m_Data.push_back(list);

  0029d	8d 45 d8	 lea	 eax, DWORD PTR _list$228432[ebp]
  002a0	50		 push	 eax
  002a1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  002a4	e8 00 00 00 00	 call	 ?push_back@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAEXABUMAPQUEST_DATA@@@Z ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::push_back

; 100  : 	}

  002a9	e9 35 ff ff ff	 jmp	 $LN5@Read
$LN3@Read:

; 101  : 
; 102  : 	fclose(SMDFile);	

  002ae	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  002b3	50		 push	 eax
  002b4	e8 00 00 00 00	 call	 _fclose
  002b9	83 c4 04	 add	 esp, 4

; 103  : 
; 104  : 	LogAddTD("[MapQuest] [%d] Quest loaded from list", this->m_Data.size());

  002bc	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  002bf	e8 00 00 00 00	 call	 ?size@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QBEIXZ ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::size
  002c4	50		 push	 eax
  002c5	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@OECLMHKE@?$FLMapQuest?$FN?5?$FL?$CFd?$FN?5Quest?5loaded?5fro@
  002ca	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  002d0	83 c4 08	 add	 esp, 8
$LN6@Read:

; 105  : }

  002d3	5f		 pop	 edi
  002d4	5e		 pop	 esi
  002d5	5b		 pop	 ebx
  002d6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002d9	33 cd		 xor	 ecx, ebp
  002db	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002e0	8b e5		 mov	 esp, ebp
  002e2	5d		 pop	 ebp
  002e3	c2 04 00	 ret	 4
?Read@CMapQuest@@QAEXPAD@Z ENDP				; CMapQuest::Read
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_isalnum:PROC
EXTRN	_isalpha:PROC
EXTRN	_atof:PROC
EXTRN	_isdigit:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_isspace:PROC
EXTRN	_fgetc:PROC
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_CurrentToken DD 01H DUP (?)
_TokenString DB	064H DUP (?)
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\include\readscript.h
_BSS	ENDS
_TEXT	SEGMENT
tv90 = -180						; size = 4
_TempString$ = -112					; size = 100
_p$ = -12						; size = 4
_ch$ = -5						; size = 1
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken

; 24   : {

  002f0	55		 push	 ebp
  002f1	8b ec		 mov	 ebp, esp
  002f3	81 ec b4 00 00
	00		 sub	 esp, 180		; 000000b4H
  002f9	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  002fe	33 c5		 xor	 eax, ebp
  00300	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00303	53		 push	 ebx
  00304	56		 push	 esi
  00305	57		 push	 edi

; 25   : 	char ch;
; 26   : 	char* p;
; 27   : 	char TempString[100];
; 28   : 
; 29   : 	TokenString[0]=0;

  00306	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _TokenString, 0
$LN31@GetToken:

; 30   : 
; 31   : 	do
; 32   : 	{
; 33   : 		if ((ch=fgetc(SMDFile)) == -1)

  0030d	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00312	50		 push	 eax
  00313	e8 00 00 00 00	 call	 _fgetc
  00318	83 c4 04	 add	 esp, 4
  0031b	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0031e	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00322	83 f9 ff	 cmp	 ecx, -1
  00325	75 0c		 jne	 SHORT $LN28@GetToken

; 34   : 		{
; 35   : 			return END;	// End of FILE (EOF)

  00327	b8 02 00 00 00	 mov	 eax, 2
  0032c	e9 f7 02 00 00	 jmp	 $LN32@GetToken

; 36   : 		}
; 37   : 		else

  00331	eb 5b		 jmp	 SHORT $LN22@GetToken
$LN28@GetToken:

; 38   : 		{	
; 39   : 			if (ch=='/')		// this is /

  00333	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00337	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  0033a	75 52		 jne	 SHORT $LN22@GetToken

; 40   : 			{
; 41   : 				if((ch=fgetc(SMDFile)) == '/')

  0033c	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00341	50		 push	 eax
  00342	e8 00 00 00 00	 call	 _fgetc
  00347	83 c4 04	 add	 esp, 4
  0034a	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0034d	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00351	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  00354	75 38		 jne	 SHORT $LN22@GetToken
$LN24@GetToken:

; 42   : 				{
; 43   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  00356	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  0035a	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0035d	74 1c		 je	 SHORT $LN23@GetToken
  0035f	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00363	83 f8 ff	 cmp	 eax, -1
  00366	74 13		 je	 SHORT $LN23@GetToken

; 44   : 					{
; 45   : 						ch=fgetc(SMDFile);

  00368	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0036d	50		 push	 eax
  0036e	e8 00 00 00 00	 call	 _fgetc
  00373	83 c4 04	 add	 esp, 4
  00376	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al

; 46   : 					}

  00379	eb db		 jmp	 SHORT $LN24@GetToken
$LN23@GetToken:

; 47   : 	
; 48   : 					if (ch == -1)

  0037b	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  0037f	83 f8 ff	 cmp	 eax, -1
  00382	75 0a		 jne	 SHORT $LN22@GetToken

; 49   : 					{
; 50   : 						return END;	// End of FILE

  00384	b8 02 00 00 00	 mov	 eax, 2
  00389	e9 9a 02 00 00	 jmp	 $LN32@GetToken
$LN22@GetToken:

; 51   : 					}
; 52   : 				}
; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : 	while (isspace(ch) != 0);

  0038e	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00392	50		 push	 eax
  00393	e8 00 00 00 00	 call	 _isspace
  00398	83 c4 04	 add	 esp, 4
  0039b	85 c0		 test	 eax, eax
  0039d	0f 85 6a ff ff
	ff		 jne	 $LN31@GetToken

; 57   : 
; 58   : 	
; 59   : 	switch(ch)

  003a3	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  003a7	89 85 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], eax
  003ad	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR tv90[ebp]
  003b3	83 e9 22	 sub	 ecx, 34			; 00000022H
  003b6	89 8d 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], ecx
  003bc	83 bd 4c ff ff
	ff 5b		 cmp	 DWORD PTR tv90[ebp], 91	; 0000005bH
  003c3	0f 87 a3 01 00
	00		 ja	 $LN6@GetToken
  003c9	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR tv90[ebp]
  003cf	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN34@GetToken[edx]
  003d6	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN35@GetToken[eax*4]
$LN19@GetToken:

; 60   : 	{
; 61   : 
; 62   : 	case 0x23:	// #
; 63   : 		return CurrentToken=COMMAND;

  003dd	c7 05 00 00 00
	00 23 00 00 00	 mov	 DWORD PTR _CurrentToken, 35 ; 00000023H
  003e7	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  003ec	e9 37 02 00 00	 jmp	 $LN32@GetToken

; 64   : 		break;

  003f1	e9 30 02 00 00	 jmp	 $LN20@GetToken
$LN18@GetToken:

; 65   : 	
; 66   : 	case 0x3B:	// ;
; 67   : 		return CurrentToken=SEMICOLON;

  003f6	c7 05 00 00 00
	00 3b 00 00 00	 mov	 DWORD PTR _CurrentToken, 59 ; 0000003bH
  00400	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00405	e9 1e 02 00 00	 jmp	 $LN32@GetToken

; 68   : 		break;

  0040a	e9 17 02 00 00	 jmp	 $LN20@GetToken
$LN17@GetToken:

; 69   : 	
; 70   : 	case 0x2C:	// ,
; 71   : 
; 72   : 		return CurrentToken=COMMA;

  0040f	c7 05 00 00 00
	00 2c 00 00 00	 mov	 DWORD PTR _CurrentToken, 44 ; 0000002cH
  00419	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  0041e	e9 05 02 00 00	 jmp	 $LN32@GetToken

; 73   : 		break;

  00423	e9 fe 01 00 00	 jmp	 $LN20@GetToken
$LN16@GetToken:

; 74   : 	
; 75   : 	case 0x7B:	// {
; 76   : 		return CurrentToken = LP;

  00428	c7 05 00 00 00
	00 7b 00 00 00	 mov	 DWORD PTR _CurrentToken, 123 ; 0000007bH
  00432	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00437	e9 ec 01 00 00	 jmp	 $LN32@GetToken

; 77   : 		break;

  0043c	e9 e5 01 00 00	 jmp	 $LN20@GetToken
$LN15@GetToken:

; 78   : 
; 79   : 	case 0x7D:	// }
; 80   : 		return CurrentToken = RP;

  00441	c7 05 00 00 00
	00 7d 00 00 00	 mov	 DWORD PTR _CurrentToken, 125 ; 0000007dH
  0044b	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00450	e9 d3 01 00 00	 jmp	 $LN32@GetToken

; 81   : 		break;

  00455	e9 cc 01 00 00	 jmp	 $LN20@GetToken
$LN14@GetToken:

; 82   : 	// Nice Index Table :)	by Deathway
; 83   : 	// Numbers Case
; 84   : 	case 0x2D:	//-
; 85   : 	case 0x2E:	//.
; 86   : 	case '0':	//0
; 87   : 	case '1':	//1
; 88   : 	case '2':	//2
; 89   : 	case '3':	//3
; 90   : 	case '4':	//4		
; 91   : 	case '5':	//5
; 92   : 	case '6':	//6
; 93   : 	case '7':	//7
; 94   : 	case '8':	//8
; 95   : 	case '9':	//9
; 96   : 		ungetc(ch, SMDFile);

  0045a	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0045f	50		 push	 eax
  00460	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00464	51		 push	 ecx
  00465	e8 00 00 00 00	 call	 _ungetc
  0046a	83 c4 08	 add	 esp, 8

; 97   : 		p = TempString;

  0046d	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  00470	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN13@GetToken:

; 98   : 		
; 99   : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  00473	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00478	50		 push	 eax
  00479	e8 00 00 00 00	 call	 _getc
  0047e	83 c4 04	 add	 esp, 4
  00481	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00484	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00488	83 f9 ff	 cmp	 ecx, -1
  0048b	74 36		 je	 SHORT $LN12@GetToken
  0048d	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00491	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  00494	74 1a		 je	 SHORT $LN11@GetToken
  00496	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  0049a	50		 push	 eax
  0049b	e8 00 00 00 00	 call	 _isdigit
  004a0	83 c4 04	 add	 esp, 4
  004a3	85 c0		 test	 eax, eax
  004a5	75 09		 jne	 SHORT $LN11@GetToken
  004a7	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  004ab	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  004ae	75 13		 jne	 SHORT $LN12@GetToken
$LN11@GetToken:

; 100  : 		{
; 101  : 			*p = ch;	// Construct a String

  004b0	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  004b3	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  004b6	88 08		 mov	 BYTE PTR [eax], cl

; 102  : 			p++;

  004b8	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  004bb	83 c0 01	 add	 eax, 1
  004be	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 103  : 		}		

  004c1	eb b0		 jmp	 SHORT $LN13@GetToken
$LN12@GetToken:

; 104  : 		*p = 0;

  004c3	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  004c6	c6 00 00	 mov	 BYTE PTR [eax], 0

; 105  : 		TokenNumber = atof( TempString);	// Select the first Byte as Main ID

  004c9	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  004cc	50		 push	 eax
  004cd	e8 00 00 00 00	 call	 _atof
  004d2	83 c4 04	 add	 esp, 4
  004d5	d9 1d 00 00 00
	00		 fstp	 DWORD PTR _TokenNumber

; 106  : 		return CurrentToken  = NUMBER ;

  004db	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CurrentToken, 1
  004e5	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  004ea	e9 39 01 00 00	 jmp	 $LN32@GetToken

; 107  : 		break;

  004ef	e9 32 01 00 00	 jmp	 $LN20@GetToken
$LN10@GetToken:

; 108  : 
; 109  : 	case '\"':	// "	String Case
; 110  : 		p=&TokenString[0];

  004f4	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString
$LN9@GetToken:

; 111  : 		
; 112  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  004fb	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00500	50		 push	 eax
  00501	e8 00 00 00 00	 call	 _getc
  00506	83 c4 04	 add	 esp, 4
  00509	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0050c	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00510	83 f9 ff	 cmp	 ecx, -1
  00513	74 1c		 je	 SHORT $LN8@GetToken
  00515	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00519	83 f8 22	 cmp	 eax, 34			; 00000022H
  0051c	74 13		 je	 SHORT $LN8@GetToken

; 113  : 		{
; 114  : 			*p = ch;

  0051e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00521	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00524	88 08		 mov	 BYTE PTR [eax], cl

; 115  : 			p++;

  00526	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00529	83 c0 01	 add	 eax, 1
  0052c	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 116  : 		}

  0052f	eb ca		 jmp	 SHORT $LN9@GetToken
$LN8@GetToken:

; 117  : 		if (ch != 0x22 )

  00531	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00535	83 f8 22	 cmp	 eax, 34			; 00000022H
  00538	74 13		 je	 SHORT $LN7@GetToken

; 118  : 		{
; 119  : 			ungetc(ch, SMDFile);

  0053a	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0053f	50		 push	 eax
  00540	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00544	51		 push	 ecx
  00545	e8 00 00 00 00	 call	 _ungetc
  0054a	83 c4 08	 add	 esp, 8
$LN7@GetToken:

; 120  : 		}
; 121  : 		*p = 0;

  0054d	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00550	c6 00 00	 mov	 BYTE PTR [eax], 0

; 122  : 		return CurrentToken = NAME;

  00553	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0
  0055d	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00562	e9 c1 00 00 00	 jmp	 $LN32@GetToken

; 123  : 		break;

  00567	e9 ba 00 00 00	 jmp	 $LN20@GetToken
$LN6@GetToken:

; 124  : 
; 125  : 	default:	// Others
; 126  : 		if (isalpha(ch))

  0056c	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00570	50		 push	 eax
  00571	e8 00 00 00 00	 call	 _isalpha
  00576	83 c4 04	 add	 esp, 4
  00579	85 c0		 test	 eax, eax
  0057b	0f 84 94 00 00
	00		 je	 $LN5@GetToken

; 127  : 		{
; 128  : 			p=&TokenString[0];

  00581	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString

; 129  : 			*p=ch;

  00588	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0058b	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  0058e	88 08		 mov	 BYTE PTR [eax], cl

; 130  : 			p++;

  00590	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00593	83 c0 01	 add	 eax, 1
  00596	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN4@GetToken:

; 131  : 
; 132  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  00599	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0059e	50		 push	 eax
  0059f	e8 00 00 00 00	 call	 _getc
  005a4	83 c4 04	 add	 esp, 4
  005a7	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  005aa	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  005ae	83 f9 ff	 cmp	 ecx, -1
  005b1	74 36		 je	 SHORT $LN3@GetToken
  005b3	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  005b7	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  005ba	74 1a		 je	 SHORT $LN2@GetToken
  005bc	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  005c0	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  005c3	74 11		 je	 SHORT $LN2@GetToken
  005c5	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  005c9	50		 push	 eax
  005ca	e8 00 00 00 00	 call	 _isalnum
  005cf	83 c4 04	 add	 esp, 4
  005d2	85 c0		 test	 eax, eax
  005d4	74 13		 je	 SHORT $LN3@GetToken
$LN2@GetToken:

; 133  : 			{
; 134  : 				*p=ch;

  005d6	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  005d9	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  005dc	88 08		 mov	 BYTE PTR [eax], cl

; 135  : 				p++;

  005de	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  005e1	83 c0 01	 add	 eax, 1
  005e4	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 136  : 				
; 137  : 			}

  005e7	eb b0		 jmp	 SHORT $LN4@GetToken
$LN3@GetToken:

; 138  : 
; 139  : 			ungetc(ch, SMDFile);

  005e9	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  005ee	50		 push	 eax
  005ef	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  005f3	51		 push	 ecx
  005f4	e8 00 00 00 00	 call	 _ungetc
  005f9	83 c4 08	 add	 esp, 8

; 140  : 			*p=0;

  005fc	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  005ff	c6 00 00	 mov	 BYTE PTR [eax], 0

; 141  : 			CurrentToken=NAME;

  00602	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0

; 142  : 			return CurrentToken;

  0060c	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00611	eb 15		 jmp	 SHORT $LN32@GetToken

; 143  : 		}
; 144  : 		else

  00613	eb 11		 jmp	 SHORT $LN1@GetToken
$LN5@GetToken:

; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'

  00615	c7 05 00 00 00
	00 3c 00 00 00	 mov	 DWORD PTR _CurrentToken, 60 ; 0000003cH
  0061f	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00624	eb 02		 jmp	 SHORT $LN32@GetToken
$LN1@GetToken:
$LN20@GetToken:

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;

  00626	33 c0		 xor	 eax, eax
$LN32@GetToken:

; 153  : }

  00628	5f		 pop	 edi
  00629	5e		 pop	 esi
  0062a	5b		 pop	 ebx
  0062b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0062e	33 cd		 xor	 ecx, ebp
  00630	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00635	8b e5		 mov	 esp, ebp
  00637	5d		 pop	 ebp
  00638	c3		 ret	 0
  00639	8d 49 00	 npad	 3
$LN35@GetToken:
  0063c	00 00 00 00	 DD	 $LN10@GetToken
  00640	00 00 00 00	 DD	 $LN19@GetToken
  00644	00 00 00 00	 DD	 $LN17@GetToken
  00648	00 00 00 00	 DD	 $LN14@GetToken
  0064c	00 00 00 00	 DD	 $LN18@GetToken
  00650	00 00 00 00	 DD	 $LN16@GetToken
  00654	00 00 00 00	 DD	 $LN15@GetToken
  00658	00 00 00 00	 DD	 $LN6@GetToken
$LN34@GetToken:
  0065c	00		 DB	 0
  0065d	01		 DB	 1
  0065e	07		 DB	 7
  0065f	07		 DB	 7
  00660	07		 DB	 7
  00661	07		 DB	 7
  00662	07		 DB	 7
  00663	07		 DB	 7
  00664	07		 DB	 7
  00665	07		 DB	 7
  00666	02		 DB	 2
  00667	03		 DB	 3
  00668	03		 DB	 3
  00669	07		 DB	 7
  0066a	03		 DB	 3
  0066b	03		 DB	 3
  0066c	03		 DB	 3
  0066d	03		 DB	 3
  0066e	03		 DB	 3
  0066f	03		 DB	 3
  00670	03		 DB	 3
  00671	03		 DB	 3
  00672	03		 DB	 3
  00673	03		 DB	 3
  00674	07		 DB	 7
  00675	04		 DB	 4
  00676	07		 DB	 7
  00677	07		 DB	 7
  00678	07		 DB	 7
  00679	07		 DB	 7
  0067a	07		 DB	 7
  0067b	07		 DB	 7
  0067c	07		 DB	 7
  0067d	07		 DB	 7
  0067e	07		 DB	 7
  0067f	07		 DB	 7
  00680	07		 DB	 7
  00681	07		 DB	 7
  00682	07		 DB	 7
  00683	07		 DB	 7
  00684	07		 DB	 7
  00685	07		 DB	 7
  00686	07		 DB	 7
  00687	07		 DB	 7
  00688	07		 DB	 7
  00689	07		 DB	 7
  0068a	07		 DB	 7
  0068b	07		 DB	 7
  0068c	07		 DB	 7
  0068d	07		 DB	 7
  0068e	07		 DB	 7
  0068f	07		 DB	 7
  00690	07		 DB	 7
  00691	07		 DB	 7
  00692	07		 DB	 7
  00693	07		 DB	 7
  00694	07		 DB	 7
  00695	07		 DB	 7
  00696	07		 DB	 7
  00697	07		 DB	 7
  00698	07		 DB	 7
  00699	07		 DB	 7
  0069a	07		 DB	 7
  0069b	07		 DB	 7
  0069c	07		 DB	 7
  0069d	07		 DB	 7
  0069e	07		 DB	 7
  0069f	07		 DB	 7
  006a0	07		 DB	 7
  006a1	07		 DB	 7
  006a2	07		 DB	 7
  006a3	07		 DB	 7
  006a4	07		 DB	 7
  006a5	07		 DB	 7
  006a6	07		 DB	 7
  006a7	07		 DB	 7
  006a8	07		 DB	 7
  006a9	07		 DB	 7
  006aa	07		 DB	 7
  006ab	07		 DB	 7
  006ac	07		 DB	 7
  006ad	07		 DB	 7
  006ae	07		 DB	 7
  006af	07		 DB	 7
  006b0	07		 DB	 7
  006b1	07		 DB	 7
  006b2	07		 DB	 7
  006b3	07		 DB	 7
  006b4	07		 DB	 7
  006b5	05		 DB	 5
  006b6	07		 DB	 7
  006b7	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
PUBLIC	?AddBossEx@CMapQuest@@QAEXHHHHHH@Z		; CMapQuest::AddBossEx
PUBLIC	?DelMonster@CMapQuest@@QAEXHH@Z			; CMapQuest::DelMonster
PUBLIC	?DelMonsterMap@CMapQuest@@QAEXH@Z		; CMapQuest::DelMonsterMap
PUBLIC	?GCInfo@CMapQuest@@QAEXH_NHH@Z			; CMapQuest::GCInfo
PUBLIC	??A?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAEAAUMAPQUEST_DATA@@I@Z ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::operator[]
PUBLIC	?MonsterKill@CMapQuest@@QAEXHH@Z		; CMapQuest::MonsterKill
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\mapquest.cpp
_TEXT	SEGMENT
tv87 = -88						; size = 4
tv74 = -88						; size = 4
tv69 = -88						; size = 4
_quest$228449 = -20					; size = 4
_i$228445 = -16						; size = 4
_lpMonster$ = -12					; size = 4
_lpUser$ = -8						; size = 4
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
?MonsterKill@CMapQuest@@QAEXHH@Z PROC			; CMapQuest::MonsterKill
; _this$ = ecx

; 108  : {

  006c0	55		 push	 ebp
  006c1	8b ec		 mov	 ebp, esp
  006c3	83 ec 58	 sub	 esp, 88			; 00000058H
  006c6	53		 push	 ebx
  006c7	56		 push	 esi
  006c8	57		 push	 edi
  006c9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 109  : 	if(!g_ExLicense.user.MapQuest)

  006cc	0f b6 05 e7 00
	00 00		 movzx	 eax, BYTE PTR ?g_ExLicense@@3VCExLicense@@A+231
  006d3	85 c0		 test	 eax, eax
  006d5	75 05		 jne	 SHORT $LN14@MonsterKil

; 110  : 	{
; 111  : 		return;

  006d7	e9 53 02 00 00	 jmp	 $LN15@MonsterKil
$LN14@MonsterKil:

; 112  : 	}
; 113  : 
; 114  : 	if ( !OBJMAX_RANGE(aIndex) || !OBJMAX_RANGE(aTargetIndex) )

  006dc	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  006e0	7d 09		 jge	 SHORT $LN17@MonsterKil
  006e2	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
  006e9	eb 0f		 jmp	 SHORT $LN18@MonsterKil
$LN17@MonsterKil:
  006eb	33 c0		 xor	 eax, eax
  006ed	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  006f4	0f 9e c0	 setle	 al
  006f7	89 45 a8	 mov	 DWORD PTR tv69[ebp], eax
$LN18@MonsterKil:
  006fa	83 7d a8 00	 cmp	 DWORD PTR tv69[ebp], 0
  006fe	74 24		 je	 SHORT $LN12@MonsterKil
  00700	83 7d 0c 00	 cmp	 DWORD PTR _aTargetIndex$[ebp], 0
  00704	7d 09		 jge	 SHORT $LN19@MonsterKil
  00706	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
  0070d	eb 0f		 jmp	 SHORT $LN20@MonsterKil
$LN19@MonsterKil:
  0070f	33 c0		 xor	 eax, eax
  00711	81 7d 0c 97 3a
	00 00		 cmp	 DWORD PTR _aTargetIndex$[ebp], 14999 ; 00003a97H
  00718	0f 9e c0	 setle	 al
  0071b	89 45 a8	 mov	 DWORD PTR tv74[ebp], eax
$LN20@MonsterKil:
  0071e	83 7d a8 00	 cmp	 DWORD PTR tv74[ebp], 0
  00722	75 05		 jne	 SHORT $LN13@MonsterKil
$LN12@MonsterKil:

; 115  : 	{
; 116  : 		return;

  00724	e9 06 02 00 00	 jmp	 $LN15@MonsterKil
$LN13@MonsterKil:

; 117  : 	}
; 118  : 
; 119  : 	LPOBJ lpUser = &gObj[aIndex];

  00729	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0072c	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00732	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00738	89 45 f8	 mov	 DWORD PTR _lpUser$[ebp], eax

; 120  : 	LPOBJ lpMonster = &gObj[aTargetIndex];

  0073b	8b 45 0c	 mov	 eax, DWORD PTR _aTargetIndex$[ebp]
  0073e	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00744	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0074a	89 45 f4	 mov	 DWORD PTR _lpMonster$[ebp], eax

; 121  : 
; 122  : 	if ( MAX_MAP_RANGE(lpMonster->MapNumber) == FALSE ) 

  0074d	8b 45 f4	 mov	 eax, DWORD PTR _lpMonster$[ebp]
  00750	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  00757	85 c9		 test	 ecx, ecx
  00759	7d 09		 jge	 SHORT $LN21@MonsterKil
  0075b	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv87[ebp], 0
  00762	eb 15		 jmp	 SHORT $LN22@MonsterKil
$LN21@MonsterKil:
  00764	8b 55 f4	 mov	 edx, DWORD PTR _lpMonster$[ebp]
  00767	0f b6 82 49 01
	00 00		 movzx	 eax, BYTE PTR [edx+329]
  0076e	33 c9		 xor	 ecx, ecx
  00770	83 f8 59	 cmp	 eax, 89			; 00000059H
  00773	0f 9e c1	 setle	 cl
  00776	89 4d a8	 mov	 DWORD PTR tv87[ebp], ecx
$LN22@MonsterKil:
  00779	83 7d a8 00	 cmp	 DWORD PTR tv87[ebp], 0
  0077d	75 05		 jne	 SHORT $LN11@MonsterKil

; 123  : 	{
; 124  : 		return;

  0077f	e9 ab 01 00 00	 jmp	 $LN15@MonsterKil
$LN11@MonsterKil:

; 125  : 	}
; 126  : 
; 127  : 	for( int i = 0; i < this->m_Data.size(); i++ )

  00784	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$228445[ebp], 0
  0078b	eb 09		 jmp	 SHORT $LN10@MonsterKil
$LN9@MonsterKil:
  0078d	8b 45 f0	 mov	 eax, DWORD PTR _i$228445[ebp]
  00790	83 c0 01	 add	 eax, 1
  00793	89 45 f0	 mov	 DWORD PTR _i$228445[ebp], eax
$LN10@MonsterKil:
  00796	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00799	e8 00 00 00 00	 call	 ?size@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QBEIXZ ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::size
  0079e	39 45 f0	 cmp	 DWORD PTR _i$228445[ebp], eax
  007a1	0f 83 88 01 00
	00		 jae	 $LN15@MonsterKil

; 128  : 	{
; 129  : 		MAPQUEST_DATA & quest = this->m_Data[i];

  007a7	8b 45 f0	 mov	 eax, DWORD PTR _i$228445[ebp]
  007aa	50		 push	 eax
  007ab	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  007ae	e8 00 00 00 00	 call	 ??A?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAEAAUMAPQUEST_DATA@@I@Z ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::operator[]
  007b3	89 45 ec	 mov	 DWORD PTR _quest$228449[ebp], eax

; 130  : 
; 131  : 		if(lpMonster->MapNumber == quest.MapNum)

  007b6	8b 45 f4	 mov	 eax, DWORD PTR _lpMonster$[ebp]
  007b9	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  007c0	8b 55 ec	 mov	 edx, DWORD PTR _quest$228449[ebp]
  007c3	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  007c5	0f 85 5f 01 00
	00		 jne	 $LN7@MonsterKil

; 132  : 		{
; 133  : 			if(this->m_BossStart[lpMonster->MapNumber] == true)

  007cb	8b 45 f4	 mov	 eax, DWORD PTR _lpMonster$[ebp]
  007ce	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  007d5	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  007d8	0f b6 84 0a 78
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+376]
  007e0	83 f8 01	 cmp	 eax, 1
  007e3	0f 85 a6 00 00
	00		 jne	 $LN6@MonsterKil

; 134  : 			{
; 135  : 				if(lpMonster->Class == quest.BossClass)

  007e9	8b 45 f4	 mov	 eax, DWORD PTR _lpMonster$[ebp]
  007ec	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  007f3	8b 55 ec	 mov	 edx, DWORD PTR _quest$228449[ebp]
  007f6	3b 4a 08	 cmp	 ecx, DWORD PTR [edx+8]
  007f9	75 66		 jne	 SHORT $LN5@MonsterKil

; 136  : 				{
; 137  : 					this->m_BossStart[lpMonster->MapNumber] = false;

  007fb	8b 45 f4	 mov	 eax, DWORD PTR _lpMonster$[ebp]
  007fe	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  00805	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00808	c6 84 0a 78 01
	00 00 00	 mov	 BYTE PTR [edx+ecx+376], 0

; 138  : 					this->m_MapKillCount[lpMonster->MapNumber] = 0;

  00810	8b 45 f4	 mov	 eax, DWORD PTR _lpMonster$[ebp]
  00813	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  0081a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0081d	c7 44 8a 10 00
	00 00 00	 mov	 DWORD PTR [edx+ecx*4+16], 0

; 139  : 					this->GCInfo(aIndex, true, this->m_MapKillCount[lpMonster->MapNumber], quest.MonsterCount);

  00825	8b 45 ec	 mov	 eax, DWORD PTR _quest$228449[ebp]
  00828	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0082b	51		 push	 ecx
  0082c	8b 55 f4	 mov	 edx, DWORD PTR _lpMonster$[ebp]
  0082f	0f b6 82 49 01
	00 00		 movzx	 eax, BYTE PTR [edx+329]
  00836	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00839	8b 54 81 10	 mov	 edx, DWORD PTR [ecx+eax*4+16]
  0083d	52		 push	 edx
  0083e	6a 01		 push	 1
  00840	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00843	50		 push	 eax
  00844	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00847	e8 00 00 00 00	 call	 ?GCInfo@CMapQuest@@QAEXH_NHH@Z ; CMapQuest::GCInfo

; 140  : 
; 141  : 					this->DelMonsterMap(lpMonster->MapNumber);

  0084c	8b 45 f4	 mov	 eax, DWORD PTR _lpMonster$[ebp]
  0084f	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  00856	51		 push	 ecx
  00857	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0085a	e8 00 00 00 00	 call	 ?DelMonsterMap@CMapQuest@@QAEXH@Z ; CMapQuest::DelMonsterMap
  0085f	eb 29		 jmp	 SHORT $LN4@MonsterKil
$LN5@MonsterKil:

; 142  : 				}	
; 143  : 				else if(lpMonster->Class == quest.OrcClass)

  00861	8b 45 f4	 mov	 eax, DWORD PTR _lpMonster$[ebp]
  00864	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  0086b	8b 55 ec	 mov	 edx, DWORD PTR _quest$228449[ebp]
  0086e	3b 4a 14	 cmp	 ecx, DWORD PTR [edx+20]
  00871	75 17		 jne	 SHORT $LN4@MonsterKil

; 144  : 				{
; 145  : 					this->DelMonster(aTargetIndex, lpMonster->MapNumber);

  00873	8b 45 f4	 mov	 eax, DWORD PTR _lpMonster$[ebp]
  00876	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  0087d	51		 push	 ecx
  0087e	8b 55 0c	 mov	 edx, DWORD PTR _aTargetIndex$[ebp]
  00881	52		 push	 edx
  00882	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00885	e8 00 00 00 00	 call	 ?DelMonster@CMapQuest@@QAEXHH@Z ; CMapQuest::DelMonster
$LN4@MonsterKil:

; 146  : 				}					
; 147  : 			}
; 148  : 			else 

  0088a	e9 9b 00 00 00	 jmp	 $LN7@MonsterKil
$LN6@MonsterKil:

; 149  : 			{
; 150  : 				this->m_MapKillCount[lpMonster->MapNumber]++;		

  0088f	8b 45 f4	 mov	 eax, DWORD PTR _lpMonster$[ebp]
  00892	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  00899	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0089c	8b 44 8a 10	 mov	 eax, DWORD PTR [edx+ecx*4+16]
  008a0	83 c0 01	 add	 eax, 1
  008a3	8b 4d f4	 mov	 ecx, DWORD PTR _lpMonster$[ebp]
  008a6	0f b6 91 49 01
	00 00		 movzx	 edx, BYTE PTR [ecx+329]
  008ad	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  008b0	89 44 91 10	 mov	 DWORD PTR [ecx+edx*4+16], eax

; 151  : 				if(this->m_MapKillCount[lpMonster->MapNumber] >= quest.MonsterCount)

  008b4	8b 45 f4	 mov	 eax, DWORD PTR _lpMonster$[ebp]
  008b7	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  008be	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  008c1	8b 45 ec	 mov	 eax, DWORD PTR _quest$228449[ebp]
  008c4	8b 4c 8a 10	 mov	 ecx, DWORD PTR [edx+ecx*4+16]
  008c8	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  008cb	7c 36		 jl	 SHORT $LN1@MonsterKil

; 152  : 				{
; 153  : 					this->AddBossEx(lpMonster->MapNumber, quest.BossClass, quest.BossX, quest.BossY, quest.OrcClass, quest.OrcCount);	

  008cd	8b 45 ec	 mov	 eax, DWORD PTR _quest$228449[ebp]
  008d0	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  008d3	51		 push	 ecx
  008d4	8b 55 ec	 mov	 edx, DWORD PTR _quest$228449[ebp]
  008d7	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  008da	50		 push	 eax
  008db	8b 4d ec	 mov	 ecx, DWORD PTR _quest$228449[ebp]
  008de	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  008e1	52		 push	 edx
  008e2	8b 45 ec	 mov	 eax, DWORD PTR _quest$228449[ebp]
  008e5	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  008e8	51		 push	 ecx
  008e9	8b 55 ec	 mov	 edx, DWORD PTR _quest$228449[ebp]
  008ec	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  008ef	50		 push	 eax
  008f0	8b 4d f4	 mov	 ecx, DWORD PTR _lpMonster$[ebp]
  008f3	0f b6 91 49 01
	00 00		 movzx	 edx, BYTE PTR [ecx+329]
  008fa	52		 push	 edx
  008fb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  008fe	e8 00 00 00 00	 call	 ?AddBossEx@CMapQuest@@QAEXHHHHHH@Z ; CMapQuest::AddBossEx
$LN1@MonsterKil:

; 154  : 					//this->m_MapKillCount[lpMonster->MapNumber] = 0;
; 155  : 				}
; 156  : 				this->GCInfo(aIndex, true, this->m_MapKillCount[lpMonster->MapNumber], quest.MonsterCount);

  00903	8b 45 ec	 mov	 eax, DWORD PTR _quest$228449[ebp]
  00906	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00909	51		 push	 ecx
  0090a	8b 55 f4	 mov	 edx, DWORD PTR _lpMonster$[ebp]
  0090d	0f b6 82 49 01
	00 00		 movzx	 eax, BYTE PTR [edx+329]
  00914	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00917	8b 54 81 10	 mov	 edx, DWORD PTR [ecx+eax*4+16]
  0091b	52		 push	 edx
  0091c	6a 01		 push	 1
  0091e	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00921	50		 push	 eax
  00922	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00925	e8 00 00 00 00	 call	 ?GCInfo@CMapQuest@@QAEXH_NHH@Z ; CMapQuest::GCInfo
$LN7@MonsterKil:

; 157  : 			}
; 158  : 		}
; 159  : 	}

  0092a	e9 5e fe ff ff	 jmp	 $LN9@MonsterKil
$LN15@MonsterKil:

; 160  : }

  0092f	5f		 pop	 edi
  00930	5e		 pop	 esi
  00931	5b		 pop	 ebx
  00932	8b e5		 mov	 esp, ebp
  00934	5d		 pop	 ebp
  00935	c2 08 00	 ret	 8
?MonsterKill@CMapQuest@@QAEXHH@Z ENDP			; CMapQuest::MonsterKill
_TEXT	ENDS
PUBLIC	??_C@_0BO@MJJEBMGN@?$FLMap?5Quest?$FN?5Boss?5?$CFs?5in?5?$CFs?5map?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?AddBoss@CMapQuest@@QAEXHHHHHH@Z		; CMapQuest::AddBoss
EXTRN	?GetBoxPosition@CMonsterSetBase@@QAEHHHHHHAAF0@Z:PROC ; CMonsterSetBase::GetBoxPosition
EXTRN	?gMSetBase@@3VCMonsterSetBase@@A:BYTE		; gMSetBase
EXTRN	?AllSendServerMsg@@YAXPAD@Z:PROC		; AllSendServerMsg
EXTRN	_sprintf:PROC
EXTRN	?exMapName@@YAPADH@Z:PROC			; exMapName
EXTRN	?gObjSetMonster@@YAHHH@Z:PROC			; gObjSetMonster
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	_rand:PROC
EXTRN	?gObjAddMonster@@YAFH@Z:PROC			; gObjAddMonster
;	COMDAT ??_C@_0BO@MJJEBMGN@?$FLMap?5Quest?$FN?5Boss?5?$CFs?5in?5?$CFs?5map?$AA@
CONST	SEGMENT
??_C@_0BO@MJJEBMGN@?$FLMap?5Quest?$FN?5Boss?5?$CFs?5in?5?$CFs?5map?$AA@ DB '['
	DB	'Map Quest] Boss %s in %s map', 00H		; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv219 = -224						; size = 4
tv71 = -224						; size = 4
_OrcIndex$228477 = -156					; size = 4
_i$228473 = -152					; size = 4
_Y$ = -148						; size = 2
_X$ = -144						; size = 2
_szMsg$ = -140						; size = 128
_BossIndex$ = -12					; size = 2
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_Map$ = 8						; size = 4
_BossClass$ = 12					; size = 4
_BossX$ = 16						; size = 4
_BossY$ = 20						; size = 4
_OrcClass$ = 24						; size = 4
_OrcCount$ = 28						; size = 4
?AddBoss@CMapQuest@@QAEXHHHHHH@Z PROC			; CMapQuest::AddBoss
; _this$ = ecx

; 163  : {

  00940	55		 push	 ebp
  00941	8b ec		 mov	 ebp, esp
  00943	81 ec e0 00 00
	00		 sub	 esp, 224		; 000000e0H
  00949	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0094e	33 c5		 xor	 eax, ebp
  00950	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00953	53		 push	 ebx
  00954	56		 push	 esi
  00955	57		 push	 edi
  00956	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 164  : 	short BossIndex = gObjAddMonster(Map);

  00959	8b 45 08	 mov	 eax, DWORD PTR _Map$[ebp]
  0095c	50		 push	 eax
  0095d	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  00962	83 c4 04	 add	 esp, 4
  00965	66 89 45 f4	 mov	 WORD PTR _BossIndex$[ebp], ax

; 165  : 
; 166  : 	if(!OBJMAX_RANGE(BossIndex))

  00969	0f bf 45 f4	 movsx	 eax, WORD PTR _BossIndex$[ebp]
  0096d	85 c0		 test	 eax, eax
  0096f	7d 0c		 jge	 SHORT $LN8@AddBoss
  00971	c7 85 20 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv71[ebp], 0
  0097b	eb 15		 jmp	 SHORT $LN9@AddBoss
$LN8@AddBoss:
  0097d	0f bf 4d f4	 movsx	 ecx, WORD PTR _BossIndex$[ebp]
  00981	33 d2		 xor	 edx, edx
  00983	81 f9 97 3a 00
	00		 cmp	 ecx, 14999		; 00003a97H
  00989	0f 9e c2	 setle	 dl
  0098c	89 95 20 ff ff
	ff		 mov	 DWORD PTR tv71[ebp], edx
$LN9@AddBoss:
  00992	83 bd 20 ff ff
	ff 00		 cmp	 DWORD PTR tv71[ebp], 0
  00999	75 05		 jne	 SHORT $LN5@AddBoss

; 167  : 	{
; 168  : 		return;

  0099b	e9 a2 05 00 00	 jmp	 $LN6@AddBoss
$LN5@AddBoss:

; 169  : 	}
; 170  : 
; 171  : 	gObj[BossIndex].m_PosNum = (WORD)-1;

  009a0	0f bf 45 f4	 movsx	 eax, WORD PTR _BossIndex$[ebp]
  009a4	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  009aa	83 c9 ff	 or	 ecx, -1
  009ad	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  009b3	66 89 8c 02 b0
	03 00 00	 mov	 WORD PTR [edx+eax+944], cx

; 172  : 	gObj[BossIndex].MapNumber = Map;

  009bb	0f bf 45 f4	 movsx	 eax, WORD PTR _BossIndex$[ebp]
  009bf	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  009c5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  009cb	8a 55 08	 mov	 dl, BYTE PTR _Map$[ebp]
  009ce	88 94 01 49 01
	00 00		 mov	 BYTE PTR [ecx+eax+329], dl

; 173  : 	gObj[BossIndex].Dir = rand()%8;

  009d5	e8 00 00 00 00	 call	 _rand
  009da	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  009df	79 05		 jns	 SHORT $LN12@AddBoss
  009e1	48		 dec	 eax
  009e2	83 c8 f8	 or	 eax, -8			; fffffff8H
  009e5	40		 inc	 eax
$LN12@AddBoss:
  009e6	0f bf 4d f4	 movsx	 ecx, WORD PTR _BossIndex$[ebp]
  009ea	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  009f0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  009f6	88 84 0a 48 01
	00 00		 mov	 BYTE PTR [edx+ecx+328], al

; 174  : 	gObj[BossIndex].X = BossX;

  009fd	0f bf 45 f4	 movsx	 eax, WORD PTR _BossIndex$[ebp]
  00a01	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00a07	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00a0d	66 8b 55 10	 mov	 dx, WORD PTR _BossX$[ebp]
  00a11	66 89 94 01 44
	01 00 00	 mov	 WORD PTR [ecx+eax+324], dx

; 175  : 	gObj[BossIndex].Y = BossY;

  00a19	0f bf 45 f4	 movsx	 eax, WORD PTR _BossIndex$[ebp]
  00a1d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00a23	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00a29	66 8b 55 14	 mov	 dx, WORD PTR _BossY$[ebp]
  00a2d	66 89 94 01 46
	01 00 00	 mov	 WORD PTR [ecx+eax+326], dx

; 176  : 	gObj[BossIndex].TX = BossX;

  00a35	0f bf 45 f4	 movsx	 eax, WORD PTR _BossIndex$[ebp]
  00a39	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00a3f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00a45	66 8b 55 10	 mov	 dx, WORD PTR _BossX$[ebp]
  00a49	66 89 94 01 7c
	01 00 00	 mov	 WORD PTR [ecx+eax+380], dx

; 177  : 	gObj[BossIndex].TY = BossY;

  00a51	0f bf 45 f4	 movsx	 eax, WORD PTR _BossIndex$[ebp]
  00a55	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00a5b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00a61	66 8b 55 14	 mov	 dx, WORD PTR _BossY$[ebp]
  00a65	66 89 94 01 7e
	01 00 00	 mov	 WORD PTR [ecx+eax+382], dx

; 178  : 	gObj[BossIndex].m_OldX = BossX;

  00a6d	0f bf 45 f4	 movsx	 eax, WORD PTR _BossIndex$[ebp]
  00a71	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00a77	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00a7d	66 8b 55 10	 mov	 dx, WORD PTR _BossX$[ebp]
  00a81	66 89 94 01 78
	01 00 00	 mov	 WORD PTR [ecx+eax+376], dx

; 179  : 	gObj[BossIndex].m_OldY = BossY;

  00a89	0f bf 45 f4	 movsx	 eax, WORD PTR _BossIndex$[ebp]
  00a8d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00a93	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00a99	66 8b 55 14	 mov	 dx, WORD PTR _BossY$[ebp]
  00a9d	66 89 94 01 7a
	01 00 00	 mov	 WORD PTR [ecx+eax+378], dx

; 180  : 	gObj[BossIndex].StartX = BossX;

  00aa5	0f bf 45 f4	 movsx	 eax, WORD PTR _BossIndex$[ebp]
  00aa9	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00aaf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00ab5	8a 55 10	 mov	 dl, BYTE PTR _BossX$[ebp]
  00ab8	88 94 01 76 01
	00 00		 mov	 BYTE PTR [ecx+eax+374], dl

; 181  : 	gObj[BossIndex].StartY = BossY;

  00abf	0f bf 45 f4	 movsx	 eax, WORD PTR _BossIndex$[ebp]
  00ac3	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00ac9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00acf	8a 55 14	 mov	 dl, BYTE PTR _BossY$[ebp]
  00ad2	88 94 01 77 01
	00 00		 mov	 BYTE PTR [ecx+eax+375], dl

; 182  : 	gObj[BossIndex].MaxRegenTime = 0;

  00ad9	0f bf 45 f4	 movsx	 eax, WORD PTR _BossIndex$[ebp]
  00add	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00ae3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00ae9	c7 84 01 ac 03
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+940], 0

; 183  : 	gObj[BossIndex].Dir = rand()%8;

  00af4	e8 00 00 00 00	 call	 _rand
  00af9	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  00afe	79 05		 jns	 SHORT $LN13@AddBoss
  00b00	48		 dec	 eax
  00b01	83 c8 f8	 or	 eax, -8			; fffffff8H
  00b04	40		 inc	 eax
$LN13@AddBoss:
  00b05	0f bf 4d f4	 movsx	 ecx, WORD PTR _BossIndex$[ebp]
  00b09	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  00b0f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00b15	88 84 0a 48 01
	00 00		 mov	 BYTE PTR [edx+ecx+328], al

; 184  : 	gObj[BossIndex].RegenTime = GetTickCount();

  00b1c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00b22	0f bf 4d f4	 movsx	 ecx, WORD PTR _BossIndex$[ebp]
  00b26	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  00b2c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00b32	89 84 0a a8 03
	00 00		 mov	 DWORD PTR [edx+ecx+936], eax

; 185  : 	gObj[BossIndex].m_ActState.Emotion = 1;

  00b39	0f bf 45 f4	 movsx	 eax, WORD PTR _BossIndex$[ebp]
  00b3d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00b43	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00b49	8b 94 01 18 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+536]
  00b50	81 e2 0f ff ff
	ff		 and	 edx, -241		; ffffff0fH
  00b56	83 ca 10	 or	 edx, 16			; 00000010H
  00b59	0f bf 45 f4	 movsx	 eax, WORD PTR _BossIndex$[ebp]
  00b5d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00b63	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00b69	89 94 01 18 02
	00 00		 mov	 DWORD PTR [ecx+eax+536], edx

; 186  : 	gObj[BossIndex].m_ActState.EmotionCount = 15;

  00b70	0f bf 45 f4	 movsx	 eax, WORD PTR _BossIndex$[ebp]
  00b74	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00b7a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00b80	8b 94 01 18 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+536]
  00b87	81 e2 ff 00 ff
	ff		 and	 edx, -65281		; ffff00ffH
  00b8d	81 ca 00 0f 00
	00		 or	 edx, 3840		; 00000f00H
  00b93	0f bf 45 f4	 movsx	 eax, WORD PTR _BossIndex$[ebp]
  00b97	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00b9d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00ba3	89 94 01 18 02
	00 00		 mov	 DWORD PTR [ecx+eax+536], edx

; 187  : 
; 188  : 	gObjSetMonster(BossIndex, BossClass);

  00baa	8b 45 0c	 mov	 eax, DWORD PTR _BossClass$[ebp]
  00bad	50		 push	 eax
  00bae	0f bf 4d f4	 movsx	 ecx, WORD PTR _BossIndex$[ebp]
  00bb2	51		 push	 ecx
  00bb3	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster
  00bb8	83 c4 08	 add	 esp, 8

; 189  : 
; 190  : 	char szMsg[128];
; 191  : 	sprintf(szMsg,"[Map Quest] Boss %s in %s map", gObj[BossIndex].Name, exMapName(gObj[BossIndex].MapNumber));

  00bbb	0f bf 45 f4	 movsx	 eax, WORD PTR _BossIndex$[ebp]
  00bbf	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00bc5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00bcb	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  00bd3	52		 push	 edx
  00bd4	e8 00 00 00 00	 call	 ?exMapName@@YAPADH@Z	; exMapName
  00bd9	83 c4 04	 add	 esp, 4
  00bdc	50		 push	 eax
  00bdd	0f bf 45 f4	 movsx	 eax, WORD PTR _BossIndex$[ebp]
  00be1	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00be7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00bed	8d 54 01 77	 lea	 edx, DWORD PTR [ecx+eax+119]
  00bf1	52		 push	 edx
  00bf2	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@MJJEBMGN@?$FLMap?5Quest?$FN?5Boss?5?$CFs?5in?5?$CFs?5map?$AA@
  00bf7	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _szMsg$[ebp]
  00bfd	50		 push	 eax
  00bfe	e8 00 00 00 00	 call	 _sprintf
  00c03	83 c4 10	 add	 esp, 16			; 00000010H

; 192  : 	AllSendServerMsg(szMsg);

  00c06	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _szMsg$[ebp]
  00c0c	50		 push	 eax
  00c0d	e8 00 00 00 00	 call	 ?AllSendServerMsg@@YAXPAD@Z ; AllSendServerMsg
  00c12	83 c4 04	 add	 esp, 4

; 193  : 
; 194  : 	this->m_BossStart[Map] = true;

  00c15	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00c18	03 45 08	 add	 eax, DWORD PTR _Map$[ebp]
  00c1b	c6 80 78 01 00
	00 01		 mov	 BYTE PTR [eax+376], 1

; 195  : 
; 196  : 	short X = BossX;

  00c22	66 8b 45 10	 mov	 ax, WORD PTR _BossX$[ebp]
  00c26	66 89 85 70 ff
	ff ff		 mov	 WORD PTR _X$[ebp], ax

; 197  : 	short Y = BossY;

  00c2d	66 8b 45 14	 mov	 ax, WORD PTR _BossY$[ebp]
  00c31	66 89 85 6c ff
	ff ff		 mov	 WORD PTR _Y$[ebp], ax

; 198  : 
; 199  : 	for(int i = 0; i < OrcCount; i++)

  00c38	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$228473[ebp], 0
  00c42	eb 0f		 jmp	 SHORT $LN4@AddBoss
$LN3@AddBoss:
  00c44	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _i$228473[ebp]
  00c4a	83 c0 01	 add	 eax, 1
  00c4d	89 85 68 ff ff
	ff		 mov	 DWORD PTR _i$228473[ebp], eax
$LN4@AddBoss:
  00c53	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _i$228473[ebp]
  00c59	3b 45 1c	 cmp	 eax, DWORD PTR _OrcCount$[ebp]
  00c5c	0f 8d e0 02 00
	00		 jge	 $LN6@AddBoss

; 200  : 	{
; 201  : 		int OrcIndex = gObjAddMonster(Map);

  00c62	8b 45 08	 mov	 eax, DWORD PTR _Map$[ebp]
  00c65	50		 push	 eax
  00c66	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  00c6b	83 c4 04	 add	 esp, 4
  00c6e	0f bf c8	 movsx	 ecx, ax
  00c71	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _OrcIndex$228477[ebp], ecx

; 202  : 
; 203  : 		if(!OBJMAX_RANGE(OrcIndex))

  00c77	83 bd 64 ff ff
	ff 00		 cmp	 DWORD PTR _OrcIndex$228477[ebp], 0
  00c7e	7d 0c		 jge	 SHORT $LN10@AddBoss
  00c80	c7 85 20 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv219[ebp], 0
  00c8a	eb 15		 jmp	 SHORT $LN11@AddBoss
$LN10@AddBoss:
  00c8c	33 c0		 xor	 eax, eax
  00c8e	81 bd 64 ff ff
	ff 97 3a 00 00	 cmp	 DWORD PTR _OrcIndex$228477[ebp], 14999 ; 00003a97H
  00c98	0f 9e c0	 setle	 al
  00c9b	89 85 20 ff ff
	ff		 mov	 DWORD PTR tv219[ebp], eax
$LN11@AddBoss:
  00ca1	83 bd 20 ff ff
	ff 00		 cmp	 DWORD PTR tv219[ebp], 0
  00ca8	75 02		 jne	 SHORT $LN1@AddBoss

; 204  : 		{
; 205  : 			continue;

  00caa	eb 98		 jmp	 SHORT $LN3@AddBoss
$LN1@AddBoss:

; 206  : 		}
; 207  : 
; 208  : 		gMSetBase.GetBoxPosition(Map, (BossX - 5), (BossY - 5), (BossX + 5), (BossY + 5), X, Y);

  00cac	8d 85 6c ff ff
	ff		 lea	 eax, DWORD PTR _Y$[ebp]
  00cb2	50		 push	 eax
  00cb3	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _X$[ebp]
  00cb9	51		 push	 ecx
  00cba	8b 55 14	 mov	 edx, DWORD PTR _BossY$[ebp]
  00cbd	83 c2 05	 add	 edx, 5
  00cc0	52		 push	 edx
  00cc1	8b 45 10	 mov	 eax, DWORD PTR _BossX$[ebp]
  00cc4	83 c0 05	 add	 eax, 5
  00cc7	50		 push	 eax
  00cc8	8b 4d 14	 mov	 ecx, DWORD PTR _BossY$[ebp]
  00ccb	83 e9 05	 sub	 ecx, 5
  00cce	51		 push	 ecx
  00ccf	8b 55 10	 mov	 edx, DWORD PTR _BossX$[ebp]
  00cd2	83 ea 05	 sub	 edx, 5
  00cd5	52		 push	 edx
  00cd6	8b 45 08	 mov	 eax, DWORD PTR _Map$[ebp]
  00cd9	50		 push	 eax
  00cda	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMSetBase@@3VCMonsterSetBase@@A ; gMSetBase
  00cdf	e8 00 00 00 00	 call	 ?GetBoxPosition@CMonsterSetBase@@QAEHHHHHHAAF0@Z ; CMonsterSetBase::GetBoxPosition

; 209  : 
; 210  : 		gObj[OrcIndex].m_PosNum = (WORD)-1;

  00ce4	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _OrcIndex$228477[ebp]
  00cea	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00cf0	83 c9 ff	 or	 ecx, -1
  00cf3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00cf9	66 89 8c 02 b0
	03 00 00	 mov	 WORD PTR [edx+eax+944], cx

; 211  : 		gObj[OrcIndex].MapNumber = Map;

  00d01	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _OrcIndex$228477[ebp]
  00d07	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00d0d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00d13	8a 55 08	 mov	 dl, BYTE PTR _Map$[ebp]
  00d16	88 94 01 49 01
	00 00		 mov	 BYTE PTR [ecx+eax+329], dl

; 212  : 		gObj[OrcIndex].Dir = rand()%8;

  00d1d	e8 00 00 00 00	 call	 _rand
  00d22	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  00d27	79 05		 jns	 SHORT $LN14@AddBoss
  00d29	48		 dec	 eax
  00d2a	83 c8 f8	 or	 eax, -8			; fffffff8H
  00d2d	40		 inc	 eax
$LN14@AddBoss:
  00d2e	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _OrcIndex$228477[ebp]
  00d34	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  00d3a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00d40	88 84 0a 48 01
	00 00		 mov	 BYTE PTR [edx+ecx+328], al

; 213  : 		gObj[OrcIndex].X = X;

  00d47	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _OrcIndex$228477[ebp]
  00d4d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00d53	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00d59	66 8b 95 70 ff
	ff ff		 mov	 dx, WORD PTR _X$[ebp]
  00d60	66 89 94 01 44
	01 00 00	 mov	 WORD PTR [ecx+eax+324], dx

; 214  : 		gObj[OrcIndex].Y = Y;

  00d68	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _OrcIndex$228477[ebp]
  00d6e	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00d74	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00d7a	66 8b 95 6c ff
	ff ff		 mov	 dx, WORD PTR _Y$[ebp]
  00d81	66 89 94 01 46
	01 00 00	 mov	 WORD PTR [ecx+eax+326], dx

; 215  : 		gObj[OrcIndex].TX = X;

  00d89	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _OrcIndex$228477[ebp]
  00d8f	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00d95	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00d9b	66 8b 95 70 ff
	ff ff		 mov	 dx, WORD PTR _X$[ebp]
  00da2	66 89 94 01 7c
	01 00 00	 mov	 WORD PTR [ecx+eax+380], dx

; 216  : 		gObj[OrcIndex].TY = Y;

  00daa	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _OrcIndex$228477[ebp]
  00db0	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00db6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00dbc	66 8b 95 6c ff
	ff ff		 mov	 dx, WORD PTR _Y$[ebp]
  00dc3	66 89 94 01 7e
	01 00 00	 mov	 WORD PTR [ecx+eax+382], dx

; 217  : 		gObj[OrcIndex].m_OldX = X;

  00dcb	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _OrcIndex$228477[ebp]
  00dd1	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00dd7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00ddd	66 8b 95 70 ff
	ff ff		 mov	 dx, WORD PTR _X$[ebp]
  00de4	66 89 94 01 78
	01 00 00	 mov	 WORD PTR [ecx+eax+376], dx

; 218  : 		gObj[OrcIndex].m_OldY = Y;

  00dec	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _OrcIndex$228477[ebp]
  00df2	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00df8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00dfe	66 8b 95 6c ff
	ff ff		 mov	 dx, WORD PTR _Y$[ebp]
  00e05	66 89 94 01 7a
	01 00 00	 mov	 WORD PTR [ecx+eax+378], dx

; 219  : 		gObj[OrcIndex].StartX = X;

  00e0d	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _OrcIndex$228477[ebp]
  00e13	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00e19	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00e1f	8a 95 70 ff ff
	ff		 mov	 dl, BYTE PTR _X$[ebp]
  00e25	88 94 01 76 01
	00 00		 mov	 BYTE PTR [ecx+eax+374], dl

; 220  : 		gObj[OrcIndex].StartY = Y;

  00e2c	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _OrcIndex$228477[ebp]
  00e32	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00e38	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00e3e	8a 95 6c ff ff
	ff		 mov	 dl, BYTE PTR _Y$[ebp]
  00e44	88 94 01 77 01
	00 00		 mov	 BYTE PTR [ecx+eax+375], dl

; 221  : 		gObj[OrcIndex].MaxRegenTime = 0;

  00e4b	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _OrcIndex$228477[ebp]
  00e51	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00e57	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00e5d	c7 84 01 ac 03
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+940], 0

; 222  : 		gObj[OrcIndex].Dir = rand()%8;

  00e68	e8 00 00 00 00	 call	 _rand
  00e6d	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  00e72	79 05		 jns	 SHORT $LN15@AddBoss
  00e74	48		 dec	 eax
  00e75	83 c8 f8	 or	 eax, -8			; fffffff8H
  00e78	40		 inc	 eax
$LN15@AddBoss:
  00e79	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _OrcIndex$228477[ebp]
  00e7f	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  00e85	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00e8b	88 84 0a 48 01
	00 00		 mov	 BYTE PTR [edx+ecx+328], al

; 223  : 		gObj[OrcIndex].RegenTime = GetTickCount();

  00e92	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00e98	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _OrcIndex$228477[ebp]
  00e9e	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  00ea4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00eaa	89 84 0a a8 03
	00 00		 mov	 DWORD PTR [edx+ecx+936], eax

; 224  : 		gObj[OrcIndex].m_ActState.Emotion = 1;

  00eb1	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _OrcIndex$228477[ebp]
  00eb7	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00ebd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00ec3	8b 94 01 18 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+536]
  00eca	81 e2 0f ff ff
	ff		 and	 edx, -241		; ffffff0fH
  00ed0	83 ca 10	 or	 edx, 16			; 00000010H
  00ed3	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _OrcIndex$228477[ebp]
  00ed9	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00edf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00ee5	89 94 01 18 02
	00 00		 mov	 DWORD PTR [ecx+eax+536], edx

; 225  : 		gObj[OrcIndex].m_ActState.EmotionCount = 15;

  00eec	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _OrcIndex$228477[ebp]
  00ef2	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00ef8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00efe	8b 94 01 18 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+536]
  00f05	81 e2 ff 00 ff
	ff		 and	 edx, -65281		; ffff00ffH
  00f0b	81 ca 00 0f 00
	00		 or	 edx, 3840		; 00000f00H
  00f11	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _OrcIndex$228477[ebp]
  00f17	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00f1d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00f23	89 94 01 18 02
	00 00		 mov	 DWORD PTR [ecx+eax+536], edx

; 226  : 
; 227  : 		gObjSetMonster(OrcIndex, OrcClass);

  00f2a	8b 45 18	 mov	 eax, DWORD PTR _OrcClass$[ebp]
  00f2d	50		 push	 eax
  00f2e	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _OrcIndex$228477[ebp]
  00f34	51		 push	 ecx
  00f35	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster
  00f3a	83 c4 08	 add	 esp, 8

; 228  : 	}

  00f3d	e9 02 fd ff ff	 jmp	 $LN3@AddBoss
$LN6@AddBoss:

; 229  : }

  00f42	5f		 pop	 edi
  00f43	5e		 pop	 esi
  00f44	5b		 pop	 ebx
  00f45	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00f48	33 cd		 xor	 ecx, ebp
  00f4a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00f4f	8b e5		 mov	 esp, ebp
  00f51	5d		 pop	 ebp
  00f52	c2 18 00	 ret	 24			; 00000018H
?AddBoss@CMapQuest@@QAEXHHHHHH@Z ENDP			; CMapQuest::AddBoss
_TEXT	ENDS
PUBLIC	?set@PBMSG_HEAD2@@QAEXPAEEEE@Z			; PBMSG_HEAD2::set
PUBLIC	__$ArrayPad$
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pMsg$ = -24						; size = 16
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_Show$ = 12						; size = 1
_Count$ = 16						; size = 4
_MaxCount$ = 20						; size = 4
?GCInfo@CMapQuest@@QAEXH_NHH@Z PROC			; CMapQuest::GCInfo
; _this$ = ecx

; 232  : {

  00f60	55		 push	 ebp
  00f61	8b ec		 mov	 ebp, esp
  00f63	83 ec 58	 sub	 esp, 88			; 00000058H
  00f66	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00f6b	33 c5		 xor	 eax, ebp
  00f6d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00f70	53		 push	 ebx
  00f71	56		 push	 esi
  00f72	57		 push	 edi
  00f73	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 233  : 	PMSG_DUNGEON_SYSTEM pMsg;
; 234  : 	pMsg.h.set((LPBYTE)&pMsg, 0xFB, 0x71, sizeof(pMsg));

  00f76	6a 10		 push	 16			; 00000010H
  00f78	6a 71		 push	 113			; 00000071H
  00f7a	68 fb 00 00 00	 push	 251			; 000000fbH
  00f7f	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00f82	50		 push	 eax
  00f83	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00f86	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ; PBMSG_HEAD2::set

; 235  : 	pMsg.Show = Show;

  00f8b	8a 45 0c	 mov	 al, BYTE PTR _Show$[ebp]
  00f8e	88 45 ec	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 236  : 	pMsg.Count = Count;

  00f91	8b 45 10	 mov	 eax, DWORD PTR _Count$[ebp]
  00f94	89 45 f0	 mov	 DWORD PTR _pMsg$[ebp+8], eax

; 237  : 	pMsg.MaxCount = MaxCount;

  00f97	8b 45 14	 mov	 eax, DWORD PTR _MaxCount$[ebp]
  00f9a	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+12], eax

; 238  : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00f9d	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00fa1	50		 push	 eax
  00fa2	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00fa5	51		 push	 ecx
  00fa6	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00fa9	52		 push	 edx
  00faa	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00faf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 239  : }

  00fb2	5f		 pop	 edi
  00fb3	5e		 pop	 esi
  00fb4	5b		 pop	 ebx
  00fb5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00fb8	33 cd		 xor	 ecx, ebp
  00fba	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00fbf	8b e5		 mov	 esp, ebp
  00fc1	5d		 pop	 ebp
  00fc2	c2 10 00	 ret	 16			; 00000010H
?GCInfo@CMapQuest@@QAEXH_NHH@Z ENDP			; CMapQuest::GCInfo
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\include\prodef.h
_TEXT	ENDS
;	COMDAT ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpBuf$ = 8						; size = 4
_head$ = 12						; size = 1
_sub$ = 16						; size = 1
_size$ = 20						; size = 1
?set@PBMSG_HEAD2@@QAEXPAEEEE@Z PROC			; PBMSG_HEAD2::set, COMDAT
; _this$ = ecx

; 104  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 105  : 		lpBuf[0] = 0xC1;

  0000c	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]
  0000f	c6 00 c1	 mov	 BYTE PTR [eax], 193	; 000000c1H

; 106  : 		lpBuf[1] = size;

  00012	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]
  00015	8a 4d 14	 mov	 cl, BYTE PTR _size$[ebp]
  00018	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 107  : 		lpBuf[2] = head;

  0001b	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]
  0001e	8a 4d 0c	 mov	 cl, BYTE PTR _head$[ebp]
  00021	88 48 02	 mov	 BYTE PTR [eax+2], cl

; 108  : 		lpBuf[3] = sub;

  00024	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]
  00027	8a 4d 10	 mov	 cl, BYTE PTR _sub$[ebp]
  0002a	88 48 03	 mov	 BYTE PTR [eax+3], cl

; 109  : 	};

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 10 00	 ret	 16			; 00000010H
?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ENDP			; PBMSG_HEAD2::set
_TEXT	ENDS
PUBLIC	?ReloadMonster@CMapQuest@@QAEXXZ		; CMapQuest::ReloadMonster
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\mapquest.cpp
_TEXT	SEGMENT
tv76 = -84						; size = 4
_iMap$228499 = -16					; size = 4
_quest$228498 = -12					; size = 4
_i$228494 = -8						; size = 4
_this$ = -4						; size = 4
?ReloadMonster@CMapQuest@@QAEXXZ PROC			; CMapQuest::ReloadMonster
; _this$ = ecx

; 242  : {

  00fd0	55		 push	 ebp
  00fd1	8b ec		 mov	 ebp, esp
  00fd3	83 ec 54	 sub	 esp, 84			; 00000054H
  00fd6	53		 push	 ebx
  00fd7	56		 push	 esi
  00fd8	57		 push	 edi
  00fd9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 243  : 	if(!g_ExLicense.user.MapQuest)

  00fdc	0f b6 05 e7 00
	00 00		 movzx	 eax, BYTE PTR ?g_ExLicense@@3VCExLicense@@A+231
  00fe3	85 c0		 test	 eax, eax
  00fe5	75 05		 jne	 SHORT $LN7@ReloadMons

; 244  : 	{
; 245  : 		return;

  00fe7	e9 b5 00 00 00	 jmp	 $LN8@ReloadMons
$LN7@ReloadMons:

; 246  : 	}
; 247  : 
; 248  : 	//memset(this->m_BossStart, 0, sizeof(this->m_BossStart));
; 249  : 	//memset(this->m_MapKillCount, 0, sizeof(this->m_MapKillCount));
; 250  : 
; 251  : 	for(int i = 0; i < this->m_Data.size(); i++)

  00fec	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$228494[ebp], 0
  00ff3	eb 09		 jmp	 SHORT $LN6@ReloadMons
$LN5@ReloadMons:
  00ff5	8b 45 f8	 mov	 eax, DWORD PTR _i$228494[ebp]
  00ff8	83 c0 01	 add	 eax, 1
  00ffb	89 45 f8	 mov	 DWORD PTR _i$228494[ebp], eax
$LN6@ReloadMons:
  00ffe	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01001	e8 00 00 00 00	 call	 ?size@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QBEIXZ ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::size
  01006	39 45 f8	 cmp	 DWORD PTR _i$228494[ebp], eax
  01009	0f 83 92 00 00
	00		 jae	 $LN8@ReloadMons

; 252  : 	{
; 253  : 		MAPQUEST_DATA & quest = this->m_Data[i];

  0100f	8b 45 f8	 mov	 eax, DWORD PTR _i$228494[ebp]
  01012	50		 push	 eax
  01013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01016	e8 00 00 00 00	 call	 ??A?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAEAAUMAPQUEST_DATA@@I@Z ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::operator[]
  0101b	89 45 f4	 mov	 DWORD PTR _quest$228498[ebp], eax

; 254  : 
; 255  : 		int iMap = quest.MapNum;

  0101e	8b 45 f4	 mov	 eax, DWORD PTR _quest$228498[ebp]
  01021	8b 08		 mov	 ecx, DWORD PTR [eax]
  01023	89 4d f0	 mov	 DWORD PTR _iMap$228499[ebp], ecx

; 256  : 
; 257  : 		if(!MAX_MAP_RANGE(iMap))

  01026	83 7d f0 00	 cmp	 DWORD PTR _iMap$228499[ebp], 0
  0102a	7d 09		 jge	 SHORT $LN10@ReloadMons
  0102c	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
  01033	eb 0c		 jmp	 SHORT $LN11@ReloadMons
$LN10@ReloadMons:
  01035	33 c0		 xor	 eax, eax
  01037	83 7d f0 59	 cmp	 DWORD PTR _iMap$228499[ebp], 89 ; 00000059H
  0103b	0f 9e c0	 setle	 al
  0103e	89 45 ac	 mov	 DWORD PTR tv76[ebp], eax
$LN11@ReloadMons:
  01041	83 7d ac 00	 cmp	 DWORD PTR tv76[ebp], 0
  01045	75 02		 jne	 SHORT $LN3@ReloadMons

; 258  : 		{
; 259  : 			continue;

  01047	eb ac		 jmp	 SHORT $LN5@ReloadMons
$LN3@ReloadMons:

; 260  : 		}
; 261  : 
; 262  : 		if(this->m_BossStart[iMap] == true)

  01049	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0104c	03 45 f0	 add	 eax, DWORD PTR _iMap$228499[ebp]
  0104f	0f b6 88 78 01
	00 00		 movzx	 ecx, BYTE PTR [eax+376]
  01056	83 f9 01	 cmp	 ecx, 1
  01059	75 41		 jne	 SHORT $LN2@ReloadMons

; 263  : 		{
; 264  : 			if(this->m_MapKillCount[iMap] >= quest.MonsterCount)

  0105b	8b 45 f0	 mov	 eax, DWORD PTR _iMap$228499[ebp]
  0105e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01061	8b 55 f4	 mov	 edx, DWORD PTR _quest$228498[ebp]
  01064	8b 44 81 10	 mov	 eax, DWORD PTR [ecx+eax*4+16]
  01068	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  0106b	7c 2f		 jl	 SHORT $LN2@ReloadMons

; 265  : 			{
; 266  : 				this->AddBossEx(iMap, quest.BossClass, quest.BossX, quest.BossY, quest.OrcClass, quest.OrcCount);	

  0106d	8b 45 f4	 mov	 eax, DWORD PTR _quest$228498[ebp]
  01070	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  01073	51		 push	 ecx
  01074	8b 55 f4	 mov	 edx, DWORD PTR _quest$228498[ebp]
  01077	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0107a	50		 push	 eax
  0107b	8b 4d f4	 mov	 ecx, DWORD PTR _quest$228498[ebp]
  0107e	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  01081	52		 push	 edx
  01082	8b 45 f4	 mov	 eax, DWORD PTR _quest$228498[ebp]
  01085	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  01088	51		 push	 ecx
  01089	8b 55 f4	 mov	 edx, DWORD PTR _quest$228498[ebp]
  0108c	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0108f	50		 push	 eax
  01090	8b 4d f0	 mov	 ecx, DWORD PTR _iMap$228499[ebp]
  01093	51		 push	 ecx
  01094	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01097	e8 00 00 00 00	 call	 ?AddBossEx@CMapQuest@@QAEXHHHHHH@Z ; CMapQuest::AddBossEx
$LN2@ReloadMons:

; 267  : 
; 268  : 			//	this->GCInfo(aIndex, true, this->m_MapKillCount[lpMonster->MapNumber], quest.MonsterCount);
; 269  : 			}
; 270  : 		}
; 271  : 	}

  0109c	e9 54 ff ff ff	 jmp	 $LN5@ReloadMons
$LN8@ReloadMons:

; 272  : 
; 273  : 
; 274  : }

  010a1	5f		 pop	 edi
  010a2	5e		 pop	 esi
  010a3	5b		 pop	 ebx
  010a4	8b e5		 mov	 esp, ebp
  010a6	5d		 pop	 ebp
  010a7	c3		 ret	 0
?ReloadMonster@CMapQuest@@QAEXXZ ENDP			; CMapQuest::ReloadMonster
_TEXT	ENDS
PUBLIC	?TeleportMap@CMapQuest@@QAEXHH@Z		; CMapQuest::TeleportMap
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv74 = -88						; size = 4
tv69 = -88						; size = 4
_quest$228517 = -20					; size = 4
_i$228513 = -16						; size = 4
_MaxCount$ = -12					; size = 4
_Result$ = -5						; size = 1
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_Map$ = 12						; size = 4
?TeleportMap@CMapQuest@@QAEXHH@Z PROC			; CMapQuest::TeleportMap
; _this$ = ecx

; 277  : {

  010b0	55		 push	 ebp
  010b1	8b ec		 mov	 ebp, esp
  010b3	83 ec 58	 sub	 esp, 88			; 00000058H
  010b6	53		 push	 ebx
  010b7	56		 push	 esi
  010b8	57		 push	 edi
  010b9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 278  : 	if(!g_ExLicense.user.MapQuest)

  010bc	0f b6 05 e7 00
	00 00		 movzx	 eax, BYTE PTR ?g_ExLicense@@3VCExLicense@@A+231
  010c3	85 c0		 test	 eax, eax
  010c5	75 05		 jne	 SHORT $LN7@TeleportMa

; 279  : 	{
; 280  : 		return;

  010c7	e9 bb 00 00 00	 jmp	 $LN8@TeleportMa
$LN7@TeleportMa:

; 281  : 	}
; 282  : 
; 283  : 	if(!OBJMAX_RANGE(aIndex) || !MAX_MAP_RANGE(Map))

  010cc	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  010d0	7d 09		 jge	 SHORT $LN10@TeleportMa
  010d2	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
  010d9	eb 0f		 jmp	 SHORT $LN11@TeleportMa
$LN10@TeleportMa:
  010db	33 c0		 xor	 eax, eax
  010dd	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  010e4	0f 9e c0	 setle	 al
  010e7	89 45 a8	 mov	 DWORD PTR tv69[ebp], eax
$LN11@TeleportMa:
  010ea	83 7d a8 00	 cmp	 DWORD PTR tv69[ebp], 0
  010ee	74 21		 je	 SHORT $LN5@TeleportMa
  010f0	83 7d 0c 00	 cmp	 DWORD PTR _Map$[ebp], 0
  010f4	7d 09		 jge	 SHORT $LN12@TeleportMa
  010f6	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
  010fd	eb 0c		 jmp	 SHORT $LN13@TeleportMa
$LN12@TeleportMa:
  010ff	33 c0		 xor	 eax, eax
  01101	83 7d 0c 59	 cmp	 DWORD PTR _Map$[ebp], 89 ; 00000059H
  01105	0f 9e c0	 setle	 al
  01108	89 45 a8	 mov	 DWORD PTR tv74[ebp], eax
$LN13@TeleportMa:
  0110b	83 7d a8 00	 cmp	 DWORD PTR tv74[ebp], 0
  0110f	75 02		 jne	 SHORT $LN6@TeleportMa
$LN5@TeleportMa:

; 284  : 	{
; 285  : 		return;

  01111	eb 74		 jmp	 SHORT $LN8@TeleportMa
$LN6@TeleportMa:

; 286  : 	}
; 287  : 
; 288  : 	bool Result = false;

  01113	c6 45 fb 00	 mov	 BYTE PTR _Result$[ebp], 0

; 289  : 	int MaxCount = 0;

  01117	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _MaxCount$[ebp], 0

; 290  : 
; 291  : 	for(int i = 0; i < this->m_Data.size(); i++)

  0111e	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$228513[ebp], 0
  01125	eb 09		 jmp	 SHORT $LN4@TeleportMa
$LN3@TeleportMa:
  01127	8b 45 f0	 mov	 eax, DWORD PTR _i$228513[ebp]
  0112a	83 c0 01	 add	 eax, 1
  0112d	89 45 f0	 mov	 DWORD PTR _i$228513[ebp], eax
$LN4@TeleportMa:
  01130	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01133	e8 00 00 00 00	 call	 ?size@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QBEIXZ ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::size
  01138	39 45 f0	 cmp	 DWORD PTR _i$228513[ebp], eax
  0113b	73 2a		 jae	 SHORT $LN2@TeleportMa

; 292  : 	{
; 293  : 		MAPQUEST_DATA & quest = this->m_Data[i];

  0113d	8b 45 f0	 mov	 eax, DWORD PTR _i$228513[ebp]
  01140	50		 push	 eax
  01141	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01144	e8 00 00 00 00	 call	 ??A?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAEAAUMAPQUEST_DATA@@I@Z ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::operator[]
  01149	89 45 ec	 mov	 DWORD PTR _quest$228517[ebp], eax

; 294  : 
; 295  : 		if(Map == quest.MapNum)

  0114c	8b 45 ec	 mov	 eax, DWORD PTR _quest$228517[ebp]
  0114f	8b 4d 0c	 mov	 ecx, DWORD PTR _Map$[ebp]
  01152	3b 08		 cmp	 ecx, DWORD PTR [eax]
  01154	75 0f		 jne	 SHORT $LN1@TeleportMa

; 296  : 		{
; 297  : 			Result = true;

  01156	c6 45 fb 01	 mov	 BYTE PTR _Result$[ebp], 1

; 298  : 			MaxCount = quest.MonsterCount;

  0115a	8b 45 ec	 mov	 eax, DWORD PTR _quest$228517[ebp]
  0115d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01160	89 4d f4	 mov	 DWORD PTR _MaxCount$[ebp], ecx

; 299  : 			break;

  01163	eb 02		 jmp	 SHORT $LN2@TeleportMa
$LN1@TeleportMa:

; 300  : 		}
; 301  : 	}

  01165	eb c0		 jmp	 SHORT $LN3@TeleportMa
$LN2@TeleportMa:

; 302  : 
; 303  : 	this->GCInfo(aIndex, Result, this->m_MapKillCount[Map], MaxCount);

  01167	8b 45 f4	 mov	 eax, DWORD PTR _MaxCount$[ebp]
  0116a	50		 push	 eax
  0116b	8b 4d 0c	 mov	 ecx, DWORD PTR _Map$[ebp]
  0116e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01171	8b 44 8a 10	 mov	 eax, DWORD PTR [edx+ecx*4+16]
  01175	50		 push	 eax
  01176	0f b6 4d fb	 movzx	 ecx, BYTE PTR _Result$[ebp]
  0117a	51		 push	 ecx
  0117b	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0117e	52		 push	 edx
  0117f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01182	e8 00 00 00 00	 call	 ?GCInfo@CMapQuest@@QAEXH_NHH@Z ; CMapQuest::GCInfo
$LN8@TeleportMa:

; 304  : }

  01187	5f		 pop	 edi
  01188	5e		 pop	 esi
  01189	5b		 pop	 ebx
  0118a	8b e5		 mov	 esp, ebp
  0118c	5d		 pop	 ebp
  0118d	c2 08 00	 ret	 8
?TeleportMap@CMapQuest@@QAEXHH@Z ENDP			; CMapQuest::TeleportMap
_TEXT	ENDS
PUBLIC	?GetMonsterPos@CMapQuest@@QAEHGEEE@Z		; CMapQuest::GetMonsterPos
PUBLIC	?LoadMonsterPos@CMapQuest@@QAEXXZ		; CMapQuest::LoadMonsterPos
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv74 = -88						; size = 4
_i$228530 = -20						; size = 4
_iMobPos$228528 = -16					; size = 4
_quest$228526 = -12					; size = 4
_n$228522 = -8						; size = 4
_this$ = -4						; size = 4
?LoadMonsterPos@CMapQuest@@QAEXXZ PROC			; CMapQuest::LoadMonsterPos
; _this$ = ecx

; 307  : {

  01190	55		 push	 ebp
  01191	8b ec		 mov	 ebp, esp
  01193	83 ec 58	 sub	 esp, 88			; 00000058H
  01196	53		 push	 ebx
  01197	56		 push	 esi
  01198	57		 push	 edi
  01199	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 308  : 	for( int n = 0; n < this->m_Data.size(); n++ )

  0119c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$228522[ebp], 0
  011a3	eb 09		 jmp	 SHORT $LN9@LoadMonste
$LN8@LoadMonste:
  011a5	8b 45 f8	 mov	 eax, DWORD PTR _n$228522[ebp]
  011a8	83 c0 01	 add	 eax, 1
  011ab	89 45 f8	 mov	 DWORD PTR _n$228522[ebp], eax
$LN9@LoadMonste:
  011ae	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  011b1	e8 00 00 00 00	 call	 ?size@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QBEIXZ ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::size
  011b6	39 45 f8	 cmp	 DWORD PTR _n$228522[ebp], eax
  011b9	0f 83 23 01 00
	00		 jae	 $LN10@LoadMonste

; 309  : 	{
; 310  : 		MAPQUEST_DATA & quest = this->m_Data[n];

  011bf	8b 45 f8	 mov	 eax, DWORD PTR _n$228522[ebp]
  011c2	50		 push	 eax
  011c3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  011c6	e8 00 00 00 00	 call	 ??A?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAEAAUMAPQUEST_DATA@@I@Z ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::operator[]
  011cb	89 45 f4	 mov	 DWORD PTR _quest$228526[ebp], eax

; 311  : 
; 312  : 		if ( MAX_MAP_RANGE(quest.MapNum) == FALSE ) 

  011ce	8b 45 f4	 mov	 eax, DWORD PTR _quest$228526[ebp]
  011d1	83 38 00	 cmp	 DWORD PTR [eax], 0
  011d4	7d 09		 jge	 SHORT $LN12@LoadMonste
  011d6	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
  011dd	eb 0e		 jmp	 SHORT $LN13@LoadMonste
$LN12@LoadMonste:
  011df	8b 4d f4	 mov	 ecx, DWORD PTR _quest$228526[ebp]
  011e2	33 d2		 xor	 edx, edx
  011e4	83 39 59	 cmp	 DWORD PTR [ecx], 89	; 00000059H
  011e7	0f 9e c2	 setle	 dl
  011ea	89 55 a8	 mov	 DWORD PTR tv74[ebp], edx
$LN13@LoadMonste:
  011ed	83 7d a8 00	 cmp	 DWORD PTR tv74[ebp], 0
  011f1	75 02		 jne	 SHORT $LN6@LoadMonste

; 313  : 		{
; 314  : 			continue;

  011f3	eb b0		 jmp	 SHORT $LN8@LoadMonste
$LN6@LoadMonste:

; 315  : 		}
; 316  : 
; 317  : 		int iMobPos = this->GetMonsterPos(quest.BossClass, quest.MapNum, 0, 0);

  011f5	6a 00		 push	 0
  011f7	6a 00		 push	 0
  011f9	8b 45 f4	 mov	 eax, DWORD PTR _quest$228526[ebp]
  011fc	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  011ff	51		 push	 ecx
  01200	8b 55 f4	 mov	 edx, DWORD PTR _quest$228526[ebp]
  01203	0f b7 42 08	 movzx	 eax, WORD PTR [edx+8]
  01207	50		 push	 eax
  01208	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0120b	e8 00 00 00 00	 call	 ?GetMonsterPos@CMapQuest@@QAEHGEEE@Z ; CMapQuest::GetMonsterPos
  01210	89 45 f0	 mov	 DWORD PTR _iMobPos$228528[ebp], eax

; 318  : 
; 319  : 		this->m_Boss[quest.MapNum].sIndex = -1;

  01213	8b 45 f4	 mov	 eax, DWORD PTR _quest$228526[ebp]
  01216	8b 08		 mov	 ecx, DWORD PTR [eax]
  01218	6b c9 06	 imul	 ecx, 6
  0121b	83 ca ff	 or	 edx, -1
  0121e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01221	66 89 94 08 d2
	01 00 00	 mov	 WORD PTR [eax+ecx+466], dx

; 320  : 		this->m_Boss[quest.MapNum].sPos = iMobPos;

  01229	8b 45 f4	 mov	 eax, DWORD PTR _quest$228526[ebp]
  0122c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0122e	6b c9 06	 imul	 ecx, 6
  01231	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01234	66 8b 45 f0	 mov	 ax, WORD PTR _iMobPos$228528[ebp]
  01238	66 89 84 0a d4
	01 00 00	 mov	 WORD PTR [edx+ecx+468], ax

; 321  : 
; 322  : 		if(iMobPos >= 0)

  01240	83 7d f0 00	 cmp	 DWORD PTR _iMobPos$228528[ebp], 0
  01244	0f 8c 93 00 00
	00		 jl	 $LN5@LoadMonste

; 323  : 		{
; 324  : 			for(int i = 0; i < quest.OrcCount; i++)

  0124a	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$228530[ebp], 0
  01251	eb 09		 jmp	 SHORT $LN4@LoadMonste
$LN3@LoadMonste:
  01253	8b 45 ec	 mov	 eax, DWORD PTR _i$228530[ebp]
  01256	83 c0 01	 add	 eax, 1
  01259	89 45 ec	 mov	 DWORD PTR _i$228530[ebp], eax
$LN4@LoadMonste:
  0125c	8b 45 f4	 mov	 eax, DWORD PTR _quest$228526[ebp]
  0125f	8b 4d ec	 mov	 ecx, DWORD PTR _i$228530[ebp]
  01262	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  01265	7d 6c		 jge	 SHORT $LN2@LoadMonste

; 325  : 			{
; 326  : 				iMobPos = this->GetMonsterPos(quest.OrcClass, quest.MapNum, 0, 0);

  01267	6a 00		 push	 0
  01269	6a 00		 push	 0
  0126b	8b 45 f4	 mov	 eax, DWORD PTR _quest$228526[ebp]
  0126e	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  01271	51		 push	 ecx
  01272	8b 55 f4	 mov	 edx, DWORD PTR _quest$228526[ebp]
  01275	0f b7 42 14	 movzx	 eax, WORD PTR [edx+20]
  01279	50		 push	 eax
  0127a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0127d	e8 00 00 00 00	 call	 ?GetMonsterPos@CMapQuest@@QAEHGEEE@Z ; CMapQuest::GetMonsterPos
  01282	89 45 f0	 mov	 DWORD PTR _iMobPos$228528[ebp], eax

; 327  : 
; 328  : 				if(iMobPos >= 0)

  01285	83 7d f0 00	 cmp	 DWORD PTR _iMobPos$228528[ebp], 0
  01289	7c 46		 jl	 SHORT $LN1@LoadMonste

; 329  : 				{
; 330  : 					this->m_Monster[quest.MapNum][i].sIndex = -1;

  0128b	8b 45 f4	 mov	 eax, DWORD PTR _quest$228526[ebp]
  0128e	8b 08		 mov	 ecx, DWORD PTR [eax]
  01290	69 c9 58 02 00
	00		 imul	 ecx, 600		; 00000258H
  01296	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01299	8d 84 0a ee 03
	00 00		 lea	 eax, DWORD PTR [edx+ecx+1006]
  012a0	8b 4d ec	 mov	 ecx, DWORD PTR _i$228530[ebp]
  012a3	6b c9 06	 imul	 ecx, 6
  012a6	83 ca ff	 or	 edx, -1
  012a9	66 89 14 08	 mov	 WORD PTR [eax+ecx], dx

; 331  : 					this->m_Monster[quest.MapNum][i].sPos = iMobPos;

  012ad	8b 45 f4	 mov	 eax, DWORD PTR _quest$228526[ebp]
  012b0	8b 08		 mov	 ecx, DWORD PTR [eax]
  012b2	69 c9 58 02 00
	00		 imul	 ecx, 600		; 00000258H
  012b8	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  012bb	8d 84 0a ee 03
	00 00		 lea	 eax, DWORD PTR [edx+ecx+1006]
  012c2	8b 4d ec	 mov	 ecx, DWORD PTR _i$228530[ebp]
  012c5	6b c9 06	 imul	 ecx, 6
  012c8	66 8b 55 f0	 mov	 dx, WORD PTR _iMobPos$228528[ebp]
  012cc	66 89 54 08 02	 mov	 WORD PTR [eax+ecx+2], dx
$LN1@LoadMonste:

; 332  : 				}
; 333  : 			}

  012d1	eb 80		 jmp	 SHORT $LN3@LoadMonste
$LN2@LoadMonste:

; 334  : 
; 335  : 			this->m_MonsterPosLoaded = true;

  012d3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  012d6	c6 80 de d6 00
	00 01		 mov	 BYTE PTR [eax+55006], 1
$LN5@LoadMonste:

; 336  : 		}
; 337  : 	}

  012dd	e9 c3 fe ff ff	 jmp	 $LN8@LoadMonste
$LN10@LoadMonste:

; 338  : }

  012e2	5f		 pop	 edi
  012e3	5e		 pop	 esi
  012e4	5b		 pop	 ebx
  012e5	8b e5		 mov	 esp, ebp
  012e7	5d		 pop	 ebp
  012e8	c3		 ret	 0
?LoadMonsterPos@CMapQuest@@QAEXXZ ENDP			; CMapQuest::LoadMonsterPos
_TEXT	ENDS
PUBLIC	??_C@_0DM@OINGDCBK@?$FLAttackerAdd?$FN?5No?5need?5to?5load?5mo@ ; `string'
PUBLIC	??_C@_0CB@MPDJJDKE@Monster?5attribute?5max?5over?5?$CFs?5?$CFd@ ; `string'
PUBLIC	??_C@_0EA@CHBBPFEP@d?3?2projects?2exteam6?43?2source?2gam@ ; `string'
PUBLIC	?__LINE__Var@?1??GetMonsterPos@CMapQuest@@QAEHGEEE@Z@4JA ; `CMapQuest::GetMonsterPos'::`2'::__LINE__Var
EXTRN	?LogAddC@@3P6AXEPADZZA:DWORD			; LogAddC
EXTRN	?CheckMapCanMove@CMapServerManager@@QAEHH@Z:PROC ; CMapServerManager::CheckMapCanMove
EXTRN	?g_MapServerManager@@3VCMapServerManager@@A:BYTE ; g_MapServerManager
;	COMDAT ??_C@_0DM@OINGDCBK@?$FLAttackerAdd?$FN?5No?5need?5to?5load?5mo@
CONST	SEGMENT
??_C@_0DM@OINGDCBK@?$FLAttackerAdd?$FN?5No?5need?5to?5load?5mo@ DB '[Atta'
	DB	'ckerAdd] No need to load monster for map %d [%d,%d,%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@MPDJJDKE@Monster?5attribute?5max?5over?5?$CFs?5?$CFd@
CONST	SEGMENT
??_C@_0CB@MPDJJDKE@Monster?5attribute?5max?5over?5?$CFs?5?$CFd@ DB 'Monst'
	DB	'er attribute max over %s %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@CHBBPFEP@d?3?2projects?2exteam6?43?2source?2gam@
CONST	SEGMENT
??_C@_0EA@CHBBPFEP@d?3?2projects?2exteam6?43?2source?2gam@ DB 'd:\project'
	DB	's\exteam6.3\source\gameserver\gameserver\mapquest.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??GetMonsterPos@CMapQuest@@QAEHGEEE@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??GetMonsterPos@CMapQuest@@QAEHGEEE@Z@4JA DD 0155H ; `CMapQuest::GetMonsterPos'::`2'::__LINE__Var
; Function compile flags: /Odtp /ZI
_DATA	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
_Type$ = 8						; size = 2
_Map$ = 12						; size = 1
_X$ = 16						; size = 1
_Y$ = 20						; size = 1
?GetMonsterPos@CMapQuest@@QAEHGEEE@Z PROC		; CMapQuest::GetMonsterPos
; _this$ = ecx

; 341  : {

  012f0	55		 push	 ebp
  012f1	8b ec		 mov	 ebp, esp
  012f3	83 ec 44	 sub	 esp, 68			; 00000044H
  012f6	53		 push	 ebx
  012f7	56		 push	 esi
  012f8	57		 push	 edi
  012f9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 342  : 	if(gMSetBase.m_Count >= OBJ_MAXMONSTER-1)

  012fc	81 3d 84 2c 03
	00 c7 32 00 00	 cmp	 DWORD PTR ?gMSetBase@@3VCMonsterSetBase@@A+208004, 12999 ; 000032c7H
  01306	7c 23		 jl	 SHORT $LN2@GetMonster

; 343  : 	{
; 344  : 		MsgBox("Monster attribute max over %s %d", __FILE__, __LINE__);

  01308	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?1??GetMonsterPos@CMapQuest@@QAEHGEEE@Z@4JA
  0130d	83 c0 03	 add	 eax, 3
  01310	50		 push	 eax
  01311	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@CHBBPFEP@d?3?2projects?2exteam6?43?2source?2gam@
  01316	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@MPDJJDKE@Monster?5attribute?5max?5over?5?$CFs?5?$CFd@
  0131b	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  01320	83 c4 0c	 add	 esp, 12			; 0000000cH

; 345  : 		return -1;

  01323	83 c8 ff	 or	 eax, -1
  01326	e9 e6 00 00 00	 jmp	 $LN3@GetMonster
$LN2@GetMonster:

; 346  : 	}
; 347  : 
; 348  : 	if(g_MapServerManager.CheckMapCanMove(Map) == FALSE)

  0132b	0f b6 45 0c	 movzx	 eax, BYTE PTR _Map$[ebp]
  0132f	50		 push	 eax
  01330	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  01335	e8 00 00 00 00	 call	 ?CheckMapCanMove@CMapServerManager@@QAEHH@Z ; CMapServerManager::CheckMapCanMove
  0133a	85 c0		 test	 eax, eax
  0133c	75 2c		 jne	 SHORT $LN1@GetMonster

; 349  : 	{
; 350  : 		LogAddC(3,"[AttackerAdd] No need to load monster for map %d [%d,%d,%d]",Map,Type,X,Y);

  0133e	0f b6 45 14	 movzx	 eax, BYTE PTR _Y$[ebp]
  01342	50		 push	 eax
  01343	0f b6 4d 10	 movzx	 ecx, BYTE PTR _X$[ebp]
  01347	51		 push	 ecx
  01348	0f b7 55 08	 movzx	 edx, WORD PTR _Type$[ebp]
  0134c	52		 push	 edx
  0134d	0f b6 45 0c	 movzx	 eax, BYTE PTR _Map$[ebp]
  01351	50		 push	 eax
  01352	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@OINGDCBK@?$FLAttackerAdd?$FN?5No?5need?5to?5load?5mo@
  01357	6a 03		 push	 3
  01359	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0135f	83 c4 18	 add	 esp, 24			; 00000018H

; 351  : 		return -1;

  01362	83 c8 ff	 or	 eax, -1
  01365	e9 a7 00 00 00	 jmp	 $LN3@GetMonster
$LN1@GetMonster:

; 352  : 	}
; 353  : 
; 354  : 	gMSetBase.m_Count++;

  0136a	a1 84 2c 03 00	 mov	 eax, DWORD PTR ?gMSetBase@@3VCMonsterSetBase@@A+208004
  0136f	83 c0 01	 add	 eax, 1
  01372	a3 84 2c 03 00	 mov	 DWORD PTR ?gMSetBase@@3VCMonsterSetBase@@A+208004, eax

; 355  : 	gMSetBase.m_Mp[gMSetBase.m_Count].m_Dis			= 5;	//0

  01377	a1 84 2c 03 00	 mov	 eax, DWORD PTR ?gMSetBase@@3VCMonsterSetBase@@A+208004
  0137c	c1 e0 04	 shl	 eax, 4
  0137f	c6 80 09 00 00
	00 05		 mov	 BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+9], 5

; 356  : 	gMSetBase.m_Mp[gMSetBase.m_Count].m_Type		= Type;

  01386	a1 84 2c 03 00	 mov	 eax, DWORD PTR ?gMSetBase@@3VCMonsterSetBase@@A+208004
  0138b	c1 e0 04	 shl	 eax, 4
  0138e	66 8b 4d 08	 mov	 cx, WORD PTR _Type$[ebp]
  01392	66 89 88 06 00
	00 00		 mov	 WORD PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+6], cx

; 357  : 	gMSetBase.m_Mp[gMSetBase.m_Count].m_MapNumber	= Map;

  01399	a1 84 2c 03 00	 mov	 eax, DWORD PTR ?gMSetBase@@3VCMonsterSetBase@@A+208004
  0139e	c1 e0 04	 shl	 eax, 4
  013a1	8a 4d 0c	 mov	 cl, BYTE PTR _Map$[ebp]
  013a4	88 88 08 00 00
	00		 mov	 BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+8], cl

; 358  : 	gMSetBase.m_Mp[gMSetBase.m_Count].m_W			= X;

  013aa	a1 84 2c 03 00	 mov	 eax, DWORD PTR ?gMSetBase@@3VCMonsterSetBase@@A+208004
  013af	c1 e0 04	 shl	 eax, 4
  013b2	8a 4d 10	 mov	 cl, BYTE PTR _X$[ebp]
  013b5	88 88 0d 00 00
	00		 mov	 BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+13], cl

; 359  : 	gMSetBase.m_Mp[gMSetBase.m_Count].m_H			= Y;

  013bb	a1 84 2c 03 00	 mov	 eax, DWORD PTR ?gMSetBase@@3VCMonsterSetBase@@A+208004
  013c0	c1 e0 04	 shl	 eax, 4
  013c3	8a 4d 14	 mov	 cl, BYTE PTR _Y$[ebp]
  013c6	88 88 0e 00 00
	00		 mov	 BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+14], cl

; 360  : 	gMSetBase.m_Mp[gMSetBase.m_Count].m_X			= X;

  013cc	a1 84 2c 03 00	 mov	 eax, DWORD PTR ?gMSetBase@@3VCMonsterSetBase@@A+208004
  013d1	c1 e0 04	 shl	 eax, 4
  013d4	8a 4d 10	 mov	 cl, BYTE PTR _X$[ebp]
  013d7	88 88 0a 00 00
	00		 mov	 BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+10], cl

; 361  : 	gMSetBase.m_Mp[gMSetBase.m_Count].m_Y			= Y;

  013dd	a1 84 2c 03 00	 mov	 eax, DWORD PTR ?gMSetBase@@3VCMonsterSetBase@@A+208004
  013e2	c1 e0 04	 shl	 eax, 4
  013e5	8a 4d 14	 mov	 cl, BYTE PTR _Y$[ebp]
  013e8	88 88 0b 00 00
	00		 mov	 BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+11], cl

; 362  : 	gMSetBase.m_Mp[gMSetBase.m_Count].m_ArrangeType = 2;	//3	1 0	//2<<

  013ee	a1 84 2c 03 00	 mov	 eax, DWORD PTR ?gMSetBase@@3VCMonsterSetBase@@A+208004
  013f3	c1 e0 04	 shl	 eax, 4
  013f6	c6 80 04 00 00
	00 02		 mov	 BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+4], 2

; 363  : 	gMSetBase.m_Mp[gMSetBase.m_Count].m_Dir			= 2;

  013fd	a1 84 2c 03 00	 mov	 eax, DWORD PTR ?gMSetBase@@3VCMonsterSetBase@@A+208004
  01402	c1 e0 04	 shl	 eax, 4
  01405	c6 80 0c 00 00
	00 02		 mov	 BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+12], 2

; 364  : 
; 365  : 	return gMSetBase.m_Count;

  0140c	a1 84 2c 03 00	 mov	 eax, DWORD PTR ?gMSetBase@@3VCMonsterSetBase@@A+208004
$LN3@GetMonster:

; 366  : }

  01411	5f		 pop	 edi
  01412	5e		 pop	 esi
  01413	5b		 pop	 ebx
  01414	8b e5		 mov	 esp, ebp
  01416	5d		 pop	 ebp
  01417	c2 10 00	 ret	 16			; 00000010H
?GetMonsterPos@CMapQuest@@QAEHGEEE@Z ENDP		; CMapQuest::GetMonsterPos
_TEXT	ENDS
PUBLIC	__$ArrayPad$
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv240 = -224						; size = 4
tv77 = -224						; size = 4
_OrcIndex$228568 = -156					; size = 4
_i$228563 = -152					; size = 4
_Y$ = -148						; size = 2
_X$ = -144						; size = 2
_szMsg$ = -140						; size = 128
_BossIndex$ = -12					; size = 2
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_Map$ = 8						; size = 4
_BossClass$ = 12					; size = 4
_BossX$ = 16						; size = 4
_BossY$ = 20						; size = 4
_OrcClass$ = 24						; size = 4
_OrcCount$ = 28						; size = 4
?AddBossEx@CMapQuest@@QAEXHHHHHH@Z PROC			; CMapQuest::AddBossEx
; _this$ = ecx

; 369  : {

  01420	55		 push	 ebp
  01421	8b ec		 mov	 ebp, esp
  01423	81 ec e0 00 00
	00		 sub	 esp, 224		; 000000e0H
  01429	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0142e	33 c5		 xor	 eax, ebp
  01430	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  01433	53		 push	 ebx
  01434	56		 push	 esi
  01435	57		 push	 edi
  01436	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 370  : 	if(this->m_Boss[Map].sPos == -1)

  01439	8b 45 08	 mov	 eax, DWORD PTR _Map$[ebp]
  0143c	6b c0 06	 imul	 eax, 6
  0143f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01442	0f bf 94 01 d4
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+468]
  0144a	83 fa ff	 cmp	 edx, -1
  0144d	75 05		 jne	 SHORT $LN7@AddBossEx

; 371  : 	{
; 372  : 		return;

  0144f	e9 7a 06 00 00	 jmp	 $LN8@AddBossEx
$LN7@AddBossEx:

; 373  : 	}
; 374  : 
; 375  : 	short BossIndex = gObjAddMonster(Map);

  01454	8b 45 08	 mov	 eax, DWORD PTR _Map$[ebp]
  01457	50		 push	 eax
  01458	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  0145d	83 c4 04	 add	 esp, 4
  01460	66 89 45 f4	 mov	 WORD PTR _BossIndex$[ebp], ax

; 376  : 
; 377  : 	if(!OBJMAX_RANGE(BossIndex))

  01464	0f bf 45 f4	 movsx	 eax, WORD PTR _BossIndex$[ebp]
  01468	85 c0		 test	 eax, eax
  0146a	7d 0c		 jge	 SHORT $LN10@AddBossEx
  0146c	c7 85 20 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv77[ebp], 0
  01476	eb 15		 jmp	 SHORT $LN11@AddBossEx
$LN10@AddBossEx:
  01478	0f bf 4d f4	 movsx	 ecx, WORD PTR _BossIndex$[ebp]
  0147c	33 d2		 xor	 edx, edx
  0147e	81 f9 97 3a 00
	00		 cmp	 ecx, 14999		; 00003a97H
  01484	0f 9e c2	 setle	 dl
  01487	89 95 20 ff ff
	ff		 mov	 DWORD PTR tv77[ebp], edx
$LN11@AddBossEx:
  0148d	83 bd 20 ff ff
	ff 00		 cmp	 DWORD PTR tv77[ebp], 0
  01494	75 05		 jne	 SHORT $LN6@AddBossEx

; 378  : 	{
; 379  : 		return;

  01496	e9 33 06 00 00	 jmp	 $LN8@AddBossEx
$LN6@AddBossEx:

; 380  : 	}
; 381  : 
; 382  : 	this->m_Boss[Map].sIndex = BossIndex;

  0149b	8b 45 08	 mov	 eax, DWORD PTR _Map$[ebp]
  0149e	6b c0 06	 imul	 eax, 6
  014a1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  014a4	66 8b 55 f4	 mov	 dx, WORD PTR _BossIndex$[ebp]
  014a8	66 89 94 01 d2
	01 00 00	 mov	 WORD PTR [ecx+eax+466], dx

; 383  : 
; 384  : 	gObj[BossIndex].m_PosNum = this->m_Boss[Map].sPos;

  014b0	8b 45 08	 mov	 eax, DWORD PTR _Map$[ebp]
  014b3	6b c0 06	 imul	 eax, 6
  014b6	0f bf 4d f4	 movsx	 ecx, WORD PTR _BossIndex$[ebp]
  014ba	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  014c0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  014c6	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  014c9	66 8b 84 06 d4
	01 00 00	 mov	 ax, WORD PTR [esi+eax+468]
  014d1	66 89 84 0a b0
	03 00 00	 mov	 WORD PTR [edx+ecx+944], ax

; 385  : 	gObj[BossIndex].MapNumber = Map;

  014d9	0f bf 45 f4	 movsx	 eax, WORD PTR _BossIndex$[ebp]
  014dd	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  014e3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  014e9	8a 55 08	 mov	 dl, BYTE PTR _Map$[ebp]
  014ec	88 94 01 49 01
	00 00		 mov	 BYTE PTR [ecx+eax+329], dl

; 386  : 	gObj[BossIndex].Dir = rand()%8;

  014f3	e8 00 00 00 00	 call	 _rand
  014f8	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  014fd	79 05		 jns	 SHORT $LN14@AddBossEx
  014ff	48		 dec	 eax
  01500	83 c8 f8	 or	 eax, -8			; fffffff8H
  01503	40		 inc	 eax
$LN14@AddBossEx:
  01504	0f bf 4d f4	 movsx	 ecx, WORD PTR _BossIndex$[ebp]
  01508	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0150e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01514	88 84 0a 48 01
	00 00		 mov	 BYTE PTR [edx+ecx+328], al

; 387  : 	gObj[BossIndex].X = BossX;

  0151b	0f bf 45 f4	 movsx	 eax, WORD PTR _BossIndex$[ebp]
  0151f	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01525	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0152b	66 8b 55 10	 mov	 dx, WORD PTR _BossX$[ebp]
  0152f	66 89 94 01 44
	01 00 00	 mov	 WORD PTR [ecx+eax+324], dx

; 388  : 	gObj[BossIndex].Y = BossY;

  01537	0f bf 45 f4	 movsx	 eax, WORD PTR _BossIndex$[ebp]
  0153b	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01541	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01547	66 8b 55 14	 mov	 dx, WORD PTR _BossY$[ebp]
  0154b	66 89 94 01 46
	01 00 00	 mov	 WORD PTR [ecx+eax+326], dx

; 389  : 	gObj[BossIndex].TX = BossX;

  01553	0f bf 45 f4	 movsx	 eax, WORD PTR _BossIndex$[ebp]
  01557	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0155d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01563	66 8b 55 10	 mov	 dx, WORD PTR _BossX$[ebp]
  01567	66 89 94 01 7c
	01 00 00	 mov	 WORD PTR [ecx+eax+380], dx

; 390  : 	gObj[BossIndex].TY = BossY;

  0156f	0f bf 45 f4	 movsx	 eax, WORD PTR _BossIndex$[ebp]
  01573	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01579	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0157f	66 8b 55 14	 mov	 dx, WORD PTR _BossY$[ebp]
  01583	66 89 94 01 7e
	01 00 00	 mov	 WORD PTR [ecx+eax+382], dx

; 391  : 	gObj[BossIndex].m_OldX = BossX;

  0158b	0f bf 45 f4	 movsx	 eax, WORD PTR _BossIndex$[ebp]
  0158f	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01595	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0159b	66 8b 55 10	 mov	 dx, WORD PTR _BossX$[ebp]
  0159f	66 89 94 01 78
	01 00 00	 mov	 WORD PTR [ecx+eax+376], dx

; 392  : 	gObj[BossIndex].m_OldY = BossY;

  015a7	0f bf 45 f4	 movsx	 eax, WORD PTR _BossIndex$[ebp]
  015ab	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  015b1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  015b7	66 8b 55 14	 mov	 dx, WORD PTR _BossY$[ebp]
  015bb	66 89 94 01 7a
	01 00 00	 mov	 WORD PTR [ecx+eax+378], dx

; 393  : 	gObj[BossIndex].StartX = BossX;

  015c3	0f bf 45 f4	 movsx	 eax, WORD PTR _BossIndex$[ebp]
  015c7	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  015cd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  015d3	8a 55 10	 mov	 dl, BYTE PTR _BossX$[ebp]
  015d6	88 94 01 76 01
	00 00		 mov	 BYTE PTR [ecx+eax+374], dl

; 394  : 	gObj[BossIndex].StartY = BossY;

  015dd	0f bf 45 f4	 movsx	 eax, WORD PTR _BossIndex$[ebp]
  015e1	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  015e7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  015ed	8a 55 14	 mov	 dl, BYTE PTR _BossY$[ebp]
  015f0	88 94 01 77 01
	00 00		 mov	 BYTE PTR [ecx+eax+375], dl

; 395  : 	gObj[BossIndex].MaxRegenTime = 0;

  015f7	0f bf 45 f4	 movsx	 eax, WORD PTR _BossIndex$[ebp]
  015fb	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01601	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01607	c7 84 01 ac 03
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+940], 0

; 396  : 	gObj[BossIndex].Dir = rand()%8;

  01612	e8 00 00 00 00	 call	 _rand
  01617	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  0161c	79 05		 jns	 SHORT $LN15@AddBossEx
  0161e	48		 dec	 eax
  0161f	83 c8 f8	 or	 eax, -8			; fffffff8H
  01622	40		 inc	 eax
$LN15@AddBossEx:
  01623	0f bf 4d f4	 movsx	 ecx, WORD PTR _BossIndex$[ebp]
  01627	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0162d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01633	88 84 0a 48 01
	00 00		 mov	 BYTE PTR [edx+ecx+328], al

; 397  : 	gObj[BossIndex].RegenTime = GetTickCount();

  0163a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  01640	0f bf 4d f4	 movsx	 ecx, WORD PTR _BossIndex$[ebp]
  01644	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0164a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01650	89 84 0a a8 03
	00 00		 mov	 DWORD PTR [edx+ecx+936], eax

; 398  : 	gObj[BossIndex].m_ActState.Emotion = 1;

  01657	0f bf 45 f4	 movsx	 eax, WORD PTR _BossIndex$[ebp]
  0165b	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01661	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01667	8b 94 01 18 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+536]
  0166e	81 e2 0f ff ff
	ff		 and	 edx, -241		; ffffff0fH
  01674	83 ca 10	 or	 edx, 16			; 00000010H
  01677	0f bf 45 f4	 movsx	 eax, WORD PTR _BossIndex$[ebp]
  0167b	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01681	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01687	89 94 01 18 02
	00 00		 mov	 DWORD PTR [ecx+eax+536], edx

; 399  : 	gObj[BossIndex].m_ActState.EmotionCount = 15;

  0168e	0f bf 45 f4	 movsx	 eax, WORD PTR _BossIndex$[ebp]
  01692	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01698	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0169e	8b 94 01 18 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+536]
  016a5	81 e2 ff 00 ff
	ff		 and	 edx, -65281		; ffff00ffH
  016ab	81 ca 00 0f 00
	00		 or	 edx, 3840		; 00000f00H
  016b1	0f bf 45 f4	 movsx	 eax, WORD PTR _BossIndex$[ebp]
  016b5	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  016bb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  016c1	89 94 01 18 02
	00 00		 mov	 DWORD PTR [ecx+eax+536], edx

; 400  : 
; 401  : 	gObjSetMonster(BossIndex, BossClass);

  016c8	8b 45 0c	 mov	 eax, DWORD PTR _BossClass$[ebp]
  016cb	50		 push	 eax
  016cc	0f bf 4d f4	 movsx	 ecx, WORD PTR _BossIndex$[ebp]
  016d0	51		 push	 ecx
  016d1	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster
  016d6	83 c4 08	 add	 esp, 8

; 402  : 
; 403  : 	char szMsg[128];
; 404  : 	sprintf(szMsg,"[Map Quest] Boss %s in %s map", gObj[BossIndex].Name, exMapName(gObj[BossIndex].MapNumber));

  016d9	0f bf 45 f4	 movsx	 eax, WORD PTR _BossIndex$[ebp]
  016dd	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  016e3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  016e9	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  016f1	52		 push	 edx
  016f2	e8 00 00 00 00	 call	 ?exMapName@@YAPADH@Z	; exMapName
  016f7	83 c4 04	 add	 esp, 4
  016fa	50		 push	 eax
  016fb	0f bf 45 f4	 movsx	 eax, WORD PTR _BossIndex$[ebp]
  016ff	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01705	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0170b	8d 54 01 77	 lea	 edx, DWORD PTR [ecx+eax+119]
  0170f	52		 push	 edx
  01710	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@MJJEBMGN@?$FLMap?5Quest?$FN?5Boss?5?$CFs?5in?5?$CFs?5map?$AA@
  01715	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _szMsg$[ebp]
  0171b	50		 push	 eax
  0171c	e8 00 00 00 00	 call	 _sprintf
  01721	83 c4 10	 add	 esp, 16			; 00000010H

; 405  : 	AllSendServerMsg(szMsg);

  01724	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _szMsg$[ebp]
  0172a	50		 push	 eax
  0172b	e8 00 00 00 00	 call	 ?AllSendServerMsg@@YAXPAD@Z ; AllSendServerMsg
  01730	83 c4 04	 add	 esp, 4

; 406  : 
; 407  : 	this->m_BossStart[Map] = true;

  01733	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  01736	03 45 08	 add	 eax, DWORD PTR _Map$[ebp]
  01739	c6 80 78 01 00
	00 01		 mov	 BYTE PTR [eax+376], 1

; 408  : 
; 409  : 	short X = BossX;

  01740	66 8b 45 10	 mov	 ax, WORD PTR _BossX$[ebp]
  01744	66 89 85 70 ff
	ff ff		 mov	 WORD PTR _X$[ebp], ax

; 410  : 	short Y = BossY;

  0174b	66 8b 45 14	 mov	 ax, WORD PTR _BossY$[ebp]
  0174f	66 89 85 6c ff
	ff ff		 mov	 WORD PTR _Y$[ebp], ax

; 411  : 
; 412  : 	for(int i = 0; i < 100; i++)

  01756	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$228563[ebp], 0
  01760	eb 0f		 jmp	 SHORT $LN5@AddBossEx
$LN4@AddBossEx:
  01762	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _i$228563[ebp]
  01768	83 c0 01	 add	 eax, 1
  0176b	89 85 68 ff ff
	ff		 mov	 DWORD PTR _i$228563[ebp], eax
$LN5@AddBossEx:
  01771	83 bd 68 ff ff
	ff 64		 cmp	 DWORD PTR _i$228563[ebp], 100 ; 00000064H
  01778	0f 8d 50 03 00
	00		 jge	 $LN8@AddBossEx

; 413  : 	{
; 414  : 		if(this->m_Monster[Map][i].sPos == -1)

  0177e	8b 45 08	 mov	 eax, DWORD PTR _Map$[ebp]
  01781	69 c0 58 02 00
	00		 imul	 eax, 600		; 00000258H
  01787	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0178a	8d 94 01 ee 03
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1006]
  01791	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _i$228563[ebp]
  01797	6b c0 06	 imul	 eax, 6
  0179a	0f bf 4c 02 02	 movsx	 ecx, WORD PTR [edx+eax+2]
  0179f	83 f9 ff	 cmp	 ecx, -1
  017a2	75 02		 jne	 SHORT $LN2@AddBossEx

; 415  : 		{
; 416  : 			continue;

  017a4	eb bc		 jmp	 SHORT $LN4@AddBossEx
$LN2@AddBossEx:

; 417  : 		}
; 418  : 
; 419  : 		int OrcIndex = gObjAddMonster(Map);

  017a6	8b 45 08	 mov	 eax, DWORD PTR _Map$[ebp]
  017a9	50		 push	 eax
  017aa	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  017af	83 c4 04	 add	 esp, 4
  017b2	0f bf c8	 movsx	 ecx, ax
  017b5	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _OrcIndex$228568[ebp], ecx

; 420  : 
; 421  : 		if(!OBJMAX_RANGE(OrcIndex))

  017bb	83 bd 64 ff ff
	ff 00		 cmp	 DWORD PTR _OrcIndex$228568[ebp], 0
  017c2	7d 0c		 jge	 SHORT $LN12@AddBossEx
  017c4	c7 85 20 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv240[ebp], 0
  017ce	eb 15		 jmp	 SHORT $LN13@AddBossEx
$LN12@AddBossEx:
  017d0	33 c0		 xor	 eax, eax
  017d2	81 bd 64 ff ff
	ff 97 3a 00 00	 cmp	 DWORD PTR _OrcIndex$228568[ebp], 14999 ; 00003a97H
  017dc	0f 9e c0	 setle	 al
  017df	89 85 20 ff ff
	ff		 mov	 DWORD PTR tv240[ebp], eax
$LN13@AddBossEx:
  017e5	83 bd 20 ff ff
	ff 00		 cmp	 DWORD PTR tv240[ebp], 0
  017ec	75 05		 jne	 SHORT $LN1@AddBossEx

; 422  : 		{
; 423  : 			continue;

  017ee	e9 6f ff ff ff	 jmp	 $LN4@AddBossEx
$LN1@AddBossEx:

; 424  : 		}
; 425  : 
; 426  : 		this->m_Monster[Map][i].sIndex = OrcIndex;

  017f3	8b 45 08	 mov	 eax, DWORD PTR _Map$[ebp]
  017f6	69 c0 58 02 00
	00		 imul	 eax, 600		; 00000258H
  017fc	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  017ff	8d 94 01 ee 03
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1006]
  01806	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _i$228563[ebp]
  0180c	6b c0 06	 imul	 eax, 6
  0180f	66 8b 8d 64 ff
	ff ff		 mov	 cx, WORD PTR _OrcIndex$228568[ebp]
  01816	66 89 0c 02	 mov	 WORD PTR [edx+eax], cx

; 427  : 
; 428  : 		gMSetBase.GetBoxPosition(Map, (BossX - 5), (BossY - 5), (BossX + 5), (BossY + 5), X, Y);

  0181a	8d 85 6c ff ff
	ff		 lea	 eax, DWORD PTR _Y$[ebp]
  01820	50		 push	 eax
  01821	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _X$[ebp]
  01827	51		 push	 ecx
  01828	8b 55 14	 mov	 edx, DWORD PTR _BossY$[ebp]
  0182b	83 c2 05	 add	 edx, 5
  0182e	52		 push	 edx
  0182f	8b 45 10	 mov	 eax, DWORD PTR _BossX$[ebp]
  01832	83 c0 05	 add	 eax, 5
  01835	50		 push	 eax
  01836	8b 4d 14	 mov	 ecx, DWORD PTR _BossY$[ebp]
  01839	83 e9 05	 sub	 ecx, 5
  0183c	51		 push	 ecx
  0183d	8b 55 10	 mov	 edx, DWORD PTR _BossX$[ebp]
  01840	83 ea 05	 sub	 edx, 5
  01843	52		 push	 edx
  01844	8b 45 08	 mov	 eax, DWORD PTR _Map$[ebp]
  01847	50		 push	 eax
  01848	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMSetBase@@3VCMonsterSetBase@@A ; gMSetBase
  0184d	e8 00 00 00 00	 call	 ?GetBoxPosition@CMonsterSetBase@@QAEHHHHHHAAF0@Z ; CMonsterSetBase::GetBoxPosition

; 429  : 		
; 430  : 		gObj[OrcIndex].m_PosNum = this->m_Monster[Map][i].sPos;

  01852	8b 45 08	 mov	 eax, DWORD PTR _Map$[ebp]
  01855	69 c0 58 02 00
	00		 imul	 eax, 600		; 00000258H
  0185b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0185e	8d 94 01 ee 03
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1006]
  01865	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _i$228563[ebp]
  0186b	6b c0 06	 imul	 eax, 6
  0186e	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _OrcIndex$228568[ebp]
  01874	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0187a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01880	66 8b 54 02 02	 mov	 dx, WORD PTR [edx+eax+2]
  01885	66 89 94 0e b0
	03 00 00	 mov	 WORD PTR [esi+ecx+944], dx

; 431  : 		gObj[OrcIndex].MapNumber = Map;

  0188d	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _OrcIndex$228568[ebp]
  01893	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01899	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0189f	8a 55 08	 mov	 dl, BYTE PTR _Map$[ebp]
  018a2	88 94 01 49 01
	00 00		 mov	 BYTE PTR [ecx+eax+329], dl

; 432  : 		gObj[OrcIndex].Dir = rand()%8;

  018a9	e8 00 00 00 00	 call	 _rand
  018ae	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  018b3	79 05		 jns	 SHORT $LN16@AddBossEx
  018b5	48		 dec	 eax
  018b6	83 c8 f8	 or	 eax, -8			; fffffff8H
  018b9	40		 inc	 eax
$LN16@AddBossEx:
  018ba	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _OrcIndex$228568[ebp]
  018c0	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  018c6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  018cc	88 84 0a 48 01
	00 00		 mov	 BYTE PTR [edx+ecx+328], al

; 433  : 		gObj[OrcIndex].X = X;

  018d3	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _OrcIndex$228568[ebp]
  018d9	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  018df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  018e5	66 8b 95 70 ff
	ff ff		 mov	 dx, WORD PTR _X$[ebp]
  018ec	66 89 94 01 44
	01 00 00	 mov	 WORD PTR [ecx+eax+324], dx

; 434  : 		gObj[OrcIndex].Y = Y;

  018f4	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _OrcIndex$228568[ebp]
  018fa	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01900	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01906	66 8b 95 6c ff
	ff ff		 mov	 dx, WORD PTR _Y$[ebp]
  0190d	66 89 94 01 46
	01 00 00	 mov	 WORD PTR [ecx+eax+326], dx

; 435  : 		gObj[OrcIndex].TX = X;

  01915	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _OrcIndex$228568[ebp]
  0191b	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01921	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01927	66 8b 95 70 ff
	ff ff		 mov	 dx, WORD PTR _X$[ebp]
  0192e	66 89 94 01 7c
	01 00 00	 mov	 WORD PTR [ecx+eax+380], dx

; 436  : 		gObj[OrcIndex].TY = Y;

  01936	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _OrcIndex$228568[ebp]
  0193c	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01942	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01948	66 8b 95 6c ff
	ff ff		 mov	 dx, WORD PTR _Y$[ebp]
  0194f	66 89 94 01 7e
	01 00 00	 mov	 WORD PTR [ecx+eax+382], dx

; 437  : 		gObj[OrcIndex].m_OldX = X;

  01957	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _OrcIndex$228568[ebp]
  0195d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01963	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01969	66 8b 95 70 ff
	ff ff		 mov	 dx, WORD PTR _X$[ebp]
  01970	66 89 94 01 78
	01 00 00	 mov	 WORD PTR [ecx+eax+376], dx

; 438  : 		gObj[OrcIndex].m_OldY = Y;

  01978	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _OrcIndex$228568[ebp]
  0197e	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01984	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0198a	66 8b 95 6c ff
	ff ff		 mov	 dx, WORD PTR _Y$[ebp]
  01991	66 89 94 01 7a
	01 00 00	 mov	 WORD PTR [ecx+eax+378], dx

; 439  : 		gObj[OrcIndex].StartX = X;

  01999	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _OrcIndex$228568[ebp]
  0199f	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  019a5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  019ab	8a 95 70 ff ff
	ff		 mov	 dl, BYTE PTR _X$[ebp]
  019b1	88 94 01 76 01
	00 00		 mov	 BYTE PTR [ecx+eax+374], dl

; 440  : 		gObj[OrcIndex].StartY = Y;

  019b8	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _OrcIndex$228568[ebp]
  019be	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  019c4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  019ca	8a 95 6c ff ff
	ff		 mov	 dl, BYTE PTR _Y$[ebp]
  019d0	88 94 01 77 01
	00 00		 mov	 BYTE PTR [ecx+eax+375], dl

; 441  : 		gObj[OrcIndex].MaxRegenTime = 0;

  019d7	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _OrcIndex$228568[ebp]
  019dd	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  019e3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  019e9	c7 84 01 ac 03
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+940], 0

; 442  : 		gObj[OrcIndex].Dir = rand()%8;

  019f4	e8 00 00 00 00	 call	 _rand
  019f9	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  019fe	79 05		 jns	 SHORT $LN17@AddBossEx
  01a00	48		 dec	 eax
  01a01	83 c8 f8	 or	 eax, -8			; fffffff8H
  01a04	40		 inc	 eax
$LN17@AddBossEx:
  01a05	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _OrcIndex$228568[ebp]
  01a0b	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  01a11	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01a17	88 84 0a 48 01
	00 00		 mov	 BYTE PTR [edx+ecx+328], al

; 443  : 		gObj[OrcIndex].RegenTime = GetTickCount();

  01a1e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  01a24	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _OrcIndex$228568[ebp]
  01a2a	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  01a30	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01a36	89 84 0a a8 03
	00 00		 mov	 DWORD PTR [edx+ecx+936], eax

; 444  : 		gObj[OrcIndex].m_ActState.Emotion = 1;

  01a3d	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _OrcIndex$228568[ebp]
  01a43	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01a49	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01a4f	8b 94 01 18 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+536]
  01a56	81 e2 0f ff ff
	ff		 and	 edx, -241		; ffffff0fH
  01a5c	83 ca 10	 or	 edx, 16			; 00000010H
  01a5f	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _OrcIndex$228568[ebp]
  01a65	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01a6b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01a71	89 94 01 18 02
	00 00		 mov	 DWORD PTR [ecx+eax+536], edx

; 445  : 		gObj[OrcIndex].m_ActState.EmotionCount = 15;

  01a78	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _OrcIndex$228568[ebp]
  01a7e	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01a84	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01a8a	8b 94 01 18 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+536]
  01a91	81 e2 ff 00 ff
	ff		 and	 edx, -65281		; ffff00ffH
  01a97	81 ca 00 0f 00
	00		 or	 edx, 3840		; 00000f00H
  01a9d	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _OrcIndex$228568[ebp]
  01aa3	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01aa9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01aaf	89 94 01 18 02
	00 00		 mov	 DWORD PTR [ecx+eax+536], edx

; 446  : 
; 447  : 		gObjSetMonster(OrcIndex, OrcClass);

  01ab6	8b 45 18	 mov	 eax, DWORD PTR _OrcClass$[ebp]
  01ab9	50		 push	 eax
  01aba	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _OrcIndex$228568[ebp]
  01ac0	51		 push	 ecx
  01ac1	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster
  01ac6	83 c4 08	 add	 esp, 8

; 448  : 	}

  01ac9	e9 94 fc ff ff	 jmp	 $LN4@AddBossEx
$LN8@AddBossEx:

; 449  : }

  01ace	5f		 pop	 edi
  01acf	5e		 pop	 esi
  01ad0	5b		 pop	 ebx
  01ad1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01ad4	33 cd		 xor	 ecx, ebp
  01ad6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01adb	8b e5		 mov	 esp, ebp
  01add	5d		 pop	 ebp
  01ade	c2 18 00	 ret	 24			; 00000018H
?AddBossEx@CMapQuest@@QAEXHHHHHH@Z ENDP			; CMapQuest::AddBossEx
_TEXT	ENDS
EXTRN	?gObjDel@@YAFH@Z:PROC				; gObjDel
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_i$228576 = -8						; size = 4
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_Map$ = 12						; size = 4
?DelMonster@CMapQuest@@QAEXHH@Z PROC			; CMapQuest::DelMonster
; _this$ = ecx

; 452  : {

  01af0	55		 push	 ebp
  01af1	8b ec		 mov	 ebp, esp
  01af3	83 ec 48	 sub	 esp, 72			; 00000048H
  01af6	53		 push	 ebx
  01af7	56		 push	 esi
  01af8	57		 push	 edi
  01af9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 453  : 	if(this->m_Boss[Map].sIndex == aIndex)

  01afc	8b 45 0c	 mov	 eax, DWORD PTR _Map$[ebp]
  01aff	6b c0 06	 imul	 eax, 6
  01b02	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01b05	0f bf 94 01 d2
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+466]
  01b0d	3b 55 08	 cmp	 edx, DWORD PTR _aIndex$[ebp]
  01b10	75 22		 jne	 SHORT $LN5@DelMonster

; 454  : 	{
; 455  : 		gObjDel(aIndex);

  01b12	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  01b15	50		 push	 eax
  01b16	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  01b1b	83 c4 04	 add	 esp, 4

; 456  : 		this->m_Boss[Map].sIndex = -1;

  01b1e	8b 45 0c	 mov	 eax, DWORD PTR _Map$[ebp]
  01b21	6b c0 06	 imul	 eax, 6
  01b24	83 c9 ff	 or	 ecx, -1
  01b27	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01b2a	66 89 8c 02 d2
	01 00 00	 mov	 WORD PTR [edx+eax+466], cx

; 457  : 		return;

  01b32	eb 6a		 jmp	 SHORT $LN6@DelMonster
$LN5@DelMonster:

; 458  : 	}
; 459  : 
; 460  : 	for(int i = 0; i < 100; i++)

  01b34	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$228576[ebp], 0
  01b3b	eb 09		 jmp	 SHORT $LN4@DelMonster
$LN3@DelMonster:
  01b3d	8b 45 f8	 mov	 eax, DWORD PTR _i$228576[ebp]
  01b40	83 c0 01	 add	 eax, 1
  01b43	89 45 f8	 mov	 DWORD PTR _i$228576[ebp], eax
$LN4@DelMonster:
  01b46	83 7d f8 64	 cmp	 DWORD PTR _i$228576[ebp], 100 ; 00000064H
  01b4a	7d 52		 jge	 SHORT $LN6@DelMonster

; 461  : 	{
; 462  : 		if(this->m_Monster[Map][i].sIndex == aIndex)

  01b4c	8b 45 0c	 mov	 eax, DWORD PTR _Map$[ebp]
  01b4f	69 c0 58 02 00
	00		 imul	 eax, 600		; 00000258H
  01b55	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01b58	8d 94 01 ee 03
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1006]
  01b5f	8b 45 f8	 mov	 eax, DWORD PTR _i$228576[ebp]
  01b62	6b c0 06	 imul	 eax, 6
  01b65	0f bf 0c 02	 movsx	 ecx, WORD PTR [edx+eax]
  01b69	3b 4d 08	 cmp	 ecx, DWORD PTR _aIndex$[ebp]
  01b6c	75 2e		 jne	 SHORT $LN1@DelMonster

; 463  : 		{
; 464  : 			gObjDel(aIndex);

  01b6e	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  01b71	50		 push	 eax
  01b72	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  01b77	83 c4 04	 add	 esp, 4

; 465  : 			this->m_Monster[Map][i].sIndex = -1;

  01b7a	8b 45 0c	 mov	 eax, DWORD PTR _Map$[ebp]
  01b7d	69 c0 58 02 00
	00		 imul	 eax, 600		; 00000258H
  01b83	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01b86	8d 94 01 ee 03
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1006]
  01b8d	8b 45 f8	 mov	 eax, DWORD PTR _i$228576[ebp]
  01b90	6b c0 06	 imul	 eax, 6
  01b93	83 c9 ff	 or	 ecx, -1
  01b96	66 89 0c 02	 mov	 WORD PTR [edx+eax], cx

; 466  : 			return;

  01b9a	eb 02		 jmp	 SHORT $LN6@DelMonster
$LN1@DelMonster:

; 467  : 		}
; 468  : 	}

  01b9c	eb 9f		 jmp	 SHORT $LN3@DelMonster
$LN6@DelMonster:

; 469  : }

  01b9e	5f		 pop	 edi
  01b9f	5e		 pop	 esi
  01ba0	5b		 pop	 ebx
  01ba1	8b e5		 mov	 esp, ebp
  01ba3	5d		 pop	 ebp
  01ba4	c2 08 00	 ret	 8
?DelMonster@CMapQuest@@QAEXHH@Z ENDP			; CMapQuest::DelMonster
; Function compile flags: /Odtp /ZI
tv134 = -76						; size = 4
tv75 = -76						; size = 4
_i$228586 = -8						; size = 4
_this$ = -4						; size = 4
_Map$ = 8						; size = 4
?DelMonsterMap@CMapQuest@@QAEXH@Z PROC			; CMapQuest::DelMonsterMap
; _this$ = ecx

; 472  : {

  01bb0	55		 push	 ebp
  01bb1	8b ec		 mov	 ebp, esp
  01bb3	83 ec 4c	 sub	 esp, 76			; 0000004cH
  01bb6	53		 push	 ebx
  01bb7	56		 push	 esi
  01bb8	57		 push	 edi
  01bb9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 473  : 	if(OBJMAX_RANGE(this->m_Boss[Map].sIndex))

  01bbc	8b 45 08	 mov	 eax, DWORD PTR _Map$[ebp]
  01bbf	6b c0 06	 imul	 eax, 6
  01bc2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01bc5	0f bf 94 01 d2
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+466]
  01bcd	85 d2		 test	 edx, edx
  01bcf	7d 09		 jge	 SHORT $LN8@DelMonster@2
  01bd1	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], 0
  01bd8	eb 1f		 jmp	 SHORT $LN9@DelMonster@2
$LN8@DelMonster@2:
  01bda	8b 45 08	 mov	 eax, DWORD PTR _Map$[ebp]
  01bdd	6b c0 06	 imul	 eax, 6
  01be0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01be3	0f bf 94 01 d2
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+466]
  01beb	33 c0		 xor	 eax, eax
  01bed	81 fa 97 3a 00
	00		 cmp	 edx, 14999		; 00003a97H
  01bf3	0f 9e c0	 setle	 al
  01bf6	89 45 b4	 mov	 DWORD PTR tv75[ebp], eax
$LN9@DelMonster@2:
  01bf9	83 7d b4 00	 cmp	 DWORD PTR tv75[ebp], 0
  01bfd	74 2e		 je	 SHORT $LN5@DelMonster@2

; 474  : 	{
; 475  : 		gObjDel(this->m_Boss[Map].sIndex);

  01bff	8b 45 08	 mov	 eax, DWORD PTR _Map$[ebp]
  01c02	6b c0 06	 imul	 eax, 6
  01c05	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01c08	0f bf 94 01 d2
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+466]
  01c10	52		 push	 edx
  01c11	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  01c16	83 c4 04	 add	 esp, 4

; 476  : 		this->m_Boss[Map].sIndex = -1;

  01c19	8b 45 08	 mov	 eax, DWORD PTR _Map$[ebp]
  01c1c	6b c0 06	 imul	 eax, 6
  01c1f	83 c9 ff	 or	 ecx, -1
  01c22	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01c25	66 89 8c 02 d2
	01 00 00	 mov	 WORD PTR [edx+eax+466], cx
$LN5@DelMonster@2:

; 477  : 	}
; 478  : 	
; 479  : 	for(int i = 0; i < 100; i++)

  01c2d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$228586[ebp], 0
  01c34	eb 09		 jmp	 SHORT $LN4@DelMonster@2
$LN3@DelMonster@2:
  01c36	8b 45 f8	 mov	 eax, DWORD PTR _i$228586[ebp]
  01c39	83 c0 01	 add	 eax, 1
  01c3c	89 45 f8	 mov	 DWORD PTR _i$228586[ebp], eax
$LN4@DelMonster@2:
  01c3f	83 7d f8 64	 cmp	 DWORD PTR _i$228586[ebp], 100 ; 00000064H
  01c43	0f 8d a5 00 00
	00		 jge	 $LN6@DelMonster@2

; 480  : 	{
; 481  : 		if(OBJMAX_RANGE(this->m_Monster[Map][i].sIndex))

  01c49	8b 45 08	 mov	 eax, DWORD PTR _Map$[ebp]
  01c4c	69 c0 58 02 00
	00		 imul	 eax, 600		; 00000258H
  01c52	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01c55	8d 94 01 ee 03
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1006]
  01c5c	8b 45 f8	 mov	 eax, DWORD PTR _i$228586[ebp]
  01c5f	6b c0 06	 imul	 eax, 6
  01c62	0f bf 0c 02	 movsx	 ecx, WORD PTR [edx+eax]
  01c66	85 c9		 test	 ecx, ecx
  01c68	7d 09		 jge	 SHORT $LN10@DelMonster@2
  01c6a	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv134[ebp], 0
  01c71	eb 2a		 jmp	 SHORT $LN11@DelMonster@2
$LN10@DelMonster@2:
  01c73	8b 55 08	 mov	 edx, DWORD PTR _Map$[ebp]
  01c76	69 d2 58 02 00
	00		 imul	 edx, 600		; 00000258H
  01c7c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01c7f	8d 8c 10 ee 03
	00 00		 lea	 ecx, DWORD PTR [eax+edx+1006]
  01c86	8b 55 f8	 mov	 edx, DWORD PTR _i$228586[ebp]
  01c89	6b d2 06	 imul	 edx, 6
  01c8c	0f bf 04 11	 movsx	 eax, WORD PTR [ecx+edx]
  01c90	33 c9		 xor	 ecx, ecx
  01c92	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  01c97	0f 9e c1	 setle	 cl
  01c9a	89 4d b4	 mov	 DWORD PTR tv134[ebp], ecx
$LN11@DelMonster@2:
  01c9d	83 7d b4 00	 cmp	 DWORD PTR tv134[ebp], 0
  01ca1	74 46		 je	 SHORT $LN1@DelMonster@2

; 482  : 		{
; 483  : 			gObjDel(this->m_Monster[Map][i].sIndex);

  01ca3	8b 45 08	 mov	 eax, DWORD PTR _Map$[ebp]
  01ca6	69 c0 58 02 00
	00		 imul	 eax, 600		; 00000258H
  01cac	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01caf	8d 94 01 ee 03
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1006]
  01cb6	8b 45 f8	 mov	 eax, DWORD PTR _i$228586[ebp]
  01cb9	6b c0 06	 imul	 eax, 6
  01cbc	0f bf 0c 02	 movsx	 ecx, WORD PTR [edx+eax]
  01cc0	51		 push	 ecx
  01cc1	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  01cc6	83 c4 04	 add	 esp, 4

; 484  : 			this->m_Monster[Map][i].sIndex = -1;

  01cc9	8b 45 08	 mov	 eax, DWORD PTR _Map$[ebp]
  01ccc	69 c0 58 02 00
	00		 imul	 eax, 600		; 00000258H
  01cd2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01cd5	8d 94 01 ee 03
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1006]
  01cdc	8b 45 f8	 mov	 eax, DWORD PTR _i$228586[ebp]
  01cdf	6b c0 06	 imul	 eax, 6
  01ce2	83 c9 ff	 or	 ecx, -1
  01ce5	66 89 0c 02	 mov	 WORD PTR [edx+eax], cx
$LN1@DelMonster@2:

; 485  : 		}
; 486  : 	}

  01ce9	e9 48 ff ff ff	 jmp	 $LN3@DelMonster@2
$LN6@DelMonster@2:

; 487  : }

  01cee	5f		 pop	 edi
  01cef	5e		 pop	 esi
  01cf0	5b		 pop	 ebx
  01cf1	8b e5		 mov	 esp, ebp
  01cf3	5d		 pop	 ebp
  01cf4	c2 04 00	 ret	 4
?DelMonsterMap@CMapQuest@@QAEXH@Z ENDP			; CMapQuest::DelMonsterMap
_TEXT	ENDS
PUBLIC	?GetMapMonster@CMapQuest@@QAE_NH@Z		; CMapQuest::GetMapMonster
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_i$228601 = -12						; size = 4
_m$228596 = -8						; size = 4
_this$ = -4						; size = 4
_aPos$ = 8						; size = 4
?GetMapMonster@CMapQuest@@QAE_NH@Z PROC			; CMapQuest::GetMapMonster
; _this$ = ecx

; 490  : {

  01d00	55		 push	 ebp
  01d01	8b ec		 mov	 ebp, esp
  01d03	83 ec 4c	 sub	 esp, 76			; 0000004cH
  01d06	53		 push	 ebx
  01d07	56		 push	 esi
  01d08	57		 push	 edi
  01d09	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 491  : //	int iPos = gObj[aIndex].m_Pos;
; 492  : 
; 493  : 	//if(OBJMAX_RANGE(aIndex))
; 494  : 	if(aPos != -1)

  01d0c	83 7d 08 ff	 cmp	 DWORD PTR _aPos$[ebp], -1
  01d10	74 75		 je	 SHORT $LN9@GetMapMons

; 495  : 	{
; 496  : 		for(int m = 0; m < MAX_NUMBER_MAP; m++)

  01d12	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _m$228596[ebp], 0
  01d19	eb 09		 jmp	 SHORT $LN8@GetMapMons
$LN7@GetMapMons:
  01d1b	8b 45 f8	 mov	 eax, DWORD PTR _m$228596[ebp]
  01d1e	83 c0 01	 add	 eax, 1
  01d21	89 45 f8	 mov	 DWORD PTR _m$228596[ebp], eax
$LN8@GetMapMons:
  01d24	83 7d f8 5a	 cmp	 DWORD PTR _m$228596[ebp], 90 ; 0000005aH
  01d28	7d 5d		 jge	 SHORT $LN9@GetMapMons

; 497  : 		{
; 498  : 			if(this->m_Boss[m].sPos == aPos)

  01d2a	8b 45 f8	 mov	 eax, DWORD PTR _m$228596[ebp]
  01d2d	6b c0 06	 imul	 eax, 6
  01d30	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01d33	0f bf 94 01 d4
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+468]
  01d3b	3b 55 08	 cmp	 edx, DWORD PTR _aPos$[ebp]
  01d3e	75 04		 jne	 SHORT $LN5@GetMapMons

; 499  : 			{
; 500  : 				return true;

  01d40	b0 01		 mov	 al, 1
  01d42	eb 45		 jmp	 SHORT $LN10@GetMapMons
$LN5@GetMapMons:

; 501  : 			}
; 502  : 
; 503  : 			for(int i = 0; i < 100; i++)

  01d44	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$228601[ebp], 0
  01d4b	eb 09		 jmp	 SHORT $LN4@GetMapMons
$LN3@GetMapMons:
  01d4d	8b 45 f4	 mov	 eax, DWORD PTR _i$228601[ebp]
  01d50	83 c0 01	 add	 eax, 1
  01d53	89 45 f4	 mov	 DWORD PTR _i$228601[ebp], eax
$LN4@GetMapMons:
  01d56	83 7d f4 64	 cmp	 DWORD PTR _i$228601[ebp], 100 ; 00000064H
  01d5a	7d 29		 jge	 SHORT $LN2@GetMapMons

; 504  : 			{
; 505  : 				if(this->m_Monster[m][i].sPos == aPos)

  01d5c	8b 45 f8	 mov	 eax, DWORD PTR _m$228596[ebp]
  01d5f	69 c0 58 02 00
	00		 imul	 eax, 600		; 00000258H
  01d65	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01d68	8d 94 01 ee 03
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1006]
  01d6f	8b 45 f4	 mov	 eax, DWORD PTR _i$228601[ebp]
  01d72	6b c0 06	 imul	 eax, 6
  01d75	0f bf 4c 02 02	 movsx	 ecx, WORD PTR [edx+eax+2]
  01d7a	3b 4d 08	 cmp	 ecx, DWORD PTR _aPos$[ebp]
  01d7d	75 04		 jne	 SHORT $LN1@GetMapMons

; 506  : 				{
; 507  : 					return true;

  01d7f	b0 01		 mov	 al, 1
  01d81	eb 06		 jmp	 SHORT $LN10@GetMapMons
$LN1@GetMapMons:

; 508  : 				}
; 509  : 			}

  01d83	eb c8		 jmp	 SHORT $LN3@GetMapMons
$LN2@GetMapMons:

; 510  : 		}

  01d85	eb 94		 jmp	 SHORT $LN7@GetMapMons
$LN9@GetMapMons:

; 511  : 	}
; 512  : 
; 513  : 	return false;

  01d87	32 c0		 xor	 al, al
$LN10@GetMapMons:

; 514  : }

  01d89	5f		 pop	 edi
  01d8a	5e		 pop	 esi
  01d8b	5b		 pop	 ebx
  01d8c	8b e5		 mov	 esp, ebp
  01d8e	5d		 pop	 ebp
  01d8f	c2 04 00	 ret	 4
?GetMapMonster@CMapQuest@@QAE_NH@Z ENDP			; CMapQuest::GetMapMonster
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAE@V?$allocator@UMAPQUEST_DATA@@@1@@Z ; std::_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >
PUBLIC	??0?$allocator@UMAPQUEST_DATA@@@std@@QAE@XZ	; std::allocator<MAPQUEST_DATA>::allocator<MAPQUEST_DATA>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T229666 = -72						; size = 4
_this$ = -4						; size = 4
??0?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAE@XZ PROC ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	51		 push	 ecx
  0000d	8b cc		 mov	 ecx, esp
  0000f	89 65 b8	 mov	 DWORD PTR $T229666[ebp], esp
  00012	e8 00 00 00 00	 call	 ??0?$allocator@UMAPQUEST_DATA@@@std@@QAE@XZ ; std::allocator<MAPQUEST_DATA>::allocator<MAPQUEST_DATA>
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAE@V?$allocator@UMAPQUEST_DATA@@@1@@Z ; std::_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >

; 508  : 		}

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAE@XZ ENDP ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAE@XZ ; std::_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::~_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >
PUBLIC	?_Tidy@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@IAEXXZ ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??1?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAE@XZ PROC ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::~vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >, COMDAT
; _this$ = ecx

; 704  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 705  : 		_Tidy();

  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@IAEXXZ ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::_Tidy

; 706  : 		}

  0003a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??1?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAE@XZ ; std::_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::~_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >
  00049	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAE@XZ ; std::_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::~_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >
__ehhandler$??1?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAE@XZ ENDP ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::~vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >
; Function compile flags: /Odtp /ZI
;	COMDAT ?size@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QBEIXZ PROC ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::size, COMDAT
; _this$ = ecx

; 878  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	99		 cdq
  00018	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  0001d	f7 f9		 idiv	 ecx

; 880  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?size@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::size
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??A?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAEAAUMAPQUEST_DATA@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAEAAUMAPQUEST_DATA@@I@Z PROC ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::operator[], COMDAT
; _this$ = ecx

; 928  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 929  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 930  : 		if (size() <= _Pos)
; 931  : 			{	// report error
; 932  : 			_DEBUG_ERROR("vector subscript out of range");
; 933  : 			_SCL_SECURE_OUT_OF_RANGE;
; 934  : 			}
; 935  : 
; 936  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 937  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 938  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 939  : 
; 940  : 		return (*(this->_Myfirst + _Pos));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  0000f	6b c0 1c	 imul	 eax, 28			; 0000001cH
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	03 01		 add	 eax, DWORD PTR [ecx]

; 941  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??A?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAEAAUMAPQUEST_DATA@@I@Z ENDP ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::operator[]
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UMAPQUEST_DATA@@@std@@UMAPQUEST_DATA@@ABU3@@std@@YAXAAV?$allocator@UMAPQUEST_DATA@@@0@PAUMAPQUEST_DATA@@ABU2@@Z ; std::_Cons_val<std::allocator<MAPQUEST_DATA>,MAPQUEST_DATA,MAPQUEST_DATA const &>
PUBLIC	??$_Cons_val@V?$allocator@UMAPQUEST_DATA@@@std@@UMAPQUEST_DATA@@AAU3@@std@@YAXAAV?$allocator@UMAPQUEST_DATA@@@0@PAUMAPQUEST_DATA@@AAU2@@Z ; std::_Cons_val<std::allocator<MAPQUEST_DATA>,MAPQUEST_DATA,MAPQUEST_DATA &>
PUBLIC	?_Orphan_range@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@IBEXPAUMAPQUEST_DATA@@0@Z ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::_Orphan_range
PUBLIC	?_Reserve@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@IAEXI@Z ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::_Reserve
PUBLIC	?_Inside@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@IBE_NPBUMAPQUEST_DATA@@@Z ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::_Inside
PUBLIC	??$addressof@$$CBUMAPQUEST_DATA@@@std@@YAPBUMAPQUEST_DATA@@ABU1@@Z ; std::addressof<MAPQUEST_DATA const >
; Function compile flags: /Odtp /ZI
;	COMDAT ?push_back@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAEXABUMAPQUEST_DATA@@@Z
_TEXT	SEGMENT
__Idx$228629 = -8					; size = 4
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAEXABUMAPQUEST_DATA@@@Z PROC ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$addressof@$$CBUMAPQUEST_DATA@@@std@@YAPBUMAPQUEST_DATA@@ABU1@@Z ; std::addressof<MAPQUEST_DATA const >
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Inside@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@IBE_NPBUMAPQUEST_DATA@@@Z ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::_Inside
  00021	0f b6 c8	 movzx	 ecx, al
  00024	85 c9		 test	 ecx, ecx
  00026	74 7d		 je	 SHORT $LN4@push_back

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$addressof@$$CBUMAPQUEST_DATA@@@std@@YAPBUMAPQUEST_DATA@@ABU1@@Z ; std::addressof<MAPQUEST_DATA const >
  00031	83 c4 04	 add	 esp, 4
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	2b 01		 sub	 eax, DWORD PTR [ecx]
  00039	99		 cdq
  0003a	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  0003f	f7 f9		 idiv	 ecx
  00041	89 45 f8	 mov	 DWORD PTR __Idx$228629[ebp], eax

; 980  : 			if (this->_Mylast == this->_Myend)

  00044	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0004d	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00050	75 0a		 jne	 SHORT $LN3@push_back

; 981  : 				_Reserve(1);

  00052	6a 01		 push	 1
  00054	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@IAEXI@Z ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::_Reserve
$LN3@push_back:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  0005c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00062	51		 push	 ecx
  00063	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00066	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00069	50		 push	 eax
  0006a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006d	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@IBEXPAUMAPQUEST_DATA@@0@Z ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::_Orphan_range

; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  00072	8b 45 f8	 mov	 eax, DWORD PTR __Idx$228629[ebp]
  00075	6b c0 1c	 imul	 eax, 28			; 0000001cH
  00078	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	03 01		 add	 eax, DWORD PTR [ecx]
  0007d	50		 push	 eax
  0007e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00081	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00084	50		 push	 eax
  00085	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00088	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0008b	51		 push	 ecx
  0008c	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UMAPQUEST_DATA@@@std@@UMAPQUEST_DATA@@AAU3@@std@@YAXAAV?$allocator@UMAPQUEST_DATA@@@0@PAUMAPQUEST_DATA@@AAU2@@Z ; std::_Cons_val<std::allocator<MAPQUEST_DATA>,MAPQUEST_DATA,MAPQUEST_DATA &>
  00091	83 c4 0c	 add	 esp, 12			; 0000000cH

; 986  : 			++this->_Mylast;

  00094	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00097	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0009a	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0009d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000a0	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 987  : 			}
; 988  : 		else

  000a3	eb 57		 jmp	 SHORT $LN5@push_back
$LN4@push_back:

; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  000a5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ab	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000ae	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  000b1	75 0a		 jne	 SHORT $LN1@push_back

; 991  : 				_Reserve(1);

  000b3	6a 01		 push	 1
  000b5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b8	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@IAEXI@Z ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::_Reserve
$LN1@push_back:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  000bd	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000c3	51		 push	 ecx
  000c4	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c7	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000ca	50		 push	 eax
  000cb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ce	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@IBEXPAUMAPQUEST_DATA@@0@Z ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::_Orphan_range

; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  000d3	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  000d6	50		 push	 eax
  000d7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000da	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000dd	52		 push	 edx
  000de	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000e1	83 c0 0c	 add	 eax, 12			; 0000000cH
  000e4	50		 push	 eax
  000e5	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UMAPQUEST_DATA@@@std@@UMAPQUEST_DATA@@ABU3@@std@@YAXAAV?$allocator@UMAPQUEST_DATA@@@0@PAUMAPQUEST_DATA@@ABU2@@Z ; std::_Cons_val<std::allocator<MAPQUEST_DATA>,MAPQUEST_DATA,MAPQUEST_DATA const &>
  000ea	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  000ed	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000f0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000f3	83 c1 1c	 add	 ecx, 28			; 0000001cH
  000f6	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000f9	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN5@push_back:

; 997  : 			}
; 998  : 		}

  000fc	5f		 pop	 edi
  000fd	5e		 pop	 esi
  000fe	5b		 pop	 ebx
  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c2 04 00	 ret	 4
?push_back@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAEXABUMAPQUEST_DATA@@@Z ENDP ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::push_back
_TEXT	ENDS
PUBLIC	?erase@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@2@0@Z ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::erase
PUBLIC	?begin@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@2@XZ ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::begin
PUBLIC	?end@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@2@XZ ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::end
; Function compile flags: /Odtp /ZI
;	COMDAT ?clear@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T229685 = -88						; size = 4
$T229686 = -84						; size = 4
$T229687 = -80						; size = 4
$T229688 = -76						; size = 4
$T229689 = -72						; size = 4
_this$ = -4						; size = 4
?clear@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAEXXZ PROC ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::clear, COMDAT
; _this$ = ecx

; 1217 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1218 : 		erase(begin(), end());

  0000c	8d 45 ac	 lea	 eax, DWORD PTR $T229686[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?end@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@2@XZ ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::end
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d a8	 mov	 DWORD PTR $T229685[ebp], ecx
  0001d	8d 55 b4	 lea	 edx, DWORD PTR $T229688[ebp]
  00020	52		 push	 edx
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?begin@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@2@XZ ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::begin
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 b0	 mov	 DWORD PTR $T229687[ebp], eax
  0002e	8b 4d a8	 mov	 ecx, DWORD PTR $T229685[ebp]
  00031	51		 push	 ecx
  00032	8b 55 b0	 mov	 edx, DWORD PTR $T229687[ebp]
  00035	52		 push	 edx
  00036	8d 45 b8	 lea	 eax, DWORD PTR $T229689[ebp]
  00039	50		 push	 eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?erase@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@2@0@Z ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::erase

; 1219 : 		}

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?clear@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAEXXZ ENDP ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::clear
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@std@@QAE@PAUMAPQUEST_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> > >::_Vector_iterator<std::_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ?begin@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@2@XZ PROC ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 782  : 		return (iterator(this->_Myfirst, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	52		 push	 edx
  00016	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00019	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@std@@QAE@PAUMAPQUEST_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> > >::_Vector_iterator<std::_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> > >
  0001e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 783  : 		}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?begin@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@2@XZ ENDP ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::begin
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?end@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@2@XZ PROC ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 792  : 		return (iterator(this->_Mylast, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	52		 push	 edx
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@std@@QAE@PAUMAPQUEST_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> > >::_Vector_iterator<std::_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> > >
  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 793  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?end@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@2@XZ ENDP ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::end
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@IAEXPAUMAPQUEST_DATA@@0@Z ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::_Destroy
PUBLIC	??$_Move@PAUMAPQUEST_DATA@@PAU1@@std@@YAPAUMAPQUEST_DATA@@PAU1@00@Z ; std::_Move<MAPQUEST_DATA *,MAPQUEST_DATA *>
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> > >::operator!=
PUBLIC	?_Make_iter@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@2@@Z ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::_Make_iter
; Function compile flags: /Odtp /ZI
;	COMDAT ?erase@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T229696 = -84						; size = 4
__Ptr$228820 = -16					; size = 4
__Last$ = -12						; size = 4
__First$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@2@0@Z PROC ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::erase, COMDAT
; _this$ = ecx

; 1190 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1191 : 		iterator _First = _Make_iter(_First_arg);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __First_arg$[ebp]
  0000f	50		 push	 eax
  00010	8d 4d f8	 lea	 ecx, DWORD PTR __First$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@2@@Z ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::_Make_iter

; 1192 : 		iterator _Last = _Make_iter(_Last_arg);

  0001c	8b 45 10	 mov	 eax, DWORD PTR __Last_arg$[ebp]
  0001f	50		 push	 eax
  00020	8d 4d f4	 lea	 ecx, DWORD PTR __Last$[ebp]
  00023	51		 push	 ecx
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@2@@Z ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::_Make_iter

; 1193 : 
; 1194 : 		if (_First != _Last)

  0002c	8d 45 f4	 lea	 eax, DWORD PTR __Last$[ebp]
  0002f	50		 push	 eax
  00030	8d 4d f8	 lea	 ecx, DWORD PTR __First$[ebp]
  00033	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> > >::operator!=
  00038	0f b6 c8	 movzx	 ecx, al
  0003b	85 c9		 test	 ecx, ecx
  0003d	74 36		 je	 SHORT $LN1@erase

; 1195 : 			{	// worth doing, copy down over hole
; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 			if (_Last < _First || _VICONT(_First) != this
; 1198 : 				|| _VIPTR(_First) < this->_Myfirst
; 1199 : 				|| this->_Mylast < _VIPTR(_Last))
; 1200 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1201 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1202 : 				_VIPTR(_First));
; 1203 : 			_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1204 : 
; 1205 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1206 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1207 : 				_VIPTR(_First));

  0003f	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00042	50		 push	 eax
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00049	52		 push	 edx
  0004a	8b 45 f4	 mov	 eax, DWORD PTR __Last$[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ??$_Move@PAUMAPQUEST_DATA@@PAU1@@std@@YAPAUMAPQUEST_DATA@@PAU1@00@Z ; std::_Move<MAPQUEST_DATA *,MAPQUEST_DATA *>
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH
  00056	89 45 f0	 mov	 DWORD PTR __Ptr$228820[ebp], eax

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 			_Destroy(_Ptr, this->_Mylast);

  00059	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005f	51		 push	 ecx
  00060	8b 55 f0	 mov	 edx, DWORD PTR __Ptr$228820[ebp]
  00063	52		 push	 edx
  00064	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@IAEXPAUMAPQUEST_DATA@@0@Z ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::_Destroy

; 1211 : 			this->_Mylast = _Ptr;

  0006c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006f	8b 4d f0	 mov	 ecx, DWORD PTR __Ptr$228820[ebp]
  00072	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@erase:

; 1212 : 			}
; 1213 : 		return (_Make_iter(_First));

  00075	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00078	89 45 ac	 mov	 DWORD PTR $T229696[ebp], eax
  0007b	8b 4d ac	 mov	 ecx, DWORD PTR $T229696[ebp]
  0007e	51		 push	 ecx
  0007f	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00082	52		 push	 edx
  00083	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@2@@Z ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::_Make_iter
  0008b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1214 : 		}

  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@2@0@Z ENDP ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::erase
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Inside@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@IBE_NPBUMAPQUEST_DATA@@@Z
_TEXT	SEGMENT
tv76 = -72						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@IBE_NPBUMAPQUEST_DATA@@@Z PROC ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00012	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00015	73 13		 jae	 SHORT $LN3@Inside
  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	3b 45 08	 cmp	 eax, DWORD PTR __Ptr$[ebp]
  0001f	77 09		 ja	 SHORT $LN3@Inside
  00021	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  00028	eb 07		 jmp	 SHORT $LN4@Inside
$LN3@Inside:
  0002a	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN4@Inside:
  00031	8a 45 b8	 mov	 al, BYTE PTR tv76[ebp]

; 1287 : 		}

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?_Inside@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@IBE_NPBUMAPQUEST_DATA@@@Z ENDP ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::_Inside
_TEXT	ENDS
PUBLIC	?reserve@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAEXI@Z ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::reserve
PUBLIC	?_Grow_to@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@IBEII@Z ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::_Grow_to
PUBLIC	?capacity@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QBEIXZ ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::capacity
PUBLIC	?_Xlen@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@IBEXXZ ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::_Xlen
PUBLIC	?max_size@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QBEIXZ ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Reserve@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$ = -8						; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@IAEXI@Z PROC ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1291 : 		size_type _Size = size();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?size@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QBEIXZ ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::size
  00014	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax

; 1292 : 		if (max_size() - _Count < _Size)

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QBEIXZ ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::max_size
  0001f	2b 45 08	 sub	 eax, DWORD PTR __Count$[ebp]
  00022	3b 45 f8	 cmp	 eax, DWORD PTR __Size$[ebp]
  00025	73 0a		 jae	 SHORT $LN4@Reserve

; 1293 : 			_Xlen();

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@IBEXXZ ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::_Xlen
  0002f	eb 2d		 jmp	 SHORT $LN6@Reserve
$LN4@Reserve:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00031	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  00034	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]
  00037	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?capacity@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QBEIXZ ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::capacity
  00042	39 45 f8	 cmp	 DWORD PTR __Size$[ebp], eax
  00045	77 02		 ja	 SHORT $LN2@Reserve

; 1295 : 			;
; 1296 : 		else

  00047	eb 15		 jmp	 SHORT $LN6@Reserve
$LN2@Reserve:

; 1297 : 			reserve(_Grow_to(_Size));

  00049	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?_Grow_to@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@IBEII@Z ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::_Grow_to
  00055	50		 push	 eax
  00056	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ?reserve@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAEXI@Z ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::reserve
$LN6@Reserve:

; 1298 : 		}

  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?_Reserve@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@IAEXI@Z ENDP ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::_Reserve
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UMAPQUEST_DATA@@@std@@QAEXPAUMAPQUEST_DATA@@I@Z ; std::allocator<MAPQUEST_DATA>::deallocate
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Tidy@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@IAEXXZ PROC ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1302 : 		if (this->_Myfirst != 0)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00012	74 42		 je	 SHORT $LN1@Tidy

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00022	51		 push	 ecx
  00023	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00026	8b 02		 mov	 eax, DWORD PTR [edx]
  00028	50		 push	 eax
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@IAEXPAUMAPQUEST_DATA@@0@Z ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::_Destroy

; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0003a	2b 01		 sub	 eax, DWORD PTR [ecx]
  0003c	99		 cdq
  0003d	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  00042	f7 f9		 idiv	 ecx
  00044	50		 push	 eax
  00045	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00048	8b 02		 mov	 eax, DWORD PTR [edx]
  0004a	50		 push	 eax
  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00051	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UMAPQUEST_DATA@@@std@@QAEXPAUMAPQUEST_DATA@@I@Z ; std::allocator<MAPQUEST_DATA>::deallocate
$LN1@Tidy:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00056	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00059	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1310 : 		this->_Mylast = 0;

  0005f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00062	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1311 : 		this->_Myend = 0;

  00069	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 1312 : 		}

  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	5b		 pop	 ebx
  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
?_Tidy@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@IAEXXZ ENDP ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::_Tidy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Orphan_range@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@IBEXPAUMAPQUEST_DATA@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@IBEXPAUMAPQUEST_DATA@@0@Z PROC ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1453 : 		{	// orphan iterators within specified (inclusive) range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1454 : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@IBEXPAUMAPQUEST_DATA@@0@Z ENDP ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??0?$allocator@UMAPQUEST_DATA@@@std@@QAE@ABV01@@Z ; std::allocator<MAPQUEST_DATA>::allocator<MAPQUEST_DATA>
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAE@V?$allocator@UMAPQUEST_DATA@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAE@V?$allocator@UMAPQUEST_DATA@@@1@@Z PROC ; std::_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00016	e8 00 00 00 00	 call	 ??0?$allocator@UMAPQUEST_DATA@@@std@@QAE@ABV01@@Z ; std::allocator<MAPQUEST_DATA>::allocator<MAPQUEST_DATA>

; 427  : 		_Myfirst = 0;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 428  : 		_Mylast = 0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 429  : 		_Myend = 0;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 430  : 		}

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
??0?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAE@V?$allocator@UMAPQUEST_DATA@@@1@@Z ENDP ; std::_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::~_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >, COMDAT
; _this$ = ecx

; 433  : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 434  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::~_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UMAPQUEST_DATA@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@UMAPQUEST_DATA@@@std@@QAE@XZ PROC	; std::allocator<MAPQUEST_DATA>::allocator<MAPQUEST_DATA>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@UMAPQUEST_DATA@@@std@@QAE@XZ ENDP	; std::allocator<MAPQUEST_DATA>::allocator<MAPQUEST_DATA>
_TEXT	ENDS
PUBLIC	??$_Umove@PAUMAPQUEST_DATA@@@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@IAEPAUMAPQUEST_DATA@@PAU2@00@Z ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::_Umove<MAPQUEST_DATA *>
PUBLIC	?allocate@?$allocator@UMAPQUEST_DATA@@@std@@QAEPAUMAPQUEST_DATA@@I@Z ; std::allocator<MAPQUEST_DATA>::allocate
EXTRN	__CxxThrowException@8:PROC
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\vector
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Size$228862 = -28					; size = 4
__Ptr$228855 = -24					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?reserve@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAEXI@Z PROC ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?reserve@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 747  : 		if (max_size() < _Count)

  0002f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?max_size@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QBEIXZ ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::max_size
  00037	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0003a	73 0d		 jae	 SHORT $LN5@reserve

; 748  : 			_Xlen();	// result too long

  0003c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@IBEXXZ ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::_Xlen
  00044	e9 f0 00 00 00	 jmp	 $LN7@reserve
$LN5@reserve:

; 749  : 		else if (capacity() < _Count)

  00049	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?capacity@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QBEIXZ ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::capacity
  00051	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  00054	0f 83 df 00 00
	00		 jae	 $LN7@reserve

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  0005a	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00064	e8 00 00 00 00	 call	 ?allocate@?$allocator@UMAPQUEST_DATA@@@std@@QAEPAUMAPQUEST_DATA@@I@Z ; std::allocator<MAPQUEST_DATA>::allocate
  00069	89 45 e8	 mov	 DWORD PTR __Ptr$228855[ebp], eax

; 752  : 
; 753  : 			_TRY_BEGIN

  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00073	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$228855[ebp]
  00076	50		 push	 eax
  00077	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007d	52		 push	 edx
  0007e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 08		 mov	 ecx, DWORD PTR [eax]
  00083	51		 push	 ecx
  00084	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	e8 00 00 00 00	 call	 ??$_Umove@PAUMAPQUEST_DATA@@@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@IAEPAUMAPQUEST_DATA@@PAU2@00@Z ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::_Umove<MAPQUEST_DATA *>
  0008c	eb 29		 jmp	 SHORT $LN8@reserve
__catch$?reserve@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  0008e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00091	50		 push	 eax
  00092	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$228855[ebp]
  00095	51		 push	 ecx
  00096	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0009c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UMAPQUEST_DATA@@@std@@QAEXPAUMAPQUEST_DATA@@I@Z ; std::allocator<MAPQUEST_DATA>::deallocate

; 757  : 			_RERAISE;

  000a1	6a 00		 push	 0
  000a3	6a 00		 push	 0
  000a5	e8 00 00 00 00	 call	 __CxxThrowException@8

; 758  : 			_CATCH_END

  000aa	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000b1	b8 00 00 00 00	 mov	 eax, __tryend$?reserve@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAEXI@Z$1
  000b6	c3		 ret	 0
$LN8@reserve:
  000b7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?reserve@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAEXI@Z$1:

; 759  : 
; 760  : 			size_type _Size = size();

  000be	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	e8 00 00 00 00	 call	 ?size@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QBEIXZ ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::size
  000c6	89 45 e4	 mov	 DWORD PTR __Size$228862[ebp], eax

; 761  : 			if (this->_Myfirst != 0)

  000c9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000cc	83 38 00	 cmp	 DWORD PTR [eax], 0
  000cf	74 3a		 je	 SHORT $LN1@reserve

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);

  000d1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d7	51		 push	 ecx
  000d8	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000db	8b 02		 mov	 eax, DWORD PTR [edx]
  000dd	50		 push	 eax
  000de	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@IAEXPAUMAPQUEST_DATA@@0@Z ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::_Destroy

; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  000e6	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000ef	2b 01		 sub	 eax, DWORD PTR [ecx]
  000f1	99		 cdq
  000f2	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  000f7	f7 f9		 idiv	 ecx
  000f9	50		 push	 eax
  000fa	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000fd	8b 02		 mov	 eax, DWORD PTR [edx]
  000ff	50		 push	 eax
  00100	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00103	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00106	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UMAPQUEST_DATA@@@std@@QAEXPAUMAPQUEST_DATA@@I@Z ; std::allocator<MAPQUEST_DATA>::deallocate
$LN1@reserve:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();

  0010b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0010e	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 769  : 			this->_Myend = _Ptr + _Count;

  00113	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00116	6b c0 1c	 imul	 eax, 28			; 0000001cH
  00119	03 45 e8	 add	 eax, DWORD PTR __Ptr$228855[ebp]
  0011c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0011f	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 770  : 			this->_Mylast = _Ptr + _Size;

  00122	8b 45 e4	 mov	 eax, DWORD PTR __Size$228862[ebp]
  00125	6b c0 1c	 imul	 eax, 28			; 0000001cH
  00128	03 45 e8	 add	 eax, DWORD PTR __Ptr$228855[ebp]
  0012b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0012e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 771  : 			this->_Myfirst = _Ptr;

  00131	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00134	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$228855[ebp]
  00137	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@reserve:

; 772  : 			}
; 773  : 		}

  00139	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0013c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00143	59		 pop	 ecx
  00144	5f		 pop	 edi
  00145	5e		 pop	 esi
  00146	5b		 pop	 ebx
  00147	8b e5		 mov	 esp, ebp
  00149	5d		 pop	 ebp
  0014a	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QAEXI@Z ENDP ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::reserve
; Function compile flags: /Odtp /ZI
;	COMDAT ?capacity@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?capacity@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QBEIXZ PROC ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::capacity, COMDAT
; _this$ = ecx

; 776  : 		{	// return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	99		 cdq
  00018	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  0001d	f7 f9		 idiv	 ecx

; 778  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?capacity@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::capacity
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@2@@Z PROC ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::_Make_iter, COMDAT
; _this$ = ecx

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  : 		return (iterator(_Where._Ptr, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@std@@QAE@PAUMAPQUEST_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> > >::_Vector_iterator<std::_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> > >
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 803  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
?_Make_iter@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@2@@Z ENDP ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UMAPQUEST_DATA@@@std@@QBEIXZ ; std::allocator<MAPQUEST_DATA>::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?max_size@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QBEIXZ PROC ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::max_size, COMDAT
; _this$ = ecx

; 883  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		return (this->_Alval.max_size());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00012	e8 00 00 00 00	 call	 ?max_size@?$allocator@UMAPQUEST_DATA@@@std@@QBEIXZ ; std::allocator<MAPQUEST_DATA>::max_size

; 885  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?max_size@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@YAXPAUMAPQUEST_DATA@@0AAV?$allocator@UMAPQUEST_DATA@@@0@@Z ; std::_Destroy_range<std::allocator<MAPQUEST_DATA> >
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Destroy@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@IAEXPAUMAPQUEST_DATA@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@IAEXPAUMAPQUEST_DATA@@0@Z PROC ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::_Destroy, COMDAT
; _this$ = ecx

; 1269 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@YAXPAUMAPQUEST_DATA@@0AAV?$allocator@UMAPQUEST_DATA@@@0@@Z ; std::_Destroy_range<std::allocator<MAPQUEST_DATA> >
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1271 : 		}

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
?_Destroy@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@IAEXPAUMAPQUEST_DATA@@0@Z ENDP ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::_Destroy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Grow_to@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -76						; size = 4
__Capacity$ = -8					; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@IBEII@Z PROC ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1275 : 		size_type _Capacity = capacity();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?capacity@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QBEIXZ ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::capacity
  00014	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@QBEIXZ ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::max_size
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  00022	d1 e9		 shr	 ecx, 1
  00024	2b c1		 sub	 eax, ecx
  00026	3b 45 f8	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  00029	73 09		 jae	 SHORT $LN4@Grow_to
  0002b	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  00032	eb 0b		 jmp	 SHORT $LN5@Grow_to
$LN4@Grow_to:
  00034	8b 55 f8	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00037	d1 ea		 shr	 edx, 1
  00039	03 55 f8	 add	 edx, DWORD PTR __Capacity$[ebp]
  0003c	89 55 b4	 mov	 DWORD PTR tv73[ebp], edx
$LN5@Grow_to:
  0003f	8b 45 b4	 mov	 eax, DWORD PTR tv73[ebp]
  00042	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1279 : 		if (_Capacity < _Count)

  00045	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00048	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0004b	73 06		 jae	 SHORT $LN1@Grow_to

; 1280 : 			_Capacity = _Count;

  0004d	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00050	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax
$LN1@Grow_to:

; 1281 : 		return (_Capacity);

  00053	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]

; 1282 : 		}

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
?_Grow_to@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@IBEII@Z ENDP ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::_Grow_to
_TEXT	ENDS
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ?_Xlen@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@IBEXXZ PROC ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::_Xlen, COMDAT
; _this$ = ecx

; 1426 : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00011	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen:

; 1428 : 		}

  00016	5f		 pop	 edi
  00017	5e		 pop	 esi
  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Xlen@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@IBEXXZ ENDP ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::_Xlen
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UMAPQUEST_DATA@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@UMAPQUEST_DATA@@@std@@QAE@ABV01@@Z PROC	; std::allocator<MAPQUEST_DATA>::allocator<MAPQUEST_DATA>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$allocator@UMAPQUEST_DATA@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<MAPQUEST_DATA>::allocator<MAPQUEST_DATA>
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp /ZI
;	COMDAT ?deallocate@?$allocator@UMAPQUEST_DATA@@@std@@QAEXPAUMAPQUEST_DATA@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UMAPQUEST_DATA@@@std@@QAEXPAUMAPQUEST_DATA@@I@Z PROC ; std::allocator<MAPQUEST_DATA>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 182  : 		::operator delete(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4

; 183  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?deallocate@?$allocator@UMAPQUEST_DATA@@@std@@QAEXPAUMAPQUEST_DATA@@I@Z ENDP ; std::allocator<MAPQUEST_DATA>::deallocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@std@@QAE@PAUMAPQUEST_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> > >::_Vector_const_iterator<std::_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@std@@QAE@PAUMAPQUEST_DATA@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@std@@QAE@PAUMAPQUEST_DATA@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> > >::_Vector_iterator<std::_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@std@@QAE@PAUMAPQUEST_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> > >::_Vector_const_iterator<std::_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> > >

; 305  : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@std@@QAE@PAUMAPQUEST_DATA@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> > >::_Vector_iterator<std::_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> > >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> > >::operator==
; Function compile flags: /Odtp /ZI
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 208  : 		return (!(*this == _Right));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??8?$_Vector_const_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> > >::operator==
  00018	0f b6 c0	 movzx	 eax, al
  0001b	f7 d8		 neg	 eax
  0001d	1b c0		 sbb	 eax, eax
  0001f	83 c0 01	 add	 eax, 1

; 209  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> > >::operator!=
_TEXT	ENDS
PUBLIC	??$_Allocate@UMAPQUEST_DATA@@@std@@YAPAUMAPQUEST_DATA@@IPAU1@@Z ; std::_Allocate<MAPQUEST_DATA>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@UMAPQUEST_DATA@@@std@@QAEPAUMAPQUEST_DATA@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UMAPQUEST_DATA@@@std@@QAEPAUMAPQUEST_DATA@@I@Z PROC ; std::allocator<MAPQUEST_DATA>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 187  : 		return (_Allocate(_Count, (pointer)0));

  0000c	6a 00		 push	 0
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Allocate@UMAPQUEST_DATA@@@std@@YAPAUMAPQUEST_DATA@@IPAU1@@Z ; std::_Allocate<MAPQUEST_DATA>
  00017	83 c4 08	 add	 esp, 8

; 188  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?allocate@?$allocator@UMAPQUEST_DATA@@@std@@QAEPAUMAPQUEST_DATA@@I@Z ENDP ; std::allocator<MAPQUEST_DATA>::allocate
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UMAPQUEST_DATA@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -76						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@UMAPQUEST_DATA@@@std@@QBEIXZ PROC	; std::allocator<MAPQUEST_DATA>::max_size, COMDAT
; _this$ = ecx

; 217  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  0000c	c7 45 f8 49 92
	24 09		 mov	 DWORD PTR __Count$[ebp], 153391689 ; 09249249H

; 219  : 		return (0 < _Count ? _Count : 1);

  00013	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00017	76 08		 jbe	 SHORT $LN3@max_size
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0001c	89 45 b4	 mov	 DWORD PTR tv65[ebp], eax
  0001f	eb 07		 jmp	 SHORT $LN4@max_size
$LN3@max_size:
  00021	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$LN4@max_size:
  00028	8b 45 b4	 mov	 eax, DWORD PTR tv65[ebp]

; 220  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?max_size@?$allocator@UMAPQUEST_DATA@@@std@@QBEIXZ ENDP	; std::allocator<MAPQUEST_DATA>::max_size
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@std@@QAE@PAUMAPQUEST_DATA@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@std@@QAE@PAUMAPQUEST_DATA@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> > >::_Vector_const_iterator<std::_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 47   : 		}

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@std@@QAE@PAUMAPQUEST_DATA@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> > >::_Vector_const_iterator<std::_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> > >
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> > >::_Compat
; Function compile flags: /Odtp /ZI
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		_Compat(_Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> > >::_Compat

; 203  : 		return (this->_Ptr == _Right._Ptr);

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001e	8b 10		 mov	 edx, DWORD PTR [eax]
  00020	33 c0		 xor	 eax, eax
  00022	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00024	0f 94 c0	 sete	 al

; 204  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> > >::operator==
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> > >::_Compat, COMDAT
; _this$ = ecx

; 252  : 		{	// test for compatible iterator pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 253  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> > >::_Compat
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$addressof@$$CBUMAPQUEST_DATA@@@std@@YAPBUMAPQUEST_DATA@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUMAPQUEST_DATA@@@std@@YAPBUMAPQUEST_DATA@@ABU1@@Z PROC ; std::addressof<MAPQUEST_DATA const >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 111  : 	return ((_Ty *) &(char&)_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@$$CBUMAPQUEST_DATA@@@std@@YAPBUMAPQUEST_DATA@@ABU1@@Z ENDP ; std::addressof<MAPQUEST_DATA const >
_TEXT	ENDS
PUBLIC	??$construct@AAUMAPQUEST_DATA@@@?$allocator@UMAPQUEST_DATA@@@std@@QAEXPAUMAPQUEST_DATA@@AAU2@@Z ; std::allocator<MAPQUEST_DATA>::construct<MAPQUEST_DATA &>
PUBLIC	??$forward@AAUMAPQUEST_DATA@@@std@@YAAAUMAPQUEST_DATA@@AAU1@@Z ; std::forward<MAPQUEST_DATA &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UMAPQUEST_DATA@@@std@@UMAPQUEST_DATA@@AAU3@@std@@YAXAAV?$allocator@UMAPQUEST_DATA@@@0@PAUMAPQUEST_DATA@@AAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UMAPQUEST_DATA@@@std@@UMAPQUEST_DATA@@AAU3@@std@@YAXAAV?$allocator@UMAPQUEST_DATA@@@0@PAUMAPQUEST_DATA@@AAU2@@Z PROC ; std::_Cons_val<std::allocator<MAPQUEST_DATA>,MAPQUEST_DATA,MAPQUEST_DATA &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@AAUMAPQUEST_DATA@@@std@@YAAAUMAPQUEST_DATA@@AAU1@@Z ; std::forward<MAPQUEST_DATA &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ??$construct@AAUMAPQUEST_DATA@@@?$allocator@UMAPQUEST_DATA@@@std@@QAEXPAUMAPQUEST_DATA@@AAU2@@Z ; std::allocator<MAPQUEST_DATA>::construct<MAPQUEST_DATA &>

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UMAPQUEST_DATA@@@std@@UMAPQUEST_DATA@@AAU3@@std@@YAXAAV?$allocator@UMAPQUEST_DATA@@@0@PAUMAPQUEST_DATA@@AAU2@@Z ENDP ; std::_Cons_val<std::allocator<MAPQUEST_DATA>,MAPQUEST_DATA,MAPQUEST_DATA &>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UMAPQUEST_DATA@@@std@@QAEXPAUMAPQUEST_DATA@@ABU3@@Z ; std::allocator<MAPQUEST_DATA>::construct
PUBLIC	??$forward@ABUMAPQUEST_DATA@@@std@@YAABUMAPQUEST_DATA@@ABU1@@Z ; std::forward<MAPQUEST_DATA const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UMAPQUEST_DATA@@@std@@UMAPQUEST_DATA@@ABU3@@std@@YAXAAV?$allocator@UMAPQUEST_DATA@@@0@PAUMAPQUEST_DATA@@ABU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UMAPQUEST_DATA@@@std@@UMAPQUEST_DATA@@ABU3@@std@@YAXAAV?$allocator@UMAPQUEST_DATA@@@0@PAUMAPQUEST_DATA@@ABU2@@Z PROC ; std::_Cons_val<std::allocator<MAPQUEST_DATA>,MAPQUEST_DATA,MAPQUEST_DATA const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@ABUMAPQUEST_DATA@@@std@@YAABUMAPQUEST_DATA@@ABU1@@Z ; std::forward<MAPQUEST_DATA const &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@UMAPQUEST_DATA@@@std@@QAEXPAUMAPQUEST_DATA@@ABU3@@Z ; std::allocator<MAPQUEST_DATA>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UMAPQUEST_DATA@@@std@@UMAPQUEST_DATA@@ABU3@@std@@YAXAAV?$allocator@UMAPQUEST_DATA@@@0@PAUMAPQUEST_DATA@@ABU2@@Z ENDP ; std::_Cons_val<std::allocator<MAPQUEST_DATA>,MAPQUEST_DATA,MAPQUEST_DATA const &>
_TEXT	ENDS
PUBLIC	??$_Move@PAUMAPQUEST_DATA@@PAU1@@std@@YAPAUMAPQUEST_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<MAPQUEST_DATA *,MAPQUEST_DATA *>
PUBLIC	??$_Ptr_cat@UMAPQUEST_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUMAPQUEST_DATA@@0@Z ; std::_Ptr_cat<MAPQUEST_DATA,MAPQUEST_DATA>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAUMAPQUEST_DATA@@PAU1@@std@@YAPAUMAPQUEST_DATA@@PAU1@00@Z
_TEXT	SEGMENT
$T229771 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAUMAPQUEST_DATA@@PAU1@@std@@YAPAUMAPQUEST_DATA@@PAU1@00@Z PROC ; std::_Move<MAPQUEST_DATA *,MAPQUEST_DATA *>, COMDAT

; 2533 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2534 : 	return (_Move(_First, _Last,
; 2535 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UMAPQUEST_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUMAPQUEST_DATA@@0@Z ; std::_Ptr_cat<MAPQUEST_DATA,MAPQUEST_DATA>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T229771[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T229771[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Move@PAUMAPQUEST_DATA@@PAU1@@std@@YAPAUMAPQUEST_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<MAPQUEST_DATA *,MAPQUEST_DATA *>
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 2536 : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Move@PAUMAPQUEST_DATA@@PAU1@@std@@YAPAUMAPQUEST_DATA@@PAU1@00@Z ENDP ; std::_Move<MAPQUEST_DATA *,MAPQUEST_DATA *>
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAUMAPQUEST_DATA@@PAU1@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@YAPAUMAPQUEST_DATA@@PAU1@00AAV?$allocator@UMAPQUEST_DATA@@@0@@Z ; std::_Uninitialized_move<MAPQUEST_DATA *,MAPQUEST_DATA *,std::allocator<MAPQUEST_DATA> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??$_Umove@PAUMAPQUEST_DATA@@@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@IAEPAUMAPQUEST_DATA@@PAU2@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAUMAPQUEST_DATA@@@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@IAEPAUMAPQUEST_DATA@@PAU2@00@Z PROC ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::_Umove<MAPQUEST_DATA *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUMAPQUEST_DATA@@PAU1@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@YAPAUMAPQUEST_DATA@@PAU1@00AAV?$allocator@UMAPQUEST_DATA@@@0@@Z ; std::_Uninitialized_move<MAPQUEST_DATA *,MAPQUEST_DATA *,std::allocator<MAPQUEST_DATA> >
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 1326 : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUMAPQUEST_DATA@@@?$vector@UMAPQUEST_DATA@@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@IAEPAUMAPQUEST_DATA@@PAU2@00@Z ENDP ; std::vector<MAPQUEST_DATA,std::allocator<MAPQUEST_DATA> >::_Umove<MAPQUEST_DATA *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@YAXPAUMAPQUEST_DATA@@0AAV?$allocator@UMAPQUEST_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<MAPQUEST_DATA> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@YAXPAUMAPQUEST_DATA@@0AAV?$allocator@UMAPQUEST_DATA@@@0@@Z
_TEXT	SEGMENT
$T229776 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@YAXPAUMAPQUEST_DATA@@0AAV?$allocator@UMAPQUEST_DATA@@@0@@Z PROC ; std::_Destroy_range<std::allocator<MAPQUEST_DATA> >, COMDAT

; 87   : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UMAPQUEST_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUMAPQUEST_DATA@@0@Z ; std::_Ptr_cat<MAPQUEST_DATA,MAPQUEST_DATA>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T229776[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T229776[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@YAXPAUMAPQUEST_DATA@@0AAV?$allocator@UMAPQUEST_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<MAPQUEST_DATA> >
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 89   : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Destroy_range@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@YAXPAUMAPQUEST_DATA@@0AAV?$allocator@UMAPQUEST_DATA@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<MAPQUEST_DATA> >
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Allocate@UMAPQUEST_DATA@@@std@@YAPAUMAPQUEST_DATA@@IPAU1@@Z
_TEXT	SEGMENT
$T229779 = -80						; size = 12
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UMAPQUEST_DATA@@@std@@YAPAUMAPQUEST_DATA@@IPAU1@@Z PROC ; std::_Allocate<MAPQUEST_DATA>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 31   : 	void *_Ptr = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 32   : 
; 33   : 	if (_Count <= 0)

  00010	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	77 09		 ja	 SHORT $LN4@Allocate

; 34   : 		_Count = 0;

  00016	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __Count$[ebp], 0

; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0001d	eb 39		 jmp	 SHORT $LN3@Allocate
$LN4@Allocate:

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0001f	81 7d 08 49 92
	24 09		 cmp	 DWORD PTR __Count$[ebp], 153391689 ; 09249249H
  00026	77 18		 ja	 SHORT $LN1@Allocate
  00028	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002b	6b c0 1c	 imul	 eax, 28			; 0000001cH
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 fc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0003a	83 7d fc 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  0003e	75 18		 jne	 SHORT $LN3@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00040	6a 00		 push	 0
  00042	8d 4d b0	 lea	 ecx, DWORD PTR $T229779[ebp]
  00045	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0004a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0004f	8d 45 b0	 lea	 eax, DWORD PTR $T229779[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Allocate:

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00058	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 40   : 	}

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
??$_Allocate@UMAPQUEST_DATA@@@std@@YAPAUMAPQUEST_DATA@@IPAU1@@Z ENDP ; std::_Allocate<MAPQUEST_DATA>
_TEXT	ENDS
PUBLIC	??$_Construct@UMAPQUEST_DATA@@ABU1@@std@@YAXPAUMAPQUEST_DATA@@ABU1@@Z ; std::_Construct<MAPQUEST_DATA,MAPQUEST_DATA const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ?construct@?$allocator@UMAPQUEST_DATA@@@std@@QAEXPAUMAPQUEST_DATA@@ABU3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UMAPQUEST_DATA@@@std@@QAEXPAUMAPQUEST_DATA@@ABU3@@Z PROC ; std::allocator<MAPQUEST_DATA>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 197  : 		_Construct(_Ptr, _Val);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ??$_Construct@UMAPQUEST_DATA@@ABU1@@std@@YAXPAUMAPQUEST_DATA@@ABU1@@Z ; std::_Construct<MAPQUEST_DATA,MAPQUEST_DATA const &>
  00019	83 c4 08	 add	 esp, 8

; 198  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
?construct@?$allocator@UMAPQUEST_DATA@@@std@@QAEXPAUMAPQUEST_DATA@@ABU3@@Z ENDP ; std::allocator<MAPQUEST_DATA>::construct
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@AAUMAPQUEST_DATA@@@std@@YAAAUMAPQUEST_DATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUMAPQUEST_DATA@@@std@@YAAAUMAPQUEST_DATA@@AAU1@@Z PROC ; std::forward<MAPQUEST_DATA &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAUMAPQUEST_DATA@@@std@@YAAAUMAPQUEST_DATA@@AAU1@@Z ENDP ; std::forward<MAPQUEST_DATA &>
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??2@YAPAXIPAX@Z					; operator new
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$construct@AAUMAPQUEST_DATA@@@?$allocator@UMAPQUEST_DATA@@@std@@QAEXPAUMAPQUEST_DATA@@AAU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@AAUMAPQUEST_DATA@@@?$allocator@UMAPQUEST_DATA@@@std@@QAEXPAUMAPQUEST_DATA@@AAU2@@Z$0
__ehfuncinfo$??$construct@AAUMAPQUEST_DATA@@@?$allocator@UMAPQUEST_DATA@@@std@@QAEXPAUMAPQUEST_DATA@@AAU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@AAUMAPQUEST_DATA@@@?$allocator@UMAPQUEST_DATA@@@std@@QAEXPAUMAPQUEST_DATA@@AAU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$construct@AAUMAPQUEST_DATA@@@?$allocator@UMAPQUEST_DATA@@@std@@QAEXPAUMAPQUEST_DATA@@AAU2@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T229786 = -88						; size = 4
$T229787 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAUMAPQUEST_DATA@@@?$allocator@UMAPQUEST_DATA@@@std@@QAEXPAUMAPQUEST_DATA@@AAU2@@Z PROC ; std::allocator<MAPQUEST_DATA>::construct<MAPQUEST_DATA &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@AAUMAPQUEST_DATA@@@?$allocator@UMAPQUEST_DATA@@@std@@QAEXPAUMAPQUEST_DATA@@AAU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 1c		 push	 28			; 0000001cH
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T229787[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T229787[ebp], 0
  00047	74 20		 je	 SHORT $LN3@construct
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@AAUMAPQUEST_DATA@@@std@@YAAAUMAPQUEST_DATA@@AAU1@@Z ; std::forward<MAPQUEST_DATA &>
  00052	83 c4 04	 add	 esp, 4
  00055	b9 07 00 00 00	 mov	 ecx, 7
  0005a	8b f0		 mov	 esi, eax
  0005c	8b 7d ac	 mov	 edi, DWORD PTR $T229787[ebp]
  0005f	f3 a5		 rep movsd
  00061	8b 55 ac	 mov	 edx, DWORD PTR $T229787[ebp]
  00064	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  00067	eb 07		 jmp	 SHORT $LN4@construct
$LN3@construct:
  00069	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct:
  00070	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00073	89 45 a8	 mov	 DWORD PTR $T229786[ebp], eax
  00076	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 209  : 		}

  0007d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00080	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00087	59		 pop	 ecx
  00088	5f		 pop	 edi
  00089	5e		 pop	 esi
  0008a	5b		 pop	 ebx
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@AAUMAPQUEST_DATA@@@?$allocator@UMAPQUEST_DATA@@@std@@QAEXPAUMAPQUEST_DATA@@AAU2@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T229787[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@AAUMAPQUEST_DATA@@@?$allocator@UMAPQUEST_DATA@@@std@@QAEXPAUMAPQUEST_DATA@@AAU2@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@AAUMAPQUEST_DATA@@@?$allocator@UMAPQUEST_DATA@@@std@@QAEXPAUMAPQUEST_DATA@@AAU2@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@AAUMAPQUEST_DATA@@@?$allocator@UMAPQUEST_DATA@@@std@@QAEXPAUMAPQUEST_DATA@@AAU2@@Z ENDP ; std::allocator<MAPQUEST_DATA>::construct<MAPQUEST_DATA &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 81   :         {return (_Where); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 83   :         {return; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@ABUMAPQUEST_DATA@@@std@@YAABUMAPQUEST_DATA@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUMAPQUEST_DATA@@@std@@YAABUMAPQUEST_DATA@@ABU1@@Z PROC ; std::forward<MAPQUEST_DATA const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@ABUMAPQUEST_DATA@@@std@@YAABUMAPQUEST_DATA@@ABU1@@Z ENDP ; std::forward<MAPQUEST_DATA const &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@UMAPQUEST_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUMAPQUEST_DATA@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UMAPQUEST_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUMAPQUEST_DATA@@0@Z PROC ; std::_Ptr_cat<MAPQUEST_DATA,MAPQUEST_DATA>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00009	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Ptr_cat@UMAPQUEST_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUMAPQUEST_DATA@@0@Z ENDP ; std::_Ptr_cat<MAPQUEST_DATA,MAPQUEST_DATA>
_TEXT	ENDS
PUBLIC	??$move@AAUMAPQUEST_DATA@@@std@@YA$$QAUMAPQUEST_DATA@@AAU1@@Z ; std::move<MAPQUEST_DATA &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Move@PAUMAPQUEST_DATA@@PAU1@@std@@YAPAUMAPQUEST_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAUMAPQUEST_DATA@@PAU1@@std@@YAPAUMAPQUEST_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<MAPQUEST_DATA *,MAPQUEST_DATA *>, COMDAT

; 2512 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2513 : 	for (; _First != _Last; ++_Dest, ++_First)

  00009	eb 12		 jmp	 SHORT $LN3@Move
$LN2@Move:
  0000b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000e	83 c0 1c	 add	 eax, 28			; 0000001cH
  00011	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00017	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0001a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN3@Move:
  0001d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00020	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00023	74 1a		 je	 SHORT $LN1@Move

; 2514 : 		*_Dest = _STD move(*_First);

  00025	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??$move@AAUMAPQUEST_DATA@@@std@@YA$$QAUMAPQUEST_DATA@@AAU1@@Z ; std::move<MAPQUEST_DATA &>
  0002e	83 c4 04	 add	 esp, 4
  00031	b9 07 00 00 00	 mov	 ecx, 7
  00036	8b f0		 mov	 esi, eax
  00038	8b 7d 10	 mov	 edi, DWORD PTR __Dest$[ebp]
  0003b	f3 a5		 rep movsd
  0003d	eb cc		 jmp	 SHORT $LN2@Move
$LN1@Move:

; 2515 : 	return (_Dest);

  0003f	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 2516 : 	}

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
??$_Move@PAUMAPQUEST_DATA@@PAU1@@std@@YAPAUMAPQUEST_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<MAPQUEST_DATA *,MAPQUEST_DATA *>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUMAPQUEST_DATA@@PAU1@V?$allocator@UMAPQUEST_DATA@@@std@@U1@@std@@YAPAUMAPQUEST_DATA@@PAU1@00AAV?$allocator@UMAPQUEST_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<MAPQUEST_DATA *,MAPQUEST_DATA *,std::allocator<MAPQUEST_DATA>,MAPQUEST_DATA>
PUBLIC	??$_Val_type@PAUMAPQUEST_DATA@@@std@@YAPAUMAPQUEST_DATA@@PAU1@@Z ; std::_Val_type<MAPQUEST_DATA *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_move@PAUMAPQUEST_DATA@@PAU1@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@YAPAUMAPQUEST_DATA@@PAU1@00AAV?$allocator@UMAPQUEST_DATA@@@0@@Z
_TEXT	SEGMENT
$T229809 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUMAPQUEST_DATA@@PAU1@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@YAPAUMAPQUEST_DATA@@PAU1@00AAV?$allocator@UMAPQUEST_DATA@@@0@@Z PROC ; std::_Uninitialized_move<MAPQUEST_DATA *,MAPQUEST_DATA *,std::allocator<MAPQUEST_DATA> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UMAPQUEST_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUMAPQUEST_DATA@@0@Z ; std::_Ptr_cat<MAPQUEST_DATA,MAPQUEST_DATA>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T229809[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T229809[ebp]
  00020	52		 push	 edx
  00021	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??$_Val_type@PAUMAPQUEST_DATA@@@std@@YAPAUMAPQUEST_DATA@@PAU1@@Z ; std::_Val_type<MAPQUEST_DATA *>
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00031	51		 push	 ecx
  00032	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00035	52		 push	 edx
  00036	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUMAPQUEST_DATA@@PAU1@V?$allocator@UMAPQUEST_DATA@@@std@@U1@@std@@YAPAUMAPQUEST_DATA@@PAU1@00AAV?$allocator@UMAPQUEST_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<MAPQUEST_DATA *,MAPQUEST_DATA *,std::allocator<MAPQUEST_DATA>,MAPQUEST_DATA>
  00043	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
??$_Uninitialized_move@PAUMAPQUEST_DATA@@PAU1@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@YAPAUMAPQUEST_DATA@@PAU1@00AAV?$allocator@UMAPQUEST_DATA@@@0@@Z ENDP ; std::_Uninitialized_move<MAPQUEST_DATA *,MAPQUEST_DATA *,std::allocator<MAPQUEST_DATA> >
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@UMAPQUEST_DATA@@@std@@UMAPQUEST_DATA@@@std@@YAXAAV?$allocator@UMAPQUEST_DATA@@@0@PAUMAPQUEST_DATA@@@Z ; std::_Dest_val<std::allocator<MAPQUEST_DATA>,MAPQUEST_DATA>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@YAXPAUMAPQUEST_DATA@@0AAV?$allocator@UMAPQUEST_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@YAXPAUMAPQUEST_DATA@@0AAV?$allocator@UMAPQUEST_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<MAPQUEST_DATA> >, COMDAT

; 95   : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 96   : 	for (; _First != _Last; ++_First)

  00009	eb 09		 jmp	 SHORT $LN3@Destroy_ra
$LN2@Destroy_ra:
  0000b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000e	83 c0 1c	 add	 eax, 28			; 0000001cH
  00011	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra:
  00014	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00017	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0001a	74 12		 je	 SHORT $LN4@Destroy_ra

; 97   : 		_Dest_val(_Al, _First);

  0001c	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@UMAPQUEST_DATA@@@std@@UMAPQUEST_DATA@@@std@@YAXAAV?$allocator@UMAPQUEST_DATA@@@0@PAUMAPQUEST_DATA@@@Z ; std::_Dest_val<std::allocator<MAPQUEST_DATA>,MAPQUEST_DATA>
  00029	83 c4 08	 add	 esp, 8
  0002c	eb dd		 jmp	 SHORT $LN2@Destroy_ra
$LN4@Destroy_ra:

; 98   : 	}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$_Destroy_range@V?$allocator@UMAPQUEST_DATA@@@std@@@std@@YAXPAUMAPQUEST_DATA@@0AAV?$allocator@UMAPQUEST_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<MAPQUEST_DATA> >
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Construct@UMAPQUEST_DATA@@ABU1@@std@@YAXPAUMAPQUEST_DATA@@ABU1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@UMAPQUEST_DATA@@ABU1@@std@@YAXPAUMAPQUEST_DATA@@ABU1@@Z$0
__ehfuncinfo$??$_Construct@UMAPQUEST_DATA@@ABU1@@std@@YAXPAUMAPQUEST_DATA@@ABU1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@UMAPQUEST_DATA@@ABU1@@std@@YAXPAUMAPQUEST_DATA@@ABU1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Construct@UMAPQUEST_DATA@@ABU1@@std@@YAXPAUMAPQUEST_DATA@@ABU1@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T229814 = -88						; size = 4
$T229815 = -84						; size = 4
__Vptr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UMAPQUEST_DATA@@ABU1@@std@@YAXPAUMAPQUEST_DATA@@ABU1@@Z PROC ; std::_Construct<MAPQUEST_DATA,MAPQUEST_DATA const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Construct@UMAPQUEST_DATA@@ABU1@@std@@YAXPAUMAPQUEST_DATA@@ABU1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 47   : 	void _FARQ *_Vptr = _Ptr;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002b	89 45 f0	 mov	 DWORD PTR __Vptr$[ebp], eax

; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  0002e	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00031	50		 push	 eax
  00032	6a 1c		 push	 28			; 0000001cH
  00034	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00039	83 c4 08	 add	 esp, 8
  0003c	89 45 ac	 mov	 DWORD PTR $T229815[ebp], eax
  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00046	83 7d ac 00	 cmp	 DWORD PTR $T229815[ebp], 0
  0004a	74 20		 je	 SHORT $LN3@Construct
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ??$forward@ABUMAPQUEST_DATA@@@std@@YAABUMAPQUEST_DATA@@ABU1@@Z ; std::forward<MAPQUEST_DATA const &>
  00055	83 c4 04	 add	 esp, 4
  00058	b9 07 00 00 00	 mov	 ecx, 7
  0005d	8b f0		 mov	 esi, eax
  0005f	8b 7d ac	 mov	 edi, DWORD PTR $T229815[ebp]
  00062	f3 a5		 rep movsd
  00064	8b 55 ac	 mov	 edx, DWORD PTR $T229815[ebp]
  00067	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  0006a	eb 07		 jmp	 SHORT $LN4@Construct
$LN3@Construct:
  0006c	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@Construct:
  00073	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00076	89 45 a8	 mov	 DWORD PTR $T229814[ebp], eax
  00079	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 49   : 	}

  00080	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00083	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008a	59		 pop	 ecx
  0008b	5f		 pop	 edi
  0008c	5e		 pop	 esi
  0008d	5b		 pop	 ebx
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@UMAPQUEST_DATA@@ABU1@@std@@YAXPAUMAPQUEST_DATA@@ABU1@@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T229815[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Construct@UMAPQUEST_DATA@@ABU1@@std@@YAXPAUMAPQUEST_DATA@@ABU1@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Construct@UMAPQUEST_DATA@@ABU1@@std@@YAXPAUMAPQUEST_DATA@@ABU1@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Construct@UMAPQUEST_DATA@@ABU1@@std@@YAXPAUMAPQUEST_DATA@@ABU1@@Z ENDP ; std::_Construct<MAPQUEST_DATA,MAPQUEST_DATA const &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$move@AAUMAPQUEST_DATA@@@std@@YA$$QAUMAPQUEST_DATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAUMAPQUEST_DATA@@@std@@YA$$QAUMAPQUEST_DATA@@AAU1@@Z PROC ; std::move<MAPQUEST_DATA &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$move@AAUMAPQUEST_DATA@@@std@@YA$$QAUMAPQUEST_DATA@@AAU1@@Z ENDP ; std::move<MAPQUEST_DATA &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Val_type@PAUMAPQUEST_DATA@@@std@@YAPAUMAPQUEST_DATA@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUMAPQUEST_DATA@@@std@@YAPAUMAPQUEST_DATA@@PAU1@@Z PROC ; std::_Val_type<MAPQUEST_DATA *>, COMDAT

; 789  : 	{	// return value type from arbitrary argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 790  : 	return (0);

  00009	33 c0		 xor	 eax, eax

; 791  : 	}

  0000b	5f		 pop	 edi
  0000c	5e		 pop	 esi
  0000d	5b		 pop	 ebx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Val_type@PAUMAPQUEST_DATA@@@std@@YAPAUMAPQUEST_DATA@@PAU1@@Z ENDP ; std::_Val_type<MAPQUEST_DATA *>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UMAPQUEST_DATA@@@std@@UMAPQUEST_DATA@@U3@@std@@YAXAAV?$allocator@UMAPQUEST_DATA@@@0@PAUMAPQUEST_DATA@@$$QAU2@@Z ; std::_Cons_val<std::allocator<MAPQUEST_DATA>,MAPQUEST_DATA,MAPQUEST_DATA>
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_move@PAUMAPQUEST_DATA@@PAU1@V?$allocator@UMAPQUEST_DATA@@@std@@U1@@std@@YAPAUMAPQUEST_DATA@@PAU1@00AAV?$allocator@UMAPQUEST_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_move@PAUMAPQUEST_DATA@@PAU1@V?$allocator@UMAPQUEST_DATA@@@std@@U1@@std@@YAPAUMAPQUEST_DATA@@PAU1@00AAV?$allocator@UMAPQUEST_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_move@PAUMAPQUEST_DATA@@PAU1@V?$allocator@UMAPQUEST_DATA@@@std@@U1@@std@@YAPAUMAPQUEST_DATA@@PAU1@00AAV?$allocator@UMAPQUEST_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_move@PAUMAPQUEST_DATA@@PAU1@V?$allocator@UMAPQUEST_DATA@@@std@@U1@@std@@YAPAUMAPQUEST_DATA@@PAU1@00AAV?$allocator@UMAPQUEST_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_move@PAUMAPQUEST_DATA@@PAU1@V?$allocator@UMAPQUEST_DATA@@@std@@U1@@std@@YAPAUMAPQUEST_DATA@@PAU1@00AAV?$allocator@UMAPQUEST_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_move@PAUMAPQUEST_DATA@@PAU1@V?$allocator@UMAPQUEST_DATA@@@std@@U1@@std@@YAPAUMAPQUEST_DATA@@PAU1@00AAV?$allocator@UMAPQUEST_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_move@PAUMAPQUEST_DATA@@PAU1@V?$allocator@UMAPQUEST_DATA@@@std@@U1@@std@@YAPAUMAPQUEST_DATA@@PAU1@00AAV?$allocator@UMAPQUEST_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_move@PAUMAPQUEST_DATA@@PAU1@V?$allocator@UMAPQUEST_DATA@@@std@@U1@@std@@YAPAUMAPQUEST_DATA@@PAU1@00AAV?$allocator@UMAPQUEST_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Uninit_move@PAUMAPQUEST_DATA@@PAU1@V?$allocator@UMAPQUEST_DATA@@@std@@U1@@std@@YAPAUMAPQUEST_DATA@@PAU1@00AAV?$allocator@UMAPQUEST_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUMAPQUEST_DATA@@PAU1@V?$allocator@UMAPQUEST_DATA@@@std@@U1@@std@@YAPAUMAPQUEST_DATA@@PAU1@00AAV?$allocator@UMAPQUEST_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<MAPQUEST_DATA *,MAPQUEST_DATA *,std::allocator<MAPQUEST_DATA>,MAPQUEST_DATA>, COMDAT

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_move@PAUMAPQUEST_DATA@@PAU1@V?$allocator@UMAPQUEST_DATA@@@std@@U1@@std@@YAPAUMAPQUEST_DATA@@PAU1@00AAV?$allocator@UMAPQUEST_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 44	 sub	 esp, 68			; 00000044H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;

  0002c	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0002f	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 428  : 
; 429  : 	_TRY_BEGIN

  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00039	eb 12		 jmp	 SHORT $LN6@Uninit_mov
$LN5@Uninit_mov:

; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  0003b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0003e	83 c0 1c	 add	 eax, 28			; 0000001cH
  00041	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00044	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00047	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0004a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN6@Uninit_mov:
  0004d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00050	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00053	74 16		 je	 SHORT $LN4@Uninit_mov

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

  00055	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00058	50		 push	 eax
  00059	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0005c	51		 push	 ecx
  0005d	8b 55 14	 mov	 edx, DWORD PTR __Al$[ebp]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UMAPQUEST_DATA@@@std@@UMAPQUEST_DATA@@U3@@std@@YAXAAV?$allocator@UMAPQUEST_DATA@@@0@PAUMAPQUEST_DATA@@$$QAU2@@Z ; std::_Cons_val<std::allocator<MAPQUEST_DATA>,MAPQUEST_DATA,MAPQUEST_DATA>
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
  00069	eb d0		 jmp	 SHORT $LN5@Uninit_mov
$LN4@Uninit_mov:
  0006b	eb 3b		 jmp	 SHORT $LN10@Uninit_mov
__catch$??$_Uninit_move@PAUMAPQUEST_DATA@@PAU1@V?$allocator@UMAPQUEST_DATA@@@std@@U1@@std@@YAPAUMAPQUEST_DATA@@PAU1@00AAV?$allocator@UMAPQUEST_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 432  : 	_CATCH_ALL

  0006d	eb 09		 jmp	 SHORT $LN3@Uninit_mov
$LN2@Uninit_mov:

; 433  : 	for (; _Next != _Dest; ++_Next)

  0006f	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00072	83 c0 1c	 add	 eax, 28			; 0000001cH
  00075	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax
$LN3@Uninit_mov:
  00078	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  0007b	3b 45 10	 cmp	 eax, DWORD PTR __Dest$[ebp]
  0007e	74 12		 je	 SHORT $LN1@Uninit_mov

; 434  : 		_Dest_val(_Al, _Next);

  00080	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00083	50		 push	 eax
  00084	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@UMAPQUEST_DATA@@@std@@UMAPQUEST_DATA@@@std@@YAXAAV?$allocator@UMAPQUEST_DATA@@@0@PAUMAPQUEST_DATA@@@Z ; std::_Dest_val<std::allocator<MAPQUEST_DATA>,MAPQUEST_DATA>
  0008d	83 c4 08	 add	 esp, 8
  00090	eb dd		 jmp	 SHORT $LN2@Uninit_mov
$LN1@Uninit_mov:

; 435  : 	_RERAISE;

  00092	6a 00		 push	 0
  00094	6a 00		 push	 0
  00096	e8 00 00 00 00	 call	 __CxxThrowException@8

; 436  : 	_CATCH_END

  0009b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000a2	b8 00 00 00 00	 mov	 eax, __tryend$??$_Uninit_move@PAUMAPQUEST_DATA@@PAU1@V?$allocator@UMAPQUEST_DATA@@@std@@U1@@std@@YAPAUMAPQUEST_DATA@@PAU1@00AAV?$allocator@UMAPQUEST_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1
  000a7	c3		 ret	 0
$LN10@Uninit_mov:
  000a8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_move@PAUMAPQUEST_DATA@@PAU1@V?$allocator@UMAPQUEST_DATA@@@std@@U1@@std@@YAPAUMAPQUEST_DATA@@PAU1@00AAV?$allocator@UMAPQUEST_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1:

; 437  : 	return (_Dest);

  000af	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_mov:

; 438  : 	}

  000b2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000b5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000bc	59		 pop	 ecx
  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_move@PAUMAPQUEST_DATA@@PAU1@V?$allocator@UMAPQUEST_DATA@@@std@@U1@@std@@YAPAUMAPQUEST_DATA@@PAU1@00AAV?$allocator@UMAPQUEST_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninit_move@PAUMAPQUEST_DATA@@PAU1@V?$allocator@UMAPQUEST_DATA@@@std@@U1@@std@@YAPAUMAPQUEST_DATA@@PAU1@00AAV?$allocator@UMAPQUEST_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninit_move@PAUMAPQUEST_DATA@@PAU1@V?$allocator@UMAPQUEST_DATA@@@std@@U1@@std@@YAPAUMAPQUEST_DATA@@PAU1@00AAV?$allocator@UMAPQUEST_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<MAPQUEST_DATA *,MAPQUEST_DATA *,std::allocator<MAPQUEST_DATA>,MAPQUEST_DATA>
PUBLIC	?destroy@?$allocator@UMAPQUEST_DATA@@@std@@QAEXPAUMAPQUEST_DATA@@@Z ; std::allocator<MAPQUEST_DATA>::destroy
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Dest_val@V?$allocator@UMAPQUEST_DATA@@@std@@UMAPQUEST_DATA@@@std@@YAXAAV?$allocator@UMAPQUEST_DATA@@@0@PAUMAPQUEST_DATA@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@UMAPQUEST_DATA@@@std@@UMAPQUEST_DATA@@@std@@YAXAAV?$allocator@UMAPQUEST_DATA@@@0@PAUMAPQUEST_DATA@@@Z PROC ; std::_Dest_val<std::allocator<MAPQUEST_DATA>,MAPQUEST_DATA>, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 287  : 	_Alval.destroy(_Pdest);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  00010	e8 00 00 00 00	 call	 ?destroy@?$allocator@UMAPQUEST_DATA@@@std@@QAEXPAUMAPQUEST_DATA@@@Z ; std::allocator<MAPQUEST_DATA>::destroy

; 288  : 	}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Dest_val@V?$allocator@UMAPQUEST_DATA@@@std@@UMAPQUEST_DATA@@@std@@YAXAAV?$allocator@UMAPQUEST_DATA@@@0@PAUMAPQUEST_DATA@@@Z ENDP ; std::_Dest_val<std::allocator<MAPQUEST_DATA>,MAPQUEST_DATA>
_TEXT	ENDS
PUBLIC	??$_Destroy@UMAPQUEST_DATA@@@std@@YAXPAUMAPQUEST_DATA@@@Z ; std::_Destroy<MAPQUEST_DATA>
; Function compile flags: /Odtp /ZI
;	COMDAT ?destroy@?$allocator@UMAPQUEST_DATA@@@std@@QAEXPAUMAPQUEST_DATA@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UMAPQUEST_DATA@@@std@@QAEXPAUMAPQUEST_DATA@@@Z PROC ; std::allocator<MAPQUEST_DATA>::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 213  : 		_Destroy(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Destroy@UMAPQUEST_DATA@@@std@@YAXPAUMAPQUEST_DATA@@@Z ; std::_Destroy<MAPQUEST_DATA>
  00015	83 c4 04	 add	 esp, 4

; 214  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?destroy@?$allocator@UMAPQUEST_DATA@@@std@@QAEXPAUMAPQUEST_DATA@@@Z ENDP ; std::allocator<MAPQUEST_DATA>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UMAPQUEST_DATA@@@std@@QAEXPAUMAPQUEST_DATA@@$$QAU3@@Z ; std::allocator<MAPQUEST_DATA>::construct
PUBLIC	??$forward@UMAPQUEST_DATA@@@std@@YA$$QAUMAPQUEST_DATA@@AAU1@@Z ; std::forward<MAPQUEST_DATA>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UMAPQUEST_DATA@@@std@@UMAPQUEST_DATA@@U3@@std@@YAXAAV?$allocator@UMAPQUEST_DATA@@@0@PAUMAPQUEST_DATA@@$$QAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UMAPQUEST_DATA@@@std@@UMAPQUEST_DATA@@U3@@std@@YAXAAV?$allocator@UMAPQUEST_DATA@@@0@PAUMAPQUEST_DATA@@$$QAU2@@Z PROC ; std::_Cons_val<std::allocator<MAPQUEST_DATA>,MAPQUEST_DATA,MAPQUEST_DATA>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@UMAPQUEST_DATA@@@std@@YA$$QAUMAPQUEST_DATA@@AAU1@@Z ; std::forward<MAPQUEST_DATA>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@UMAPQUEST_DATA@@@std@@QAEXPAUMAPQUEST_DATA@@$$QAU3@@Z ; std::allocator<MAPQUEST_DATA>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UMAPQUEST_DATA@@@std@@UMAPQUEST_DATA@@U3@@std@@YAXAAV?$allocator@UMAPQUEST_DATA@@@0@PAUMAPQUEST_DATA@@$$QAU2@@Z ENDP ; std::_Cons_val<std::allocator<MAPQUEST_DATA>,MAPQUEST_DATA,MAPQUEST_DATA>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Destroy@UMAPQUEST_DATA@@@std@@YAXPAUMAPQUEST_DATA@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UMAPQUEST_DATA@@@std@@YAXPAUMAPQUEST_DATA@@@Z PROC ; std::_Destroy<MAPQUEST_DATA>, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Destroy@UMAPQUEST_DATA@@@std@@YAXPAUMAPQUEST_DATA@@@Z ENDP ; std::_Destroy<MAPQUEST_DATA>
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@UMAPQUEST_DATA@@@std@@QAEXPAUMAPQUEST_DATA@@$$QAU3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@UMAPQUEST_DATA@@@std@@QAEXPAUMAPQUEST_DATA@@$$QAU3@@Z$0
__ehfuncinfo$?construct@?$allocator@UMAPQUEST_DATA@@@std@@QAEXPAUMAPQUEST_DATA@@$$QAU3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@UMAPQUEST_DATA@@@std@@QAEXPAUMAPQUEST_DATA@@$$QAU3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@UMAPQUEST_DATA@@@std@@QAEXPAUMAPQUEST_DATA@@$$QAU3@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T229854 = -88						; size = 4
$T229855 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UMAPQUEST_DATA@@@std@@QAEXPAUMAPQUEST_DATA@@$$QAU3@@Z PROC ; std::allocator<MAPQUEST_DATA>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?construct@?$allocator@UMAPQUEST_DATA@@@std@@QAEXPAUMAPQUEST_DATA@@$$QAU3@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 1c		 push	 28			; 0000001cH
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T229855[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T229855[ebp], 0
  00047	74 20		 je	 SHORT $LN3@construct@2
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@UMAPQUEST_DATA@@@std@@YA$$QAUMAPQUEST_DATA@@AAU1@@Z ; std::forward<MAPQUEST_DATA>
  00052	83 c4 04	 add	 esp, 4
  00055	b9 07 00 00 00	 mov	 ecx, 7
  0005a	8b f0		 mov	 esi, eax
  0005c	8b 7d ac	 mov	 edi, DWORD PTR $T229855[ebp]
  0005f	f3 a5		 rep movsd
  00061	8b 55 ac	 mov	 edx, DWORD PTR $T229855[ebp]
  00064	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  00067	eb 07		 jmp	 SHORT $LN4@construct@2
$LN3@construct@2:
  00069	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct@2:
  00070	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00073	89 45 a8	 mov	 DWORD PTR $T229854[ebp], eax
  00076	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 203  : 		}

  0007d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00080	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00087	59		 pop	 ecx
  00088	5f		 pop	 edi
  00089	5e		 pop	 esi
  0008a	5b		 pop	 ebx
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@UMAPQUEST_DATA@@@std@@QAEXPAUMAPQUEST_DATA@@$$QAU3@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T229855[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$?construct@?$allocator@UMAPQUEST_DATA@@@std@@QAEXPAUMAPQUEST_DATA@@$$QAU3@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?construct@?$allocator@UMAPQUEST_DATA@@@std@@QAEXPAUMAPQUEST_DATA@@$$QAU3@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@UMAPQUEST_DATA@@@std@@QAEXPAUMAPQUEST_DATA@@$$QAU3@@Z ENDP ; std::allocator<MAPQUEST_DATA>::construct
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@UMAPQUEST_DATA@@@std@@YA$$QAUMAPQUEST_DATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UMAPQUEST_DATA@@@std@@YA$$QAUMAPQUEST_DATA@@AAU1@@Z PROC ; std::forward<MAPQUEST_DATA>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@UMAPQUEST_DATA@@@std@@YA$$QAUMAPQUEST_DATA@@AAU1@@Z ENDP ; std::forward<MAPQUEST_DATA>
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File d:\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
; Function compile flags: /Odtp /ZI
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ ; std::bad_alloc::~bad_alloc
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 37   : 		{	// orphan all iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 38   : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 48   : 		{	// adopt this iterator by parent

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 49   : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\mapquest.cpp
;	COMDAT ??__Eg_MapQuest@@YAXXZ
text$yc	SEGMENT
??__Eg_MapQuest@@YAXXZ PROC				; `dynamic initializer for 'g_MapQuest'', COMDAT

; 13   : CMapQuest g_MapQuest;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapQuest@@3VCMapQuest@@A ; g_MapQuest
  0000e	e8 00 00 00 00	 call	 ??0CMapQuest@@QAE@XZ	; CMapQuest::CMapQuest
  00013	68 00 00 00 00	 push	 OFFSET ??__Fg_MapQuest@@YAXXZ ; `dynamic atexit destructor for 'g_MapQuest''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??__Eg_MapQuest@@YAXXZ ENDP				; `dynamic initializer for 'g_MapQuest''
; Function compile flags: /Odtp /ZI
text$yc	ENDS
;	COMDAT ??__Fg_MapQuest@@YAXXZ
text$yd	SEGMENT
??__Fg_MapQuest@@YAXXZ PROC				; `dynamic atexit destructor for 'g_MapQuest'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapQuest@@3VCMapQuest@@A ; g_MapQuest
  0000e	e8 00 00 00 00	 call	 ??1CMapQuest@@QAE@XZ	; CMapQuest::~CMapQuest
  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__Fg_MapQuest@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_MapQuest''
text$yd	ENDS
PUBLIC	?g_MapQuest@@3VCMapQuest@@A			; g_MapQuest
_BSS	SEGMENT
?g_MapQuest@@3VCMapQuest@@A DB 0d6e0H DUP (?)		; g_MapQuest
_BSS	ENDS
CRT$XCU	SEGMENT
_g_MapQuest$initializer$ DD FLAT:??__Eg_MapQuest@@YAXXZ
CRT$XCU	ENDS
END
