; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	D:\Projects\ExTeam6.3\Source\GameServer\GameServer\MultiAttackHackCheck.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Odtp /ZI
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@vector:
  00009	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000c	83 e8 01	 sub	 eax, 1
  0000f	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00012	78 11		 js	 SHORT $LN3@vector
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00017	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  0001d	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00020	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00023	eb e4		 jmp	 SHORT $LN2@vector
$LN3@vector:
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?Init@CMultiAttackHackCheck@@QAEXXZ		; CMultiAttackHackCheck::Init
PUBLIC	??_7CMultiAttackHackCheck@@6B@			; CMultiAttackHackCheck::`vftable'
PUBLIC	??0CMultiAttackHackCheck@@QAE@XZ		; CMultiAttackHackCheck::CMultiAttackHackCheck
PUBLIC	??_R4CMultiAttackHackCheck@@6B@			; CMultiAttackHackCheck::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCMultiAttackHackCheck@@@8		; CMultiAttackHackCheck `RTTI Type Descriptor'
PUBLIC	??_R3CMultiAttackHackCheck@@8			; CMultiAttackHackCheck::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CMultiAttackHackCheck@@8			; CMultiAttackHackCheck::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CMultiAttackHackCheck@@8		; CMultiAttackHackCheck::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ECMultiAttackHackCheck@@UAEPAXI@Z:PROC	; CMultiAttackHackCheck::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CMultiAttackHackCheck@@8
; File d:\projects\exteam6.3\source\gameserver\gameserver\multiattackhackcheck.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@CMultiAttackHackCheck@@8 DD FLAT:??_R0?AVCMultiAttackHackCheck@@@8 ; CMultiAttackHackCheck::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CMultiAttackHackCheck@@8
rdata$r	ENDS
;	COMDAT ??_R2CMultiAttackHackCheck@@8
rdata$r	SEGMENT
??_R2CMultiAttackHackCheck@@8 DD FLAT:??_R1A@?0A@EA@CMultiAttackHackCheck@@8 ; CMultiAttackHackCheck::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CMultiAttackHackCheck@@8
rdata$r	SEGMENT
??_R3CMultiAttackHackCheck@@8 DD 00H			; CMultiAttackHackCheck::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CMultiAttackHackCheck@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCMultiAttackHackCheck@@@8
_DATA	SEGMENT
??_R0?AVCMultiAttackHackCheck@@@8 DD FLAT:??_7type_info@@6B@ ; CMultiAttackHackCheck `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCMultiAttackHackCheck@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CMultiAttackHackCheck@@6B@
rdata$r	SEGMENT
??_R4CMultiAttackHackCheck@@6B@ DD 00H			; CMultiAttackHackCheck::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCMultiAttackHackCheck@@@8
	DD	FLAT:??_R3CMultiAttackHackCheck@@8
rdata$r	ENDS
;	COMDAT ??_7CMultiAttackHackCheck@@6B@
CONST	SEGMENT
??_7CMultiAttackHackCheck@@6B@ DD FLAT:??_R4CMultiAttackHackCheck@@6B@ ; CMultiAttackHackCheck::`vftable'
	DD	FLAT:??_ECMultiAttackHackCheck@@UAEPAXI@Z
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CMultiAttackHackCheck@@QAE@XZ PROC			; CMultiAttackHackCheck::CMultiAttackHackCheck
; _this$ = ecx

; 11   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CMultiAttackHackCheck@@6B@

; 12   : 	this->Init();

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?Init@CMultiAttackHackCheck@@QAEXXZ ; CMultiAttackHackCheck::Init

; 13   : }

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??0CMultiAttackHackCheck@@QAE@XZ ENDP			; CMultiAttackHackCheck::CMultiAttackHackCheck
_TEXT	ENDS
PUBLIC	??1CMultiAttackHackCheck@@UAE@XZ		; CMultiAttackHackCheck::~CMultiAttackHackCheck
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp /ZI
;	COMDAT ??_GCMultiAttackHackCheck@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCMultiAttackHackCheck@@UAEPAXI@Z PROC		; CMultiAttackHackCheck::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1CMultiAttackHackCheck@@UAE@XZ ; CMultiAttackHackCheck::~CMultiAttackHackCheck
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_GCMultiAttackHackCheck@@UAEPAXI@Z ENDP		; CMultiAttackHackCheck::`scalar deleting destructor'
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CMultiAttackHackCheck@@UAE@XZ PROC			; CMultiAttackHackCheck::~CMultiAttackHackCheck
; _this$ = ecx

; 18   : {

  00030	55		 push	 ebp
  00031	8b ec		 mov	 ebp, esp
  00033	83 ec 44	 sub	 esp, 68			; 00000044H
  00036	53		 push	 ebx
  00037	56		 push	 esi
  00038	57		 push	 edi
  00039	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0003c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CMultiAttackHackCheck@@6B@

; 19   : 	return;
; 20   : }

  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	5b		 pop	 ebx
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
??1CMultiAttackHackCheck@@UAE@XZ ENDP			; CMultiAttackHackCheck::~CMultiAttackHackCheck
_TEXT	ENDS
EXTRN	_memset:PROC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_i$219430 = -8						; size = 4
_this$ = -4						; size = 4
?Init@CMultiAttackHackCheck@@QAEXXZ PROC		; CMultiAttackHackCheck::Init
; _this$ = ecx

; 23   : {

  00050	55		 push	 ebp
  00051	8b ec		 mov	 ebp, esp
  00053	83 ec 48	 sub	 esp, 72			; 00000048H
  00056	53		 push	 ebx
  00057	56		 push	 esi
  00058	57		 push	 edi
  00059	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 24   : 	this->m_iCount = 0;

  0005c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 25   : 
; 26   : 	for ( int i=0;i<MAX_MULTI_ATTACK_INFO;i++)

  00066	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$219430[ebp], 0
  0006d	eb 09		 jmp	 SHORT $LN3@Init
$LN2@Init:
  0006f	8b 45 f8	 mov	 eax, DWORD PTR _i$219430[ebp]
  00072	83 c0 01	 add	 eax, 1
  00075	89 45 f8	 mov	 DWORD PTR _i$219430[ebp], eax
$LN3@Init:
  00078	83 7d f8 28	 cmp	 DWORD PTR _i$219430[ebp], 40 ; 00000028H
  0007c	7d 36		 jge	 SHORT $LN4@Init

; 27   : 	{
; 28   : 		this->m_Table[i].number = -1;

  0007e	8b 45 f8	 mov	 eax, DWORD PTR _i$219430[ebp]
  00081	69 c0 02 01 00
	00		 imul	 eax, 258		; 00000102H
  00087	83 c9 ff	 or	 ecx, -1
  0008a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0008d	66 89 4c 02 08	 mov	 WORD PTR [edx+eax+8], cx

; 29   : 		memset(this->m_Table[i].Serial, 0, sizeof(this->m_Table[i].Serial));

  00092	68 ff 00 00 00	 push	 255			; 000000ffH
  00097	6a 00		 push	 0
  00099	8b 45 f8	 mov	 eax, DWORD PTR _i$219430[ebp]
  0009c	69 c0 02 01 00
	00		 imul	 eax, 258		; 00000102H
  000a2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	8d 54 01 0a	 lea	 edx, DWORD PTR [ecx+eax+10]
  000a9	52		 push	 edx
  000aa	e8 00 00 00 00	 call	 _memset
  000af	83 c4 0c	 add	 esp, 12			; 0000000cH

; 30   : 	}

  000b2	eb bb		 jmp	 SHORT $LN2@Init
$LN4@Init:

; 31   : }

  000b4	5f		 pop	 edi
  000b5	5e		 pop	 esi
  000b6	5b		 pop	 ebx
  000b7	8b e5		 mov	 esp, ebp
  000b9	5d		 pop	 ebp
  000ba	c3		 ret	 0
?Init@CMultiAttackHackCheck@@QAEXXZ ENDP		; CMultiAttackHackCheck::Init
_TEXT	ENDS
PUBLIC	?Insert@CMultiAttackHackCheck@@QAEHHEE@Z	; CMultiAttackHackCheck::Insert
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_i$219442 = -8						; size = 4
_this$ = -4						; size = 4
_aTargetIndex$ = 8					; size = 4
_skillnum$ = 12						; size = 1
_serial$ = 16						; size = 1
?Insert@CMultiAttackHackCheck@@QAEHHEE@Z PROC		; CMultiAttackHackCheck::Insert
; _this$ = ecx

; 37   : {

  000c0	55		 push	 ebp
  000c1	8b ec		 mov	 ebp, esp
  000c3	83 ec 48	 sub	 esp, 72			; 00000048H
  000c6	53		 push	 ebx
  000c7	56		 push	 esi
  000c8	57		 push	 edi
  000c9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 38   : 	if ( gObj[aTargetIndex].Type == OBJ_MONSTER )

  000cc	8b 45 08	 mov	 eax, DWORD PTR _aTargetIndex$[ebp]
  000cf	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  000d5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000db	0f b7 54 01 68	 movzx	 edx, WORD PTR [ecx+eax+104]
  000e0	83 fa 02	 cmp	 edx, 2
  000e3	75 0a		 jne	 SHORT $LN12@Insert

; 39   : 	{
; 40   : 		return TRUE;

  000e5	b8 01 00 00 00	 mov	 eax, 1
  000ea	e9 92 01 00 00	 jmp	 $LN13@Insert
$LN12@Insert:

; 41   : 	}
; 42   : 
; 43   : 	if ( skillnum == 12 )

  000ef	0f b6 45 0c	 movzx	 eax, BYTE PTR _skillnum$[ebp]
  000f3	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  000f6	75 0a		 jne	 SHORT $LN11@Insert

; 44   : 	{
; 45   : 		return TRUE;

  000f8	b8 01 00 00 00	 mov	 eax, 1
  000fd	e9 7f 01 00 00	 jmp	 $LN13@Insert
$LN11@Insert:

; 46   : 	}
; 47   : 
; 48   : 	for ( int i=0;i<MAX_MULTI_ATTACK_INFO;i++)

  00102	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$219442[ebp], 0
  00109	eb 09		 jmp	 SHORT $LN10@Insert
$LN9@Insert:
  0010b	8b 45 f8	 mov	 eax, DWORD PTR _i$219442[ebp]
  0010e	83 c0 01	 add	 eax, 1
  00111	89 45 f8	 mov	 DWORD PTR _i$219442[ebp], eax
$LN10@Insert:
  00114	83 7d f8 28	 cmp	 DWORD PTR _i$219442[ebp], 40 ; 00000028H
  00118	0f 8d ec 00 00
	00		 jge	 $LN8@Insert

; 49   : 	{
; 50   : 		if ( this->m_Table[i].number == aTargetIndex )

  0011e	8b 45 f8	 mov	 eax, DWORD PTR _i$219442[ebp]
  00121	69 c0 02 01 00
	00		 imul	 eax, 258		; 00000102H
  00127	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0012a	0f bf 54 01 08	 movsx	 edx, WORD PTR [ecx+eax+8]
  0012f	3b 55 08	 cmp	 edx, DWORD PTR _aTargetIndex$[ebp]
  00132	0f 85 cd 00 00
	00		 jne	 $LN7@Insert

; 51   : 		{
; 52   : 			if ( serial == (BYTE)-1  && this->m_Table[i].Serial[serial]  != 0 )

  00138	0f b6 45 10	 movzx	 eax, BYTE PTR _serial$[ebp]
  0013c	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00141	75 3d		 jne	 SHORT $LN6@Insert
  00143	8b 45 f8	 mov	 eax, DWORD PTR _i$219442[ebp]
  00146	69 c0 02 01 00
	00		 imul	 eax, 258		; 00000102H
  0014c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0014f	8d 54 01 08	 lea	 edx, DWORD PTR [ecx+eax+8]
  00153	0f b6 45 10	 movzx	 eax, BYTE PTR _serial$[ebp]
  00157	0f b6 4c 02 02	 movzx	 ecx, BYTE PTR [edx+eax+2]
  0015c	85 c9		 test	 ecx, ecx
  0015e	74 20		 je	 SHORT $LN6@Insert

; 53   : 			{
; 54   : 				memset(this->m_Table[i].Serial, 0, MULTI_ATTACK_SERIAL_SIZE);

  00160	68 ff 00 00 00	 push	 255			; 000000ffH
  00165	6a 00		 push	 0
  00167	8b 45 f8	 mov	 eax, DWORD PTR _i$219442[ebp]
  0016a	69 c0 02 01 00
	00		 imul	 eax, 258		; 00000102H
  00170	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00173	8d 54 01 0a	 lea	 edx, DWORD PTR [ecx+eax+10]
  00177	52		 push	 edx
  00178	e8 00 00 00 00	 call	 _memset
  0017d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@Insert:

; 55   : 			}
; 56   : 
; 57   : 			this->m_Table[i].Serial[serial]++;

  00180	0f b6 45 10	 movzx	 eax, BYTE PTR _serial$[ebp]
  00184	8b 4d f8	 mov	 ecx, DWORD PTR _i$219442[ebp]
  00187	69 c9 02 01 00
	00		 imul	 ecx, 258		; 00000102H
  0018d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00190	8d 4c 0a 08	 lea	 ecx, DWORD PTR [edx+ecx+8]
  00194	8a 54 01 02	 mov	 dl, BYTE PTR [ecx+eax+2]
  00198	80 c2 01	 add	 dl, 1
  0019b	0f b6 45 10	 movzx	 eax, BYTE PTR _serial$[ebp]
  0019f	8b 4d f8	 mov	 ecx, DWORD PTR _i$219442[ebp]
  001a2	69 c9 02 01 00
	00		 imul	 ecx, 258		; 00000102H
  001a8	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  001ab	8d 4c 0e 08	 lea	 ecx, DWORD PTR [esi+ecx+8]
  001af	88 54 01 02	 mov	 BYTE PTR [ecx+eax+2], dl

; 58   : 
; 59   : 			if ( skillnum == 9 )

  001b3	0f b6 45 0c	 movzx	 eax, BYTE PTR _skillnum$[ebp]
  001b7	83 f8 09	 cmp	 eax, 9
  001ba	75 27		 jne	 SHORT $LN5@Insert

; 60   : 			{
; 61   : 				if ( this->m_Table[i].Serial[serial] > 6 )

  001bc	8b 45 f8	 mov	 eax, DWORD PTR _i$219442[ebp]
  001bf	69 c0 02 01 00
	00		 imul	 eax, 258		; 00000102H
  001c5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001c8	8d 54 01 08	 lea	 edx, DWORD PTR [ecx+eax+8]
  001cc	0f b6 45 10	 movzx	 eax, BYTE PTR _serial$[ebp]
  001d0	0f b6 4c 02 02	 movzx	 ecx, BYTE PTR [edx+eax+2]
  001d5	83 f9 06	 cmp	 ecx, 6
  001d8	7e 07		 jle	 SHORT $LN4@Insert

; 62   : 				{
; 63   : 					return FALSE;

  001da	33 c0		 xor	 eax, eax
  001dc	e9 a0 00 00 00	 jmp	 $LN13@Insert
$LN4@Insert:

; 64   : 				}
; 65   : 			}

  001e1	eb 22		 jmp	 SHORT $LN7@Insert
$LN5@Insert:

; 66   : 			else if ( this->m_Table[i].Serial[serial] > 6 )

  001e3	8b 45 f8	 mov	 eax, DWORD PTR _i$219442[ebp]
  001e6	69 c0 02 01 00
	00		 imul	 eax, 258		; 00000102H
  001ec	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001ef	8d 54 01 08	 lea	 edx, DWORD PTR [ecx+eax+8]
  001f3	0f b6 45 10	 movzx	 eax, BYTE PTR _serial$[ebp]
  001f7	0f b6 4c 02 02	 movzx	 ecx, BYTE PTR [edx+eax+2]
  001fc	83 f9 06	 cmp	 ecx, 6
  001ff	7e 04		 jle	 SHORT $LN7@Insert

; 67   : 			{
; 68   : 				return FALSE;

  00201	33 c0		 xor	 eax, eax
  00203	eb 7c		 jmp	 SHORT $LN13@Insert
$LN7@Insert:

; 69   : 			}
; 70   : 		}
; 71   : 	}

  00205	e9 01 ff ff ff	 jmp	 $LN9@Insert
$LN8@Insert:

; 72   : 
; 73   : 	this->m_Table[this->m_iCount].number = aTargetIndex;

  0020a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0020d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00210	69 c9 02 01 00
	00		 imul	 ecx, 258		; 00000102H
  00216	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00219	66 8b 45 08	 mov	 ax, WORD PTR _aTargetIndex$[ebp]
  0021d	66 89 44 0a 08	 mov	 WORD PTR [edx+ecx+8], ax

; 74   : 	this->m_Table[this->m_iCount].Serial[serial]++;

  00222	0f b6 45 10	 movzx	 eax, BYTE PTR _serial$[ebp]
  00226	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00229	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0022c	69 d2 02 01 00
	00		 imul	 edx, 258		; 00000102H
  00232	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00235	8d 54 11 08	 lea	 edx, DWORD PTR [ecx+edx+8]
  00239	8a 44 02 02	 mov	 al, BYTE PTR [edx+eax+2]
  0023d	04 01		 add	 al, 1
  0023f	0f b6 4d 10	 movzx	 ecx, BYTE PTR _serial$[ebp]
  00243	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00246	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00249	69 d2 02 01 00
	00		 imul	 edx, 258		; 00000102H
  0024f	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  00252	8d 54 16 08	 lea	 edx, DWORD PTR [esi+edx+8]
  00256	88 44 0a 02	 mov	 BYTE PTR [edx+ecx+2], al

; 75   : 	this->m_iCount++;

  0025a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0025d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00260	83 c1 01	 add	 ecx, 1
  00263	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00266	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 76   : 
; 77   : 
; 78   : 	if ( this->m_iCount >= MAX_MULTI_ATTACK_INFO )

  00269	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0026c	83 78 04 28	 cmp	 DWORD PTR [eax+4], 40	; 00000028H
  00270	7c 0a		 jl	 SHORT $LN1@Insert

; 79   : 	{
; 80   : 		this->m_iCount = 0;

  00272	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00275	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
$LN1@Insert:

; 81   : 	}
; 82   : 
; 83   : 	return TRUE;

  0027c	b8 01 00 00 00	 mov	 eax, 1
$LN13@Insert:

; 84   : }

  00281	5f		 pop	 edi
  00282	5e		 pop	 esi
  00283	5b		 pop	 ebx
  00284	8b e5		 mov	 esp, ebp
  00286	5d		 pop	 ebp
  00287	c2 0c 00	 ret	 12			; 0000000cH
?Insert@CMultiAttackHackCheck@@QAEHHEE@Z ENDP		; CMultiAttackHackCheck::Insert
_TEXT	ENDS
PUBLIC	?CheckPenetrationSkill@CMultiAttackHackCheck@@QAEHHEE@Z ; CMultiAttackHackCheck::CheckPenetrationSkill
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_i$219462 = -8						; size = 4
_this$ = -4						; size = 4
_aTargetIndex$ = 8					; size = 4
_skillnum$ = 12						; size = 1
_serial$ = 16						; size = 1
?CheckPenetrationSkill@CMultiAttackHackCheck@@QAEHHEE@Z PROC ; CMultiAttackHackCheck::CheckPenetrationSkill
; _this$ = ecx

; 90   : {

  00290	55		 push	 ebp
  00291	8b ec		 mov	 ebp, esp
  00293	83 ec 48	 sub	 esp, 72			; 00000048H
  00296	53		 push	 ebx
  00297	56		 push	 esi
  00298	57		 push	 edi
  00299	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 91   : 	if ( skillnum != 52 )

  0029c	0f b6 45 0c	 movzx	 eax, BYTE PTR _skillnum$[ebp]
  002a0	83 f8 34	 cmp	 eax, 52			; 00000034H
  002a3	74 0a		 je	 SHORT $LN9@CheckPenet

; 92   : 	{
; 93   : 		return TRUE;

  002a5	b8 01 00 00 00	 mov	 eax, 1
  002aa	e9 5e 01 00 00	 jmp	 $LN10@CheckPenet
$LN9@CheckPenet:

; 94   : 	}
; 95   : 
; 96   : 	if ( serial == 10 )

  002af	0f b6 45 10	 movzx	 eax, BYTE PTR _serial$[ebp]
  002b3	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  002b6	75 08		 jne	 SHORT $LN8@CheckPenet

; 97   : 	{
; 98   : 		this->Init();

  002b8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002bb	e8 00 00 00 00	 call	 ?Init@CMultiAttackHackCheck@@QAEXXZ ; CMultiAttackHackCheck::Init
$LN8@CheckPenet:

; 99   : 	}
; 100  : 
; 101  : 	for ( int i=0;i<MAX_MULTI_ATTACK_INFO;i++)

  002c0	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$219462[ebp], 0
  002c7	eb 09		 jmp	 SHORT $LN7@CheckPenet
$LN6@CheckPenet:
  002c9	8b 45 f8	 mov	 eax, DWORD PTR _i$219462[ebp]
  002cc	83 c0 01	 add	 eax, 1
  002cf	89 45 f8	 mov	 DWORD PTR _i$219462[ebp], eax
$LN7@CheckPenet:
  002d2	83 7d f8 28	 cmp	 DWORD PTR _i$219462[ebp], 40 ; 00000028H
  002d6	0f 8d ba 00 00
	00		 jge	 $LN5@CheckPenet

; 102  : 	{
; 103  : 		if ( this->m_Table[i].number == aTargetIndex )

  002dc	8b 45 f8	 mov	 eax, DWORD PTR _i$219462[ebp]
  002df	69 c0 02 01 00
	00		 imul	 eax, 258		; 00000102H
  002e5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002e8	0f bf 54 01 08	 movsx	 edx, WORD PTR [ecx+eax+8]
  002ed	3b 55 08	 cmp	 edx, DWORD PTR _aTargetIndex$[ebp]
  002f0	0f 85 9b 00 00
	00		 jne	 $LN4@CheckPenet

; 104  : 		{
; 105  : 			if ( serial == 10 && this->m_Table[i].Serial[serial] != 0 )

  002f6	0f b6 45 10	 movzx	 eax, BYTE PTR _serial$[ebp]
  002fa	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  002fd	75 3d		 jne	 SHORT $LN3@CheckPenet
  002ff	8b 45 f8	 mov	 eax, DWORD PTR _i$219462[ebp]
  00302	69 c0 02 01 00
	00		 imul	 eax, 258		; 00000102H
  00308	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0030b	8d 54 01 08	 lea	 edx, DWORD PTR [ecx+eax+8]
  0030f	0f b6 45 10	 movzx	 eax, BYTE PTR _serial$[ebp]
  00313	0f b6 4c 02 02	 movzx	 ecx, BYTE PTR [edx+eax+2]
  00318	85 c9		 test	 ecx, ecx
  0031a	74 20		 je	 SHORT $LN3@CheckPenet

; 106  : 			{
; 107  : 				memset(this->m_Table[i].Serial , 0, MULTI_ATTACK_SERIAL_SIZE);

  0031c	68 ff 00 00 00	 push	 255			; 000000ffH
  00321	6a 00		 push	 0
  00323	8b 45 f8	 mov	 eax, DWORD PTR _i$219462[ebp]
  00326	69 c0 02 01 00
	00		 imul	 eax, 258		; 00000102H
  0032c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0032f	8d 54 01 0a	 lea	 edx, DWORD PTR [ecx+eax+10]
  00333	52		 push	 edx
  00334	e8 00 00 00 00	 call	 _memset
  00339	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@CheckPenet:

; 108  : 			}
; 109  : 			
; 110  : 			this->m_Table[i].Serial[serial]++;

  0033c	0f b6 45 10	 movzx	 eax, BYTE PTR _serial$[ebp]
  00340	8b 4d f8	 mov	 ecx, DWORD PTR _i$219462[ebp]
  00343	69 c9 02 01 00
	00		 imul	 ecx, 258		; 00000102H
  00349	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0034c	8d 4c 0a 08	 lea	 ecx, DWORD PTR [edx+ecx+8]
  00350	8a 54 01 02	 mov	 dl, BYTE PTR [ecx+eax+2]
  00354	80 c2 01	 add	 dl, 1
  00357	0f b6 45 10	 movzx	 eax, BYTE PTR _serial$[ebp]
  0035b	8b 4d f8	 mov	 ecx, DWORD PTR _i$219462[ebp]
  0035e	69 c9 02 01 00
	00		 imul	 ecx, 258		; 00000102H
  00364	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  00367	8d 4c 0e 08	 lea	 ecx, DWORD PTR [esi+ecx+8]
  0036b	88 54 01 02	 mov	 BYTE PTR [ecx+eax+2], dl

; 111  : 
; 112  : 			if ( this->m_Table[i].Serial[serial] > 1 )

  0036f	8b 45 f8	 mov	 eax, DWORD PTR _i$219462[ebp]
  00372	69 c0 02 01 00
	00		 imul	 eax, 258		; 00000102H
  00378	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0037b	8d 54 01 08	 lea	 edx, DWORD PTR [ecx+eax+8]
  0037f	0f b6 45 10	 movzx	 eax, BYTE PTR _serial$[ebp]
  00383	0f b6 4c 02 02	 movzx	 ecx, BYTE PTR [edx+eax+2]
  00388	83 f9 01	 cmp	 ecx, 1
  0038b	7e 04		 jle	 SHORT $LN4@CheckPenet

; 113  : 			{
; 114  : 				return FALSE;

  0038d	33 c0		 xor	 eax, eax
  0038f	eb 7c		 jmp	 SHORT $LN10@CheckPenet
$LN4@CheckPenet:

; 115  : 			}
; 116  : 		}
; 117  : 	}

  00391	e9 33 ff ff ff	 jmp	 $LN6@CheckPenet
$LN5@CheckPenet:

; 118  : 
; 119  : 	this->m_Table[this->m_iCount].number = aTargetIndex;

  00396	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00399	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0039c	69 c9 02 01 00
	00		 imul	 ecx, 258		; 00000102H
  003a2	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  003a5	66 8b 45 08	 mov	 ax, WORD PTR _aTargetIndex$[ebp]
  003a9	66 89 44 0a 08	 mov	 WORD PTR [edx+ecx+8], ax

; 120  : 	this->m_Table[this->m_iCount].Serial[serial]++;

  003ae	0f b6 45 10	 movzx	 eax, BYTE PTR _serial$[ebp]
  003b2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003b5	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  003b8	69 d2 02 01 00
	00		 imul	 edx, 258		; 00000102H
  003be	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003c1	8d 54 11 08	 lea	 edx, DWORD PTR [ecx+edx+8]
  003c5	8a 44 02 02	 mov	 al, BYTE PTR [edx+eax+2]
  003c9	04 01		 add	 al, 1
  003cb	0f b6 4d 10	 movzx	 ecx, BYTE PTR _serial$[ebp]
  003cf	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  003d2	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  003d5	69 d2 02 01 00
	00		 imul	 edx, 258		; 00000102H
  003db	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  003de	8d 54 16 08	 lea	 edx, DWORD PTR [esi+edx+8]
  003e2	88 44 0a 02	 mov	 BYTE PTR [edx+ecx+2], al

; 121  : 	this->m_iCount++;

  003e6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  003e9	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  003ec	83 c1 01	 add	 ecx, 1
  003ef	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  003f2	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 122  : 
; 123  : 
; 124  : 	if ( this->m_iCount >= MAX_MULTI_ATTACK_INFO )

  003f5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  003f8	83 78 04 28	 cmp	 DWORD PTR [eax+4], 40	; 00000028H
  003fc	7c 0a		 jl	 SHORT $LN1@CheckPenet

; 125  : 	{
; 126  : 		this->m_iCount = 0;

  003fe	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00401	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
$LN1@CheckPenet:

; 127  : 	}
; 128  : 
; 129  : 	return TRUE;

  00408	b8 01 00 00 00	 mov	 eax, 1
$LN10@CheckPenet:

; 130  : }

  0040d	5f		 pop	 edi
  0040e	5e		 pop	 esi
  0040f	5b		 pop	 ebx
  00410	8b e5		 mov	 esp, ebp
  00412	5d		 pop	 ebp
  00413	c2 0c 00	 ret	 12			; 0000000cH
?CheckPenetrationSkill@CMultiAttackHackCheck@@QAEHHEE@Z ENDP ; CMultiAttackHackCheck::CheckPenetrationSkill
_TEXT	ENDS
PUBLIC	?GetFireScreamMaxAttackCountSameSerial@CSkillAdditionInfo@@QAEHXZ ; CSkillAdditionInfo::GetFireScreamMaxAttackCountSameSerial
PUBLIC	?GetFireScreamSerialInitCount@CSkillAdditionInfo@@QAEHXZ ; CSkillAdditionInfo::GetFireScreamSerialInitCount
PUBLIC	?GetCheckFireScreamSkill@CSkillAdditionInfo@@QAEHXZ ; CSkillAdditionInfo::GetCheckFireScreamSkill
PUBLIC	?CheckFireScreamSkill@CMultiAttackHackCheck@@QAEHHEE@Z ; CMultiAttackHackCheck::CheckFireScreamSkill
EXTRN	?g_SkillAdditionInfo@@3VCSkillAdditionInfo@@A:BYTE ; g_SkillAdditionInfo
EXTRN	?CheckUser@CExLicense@@QAE_NH@Z:PROC		; CExLicense::CheckUser
EXTRN	?g_ExLicense@@3VCExLicense@@A:BYTE		; g_ExLicense
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_iCount$219480 = -8					; size = 4
_this$ = -4						; size = 4
_iTargetIndex$ = 8					; size = 4
_btSkillNum$ = 12					; size = 1
_btSerial$ = 16						; size = 1
?CheckFireScreamSkill@CMultiAttackHackCheck@@QAEHHEE@Z PROC ; CMultiAttackHackCheck::CheckFireScreamSkill
; _this$ = ecx

; 136  : {

  00420	55		 push	 ebp
  00421	8b ec		 mov	 ebp, esp
  00423	83 ec 48	 sub	 esp, 72			; 00000048H
  00426	53		 push	 ebx
  00427	56		 push	 esi
  00428	57		 push	 edi
  00429	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 137  : 	if( g_ExLicense.CheckUser(eExUB::Local)		 || 
; 138  : 		g_ExLicense.CheckUser(eExUB::Gredy)		 || 
; 139  : 		g_ExLicense.CheckUser(eExUB::GredyLocal) ||
; 140  : 		g_ExLicense.CheckUser(eExUB::Gredy2)	 ||
; 141  : 		g_ExLicense.CheckUser(eExUB::SILVER1)	 || 
; 142  : 		g_ExLicense.CheckUser(eExUB::SILVER2) )

  0042c	6a 00		 push	 0
  0042e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00433	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00438	0f b6 c0	 movzx	 eax, al
  0043b	85 c0		 test	 eax, eax
  0043d	75 5f		 jne	 SHORT $LN9@CheckFireS
  0043f	6a 20		 push	 32			; 00000020H
  00441	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00446	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  0044b	0f b6 c0	 movzx	 eax, al
  0044e	85 c0		 test	 eax, eax
  00450	75 4c		 jne	 SHORT $LN9@CheckFireS
  00452	6a 21		 push	 33			; 00000021H
  00454	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00459	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  0045e	0f b6 c0	 movzx	 eax, al
  00461	85 c0		 test	 eax, eax
  00463	75 39		 jne	 SHORT $LN9@CheckFireS
  00465	6a 22		 push	 34			; 00000022H
  00467	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  0046c	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00471	0f b6 c0	 movzx	 eax, al
  00474	85 c0		 test	 eax, eax
  00476	75 26		 jne	 SHORT $LN9@CheckFireS
  00478	6a 07		 push	 7
  0047a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  0047f	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00484	0f b6 c0	 movzx	 eax, al
  00487	85 c0		 test	 eax, eax
  00489	75 13		 jne	 SHORT $LN9@CheckFireS
  0048b	6a 08		 push	 8
  0048d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00492	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00497	0f b6 c0	 movzx	 eax, al
  0049a	85 c0		 test	 eax, eax
  0049c	74 0a		 je	 SHORT $LN10@CheckFireS
$LN9@CheckFireS:

; 143  : 	{
; 144  : 		return true;

  0049e	b8 01 00 00 00	 mov	 eax, 1
  004a3	e9 4e 01 00 00	 jmp	 $LN11@CheckFireS
$LN10@CheckFireS:

; 145  : 	}
; 146  : 
; 147  : 	if ( g_SkillAdditionInfo.GetCheckFireScreamSkill() == FALSE )

  004a8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_SkillAdditionInfo@@3VCSkillAdditionInfo@@A ; g_SkillAdditionInfo
  004ad	e8 00 00 00 00	 call	 ?GetCheckFireScreamSkill@CSkillAdditionInfo@@QAEHXZ ; CSkillAdditionInfo::GetCheckFireScreamSkill
  004b2	85 c0		 test	 eax, eax
  004b4	75 0a		 jne	 SHORT $LN8@CheckFireS

; 148  : 		return TRUE;

  004b6	b8 01 00 00 00	 mov	 eax, 1
  004bb	e9 36 01 00 00	 jmp	 $LN11@CheckFireS
$LN8@CheckFireS:

; 149  : 
; 150  : 	if ( btSerial > g_SkillAdditionInfo.GetFireScreamSerialInitCount()- 4)//NEW 

  004c0	0f b6 75 10	 movzx	 esi, BYTE PTR _btSerial$[ebp]
  004c4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_SkillAdditionInfo@@3VCSkillAdditionInfo@@A ; g_SkillAdditionInfo
  004c9	e8 00 00 00 00	 call	 ?GetFireScreamSerialInitCount@CSkillAdditionInfo@@QAEHXZ ; CSkillAdditionInfo::GetFireScreamSerialInitCount
  004ce	83 e8 04	 sub	 eax, 4
  004d1	3b f0		 cmp	 esi, eax
  004d3	7e 08		 jle	 SHORT $LN7@CheckFireS

; 151  : 		this->Init();

  004d5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  004d8	e8 00 00 00 00	 call	 ?Init@CMultiAttackHackCheck@@QAEXXZ ; CMultiAttackHackCheck::Init
$LN7@CheckFireS:

; 152  : 
; 153  : 	for ( int iCount = 0 ; iCount < MAX_MULTI_ATTACK_INFO ; iCount++)

  004dd	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iCount$219480[ebp], 0
  004e4	eb 09		 jmp	 SHORT $LN6@CheckFireS
$LN5@CheckFireS:
  004e6	8b 45 f8	 mov	 eax, DWORD PTR _iCount$219480[ebp]
  004e9	83 c0 01	 add	 eax, 1
  004ec	89 45 f8	 mov	 DWORD PTR _iCount$219480[ebp], eax
$LN6@CheckFireS:
  004ef	83 7d f8 28	 cmp	 DWORD PTR _iCount$219480[ebp], 40 ; 00000028H
  004f3	0f 8d 84 00 00
	00		 jge	 $LN4@CheckFireS

; 154  : 	{
; 155  : 		if ( this->m_Table[iCount].number == iTargetIndex )

  004f9	8b 45 f8	 mov	 eax, DWORD PTR _iCount$219480[ebp]
  004fc	69 c0 02 01 00
	00		 imul	 eax, 258		; 00000102H
  00502	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00505	0f bf 54 01 08	 movsx	 edx, WORD PTR [ecx+eax+8]
  0050a	3b 55 08	 cmp	 edx, DWORD PTR _iTargetIndex$[ebp]
  0050d	75 69		 jne	 SHORT $LN3@CheckFireS

; 156  : 		{
; 157  : 			this->m_Table[iCount].Serial[btSerial]+=1;

  0050f	8b 45 f8	 mov	 eax, DWORD PTR _iCount$219480[ebp]
  00512	69 c0 02 01 00
	00		 imul	 eax, 258		; 00000102H
  00518	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0051b	8d 54 01 08	 lea	 edx, DWORD PTR [ecx+eax+8]
  0051f	0f b6 45 10	 movzx	 eax, BYTE PTR _btSerial$[ebp]
  00523	0f b6 4c 02 02	 movzx	 ecx, BYTE PTR [edx+eax+2]
  00528	83 c1 01	 add	 ecx, 1
  0052b	0f b6 55 10	 movzx	 edx, BYTE PTR _btSerial$[ebp]
  0052f	8b 45 f8	 mov	 eax, DWORD PTR _iCount$219480[ebp]
  00532	69 c0 02 01 00
	00		 imul	 eax, 258		; 00000102H
  00538	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  0053b	8d 44 06 08	 lea	 eax, DWORD PTR [esi+eax+8]
  0053f	88 4c 10 02	 mov	 BYTE PTR [eax+edx+2], cl

; 158  : 
; 159  : 			if ( this->m_Table[iCount].Serial[btSerial] > g_SkillAdditionInfo.GetFireScreamMaxAttackCountSameSerial() )

  00543	8b 45 f8	 mov	 eax, DWORD PTR _iCount$219480[ebp]
  00546	69 c0 02 01 00
	00		 imul	 eax, 258		; 00000102H
  0054c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0054f	8d 54 01 08	 lea	 edx, DWORD PTR [ecx+eax+8]
  00553	0f b6 45 10	 movzx	 eax, BYTE PTR _btSerial$[ebp]
  00557	0f b6 74 02 02	 movzx	 esi, BYTE PTR [edx+eax+2]
  0055c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_SkillAdditionInfo@@3VCSkillAdditionInfo@@A ; g_SkillAdditionInfo
  00561	e8 00 00 00 00	 call	 ?GetFireScreamMaxAttackCountSameSerial@CSkillAdditionInfo@@QAEHXZ ; CSkillAdditionInfo::GetFireScreamMaxAttackCountSameSerial
  00566	3b f0		 cmp	 esi, eax
  00568	7e 07		 jle	 SHORT $LN2@CheckFireS

; 160  : 			{
; 161  : 				return FALSE;

  0056a	33 c0		 xor	 eax, eax
  0056c	e9 85 00 00 00	 jmp	 $LN11@CheckFireS
$LN2@CheckFireS:

; 162  : 			}
; 163  : 
; 164  : 			return TRUE;//NEW

  00571	b8 01 00 00 00	 mov	 eax, 1
  00576	eb 7e		 jmp	 SHORT $LN11@CheckFireS
$LN3@CheckFireS:

; 165  : 		}
; 166  : 	}

  00578	e9 69 ff ff ff	 jmp	 $LN5@CheckFireS
$LN4@CheckFireS:

; 167  : 
; 168  : 	this->m_Table[this->m_iCount].number = iTargetIndex;

  0057d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00580	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00583	69 c9 02 01 00
	00		 imul	 ecx, 258		; 00000102H
  00589	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0058c	66 8b 45 08	 mov	 ax, WORD PTR _iTargetIndex$[ebp]
  00590	66 89 44 0a 08	 mov	 WORD PTR [edx+ecx+8], ax

; 169  : 	this->m_Table[this->m_iCount].Serial[btSerial]+=1;

  00595	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00598	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0059b	69 c9 02 01 00
	00		 imul	 ecx, 258		; 00000102H
  005a1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  005a4	8d 44 0a 08	 lea	 eax, DWORD PTR [edx+ecx+8]
  005a8	0f b6 4d 10	 movzx	 ecx, BYTE PTR _btSerial$[ebp]
  005ac	0f b6 54 08 02	 movzx	 edx, BYTE PTR [eax+ecx+2]
  005b1	83 c2 01	 add	 edx, 1
  005b4	0f b6 45 10	 movzx	 eax, BYTE PTR _btSerial$[ebp]
  005b8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  005bb	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  005be	69 c9 02 01 00
	00		 imul	 ecx, 258		; 00000102H
  005c4	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  005c7	8d 4c 0e 08	 lea	 ecx, DWORD PTR [esi+ecx+8]
  005cb	88 54 01 02	 mov	 BYTE PTR [ecx+eax+2], dl

; 170  : 	this->m_iCount++;

  005cf	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  005d2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  005d5	83 c1 01	 add	 ecx, 1
  005d8	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  005db	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 171  : 
; 172  : 	if ( this->m_iCount >= MAX_MULTI_ATTACK_INFO )

  005de	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  005e1	83 78 04 28	 cmp	 DWORD PTR [eax+4], 40	; 00000028H
  005e5	7c 0a		 jl	 SHORT $LN1@CheckFireS

; 173  : 		this->m_iCount = 0;

  005e7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  005ea	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
$LN1@CheckFireS:

; 174  : 
; 175  : 	return TRUE;

  005f1	b8 01 00 00 00	 mov	 eax, 1
$LN11@CheckFireS:

; 176  : }

  005f6	5f		 pop	 edi
  005f7	5e		 pop	 esi
  005f8	5b		 pop	 ebx
  005f9	8b e5		 mov	 esp, ebp
  005fb	5d		 pop	 ebp
  005fc	c2 0c 00	 ret	 12			; 0000000cH
?CheckFireScreamSkill@CMultiAttackHackCheck@@QAEHHEE@Z ENDP ; CMultiAttackHackCheck::CheckFireScreamSkill
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\skilladditioninfo.h
_TEXT	ENDS
;	COMDAT ?GetFireScreamMaxAttackCountSameSerial@CSkillAdditionInfo@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFireScreamMaxAttackCountSameSerial@CSkillAdditionInfo@@QAEHXZ PROC ; CSkillAdditionInfo::GetFireScreamMaxAttackCountSameSerial, COMDAT
; _this$ = ecx

; 53   : 	int GetFireScreamMaxAttackCountSameSerial(){return this->m_iFireScreamMaxAttackCountSameSerial;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  00012	5f		 pop	 edi
  00013	5e		 pop	 esi
  00014	5b		 pop	 ebx
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?GetFireScreamMaxAttackCountSameSerial@CSkillAdditionInfo@@QAEHXZ ENDP ; CSkillAdditionInfo::GetFireScreamMaxAttackCountSameSerial
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?GetFireScreamSerialInitCount@CSkillAdditionInfo@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFireScreamSerialInitCount@CSkillAdditionInfo@@QAEHXZ PROC ; CSkillAdditionInfo::GetFireScreamSerialInitCount, COMDAT
; _this$ = ecx

; 55   : 	int GetFireScreamSerialInitCount(){return this->m_iFireScreamSerialInitCount;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 40 2c	 mov	 eax, DWORD PTR [eax+44]
  00012	5f		 pop	 edi
  00013	5e		 pop	 esi
  00014	5b		 pop	 ebx
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?GetFireScreamSerialInitCount@CSkillAdditionInfo@@QAEHXZ ENDP ; CSkillAdditionInfo::GetFireScreamSerialInitCount
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?GetCheckFireScreamSkill@CSkillAdditionInfo@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCheckFireScreamSkill@CSkillAdditionInfo@@QAEHXZ PROC ; CSkillAdditionInfo::GetCheckFireScreamSkill, COMDAT
; _this$ = ecx

; 57   : 	BOOL GetCheckFireScreamSkill(){return this->m_bCheckFireScreamSerial;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 40 30	 mov	 eax, DWORD PTR [eax+48]
  00012	5f		 pop	 edi
  00013	5e		 pop	 esi
  00014	5b		 pop	 ebx
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?GetCheckFireScreamSkill@CSkillAdditionInfo@@QAEHXZ ENDP ; CSkillAdditionInfo::GetCheckFireScreamSkill
_TEXT	ENDS
EXTRN	_atexit:PROC
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\multiattackhackcheck.cpp
;	COMDAT ??__EgMultiAttackHackCheck@@YAXXZ
text$yc	SEGMENT
??__EgMultiAttackHackCheck@@YAXXZ PROC			; `dynamic initializer for 'gMultiAttackHackCheck'', COMDAT

; 8    : CMultiAttackHackCheck gMultiAttackHackCheck[OBJMAX];

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	68 00 00 00 00	 push	 OFFSET ??1CMultiAttackHackCheck@@UAE@XZ ; CMultiAttackHackCheck::~CMultiAttackHackCheck
  0000e	68 00 00 00 00	 push	 OFFSET ??0CMultiAttackHackCheck@@QAE@XZ ; CMultiAttackHackCheck::CMultiAttackHackCheck
  00013	68 98 3a 00 00	 push	 15000			; 00003a98H
  00018	68 58 28 00 00	 push	 10328			; 00002858H
  0001d	68 00 00 00 00	 push	 OFFSET ?gMultiAttackHackCheck@@3PAVCMultiAttackHackCheck@@A ; gMultiAttackHackCheck
  00022	e8 00 00 00 00	 call	 ??_L@YGXPAXIHP6EX0@Z1@Z
  00027	68 00 00 00 00	 push	 OFFSET ??__FgMultiAttackHackCheck@@YAXXZ ; `dynamic atexit destructor for 'gMultiAttackHackCheck''
  0002c	e8 00 00 00 00	 call	 _atexit
  00031	83 c4 04	 add	 esp, 4
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??__EgMultiAttackHackCheck@@YAXXZ ENDP			; `dynamic initializer for 'gMultiAttackHackCheck''
text$yc	ENDS
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
; Function compile flags: /Odtp /ZI
;	COMDAT ??__FgMultiAttackHackCheck@@YAXXZ
text$yd	SEGMENT
??__FgMultiAttackHackCheck@@YAXXZ PROC			; `dynamic atexit destructor for 'gMultiAttackHackCheck'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	68 00 00 00 00	 push	 OFFSET ??1CMultiAttackHackCheck@@UAE@XZ ; CMultiAttackHackCheck::~CMultiAttackHackCheck
  0000e	68 98 3a 00 00	 push	 15000			; 00003a98H
  00013	68 58 28 00 00	 push	 10328			; 00002858H
  00018	68 00 00 00 00	 push	 OFFSET ?gMultiAttackHackCheck@@3PAVCMultiAttackHackCheck@@A ; gMultiAttackHackCheck
  0001d	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??__FgMultiAttackHackCheck@@YAXXZ ENDP			; `dynamic atexit destructor for 'gMultiAttackHackCheck''
text$yd	ENDS
PUBLIC	?gMultiAttackHackCheck@@3PAVCMultiAttackHackCheck@@A ; gMultiAttackHackCheck
_BSS	SEGMENT
?gMultiAttackHackCheck@@3PAVCMultiAttackHackCheck@@A DB 093be440H DUP (?) ; gMultiAttackHackCheck
_BSS	ENDS
CRT$XCU	SEGMENT
_gMultiAttackHackCheck$initializer$ DD FLAT:??__EgMultiAttackHackCheck@@YAXXZ
CRT$XCU	ENDS
END
