; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	D:\Projects\ExTeam6.3\Source\GameServer\GameServer\RingAttackEvent.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
_g_RingEventMapNum DD 00H
	DD	02H
	DD	03H
_g_RingMapPosition DD 042H
	DD	02cH
	DD	0bfH
	DD	0c5H
	DD	06fH
	DD	0eH
	DD	0e8H
	DD	07dH
	DD	088H
	DD	035H
	DD	0dfH
	DD	0b5H
?s_iTIME_REMAIN@?7??ProcState_Playing@CRingAttackEvent@@QAEXXZ@4HA DD 0ffffffffH ; `CRingAttackEvent::ProcState_Playing'::`8'::s_iTIME_REMAIN
_g_RingMapDestPosition DD 085H
	DD	04fH
	DD	057H
	DD	07eH
	DD	085H
	DD	0b2H
	DD	0b4H
	DD	07eH
	DD	0a4H
	DD	02aH
	DD	0ddH
	DD	055H
	DD	0a4H
	DD	02aH
	DD	0ddH
	DD	055H
	DD	0a0H
	DD	02dH
	DD	0a0H
	DD	02dH
	DD	098H
	DD	075H
	DD	0d1H
	DD	085H
_DATA	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Odtp /ZI
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@vector:
  00009	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000c	83 e8 01	 sub	 eax, 1
  0000f	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00012	78 11		 js	 SHORT $LN3@vector
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00017	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  0001d	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00020	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00023	eb e4		 jmp	 SHORT $LN2@vector
$LN3@vector:
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??_7CRingMonsterHerd@@6B@			; CRingMonsterHerd::`vftable'
PUBLIC	??0CRingMonsterHerd@@QAE@XZ			; CRingMonsterHerd::CRingMonsterHerd
PUBLIC	??_R4CRingMonsterHerd@@6B@			; CRingMonsterHerd::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCRingMonsterHerd@@@8			; CRingMonsterHerd `RTTI Type Descriptor'
PUBLIC	??_R3CRingMonsterHerd@@8			; CRingMonsterHerd::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CRingMonsterHerd@@8			; CRingMonsterHerd::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CRingMonsterHerd@@8		; CRingMonsterHerd::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@MonsterHerd@@8			; MonsterHerd::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVMonsterHerd@@@8				; MonsterHerd `RTTI Type Descriptor'
PUBLIC	??_R3MonsterHerd@@8				; MonsterHerd::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2MonsterHerd@@8				; MonsterHerd::`RTTI Base Class Array'
PUBLIC	?Start@CRingMonsterHerd@@UAEHXZ			; CRingMonsterHerd::Start
PUBLIC	?MonsterHerdItemDrop@CRingMonsterHerd@@UAEHPAUOBJECTSTRUCT@@@Z ; CRingMonsterHerd::MonsterHerdItemDrop
PUBLIC	?MonsterAttackAction@CRingMonsterHerd@@UAEXPAUOBJECTSTRUCT@@0@Z ; CRingMonsterHerd::MonsterAttackAction
EXTRN	??0MonsterHerd@@QAE@XZ:PROC			; MonsterHerd::MonsterHerd
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ECRingMonsterHerd@@UAEPAXI@Z:PROC		; CRingMonsterHerd::`vector deleting destructor'
EXTRN	?SetTotalInfo@MonsterHerd@@UAEHHHHH@Z:PROC	; MonsterHerd::SetTotalInfo
EXTRN	?AddMonster@MonsterHerd@@UAEHHHH@Z:PROC		; MonsterHerd::AddMonster
EXTRN	?SetRadius@MonsterHerd@@UAEXH@Z:PROC		; MonsterHerd::SetRadius
EXTRN	?SetPosition@MonsterHerd@@UAEXEE@Z:PROC		; MonsterHerd::SetPosition
EXTRN	?Stop@MonsterHerd@@UAEXXZ:PROC			; MonsterHerd::Stop
EXTRN	?CheckInRadius@MonsterHerd@@UAEHH@Z:PROC	; MonsterHerd::CheckInRadius
EXTRN	?GetCurrentLocation@MonsterHerd@@UAEHAAE0@Z:PROC ; MonsterHerd::GetCurrentLocation
EXTRN	?GetRandomLocation@MonsterHerd@@UAEHAAE0@Z:PROC	; MonsterHerd::GetRandomLocation
EXTRN	?CheckLocation@MonsterHerd@@UAEHAAE0@Z:PROC	; MonsterHerd::CheckLocation
EXTRN	?MoveHerd@MonsterHerd@@UAEHEE@Z:PROC		; MonsterHerd::MoveHerd
EXTRN	?GetMonsterData@MonsterHerd@@UAEPAU_MONSTER_HERD_DATA@@H@Z:PROC ; MonsterHerd::GetMonsterData
EXTRN	?BeenAttacked@MonsterHerd@@UAEXPAUOBJECTSTRUCT@@0@Z:PROC ; MonsterHerd::BeenAttacked
EXTRN	?OrderAttack@MonsterHerd@@UAEXPAUOBJECTSTRUCT@@0H@Z:PROC ; MonsterHerd::OrderAttack
EXTRN	?MonsterBaseAct@MonsterHerd@@UAEXPAUOBJECTSTRUCT@@@Z:PROC ; MonsterHerd::MonsterBaseAct
EXTRN	?MonsterMoveAction@MonsterHerd@@UAEXPAUOBJECTSTRUCT@@@Z:PROC ; MonsterHerd::MonsterMoveAction
EXTRN	?MonsterDieAction@MonsterHerd@@UAEXPAUOBJECTSTRUCT@@@Z:PROC ; MonsterHerd::MonsterDieAction
EXTRN	?MonsterRegenAction@MonsterHerd@@UAEHPAUOBJECTSTRUCT@@@Z:PROC ; MonsterHerd::MonsterRegenAction
;	COMDAT ??_R2MonsterHerd@@8
; File d:\projects\exteam6.3\source\gameserver\gameserver\ringattackevent.cpp
rdata$r	SEGMENT
??_R2MonsterHerd@@8 DD FLAT:??_R1A@?0A@EA@MonsterHerd@@8 ; MonsterHerd::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3MonsterHerd@@8
rdata$r	SEGMENT
??_R3MonsterHerd@@8 DD 00H				; MonsterHerd::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2MonsterHerd@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMonsterHerd@@@8
_DATA	SEGMENT
??_R0?AVMonsterHerd@@@8 DD FLAT:??_7type_info@@6B@	; MonsterHerd `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMonsterHerd@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@MonsterHerd@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MonsterHerd@@8 DD FLAT:??_R0?AVMonsterHerd@@@8 ; MonsterHerd::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MonsterHerd@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CRingMonsterHerd@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CRingMonsterHerd@@8 DD FLAT:??_R0?AVCRingMonsterHerd@@@8 ; CRingMonsterHerd::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CRingMonsterHerd@@8
rdata$r	ENDS
;	COMDAT ??_R2CRingMonsterHerd@@8
rdata$r	SEGMENT
??_R2CRingMonsterHerd@@8 DD FLAT:??_R1A@?0A@EA@CRingMonsterHerd@@8 ; CRingMonsterHerd::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@MonsterHerd@@8
rdata$r	ENDS
;	COMDAT ??_R3CRingMonsterHerd@@8
rdata$r	SEGMENT
??_R3CRingMonsterHerd@@8 DD 00H				; CRingMonsterHerd::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CRingMonsterHerd@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCRingMonsterHerd@@@8
_DATA	SEGMENT
??_R0?AVCRingMonsterHerd@@@8 DD FLAT:??_7type_info@@6B@	; CRingMonsterHerd `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCRingMonsterHerd@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CRingMonsterHerd@@6B@
rdata$r	SEGMENT
??_R4CRingMonsterHerd@@6B@ DD 00H			; CRingMonsterHerd::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCRingMonsterHerd@@@8
	DD	FLAT:??_R3CRingMonsterHerd@@8
rdata$r	ENDS
;	COMDAT ??_7CRingMonsterHerd@@6B@
CONST	SEGMENT
??_7CRingMonsterHerd@@6B@ DD FLAT:??_R4CRingMonsterHerd@@6B@ ; CRingMonsterHerd::`vftable'
	DD	FLAT:??_ECRingMonsterHerd@@UAEPAXI@Z
	DD	FLAT:?SetTotalInfo@MonsterHerd@@UAEHHHHH@Z
	DD	FLAT:?AddMonster@MonsterHerd@@UAEHHHH@Z
	DD	FLAT:?SetRadius@MonsterHerd@@UAEXH@Z
	DD	FLAT:?SetPosition@MonsterHerd@@UAEXEE@Z
	DD	FLAT:?Start@CRingMonsterHerd@@UAEHXZ
	DD	FLAT:?Stop@MonsterHerd@@UAEXXZ
	DD	FLAT:?CheckInRadius@MonsterHerd@@UAEHH@Z
	DD	FLAT:?GetCurrentLocation@MonsterHerd@@UAEHAAE0@Z
	DD	FLAT:?GetRandomLocation@MonsterHerd@@UAEHAAE0@Z
	DD	FLAT:?CheckLocation@MonsterHerd@@UAEHAAE0@Z
	DD	FLAT:?MoveHerd@MonsterHerd@@UAEHEE@Z
	DD	FLAT:?MonsterHerdItemDrop@CRingMonsterHerd@@UAEHPAUOBJECTSTRUCT@@@Z
	DD	FLAT:?GetMonsterData@MonsterHerd@@UAEPAU_MONSTER_HERD_DATA@@H@Z
	DD	FLAT:?BeenAttacked@MonsterHerd@@UAEXPAUOBJECTSTRUCT@@0@Z
	DD	FLAT:?OrderAttack@MonsterHerd@@UAEXPAUOBJECTSTRUCT@@0H@Z
	DD	FLAT:?MonsterBaseAct@MonsterHerd@@UAEXPAUOBJECTSTRUCT@@@Z
	DD	FLAT:?MonsterMoveAction@MonsterHerd@@UAEXPAUOBJECTSTRUCT@@@Z
	DD	FLAT:?MonsterAttackAction@CRingMonsterHerd@@UAEXPAUOBJECTSTRUCT@@0@Z
	DD	FLAT:?MonsterDieAction@MonsterHerd@@UAEXPAUOBJECTSTRUCT@@@Z
	DD	FLAT:?MonsterRegenAction@MonsterHerd@@UAEHPAUOBJECTSTRUCT@@@Z
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CRingMonsterHerd@@QAE@XZ PROC			; CRingMonsterHerd::CRingMonsterHerd
; _this$ = ecx

; 15   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0MonsterHerd@@QAE@XZ	; MonsterHerd::MonsterHerd
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CRingMonsterHerd@@6B@

; 16   : 	return;
; 17   : }

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??0CRingMonsterHerd@@QAE@XZ ENDP			; CRingMonsterHerd::CRingMonsterHerd
_TEXT	ENDS
PUBLIC	??1CRingMonsterHerd@@UAE@XZ			; CRingMonsterHerd::~CRingMonsterHerd
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp /ZI
;	COMDAT ??_GCRingMonsterHerd@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCRingMonsterHerd@@UAEPAXI@Z PROC			; CRingMonsterHerd::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1CRingMonsterHerd@@UAE@XZ ; CRingMonsterHerd::~CRingMonsterHerd
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_GCRingMonsterHerd@@UAEPAXI@Z ENDP			; CRingMonsterHerd::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	??1MonsterHerd@@UAE@XZ:PROC			; MonsterHerd::~MonsterHerd
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CRingMonsterHerd@@UAE@XZ PROC			; CRingMonsterHerd::~CRingMonsterHerd
; _this$ = ecx

; 20   : {

  00030	55		 push	 ebp
  00031	8b ec		 mov	 ebp, esp
  00033	83 ec 44	 sub	 esp, 68			; 00000044H
  00036	53		 push	 ebx
  00037	56		 push	 esi
  00038	57		 push	 edi
  00039	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0003c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CRingMonsterHerd@@6B@

; 21   : 	return;
; 22   : }

  00045	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ??1MonsterHerd@@UAE@XZ	; MonsterHerd::~MonsterHerd
  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5b		 pop	 ebx
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
??1CRingMonsterHerd@@UAE@XZ ENDP			; CRingMonsterHerd::~CRingMonsterHerd
_TEXT	ENDS
EXTRN	?Start@MonsterHerd@@UAEHXZ:PROC			; MonsterHerd::Start
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Start@CRingMonsterHerd@@UAEHXZ PROC			; CRingMonsterHerd::Start
; _this$ = ecx

; 25   : {

  00060	55		 push	 ebp
  00061	8b ec		 mov	 ebp, esp
  00063	83 ec 44	 sub	 esp, 68			; 00000044H
  00066	53		 push	 ebx
  00067	56		 push	 esi
  00068	57		 push	 edi
  00069	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 26   : 	this->m_bEventSuccess = FALSE;

  0006c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006f	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [eax+72], 0

; 27   : 	return this->MonsterHerd::Start();

  00076	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00079	e8 00 00 00 00	 call	 ?Start@MonsterHerd@@UAEHXZ ; MonsterHerd::Start

; 28   : }

  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
?Start@CRingMonsterHerd@@UAEHXZ ENDP			; CRingMonsterHerd::Start
_TEXT	ENDS
PUBLIC	?SendEventGiftWinner@CRingMonsterHerd@@QAEXHH@Z	; CRingMonsterHerd::SendEventGiftWinner
PUBLIC	??_C@_0DL@ELDBHEBB@?$FLRing?5Event?$FN?5White?5Wizard?5Killed@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?MoneyItemDrop@MapClass@@QAEHHHH@Z:PROC		; MapClass::MoneyItemDrop
EXTRN	?MapC@@3PAVMapClass@@A:BYTE			; MapC
EXTRN	?g_iRingOrcKillGiftRate@@3HA:DWORD		; g_iRingOrcKillGiftRate
EXTRN	_rand:PROC
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?AllSendServerMsg@@YAXPAD@Z:PROC		; AllSendServerMsg
EXTRN	__imp__wsprintfA:PROC
EXTRN	?Get@CMsg@@QAEPADH@Z:PROC			; CMsg::Get
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?gMapName@@3PAY0PP@DA:BYTE			; gMapName
EXTRN	?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z:PROC	; ItemSerialCreateSend
EXTRN	?ItemGetNumberMake@@YAHHH@Z:PROC		; ItemGetNumberMake
EXTRN	?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z:PROC ; gObjMonsterTopHitDamageUser
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_0DL@ELDBHEBB@?$FLRing?5Event?$FN?5White?5Wizard?5Killed@
CONST	SEGMENT
??_C@_0DL@ELDBHEBB@?$FLRing?5Event?$FN?5White?5Wizard?5Killed@ DB '[Ring '
	DB	'Event] White Wizard Killed by [%s][%s], MapNumber:%d', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_iIndex$230574 = -284					; size = 4
_itemnumber$230570 = -280				; size = 4
_iIndex$230569 = -276					; size = 4
_szTemp$230564 = -272					; size = 256
_itemnumber$230561 = -16				; size = 4
_iIndex$230560 = -12					; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?MonsterHerdItemDrop@CRingMonsterHerd@@UAEHPAUOBJECTSTRUCT@@@Z PROC ; CRingMonsterHerd::MonsterHerdItemDrop
; _this$ = ecx

; 32   : {

  00090	55		 push	 ebp
  00091	8b ec		 mov	 ebp, esp
  00093	81 ec 5c 01 00
	00		 sub	 esp, 348		; 0000015cH
  00099	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0009e	33 c5		 xor	 eax, ebp
  000a0	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  000a3	53		 push	 ebx
  000a4	56		 push	 esi
  000a5	57		 push	 edi
  000a6	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 33   : 	if ( lpObj->Class == 135 )

  000a9	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ac	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  000b3	81 f9 87 00 00
	00		 cmp	 ecx, 135		; 00000087H
  000b9	0f 85 14 01 00
	00		 jne	 $LN5@MonsterHer

; 34   : 	{
; 35   : 		int iIndex = gObjMonsterTopHitDamageUser(lpObj);

  000bf	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000c2	50		 push	 eax
  000c3	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  000c8	83 c4 04	 add	 esp, 4
  000cb	89 45 f4	 mov	 DWORD PTR _iIndex$230560[ebp], eax

; 36   : 		int itemnumber = ItemGetNumberMake(14, 13);

  000ce	6a 0d		 push	 13			; 0000000dH
  000d0	6a 0e		 push	 14			; 0000000eH
  000d2	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  000d7	83 c4 08	 add	 esp, 8
  000da	89 45 f0	 mov	 DWORD PTR _itemnumber$230561[ebp], eax

; 37   : 
; 38   : 		ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)lpObj->X, (BYTE)lpObj->Y, itemnumber, 0, 0, 0, 0, 0, iIndex, 0, 0);

  000dd	6a 00		 push	 0
  000df	6a 00		 push	 0
  000e1	8b 45 f4	 mov	 eax, DWORD PTR _iIndex$230560[ebp]
  000e4	50		 push	 eax
  000e5	6a 00		 push	 0
  000e7	6a 00		 push	 0
  000e9	6a 00		 push	 0
  000eb	6a 00		 push	 0
  000ed	6a 00		 push	 0
  000ef	8b 4d f0	 mov	 ecx, DWORD PTR _itemnumber$230561[ebp]
  000f2	51		 push	 ecx
  000f3	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000f6	0f b6 82 46 01
	00 00		 movzx	 eax, BYTE PTR [edx+326]
  000fd	50		 push	 eax
  000fe	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00101	0f b6 91 44 01
	00 00		 movzx	 edx, BYTE PTR [ecx+324]
  00108	52		 push	 edx
  00109	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0010c	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  00113	51		 push	 ecx
  00114	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00117	8b 02		 mov	 eax, DWORD PTR [edx]
  00119	50		 push	 eax
  0011a	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  0011f	83 c4 34	 add	 esp, 52			; 00000034H

; 39   : 
; 40   : 		char szTemp[256];
; 41   : 		wsprintf(szTemp, lMsg.Get(MSGGET(4, 181)), gObj[iIndex].Name, gMapName[lpObj->MapNumber]);

  00122	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00125	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  0012c	69 c9 ff 00 00
	00		 imul	 ecx, 255		; 000000ffH
  00132	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?gMapName@@3PAY0PP@DA ; gMapName
  00138	51		 push	 ecx
  00139	8b 55 f4	 mov	 edx, DWORD PTR _iIndex$230560[ebp]
  0013c	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  00142	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00147	8d 4c 10 77	 lea	 ecx, DWORD PTR [eax+edx+119]
  0014b	51		 push	 ecx
  0014c	68 b5 04 00 00	 push	 1205			; 000004b5H
  00151	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00156	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0015b	50		 push	 eax
  0015c	8d 95 f0 fe ff
	ff		 lea	 edx, DWORD PTR _szTemp$230564[ebp]
  00162	52		 push	 edx
  00163	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00169	83 c4 10	 add	 esp, 16			; 00000010H

; 42   : 
; 43   : 		AllSendServerMsg( szTemp );

  0016c	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$230564[ebp]
  00172	50		 push	 eax
  00173	e8 00 00 00 00	 call	 ?AllSendServerMsg@@YAXPAD@Z ; AllSendServerMsg
  00178	83 c4 04	 add	 esp, 4

; 44   : 
; 45   : 		LogAddTD("[Ring Event] White Wizard Killed by [%s][%s], MapNumber:%d", gObj[iIndex].AccountID, gObj[iIndex].Name, gObj[iIndex].MapNumber);

  0017b	8b 45 f4	 mov	 eax, DWORD PTR _iIndex$230560[ebp]
  0017e	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00184	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0018a	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  00192	52		 push	 edx
  00193	8b 45 f4	 mov	 eax, DWORD PTR _iIndex$230560[ebp]
  00196	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0019c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001a2	8d 54 01 77	 lea	 edx, DWORD PTR [ecx+eax+119]
  001a6	52		 push	 edx
  001a7	8b 45 f4	 mov	 eax, DWORD PTR _iIndex$230560[ebp]
  001aa	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  001b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001b6	8d 54 01 6c	 lea	 edx, DWORD PTR [ecx+eax+108]
  001ba	52		 push	 edx
  001bb	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@ELDBHEBB@?$FLRing?5Event?$FN?5White?5Wizard?5Killed@
  001c0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001c6	83 c4 10	 add	 esp, 16			; 00000010H

; 46   : 		return TRUE;

  001c9	b8 01 00 00 00	 mov	 eax, 1
  001ce	e9 29 01 00 00	 jmp	 $LN6@MonsterHer
$LN5@MonsterHer:

; 47   : 	}
; 48   : 	
; 49   : 	if ( lpObj->Class == 136 || lpObj->Class == 137)

  001d3	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001d6	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  001dd	81 f9 88 00 00
	00		 cmp	 ecx, 136		; 00000088H
  001e3	74 16		 je	 SHORT $LN3@MonsterHer
  001e5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001e8	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  001ef	81 f9 89 00 00
	00		 cmp	 ecx, 137		; 00000089H
  001f5	0f 85 ff 00 00
	00		 jne	 $LN4@MonsterHer
$LN3@MonsterHer:

; 50   : 	{
; 51   : 		if ( (rand()%100) < 30 )

  001fb	e8 00 00 00 00	 call	 _rand
  00200	99		 cdq
  00201	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00206	f7 f9		 idiv	 ecx
  00208	83 fa 1e	 cmp	 edx, 30			; 0000001eH
  0020b	7d 76		 jge	 SHORT $LN2@MonsterHer

; 52   : 		{
; 53   : 			int iIndex = gObjMonsterTopHitDamageUser(lpObj);

  0020d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00210	50		 push	 eax
  00211	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  00216	83 c4 04	 add	 esp, 4
  00219	89 85 ec fe ff
	ff		 mov	 DWORD PTR _iIndex$230569[ebp], eax

; 54   : 			int itemnumber = ItemGetNumberMake(13, 20);

  0021f	6a 14		 push	 20			; 00000014H
  00221	6a 0d		 push	 13			; 0000000dH
  00223	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00228	83 c4 08	 add	 esp, 8
  0022b	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _itemnumber$230570[ebp], eax

; 55   : 			ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)lpObj->X, (BYTE)lpObj->Y, itemnumber, 0, 30, 0, 0, 0, iIndex, 0, 0);

  00231	6a 00		 push	 0
  00233	6a 00		 push	 0
  00235	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _iIndex$230569[ebp]
  0023b	50		 push	 eax
  0023c	6a 00		 push	 0
  0023e	6a 00		 push	 0
  00240	6a 00		 push	 0
  00242	6a 1e		 push	 30			; 0000001eH
  00244	6a 00		 push	 0
  00246	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _itemnumber$230570[ebp]
  0024c	51		 push	 ecx
  0024d	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00250	0f b6 82 46 01
	00 00		 movzx	 eax, BYTE PTR [edx+326]
  00257	50		 push	 eax
  00258	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0025b	0f b6 91 44 01
	00 00		 movzx	 edx, BYTE PTR [ecx+324]
  00262	52		 push	 edx
  00263	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00266	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  0026d	51		 push	 ecx
  0026e	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00271	8b 02		 mov	 eax, DWORD PTR [edx]
  00273	50		 push	 eax
  00274	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  00279	83 c4 34	 add	 esp, 52			; 00000034H

; 56   : 			return TRUE;

  0027c	b8 01 00 00 00	 mov	 eax, 1
  00281	eb 79		 jmp	 SHORT $LN6@MonsterHer
$LN2@MonsterHer:

; 57   : 		}
; 58   : 
; 59   : 		if ( (rand() % g_iRingOrcKillGiftRate) == 0 )

  00283	e8 00 00 00 00	 call	 _rand
  00288	99		 cdq
  00289	f7 3d 00 00 00
	00		 idiv	 DWORD PTR ?g_iRingOrcKillGiftRate@@3HA ; g_iRingOrcKillGiftRate
  0028f	85 d2		 test	 edx, edx
  00291	75 2a		 jne	 SHORT $LN1@MonsterHer

; 60   : 		{
; 61   : 			int iIndex = gObjMonsterTopHitDamageUser(lpObj);

  00293	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00296	50		 push	 eax
  00297	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  0029c	83 c4 04	 add	 esp, 4
  0029f	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _iIndex$230574[ebp], eax

; 62   : 			this->SendEventGiftWinner(iIndex, 1);

  002a5	6a 01		 push	 1
  002a7	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _iIndex$230574[ebp]
  002ad	50		 push	 eax
  002ae	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  002b1	e8 00 00 00 00	 call	 ?SendEventGiftWinner@CRingMonsterHerd@@QAEXHH@Z ; CRingMonsterHerd::SendEventGiftWinner

; 63   : 			return TRUE;

  002b6	b8 01 00 00 00	 mov	 eax, 1
  002bb	eb 3f		 jmp	 SHORT $LN6@MonsterHer
$LN1@MonsterHer:

; 64   : 		}
; 65   : 
; 66   : 		MapC[lpObj->MapNumber].MoneyItemDrop(10000, (BYTE)lpObj->X, (BYTE)lpObj->Y);

  002bd	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002c0	0f b6 88 46 01
	00 00		 movzx	 ecx, BYTE PTR [eax+326]
  002c7	51		 push	 ecx
  002c8	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002cb	0f b6 82 44 01
	00 00		 movzx	 eax, BYTE PTR [edx+324]
  002d2	50		 push	 eax
  002d3	68 10 27 00 00	 push	 10000			; 00002710H
  002d8	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002db	0f b6 89 49 01
	00 00		 movzx	 ecx, BYTE PTR [ecx+329]
  002e2	69 c9 b8 3d 05
	00		 imul	 ecx, 343480		; 00053db8H
  002e8	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  002ee	e8 00 00 00 00	 call	 ?MoneyItemDrop@MapClass@@QAEHHHH@Z ; MapClass::MoneyItemDrop

; 67   : 		return TRUE;

  002f3	b8 01 00 00 00	 mov	 eax, 1
  002f8	eb 02		 jmp	 SHORT $LN6@MonsterHer
$LN4@MonsterHer:

; 68   : 	}
; 69   : 
; 70   : 	return FALSE;

  002fa	33 c0		 xor	 eax, eax
$LN6@MonsterHer:

; 71   : 
; 72   : }

  002fc	5f		 pop	 edi
  002fd	5e		 pop	 esi
  002fe	5b		 pop	 ebx
  002ff	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00302	33 cd		 xor	 ecx, ebp
  00304	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00309	8b e5		 mov	 esp, ebp
  0030b	5d		 pop	 ebp
  0030c	c2 04 00	 ret	 4
?MonsterHerdItemDrop@CRingMonsterHerd@@UAEHPAUOBJECTSTRUCT@@@Z ENDP ; CRingMonsterHerd::MonsterHerdItemDrop
_TEXT	ENDS
EXTRN	?gObjSearchActiveEffect@@YAEPAUOBJECTSTRUCT@@H@Z:PROC ; gObjSearchActiveEffect
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
?MonsterAttackAction@CRingMonsterHerd@@UAEXPAUOBJECTSTRUCT@@0@Z PROC ; CRingMonsterHerd::MonsterAttackAction
; _this$ = ecx

; 76   : {

  00310	55		 push	 ebp
  00311	8b ec		 mov	 ebp, esp
  00313	83 ec 44	 sub	 esp, 68			; 00000044H
  00316	53		 push	 ebx
  00317	56		 push	 esi
  00318	57		 push	 edi
  00319	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 77   : 	if(gObjSearchActiveEffect(lpObj, AT_ICE_ARROW) == 1)

  0031c	6a 39		 push	 57			; 00000039H
  0031e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00321	50		 push	 eax
  00322	e8 00 00 00 00	 call	 ?gObjSearchActiveEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjSearchActiveEffect
  00327	83 c4 08	 add	 esp, 8
  0032a	0f b6 c8	 movzx	 ecx, al
  0032d	83 f9 01	 cmp	 ecx, 1
  00330	75 05		 jne	 SHORT $LN9@MonsterAtt

; 78   : 	{
; 79   : 		return;

  00332	e9 8b 00 00 00	 jmp	 $LN10@MonsterAtt
$LN9@MonsterAtt:

; 80   : 	}
; 81   : 
; 82   : 	if(gObjSearchActiveEffect(lpObj, AT_STUN) == 1)

  00337	6a 3d		 push	 61			; 0000003dH
  00339	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0033c	50		 push	 eax
  0033d	e8 00 00 00 00	 call	 ?gObjSearchActiveEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjSearchActiveEffect
  00342	83 c4 08	 add	 esp, 8
  00345	0f b6 c8	 movzx	 ecx, al
  00348	83 f9 01	 cmp	 ecx, 1
  0034b	75 02		 jne	 SHORT $LN8@MonsterAtt

; 83   : 	{
; 84   : 		return;

  0034d	eb 73		 jmp	 SHORT $LN10@MonsterAtt
$LN8@MonsterAtt:

; 85   : 	}
; 86   : 
; 87   : 	if(gObjSearchActiveEffect(lpObj, AT_SLEEP) == 1)

  0034f	6a 48		 push	 72			; 00000048H
  00351	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00354	50		 push	 eax
  00355	e8 00 00 00 00	 call	 ?gObjSearchActiveEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjSearchActiveEffect
  0035a	83 c4 08	 add	 esp, 8
  0035d	0f b6 c8	 movzx	 ecx, al
  00360	83 f9 01	 cmp	 ecx, 1
  00363	75 02		 jne	 SHORT $LN7@MonsterAtt

; 88   : 	{
; 89   : 		return;

  00365	eb 5b		 jmp	 SHORT $LN10@MonsterAtt
$LN7@MonsterAtt:

; 90   : 	}
; 91   : 
; 92   : 	if ( lpObj == NULL )

  00367	83 7d 08 00	 cmp	 DWORD PTR _lpObj$[ebp], 0
  0036b	75 02		 jne	 SHORT $LN6@MonsterAtt

; 93   : 	{
; 94   : 		return;

  0036d	eb 53		 jmp	 SHORT $LN10@MonsterAtt
$LN6@MonsterAtt:

; 95   : 	}
; 96   : 
; 97   : 	if ( lpTargetObj == NULL )

  0036f	83 7d 0c 00	 cmp	 DWORD PTR _lpTargetObj$[ebp], 0
  00373	75 02		 jne	 SHORT $LN5@MonsterAtt

; 98   : 	{
; 99   : 		return;

  00375	eb 4b		 jmp	 SHORT $LN10@MonsterAtt
$LN5@MonsterAtt:

; 100  : 	}
; 101  : 
; 102  : 	if ( lpObj->Connected < PLAYER_PLAYING || lpObj->Type != OBJ_MONSTER )

  00377	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0037a	83 78 04 03	 cmp	 DWORD PTR [eax+4], 3
  0037e	7c 0c		 jl	 SHORT $LN3@MonsterAtt
  00380	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00383	0f b7 48 68	 movzx	 ecx, WORD PTR [eax+104]
  00387	83 f9 02	 cmp	 ecx, 2
  0038a	74 02		 je	 SHORT $LN4@MonsterAtt
$LN3@MonsterAtt:

; 103  : 	{
; 104  : 		return;

  0038c	eb 34		 jmp	 SHORT $LN10@MonsterAtt
$LN4@MonsterAtt:

; 105  : 	}
; 106  : 
; 107  : 	if ( lpTargetObj->Connected < PLAYER_PLAYING )

  0038e	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00391	83 78 04 03	 cmp	 DWORD PTR [eax+4], 3
  00395	7d 02		 jge	 SHORT $LN2@MonsterAtt

; 108  : 	{
; 109  : 		return;

  00397	eb 29		 jmp	 SHORT $LN10@MonsterAtt
$LN2@MonsterAtt:

; 110  : 	}
; 111  : 
; 112  : 	if ( lpObj->Class == 135 )

  00399	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0039c	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  003a3	81 f9 87 00 00
	00		 cmp	 ecx, 135		; 00000087H
  003a9	75 17		 jne	 SHORT $LN10@MonsterAtt

; 113  : 	{
; 114  : 		this->OrderAttack(lpObj, lpTargetObj, 90 );

  003ab	6a 5a		 push	 90			; 0000005aH
  003ad	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  003b0	50		 push	 eax
  003b1	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  003b4	51		 push	 ecx
  003b5	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  003b8	8b 02		 mov	 eax, DWORD PTR [edx]
  003ba	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003bd	8b 50 3c	 mov	 edx, DWORD PTR [eax+60]
  003c0	ff d2		 call	 edx
$LN10@MonsterAtt:

; 115  : 	}
; 116  : }

  003c2	5f		 pop	 edi
  003c3	5e		 pop	 esi
  003c4	5b		 pop	 ebx
  003c5	8b e5		 mov	 esp, ebp
  003c7	5d		 pop	 ebp
  003c8	c2 08 00	 ret	 8
?MonsterAttackAction@CRingMonsterHerd@@UAEXPAUOBJECTSTRUCT@@0@Z ENDP ; CRingMonsterHerd::MonsterAttackAction
_TEXT	ENDS
PUBLIC	??_C@_0EA@DGMJBKOB@?$FLRing?5Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5to@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?DataSendEventChip@@YAXPADH@Z:PROC		; DataSendEventChip
EXTRN	_memcpy:PROC
EXTRN	?PHeadSetB@@YAXPAEEH@Z:PROC			; PHeadSetB
EXTRN	?gObjIsConnected@@YAHH@Z:PROC			; gObjIsConnected
;	COMDAT ??_C@_0EA@DGMJBKOB@?$FLRing?5Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5to@
CONST	SEGMENT
??_C@_0EA@DGMJBKOB@?$FLRing?5Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5to@ DB '['
	DB	'Ring Event] [%s][%s] Request to Register Gift - Gift Kind (%d'
	DB	')', 00H					; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_pMsg$ = -28						; size = 20
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iGiftKind$ = 12					; size = 4
?SendEventGiftWinner@CRingMonsterHerd@@QAEXHH@Z PROC	; CRingMonsterHerd::SendEventGiftWinner
; _this$ = ecx

; 127  : {

  003d0	55		 push	 ebp
  003d1	8b ec		 mov	 ebp, esp
  003d3	83 ec 5c	 sub	 esp, 92			; 0000005cH
  003d6	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  003db	33 c5		 xor	 eax, ebp
  003dd	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  003e0	53		 push	 ebx
  003e1	56		 push	 esi
  003e2	57		 push	 edi
  003e3	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 128  : 	if ( gObjIsConnected(iIndex) == FALSE )

  003e6	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  003e9	50		 push	 eax
  003ea	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  003ef	83 c4 04	 add	 esp, 4
  003f2	85 c0		 test	 eax, eax
  003f4	75 05		 jne	 SHORT $LN2@SendEventG

; 129  : 	{
; 130  : 		return;

  003f6	e9 c2 00 00 00	 jmp	 $LN3@SendEventG
$LN2@SendEventG:

; 131  : 	}
; 132  : 
; 133  : 	if ( gObj[iIndex].UseEventServer != FALSE )

  003fb	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  003fe	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00404	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0040a	83 bc 01 50 10
	00 00 00	 cmp	 DWORD PTR [ecx+eax+4176], 0
  00412	74 05		 je	 SHORT $LN1@SendEventG

; 134  : 	{
; 135  : 		return;

  00414	e9 a4 00 00 00	 jmp	 $LN3@SendEventG
$LN1@SendEventG:

; 136  : 	}
; 137  : 
; 138  : 	gObj[iIndex].UseEventServer = TRUE;

  00419	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0041c	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00422	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00428	c7 84 01 50 10
	00 00 01 00 00
	00		 mov	 DWORD PTR [ecx+eax+4176], 1

; 139  : 
; 140  : 	PMSG_REQ_REG_RINGGIFT pMsg;
; 141  : 
; 142  : 	PHeadSetB((LPBYTE)&pMsg, 0x10, sizeof(pMsg));

  00433	6a 14		 push	 20			; 00000014H
  00435	6a 10		 push	 16			; 00000010H
  00437	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0043a	50		 push	 eax
  0043b	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00440	83 c4 0c	 add	 esp, 12			; 0000000cH

; 143  : 	pMsg.iINDEX  = iIndex;

  00443	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00446	89 45 e8	 mov	 DWORD PTR _pMsg$[ebp+4], eax

; 144  : 	memcpy(pMsg.szUID, gObj[iIndex].AccountID, MAX_ACCOUNT_LEN);

  00449	6a 0a		 push	 10			; 0000000aH
  0044b	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0044e	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00454	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0045a	8d 54 01 6c	 lea	 edx, DWORD PTR [ecx+eax+108]
  0045e	52		 push	 edx
  0045f	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp+8]
  00462	50		 push	 eax
  00463	e8 00 00 00 00	 call	 _memcpy
  00468	83 c4 0c	 add	 esp, 12			; 0000000cH

; 145  : 	pMsg.szUID[MAX_ACCOUNT_LEN+1] = 0;

  0046b	c6 45 f7 00	 mov	 BYTE PTR _pMsg$[ebp+19], 0

; 146  : 	pMsg.btGiftKind = iGiftKind;

  0046f	8a 45 0c	 mov	 al, BYTE PTR _iGiftKind$[ebp]
  00472	88 45 f7	 mov	 BYTE PTR _pMsg$[ebp+19], al

; 147  : 
; 148  : 	DataSendEventChip((char*)&pMsg, sizeof(pMsg));

  00475	6a 14		 push	 20			; 00000014H
  00477	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0047a	50		 push	 eax
  0047b	e8 00 00 00 00	 call	 ?DataSendEventChip@@YAXPADH@Z ; DataSendEventChip
  00480	83 c4 08	 add	 esp, 8

; 149  : 
; 150  : 	LogAddTD("[Ring Event] [%s][%s] Request to Register Gift - Gift Kind (%d)",	gObj[iIndex].AccountID, gObj[iIndex].Name,  iGiftKind);

  00483	8b 45 0c	 mov	 eax, DWORD PTR _iGiftKind$[ebp]
  00486	50		 push	 eax
  00487	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0048a	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  00490	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00496	8d 44 0a 77	 lea	 eax, DWORD PTR [edx+ecx+119]
  0049a	50		 push	 eax
  0049b	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0049e	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  004a4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004aa	8d 44 0a 6c	 lea	 eax, DWORD PTR [edx+ecx+108]
  004ae	50		 push	 eax
  004af	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@DGMJBKOB@?$FLRing?5Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5to@
  004b4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  004ba	83 c4 10	 add	 esp, 16			; 00000010H
$LN3@SendEventG:

; 151  : }

  004bd	5f		 pop	 edi
  004be	5e		 pop	 esi
  004bf	5b		 pop	 ebx
  004c0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004c3	33 cd		 xor	 ecx, ebp
  004c5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004ca	8b e5		 mov	 esp, ebp
  004cc	5d		 pop	 ebp
  004cd	c2 08 00	 ret	 8
?SendEventGiftWinner@CRingMonsterHerd@@QAEXHH@Z ENDP	; CRingMonsterHerd::SendEventGiftWinner
_TEXT	ENDS
PUBLIC	??1?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE@XZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::~vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >
PUBLIC	??0?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >
PUBLIC	??0?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE@XZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >
PUBLIC	??_7CRingAttackEvent@@6B@			; CRingAttackEvent::`vftable'
PUBLIC	??0CRingAttackEvent@@QAE@XZ			; CRingAttackEvent::CRingAttackEvent
PUBLIC	??_R4CRingAttackEvent@@6B@			; CRingAttackEvent::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCRingAttackEvent@@@8			; CRingAttackEvent `RTTI Type Descriptor'
PUBLIC	??_R3CRingAttackEvent@@8			; CRingAttackEvent::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CRingAttackEvent@@8			; CRingAttackEvent::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CRingAttackEvent@@8		; CRingAttackEvent::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?Load@CRingAttackEvent@@UAEHPAD@Z		; CRingAttackEvent::Load
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	__imp__InitializeCriticalSection@4:PROC
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_ECRingAttackEvent@@UAEPAXI@Z:PROC		; CRingAttackEvent::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CRingAttackEvent@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CRingAttackEvent@@8 DD FLAT:??_R0?AVCRingAttackEvent@@@8 ; CRingAttackEvent::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CRingAttackEvent@@8
rdata$r	ENDS
;	COMDAT ??_R2CRingAttackEvent@@8
rdata$r	SEGMENT
??_R2CRingAttackEvent@@8 DD FLAT:??_R1A@?0A@EA@CRingAttackEvent@@8 ; CRingAttackEvent::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CRingAttackEvent@@8
rdata$r	SEGMENT
??_R3CRingAttackEvent@@8 DD 00H				; CRingAttackEvent::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CRingAttackEvent@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCRingAttackEvent@@@8
_DATA	SEGMENT
??_R0?AVCRingAttackEvent@@@8 DD FLAT:??_7type_info@@6B@	; CRingAttackEvent `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCRingAttackEvent@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CRingAttackEvent@@6B@
rdata$r	SEGMENT
??_R4CRingAttackEvent@@6B@ DD 00H			; CRingAttackEvent::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCRingAttackEvent@@@8
	DD	FLAT:??_R3CRingAttackEvent@@8
rdata$r	ENDS
;	COMDAT ??_7CRingAttackEvent@@6B@
CONST	SEGMENT
??_7CRingAttackEvent@@6B@ DD FLAT:??_R4CRingAttackEvent@@6B@ ; CRingAttackEvent::`vftable'
	DD	FLAT:??_ECRingAttackEvent@@UAEPAXI@Z
	DD	FLAT:?Load@CRingAttackEvent@@UAEHPAD@Z
CONST	ENDS
xdata$x	SEGMENT
__unwindtable$??0CRingAttackEvent@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CRingAttackEvent@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CRingAttackEvent@@QAE@XZ$1
__ehfuncinfo$??0CRingAttackEvent@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0CRingAttackEvent@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CRingAttackEvent@@QAE@XZ PROC			; CRingAttackEvent::CRingAttackEvent
; _this$ = ecx

; 173  : {

  004d0	55		 push	 ebp
  004d1	8b ec		 mov	 ebp, esp
  004d3	6a ff		 push	 -1
  004d5	68 00 00 00 00	 push	 __ehhandler$??0CRingAttackEvent@@QAE@XZ
  004da	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  004e0	50		 push	 eax
  004e1	83 ec 44	 sub	 esp, 68			; 00000044H
  004e4	53		 push	 ebx
  004e5	56		 push	 esi
  004e6	57		 push	 edi
  004e7	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  004ec	33 c5		 xor	 eax, ebp
  004ee	50		 push	 eax
  004ef	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  004f2	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  004f8	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  004fb	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  004fe	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CRingAttackEvent@@6B@
  00504	68 00 00 00 00	 push	 OFFSET ??1CRingMonsterHerd@@UAE@XZ ; CRingMonsterHerd::~CRingMonsterHerd
  00509	68 00 00 00 00	 push	 OFFSET ??0CRingMonsterHerd@@QAE@XZ ; CRingMonsterHerd::CRingMonsterHerd
  0050e	6a 03		 push	 3
  00510	6a 4c		 push	 76			; 0000004cH
  00512	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00515	83 c0 04	 add	 eax, 4
  00518	50		 push	 eax
  00519	e8 00 00 00 00	 call	 ??_L@YGXPAXIHP6EX0@Z1@Z
  0051e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00525	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00528	81 c1 1c 01 00
	00		 add	 ecx, 284		; 0000011cH
  0052e	e8 00 00 00 00	 call	 ??0?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE@XZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >
  00533	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00537	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0053a	81 c1 44 01 00
	00		 add	 ecx, 324		; 00000144H
  00540	e8 00 00 00 00	 call	 ??0?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >

; 174  : 	this->m_bDoEvent = FALSE;

  00545	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00548	c7 80 e8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+232], 0

; 175  : 	this->m_bHasData = FALSE;

  00552	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00555	c7 80 ec 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+236], 0

; 176  : 	this->m_iRADIUS_MIN = 3;

  0055f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00562	c7 80 14 01 00
	00 03 00 00 00	 mov	 DWORD PTR [eax+276], 3

; 177  : 	this->m_iRADIUS_MAX = 6;

  0056c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0056f	c7 80 18 01 00
	00 06 00 00 00	 mov	 DWORD PTR [eax+280], 6

; 178  : 	this->m_iMOVE_RAND_SIZE = 15;

  00579	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0057c	c7 80 10 01 00
	00 0f 00 00 00	 mov	 DWORD PTR [eax+272], 15	; 0000000fH

; 179  : 	InitializeCriticalSection(&this->m_critMonsterAddData);

  00586	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00589	05 2c 01 00 00	 add	 eax, 300		; 0000012cH
  0058e	50		 push	 eax
  0058f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4

; 180  : }

  00595	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0059c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0059f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  005a2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  005a9	59		 pop	 ecx
  005aa	5f		 pop	 edi
  005ab	5e		 pop	 esi
  005ac	5b		 pop	 ebx
  005ad	8b e5		 mov	 esp, ebp
  005af	5d		 pop	 ebp
  005b0	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0CRingAttackEvent@@QAE@XZ$0:
  00000	68 00 00 00 00	 push	 OFFSET ??1CRingMonsterHerd@@UAE@XZ ; CRingMonsterHerd::~CRingMonsterHerd
  00005	6a 03		 push	 3
  00007	6a 4c		 push	 76			; 0000004cH
  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
  00015	c3		 ret	 0
__unwindfunclet$??0CRingAttackEvent@@QAE@XZ$1:
  00016	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	81 c1 1c 01 00
	00		 add	 ecx, 284		; 0000011cH
  0001f	e9 00 00 00 00	 jmp	 ??1?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE@XZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::~vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >
__ehhandler$??0CRingAttackEvent@@QAE@XZ:
  00024	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00028	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002b	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  0002e	33 c8		 xor	 ecx, eax
  00030	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00035	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CRingAttackEvent@@QAE@XZ
  0003a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CRingAttackEvent@@QAE@XZ ENDP			; CRingAttackEvent::CRingAttackEvent
PUBLIC	??1CRingAttackEvent@@UAE@XZ			; CRingAttackEvent::~CRingAttackEvent
; Function compile flags: /Odtp /ZI
;	COMDAT ??_GCRingAttackEvent@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCRingAttackEvent@@UAEPAXI@Z PROC			; CRingAttackEvent::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1CRingAttackEvent@@UAE@XZ ; CRingAttackEvent::~CRingAttackEvent
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar@2
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar@2:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_GCRingAttackEvent@@UAEPAXI@Z ENDP			; CRingAttackEvent::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::~vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >
EXTRN	__imp__DeleteCriticalSection@4:PROC
xdata$x	SEGMENT
__unwindtable$??1CRingAttackEvent@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CRingAttackEvent@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CRingAttackEvent@@UAE@XZ$1
__ehfuncinfo$??1CRingAttackEvent@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1CRingAttackEvent@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CRingAttackEvent@@UAE@XZ PROC			; CRingAttackEvent::~CRingAttackEvent
; _this$ = ecx

; 184  : {

  005c0	55		 push	 ebp
  005c1	8b ec		 mov	 ebp, esp
  005c3	6a ff		 push	 -1
  005c5	68 00 00 00 00	 push	 __ehhandler$??1CRingAttackEvent@@UAE@XZ
  005ca	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  005d0	50		 push	 eax
  005d1	83 ec 44	 sub	 esp, 68			; 00000044H
  005d4	53		 push	 ebx
  005d5	56		 push	 esi
  005d6	57		 push	 edi
  005d7	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  005dc	33 c5		 xor	 eax, ebp
  005de	50		 push	 eax
  005df	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  005e2	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  005e8	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  005eb	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  005ee	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CRingAttackEvent@@6B@
  005f4	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 185  : 	DeleteCriticalSection(&this->m_critMonsterAddData);

  005fb	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  005fe	05 2c 01 00 00	 add	 eax, 300		; 0000012cH
  00603	50		 push	 eax
  00604	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4

; 186  : }

  0060a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0060d	81 c1 44 01 00
	00		 add	 ecx, 324		; 00000144H
  00613	e8 00 00 00 00	 call	 ??1?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::~vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >
  00618	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0061c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0061f	81 c1 1c 01 00
	00		 add	 ecx, 284		; 0000011cH
  00625	e8 00 00 00 00	 call	 ??1?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE@XZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::~vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >
  0062a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00631	68 00 00 00 00	 push	 OFFSET ??1CRingMonsterHerd@@UAE@XZ ; CRingMonsterHerd::~CRingMonsterHerd
  00636	6a 03		 push	 3
  00638	6a 4c		 push	 76			; 0000004cH
  0063a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0063d	83 c0 04	 add	 eax, 4
  00640	50		 push	 eax
  00641	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
  00646	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00649	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00650	59		 pop	 ecx
  00651	5f		 pop	 edi
  00652	5e		 pop	 esi
  00653	5b		 pop	 ebx
  00654	8b e5		 mov	 esp, ebp
  00656	5d		 pop	 ebp
  00657	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??1CRingAttackEvent@@UAE@XZ$0:
  0003f	68 00 00 00 00	 push	 OFFSET ??1CRingMonsterHerd@@UAE@XZ ; CRingMonsterHerd::~CRingMonsterHerd
  00044	6a 03		 push	 3
  00046	6a 4c		 push	 76			; 0000004cH
  00048	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	83 c0 04	 add	 eax, 4
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
  00054	c3		 ret	 0
__unwindfunclet$??1CRingAttackEvent@@UAE@XZ$1:
  00055	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	81 c1 1c 01 00
	00		 add	 ecx, 284		; 0000011cH
  0005e	e9 00 00 00 00	 jmp	 ??1?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE@XZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::~vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >
__ehhandler$??1CRingAttackEvent@@UAE@XZ:
  00063	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00067	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0006a	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  0006d	33 c8		 xor	 ecx, eax
  0006f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00074	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CRingAttackEvent@@UAE@XZ
  00079	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CRingAttackEvent@@UAE@XZ ENDP			; CRingAttackEvent::~CRingAttackEvent
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QBEAAURINGMONSTER_DATA@@XZ ; std::_Vector_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >::operator*
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >::operator!=
PUBLIC	?end@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@2@XZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::end
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >::operator++
PUBLIC	?begin@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@2@XZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::begin
PUBLIC	??_C@_0DP@FPIHCFEB@?$FLRing?5Event?$FN?5?9?5Monster?5Start?5Pos@ ; `string'
PUBLIC	??_C@_0CN@EBKICF@?$FLRing?5Event?$FN?5?9?5Error?5?3?5No?5Monste@ ; `string'
PUBLIC	?empty@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QBE_NXZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::empty
PUBLIC	?StartEvent@CRingAttackEvent@@QAEXXZ		; CRingAttackEvent::StartEvent
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
;	COMDAT ??_C@_0DP@FPIHCFEB@?$FLRing?5Event?$FN?5?9?5Monster?5Start?5Pos@
CONST	SEGMENT
??_C@_0DP@FPIHCFEB@?$FLRing?5Event?$FN?5?9?5Monster?5Start?5Pos@ DB '[Rin'
	DB	'g Event] - Monster Start Position MapNumber:%d, X:%d, Y:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@EBKICF@?$FLRing?5Event?$FN?5?9?5Error?5?3?5No?5Monste@
CONST	SEGMENT
??_C@_0CN@EBKICF@?$FLRing?5Event?$FN?5?9?5Error?5?3?5No?5Monste@ DB '[Rin'
	DB	'g Event] - Error : No Monster Data Exist', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
$T232880 = -104						; size = 4
$T232881 = -100						; size = 4
_pRMD$230805 = -32					; size = 4
_it$230782 = -28					; size = 4
_iCount$230642 = -24					; size = 4
_i$230637 = -20						; size = 4
_loc4$ = -16						; size = 4
_iRandY$ = -12						; size = 4
_iRandX$ = -8						; size = 4
_this$ = -4						; size = 4
?StartEvent@CRingAttackEvent@@QAEXXZ PROC		; CRingAttackEvent::StartEvent
; _this$ = ecx

; 190  : {

  00660	55		 push	 ebp
  00661	8b ec		 mov	 ebp, esp
  00663	83 ec 68	 sub	 esp, 104		; 00000068H
  00666	53		 push	 ebx
  00667	56		 push	 esi
  00668	57		 push	 edi
  00669	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 191  : 	int iRandX;
; 192  : 	int iRandY;
; 193  : 
; 194  : 	if ( this->m_bHasData == 0 )

  0066c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0066f	83 b8 ec 00 00
	00 00		 cmp	 DWORD PTR [eax+236], 0
  00676	75 05		 jne	 SHORT $LN17@StartEvent

; 195  : 	{
; 196  : 		return;

  00678	e9 30 02 00 00	 jmp	 $LN18@StartEvent
$LN17@StartEvent:

; 197  : 	}
; 198  : 
; 199  : 	int loc4 = 0;//Season 4.5 addon

  0067d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _loc4$[ebp], 0

; 200  : 	loc4 = rand() % 3;//Season 4.5 addon

  00684	e8 00 00 00 00	 call	 _rand
  00689	99		 cdq
  0068a	b9 03 00 00 00	 mov	 ecx, 3
  0068f	f7 f9		 idiv	 ecx
  00691	89 55 f0	 mov	 DWORD PTR _loc4$[ebp], edx

; 201  : 
; 202  : 	for ( int i=0;i<MAX_RINGMONSTER_MAP;i++)

  00694	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$230637[ebp], 0
  0069b	eb 09		 jmp	 SHORT $LN16@StartEvent
$LN15@StartEvent:
  0069d	8b 45 ec	 mov	 eax, DWORD PTR _i$230637[ebp]
  006a0	83 c0 01	 add	 eax, 1
  006a3	89 45 ec	 mov	 DWORD PTR _i$230637[ebp], eax
$LN16@StartEvent:
  006a6	83 7d ec 03	 cmp	 DWORD PTR _i$230637[ebp], 3
  006aa	0f 8d fd 01 00
	00		 jge	 $LN18@StartEvent

; 203  : 	{
; 204  : 		if(loc4 == i)//Season 4.5 addon

  006b0	8b 45 f0	 mov	 eax, DWORD PTR _loc4$[ebp]
  006b3	3b 45 ec	 cmp	 eax, DWORD PTR _i$230637[ebp]
  006b6	75 02		 jne	 SHORT $LN13@StartEvent

; 205  : 		{
; 206  : 			continue;

  006b8	eb e3		 jmp	 SHORT $LN15@StartEvent
$LN13@StartEvent:

; 207  : 		}
; 208  : 		
; 209  : 		int iCount = 1000;

  006ba	c7 45 e8 e8 03
	00 00		 mov	 DWORD PTR _iCount$230642[ebp], 1000 ; 000003e8H
$LN12@StartEvent:

; 210  : 
; 211  : 		while ( iCount-- != 0 )

  006c1	8b 45 e8	 mov	 eax, DWORD PTR _iCount$230642[ebp]
  006c4	8b 4d e8	 mov	 ecx, DWORD PTR _iCount$230642[ebp]
  006c7	83 e9 01	 sub	 ecx, 1
  006ca	89 4d e8	 mov	 DWORD PTR _iCount$230642[ebp], ecx
  006cd	85 c0		 test	 eax, eax
  006cf	0f 84 9f 00 00
	00		 je	 $LN11@StartEvent

; 212  : 		{
; 213  : 			iRandX = rand() % (g_RingMapPosition[i][2] - g_RingMapPosition[i][0]) + g_RingMapPosition[i][0];

  006d5	e8 00 00 00 00	 call	 _rand
  006da	8b 4d ec	 mov	 ecx, DWORD PTR _i$230637[ebp]
  006dd	c1 e1 04	 shl	 ecx, 4
  006e0	8b 55 ec	 mov	 edx, DWORD PTR _i$230637[ebp]
  006e3	c1 e2 04	 shl	 edx, 4
  006e6	8b 89 08 00 00
	00		 mov	 ecx, DWORD PTR _g_RingMapPosition[ecx+8]
  006ec	2b 8a 00 00 00
	00		 sub	 ecx, DWORD PTR _g_RingMapPosition[edx]
  006f2	99		 cdq
  006f3	f7 f9		 idiv	 ecx
  006f5	8b 45 ec	 mov	 eax, DWORD PTR _i$230637[ebp]
  006f8	c1 e0 04	 shl	 eax, 4
  006fb	03 90 00 00 00
	00		 add	 edx, DWORD PTR _g_RingMapPosition[eax]
  00701	89 55 f8	 mov	 DWORD PTR _iRandX$[ebp], edx

; 214  : 			iRandY = rand() % (g_RingMapPosition[i][3] - g_RingMapPosition[i][1]) + g_RingMapPosition[i][1];

  00704	e8 00 00 00 00	 call	 _rand
  00709	8b 4d ec	 mov	 ecx, DWORD PTR _i$230637[ebp]
  0070c	c1 e1 04	 shl	 ecx, 4
  0070f	8b 55 ec	 mov	 edx, DWORD PTR _i$230637[ebp]
  00712	c1 e2 04	 shl	 edx, 4
  00715	8b 89 0c 00 00
	00		 mov	 ecx, DWORD PTR _g_RingMapPosition[ecx+12]
  0071b	2b 8a 04 00 00
	00		 sub	 ecx, DWORD PTR _g_RingMapPosition[edx+4]
  00721	99		 cdq
  00722	f7 f9		 idiv	 ecx
  00724	8b 45 ec	 mov	 eax, DWORD PTR _i$230637[ebp]
  00727	c1 e0 04	 shl	 eax, 4
  0072a	03 90 04 00 00
	00		 add	 edx, DWORD PTR _g_RingMapPosition[eax+4]
  00730	89 55 f4	 mov	 DWORD PTR _iRandY$[ebp], edx

; 215  : 
; 216  : 			if ( this->m_RingMonsterHerd[i].SetTotalInfo(g_RingEventMapNum[i] , 3, iRandX, iRandY ) != FALSE )

  00733	8b 45 f4	 mov	 eax, DWORD PTR _iRandY$[ebp]
  00736	50		 push	 eax
  00737	8b 4d f8	 mov	 ecx, DWORD PTR _iRandX$[ebp]
  0073a	51		 push	 ecx
  0073b	6a 03		 push	 3
  0073d	8b 55 ec	 mov	 edx, DWORD PTR _i$230637[ebp]
  00740	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR _g_RingEventMapNum[edx*4]
  00747	50		 push	 eax
  00748	8b 4d ec	 mov	 ecx, DWORD PTR _i$230637[ebp]
  0074b	6b c9 4c	 imul	 ecx, 76			; 0000004cH
  0074e	8b 55 ec	 mov	 edx, DWORD PTR _i$230637[ebp]
  00751	6b d2 4c	 imul	 edx, 76			; 0000004cH
  00754	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00757	8d 54 10 04	 lea	 edx, DWORD PTR [eax+edx+4]
  0075b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0075e	8b 44 08 04	 mov	 eax, DWORD PTR [eax+ecx+4]
  00762	8b ca		 mov	 ecx, edx
  00764	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00767	ff d2		 call	 edx
  00769	85 c0		 test	 eax, eax
  0076b	74 02		 je	 SHORT $LN10@StartEvent

; 217  : 			{
; 218  : 				break;

  0076d	eb 05		 jmp	 SHORT $LN11@StartEvent
$LN10@StartEvent:

; 219  : 			}
; 220  : 		}

  0076f	e9 4d ff ff ff	 jmp	 $LN12@StartEvent
$LN11@StartEvent:

; 221  : 
; 222  : 		if ( iCount == 0 )

  00774	83 7d e8 00	 cmp	 DWORD PTR _iCount$230642[ebp], 0
  00778	75 02		 jne	 SHORT $LN9@StartEvent

; 223  : 		{
; 224  : 
; 225  : 		}
; 226  : 		else

  0077a	eb 49		 jmp	 SHORT $LN8@StartEvent
$LN9@StartEvent:

; 227  : 		{
; 228  : 			if ( this->m_vtMonsterAddData.empty() != false )

  0077c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0077f	81 c1 1c 01 00
	00		 add	 ecx, 284		; 0000011cH
  00785	e8 00 00 00 00	 call	 ?empty@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QBE_NXZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::empty
  0078a	0f b6 c0	 movzx	 eax, al
  0078d	85 c0		 test	 eax, eax
  0078f	74 13		 je	 SHORT $LN7@StartEvent

; 229  : 			{
; 230  : 				LogAddTD("[Ring Event] - Error : No Monster Data Exist");

  00791	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@EBKICF@?$FLRing?5Event?$FN?5?9?5Error?5?3?5No?5Monste@
  00796	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0079c	83 c4 04	 add	 esp, 4

; 231  : 				continue;

  0079f	e9 f9 fe ff ff	 jmp	 $LN15@StartEvent
$LN7@StartEvent:

; 232  : 			}
; 233  : 
; 234  : 			LogAddTD("[Ring Event] - Monster Start Position MapNumber:%d, X:%d, Y:%d", g_RingEventMapNum[i], iRandX, iRandY);

  007a4	8b 45 f4	 mov	 eax, DWORD PTR _iRandY$[ebp]
  007a7	50		 push	 eax
  007a8	8b 4d f8	 mov	 ecx, DWORD PTR _iRandX$[ebp]
  007ab	51		 push	 ecx
  007ac	8b 55 ec	 mov	 edx, DWORD PTR _i$230637[ebp]
  007af	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR _g_RingEventMapNum[edx*4]
  007b6	50		 push	 eax
  007b7	68 00 00 00 00	 push	 OFFSET ??_C@_0DP@FPIHCFEB@?$FLRing?5Event?$FN?5?9?5Monster?5Start?5Pos@
  007bc	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  007c2	83 c4 10	 add	 esp, 16			; 00000010H
$LN8@StartEvent:

; 235  : 		}
; 236  : 
; 237  : 		EnterCriticalSection(&this->m_critMonsterAddData);

  007c5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  007c8	05 2c 01 00 00	 add	 eax, 300		; 0000012cH
  007cd	50		 push	 eax
  007ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 238  : 
; 239  : 		for ( std::vector<RINGMONSTER_DATA>::iterator it = this->m_vtMonsterAddData.begin() ; it != this->m_vtMonsterAddData.end() ; it++)

  007d4	8d 45 e4	 lea	 eax, DWORD PTR _it$230782[ebp]
  007d7	50		 push	 eax
  007d8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  007db	81 c1 1c 01 00
	00		 add	 ecx, 284		; 0000011cH
  007e1	e8 00 00 00 00	 call	 ?begin@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@2@XZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::begin
  007e6	eb 0e		 jmp	 SHORT $LN6@StartEvent
$LN5@StartEvent:
  007e8	6a 00		 push	 0
  007ea	8d 45 98	 lea	 eax, DWORD PTR $T232880[ebp]
  007ed	50		 push	 eax
  007ee	8d 4d e4	 lea	 ecx, DWORD PTR _it$230782[ebp]
  007f1	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >::operator++
$LN6@StartEvent:
  007f6	8d 45 9c	 lea	 eax, DWORD PTR $T232881[ebp]
  007f9	50		 push	 eax
  007fa	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  007fd	81 c1 1c 01 00
	00		 add	 ecx, 284		; 0000011cH
  00803	e8 00 00 00 00	 call	 ?end@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@2@XZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::end
  00808	50		 push	 eax
  00809	8d 4d e4	 lea	 ecx, DWORD PTR _it$230782[ebp]
  0080c	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >::operator!=
  00811	0f b6 c8	 movzx	 ecx, al
  00814	85 c9		 test	 ecx, ecx
  00816	74 62		 je	 SHORT $LN4@StartEvent

; 240  : 		{
; 241  : 			RINGMONSTER_DATA & pRMD = *it;

  00818	8d 4d e4	 lea	 ecx, DWORD PTR _it$230782[ebp]
  0081b	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QBEAAURINGMONSTER_DATA@@XZ ; std::_Vector_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >::operator*
  00820	89 45 e0	 mov	 DWORD PTR _pRMD$230805[ebp], eax

; 242  : 			iCount = 100;

  00823	c7 45 e8 64 00
	00 00		 mov	 DWORD PTR _iCount$230642[ebp], 100 ; 00000064H
$LN3@StartEvent:

; 243  : 
; 244  : 			while ( iCount-- != 0 )

  0082a	8b 45 e8	 mov	 eax, DWORD PTR _iCount$230642[ebp]
  0082d	8b 4d e8	 mov	 ecx, DWORD PTR _iCount$230642[ebp]
  00830	83 e9 01	 sub	 ecx, 1
  00833	89 4d e8	 mov	 DWORD PTR _iCount$230642[ebp], ecx
  00836	85 c0		 test	 eax, eax
  00838	74 3b		 je	 SHORT $LN2@StartEvent

; 245  : 			{
; 246  : 				if ( this->m_RingMonsterHerd[i].AddMonster(pRMD.m_iType, pRMD.m_bDoRegen, pRMD.m_bDoAttackFirst) != FALSE )

  0083a	8b 45 e0	 mov	 eax, DWORD PTR _pRMD$230805[ebp]
  0083d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00840	51		 push	 ecx
  00841	8b 55 e0	 mov	 edx, DWORD PTR _pRMD$230805[ebp]
  00844	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00847	50		 push	 eax
  00848	8b 4d e0	 mov	 ecx, DWORD PTR _pRMD$230805[ebp]
  0084b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0084d	52		 push	 edx
  0084e	8b 45 ec	 mov	 eax, DWORD PTR _i$230637[ebp]
  00851	6b c0 4c	 imul	 eax, 76			; 0000004cH
  00854	8b 4d ec	 mov	 ecx, DWORD PTR _i$230637[ebp]
  00857	6b c9 4c	 imul	 ecx, 76			; 0000004cH
  0085a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0085d	8d 4c 0a 04	 lea	 ecx, DWORD PTR [edx+ecx+4]
  00861	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00864	8b 44 02 04	 mov	 eax, DWORD PTR [edx+eax+4]
  00868	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0086b	ff d2		 call	 edx
  0086d	85 c0		 test	 eax, eax
  0086f	74 02		 je	 SHORT $LN1@StartEvent

; 247  : 				{
; 248  : 					break;

  00871	eb 02		 jmp	 SHORT $LN2@StartEvent
$LN1@StartEvent:

; 249  : 				}
; 250  : 			}

  00873	eb b5		 jmp	 SHORT $LN3@StartEvent
$LN2@StartEvent:

; 251  : 		}

  00875	e9 6e ff ff ff	 jmp	 $LN5@StartEvent
$LN4@StartEvent:

; 252  : 
; 253  : 		LeaveCriticalSection(&this->m_critMonsterAddData);

  0087a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0087d	05 2c 01 00 00	 add	 eax, 300		; 0000012cH
  00882	50		 push	 eax
  00883	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 254  : 		this->m_RingMonsterHerd[i].Start();

  00889	8b 45 ec	 mov	 eax, DWORD PTR _i$230637[ebp]
  0088c	6b c0 4c	 imul	 eax, 76			; 0000004cH
  0088f	8b 4d ec	 mov	 ecx, DWORD PTR _i$230637[ebp]
  00892	6b c9 4c	 imul	 ecx, 76			; 0000004cH
  00895	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00898	8d 4c 0a 04	 lea	 ecx, DWORD PTR [edx+ecx+4]
  0089c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0089f	8b 44 02 04	 mov	 eax, DWORD PTR [edx+eax+4]
  008a3	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  008a6	ff d2		 call	 edx

; 255  : 	}

  008a8	e9 f0 fd ff ff	 jmp	 $LN15@StartEvent
$LN18@StartEvent:

; 256  : }

  008ad	5f		 pop	 edi
  008ae	5e		 pop	 esi
  008af	5b		 pop	 ebx
  008b0	8b e5		 mov	 esp, ebp
  008b2	5d		 pop	 ebp
  008b3	c3		 ret	 0
?StartEvent@CRingAttackEvent@@QAEXXZ ENDP		; CRingAttackEvent::StartEvent
_TEXT	ENDS
PUBLIC	?StopEvent@CRingAttackEvent@@QAEXXZ		; CRingAttackEvent::StopEvent
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_i$230813 = -8						; size = 4
_this$ = -4						; size = 4
?StopEvent@CRingAttackEvent@@QAEXXZ PROC		; CRingAttackEvent::StopEvent
; _this$ = ecx

; 259  : {

  008c0	55		 push	 ebp
  008c1	8b ec		 mov	 ebp, esp
  008c3	83 ec 48	 sub	 esp, 72			; 00000048H
  008c6	53		 push	 ebx
  008c7	56		 push	 esi
  008c8	57		 push	 edi
  008c9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 260  : 	for ( int i=0;i<MAX_RINGMONSTER_MAP;i++)

  008cc	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$230813[ebp], 0
  008d3	eb 09		 jmp	 SHORT $LN3@StopEvent
$LN2@StopEvent:
  008d5	8b 45 f8	 mov	 eax, DWORD PTR _i$230813[ebp]
  008d8	83 c0 01	 add	 eax, 1
  008db	89 45 f8	 mov	 DWORD PTR _i$230813[ebp], eax
$LN3@StopEvent:
  008de	83 7d f8 03	 cmp	 DWORD PTR _i$230813[ebp], 3
  008e2	7d 21		 jge	 SHORT $LN1@StopEvent

; 261  : 	{
; 262  : 		this->m_RingMonsterHerd[i].Stop();

  008e4	8b 45 f8	 mov	 eax, DWORD PTR _i$230813[ebp]
  008e7	6b c0 4c	 imul	 eax, 76			; 0000004cH
  008ea	8b 4d f8	 mov	 ecx, DWORD PTR _i$230813[ebp]
  008ed	6b c9 4c	 imul	 ecx, 76			; 0000004cH
  008f0	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  008f3	8d 4c 0a 04	 lea	 ecx, DWORD PTR [edx+ecx+4]
  008f7	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  008fa	8b 44 02 04	 mov	 eax, DWORD PTR [edx+eax+4]
  008fe	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  00901	ff d2		 call	 edx

; 263  : 	}

  00903	eb d0		 jmp	 SHORT $LN2@StopEvent
$LN1@StopEvent:

; 264  : 
; 265  : 	this->m_bMonsterToDest = FALSE;

  00905	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00908	c7 80 f0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+240], 0

; 266  : }

  00912	5f		 pop	 edi
  00913	5e		 pop	 esi
  00914	5b		 pop	 ebx
  00915	8b e5		 mov	 esp, ebp
  00917	5d		 pop	 ebp
  00918	c3		 ret	 0
?StopEvent@CRingAttackEvent@@QAEXXZ ENDP		; CRingAttackEvent::StopEvent
_TEXT	ENDS
PUBLIC	?SetState@CRingAttackEvent@@QAEXH@Z		; CRingAttackEvent::SetState
PUBLIC	?EnableEvent@CRingAttackEvent@@QAEXH@Z		; CRingAttackEvent::EnableEvent
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bDoEvent$ = 8						; size = 4
?EnableEvent@CRingAttackEvent@@QAEXH@Z PROC		; CRingAttackEvent::EnableEvent
; _this$ = ecx

; 269  : {

  00920	55		 push	 ebp
  00921	8b ec		 mov	 ebp, esp
  00923	83 ec 44	 sub	 esp, 68			; 00000044H
  00926	53		 push	 ebx
  00927	56		 push	 esi
  00928	57		 push	 edi
  00929	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 270  : 	this->m_bDoEvent = bDoEvent;

  0092c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0092f	8b 4d 08	 mov	 ecx, DWORD PTR _bDoEvent$[ebp]
  00932	89 88 e8 00 00
	00		 mov	 DWORD PTR [eax+232], ecx

; 271  : 
; 272  : 	if ( this->m_bDoEvent )

  00938	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0093b	83 b8 e8 00 00
	00 00		 cmp	 DWORD PTR [eax+232], 0
  00942	74 0c		 je	 SHORT $LN2@EnableEven

; 273  : 	{
; 274  : 		this->SetState(1);

  00944	6a 01		 push	 1
  00946	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00949	e8 00 00 00 00	 call	 ?SetState@CRingAttackEvent@@QAEXH@Z ; CRingAttackEvent::SetState

; 275  : 	}
; 276  : 	else

  0094e	eb 0a		 jmp	 SHORT $LN3@EnableEven
$LN2@EnableEven:

; 277  : 	{
; 278  : 		this->SetState(0);

  00950	6a 00		 push	 0
  00952	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00955	e8 00 00 00 00	 call	 ?SetState@CRingAttackEvent@@QAEXH@Z ; CRingAttackEvent::SetState
$LN3@EnableEven:

; 279  : 	}
; 280  : }

  0095a	5f		 pop	 edi
  0095b	5e		 pop	 esi
  0095c	5b		 pop	 ebx
  0095d	8b e5		 mov	 esp, ebp
  0095f	5d		 pop	 ebp
  00960	c2 04 00	 ret	 4
?EnableEvent@CRingAttackEvent@@QAEXH@Z ENDP		; CRingAttackEvent::EnableEvent
_TEXT	ENDS
PUBLIC	??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@	; `string'
PUBLIC	?push_back@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAEXABURINGMONSTER_EVENT_TIME@@@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::push_back
PUBLIC	?push_back@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAEXABURINGMONSTER_DATA@@@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::push_back
PUBLIC	__real@0000000000000000
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	?erase@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@0@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::erase
PUBLIC	?begin@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@XZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::begin
PUBLIC	?end@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@XZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::end
PUBLIC	?erase@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@2@0@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::erase
PUBLIC	??_C@_0CG@OKIEPGH@?$FLRing?5Event?$FN?5Info?5file?5Load?5Fail@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	__$ArrayPad$
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	_fclose:PROC
EXTRN	_strcmp:PROC
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	_fopen:PROC
EXTRN	__fltused:DWORD
EXTRN	__ftol2_sse:PROC
_BSS	SEGMENT
_TokenString DB	064H DUP (?)
_TokenNumber DD	01H DUP (?)
_SMDFile DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@
CONST	SEGMENT
??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@ DB '%s file load!', 00H ; `string'
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@OKIEPGH@?$FLRing?5Event?$FN?5Info?5file?5Load?5Fail@
CONST	SEGMENT
??_C@_0CG@OKIEPGH@?$FLRing?5Event?$FN?5Info?5file?5Load?5Fail@ DB '[Ring '
	DB	'Event] Info file Load Fail [%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv201 = -141						; size = 1
tv196 = -141						; size = 1
$T232886 = -140						; size = 4
$T232887 = -136						; size = 4
$T232888 = -132						; size = 4
$T232889 = -128						; size = 4
$T232890 = -124						; size = 4
$T232891 = -120						; size = 4
$T232892 = -116						; size = 4
$T232893 = -112						; size = 4
$T232894 = -108						; size = 4
$T232895 = -104						; size = 4
_pRET$230998 = -36					; size = 8
_pRMD$230991 = -28					; size = 12
_type$ = -16						; size = 4
_Token$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpszFileName$ = 8					; size = 4
?Load@CRingAttackEvent@@UAEHPAD@Z PROC			; CRingAttackEvent::Load
; _this$ = ecx

; 283  : {

  00970	55		 push	 ebp
  00971	8b ec		 mov	 ebp, esp
  00973	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H
  00979	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0097e	33 c5		 xor	 eax, ebp
  00980	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00983	53		 push	 ebx
  00984	56		 push	 esi
  00985	57		 push	 edi
  00986	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 284  : 	SMDFile = fopen(lpszFileName, "r");

  00989	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  0098e	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  00991	50		 push	 eax
  00992	e8 00 00 00 00	 call	 _fopen
  00997	83 c4 08	 add	 esp, 8
  0099a	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax

; 285  : 
; 286  : 	if ( SMDFile == NULL )

  0099f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SMDFile, 0
  009a6	75 18		 jne	 SHORT $LN17@Load

; 287  : 	{
; 288  : 		MsgBox("[Ring Event] Info file Load Fail [%s]", lpszFileName);

  009a8	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  009ab	50		 push	 eax
  009ac	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@OKIEPGH@?$FLRing?5Event?$FN?5Info?5file?5Load?5Fail@
  009b1	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  009b6	83 c4 08	 add	 esp, 8

; 289  : 		return FALSE;

  009b9	33 c0		 xor	 eax, eax
  009bb	e9 6b 03 00 00	 jmp	 $LN18@Load
$LN17@Load:

; 290  : 	}
; 291  : 
; 292  : 	EnterCriticalSection(&this->m_critMonsterAddData);

  009c0	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  009c3	05 2c 01 00 00	 add	 eax, 300		; 0000012cH
  009c8	50		 push	 eax
  009c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 293  : 	this->m_vtMonsterAddData.erase( this->m_vtMonsterAddData.begin(), this->m_vtMonsterAddData.end() );

  009cf	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR $T232887[ebp]
  009d5	50		 push	 eax
  009d6	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  009d9	81 c1 1c 01 00
	00		 add	 ecx, 284		; 0000011cH
  009df	e8 00 00 00 00	 call	 ?end@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@2@XZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::end
  009e4	8b 08		 mov	 ecx, DWORD PTR [eax]
  009e6	89 8d 74 ff ff
	ff		 mov	 DWORD PTR $T232886[ebp], ecx
  009ec	8d 55 80	 lea	 edx, DWORD PTR $T232889[ebp]
  009ef	52		 push	 edx
  009f0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  009f3	81 c1 1c 01 00
	00		 add	 ecx, 284		; 0000011cH
  009f9	e8 00 00 00 00	 call	 ?begin@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@2@XZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::begin
  009fe	8b 00		 mov	 eax, DWORD PTR [eax]
  00a00	89 85 7c ff ff
	ff		 mov	 DWORD PTR $T232888[ebp], eax
  00a06	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR $T232886[ebp]
  00a0c	51		 push	 ecx
  00a0d	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR $T232888[ebp]
  00a13	52		 push	 edx
  00a14	8d 45 84	 lea	 eax, DWORD PTR $T232890[ebp]
  00a17	50		 push	 eax
  00a18	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00a1b	81 c1 1c 01 00
	00		 add	 ecx, 284		; 0000011cH
  00a21	e8 00 00 00 00	 call	 ?erase@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@2@0@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::erase

; 294  : 	LeaveCriticalSection(&this->m_critMonsterAddData);

  00a26	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00a29	05 2c 01 00 00	 add	 eax, 300		; 0000012cH
  00a2e	50		 push	 eax
  00a2f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 295  : 
; 296  : 	this->m_vtEventTime.erase( this->m_vtEventTime.begin(), this->m_vtEventTime.end() );

  00a35	8d 45 8c	 lea	 eax, DWORD PTR $T232892[ebp]
  00a38	50		 push	 eax
  00a39	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00a3c	81 c1 44 01 00
	00		 add	 ecx, 324		; 00000144H
  00a42	e8 00 00 00 00	 call	 ?end@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@XZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::end
  00a47	8b 08		 mov	 ecx, DWORD PTR [eax]
  00a49	89 4d 88	 mov	 DWORD PTR $T232891[ebp], ecx
  00a4c	8d 55 94	 lea	 edx, DWORD PTR $T232894[ebp]
  00a4f	52		 push	 edx
  00a50	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00a53	81 c1 44 01 00
	00		 add	 ecx, 324		; 00000144H
  00a59	e8 00 00 00 00	 call	 ?begin@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@XZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::begin
  00a5e	8b 00		 mov	 eax, DWORD PTR [eax]
  00a60	89 45 90	 mov	 DWORD PTR $T232893[ebp], eax
  00a63	8b 4d 88	 mov	 ecx, DWORD PTR $T232891[ebp]
  00a66	51		 push	 ecx
  00a67	8b 55 90	 mov	 edx, DWORD PTR $T232893[ebp]
  00a6a	52		 push	 edx
  00a6b	8d 45 98	 lea	 eax, DWORD PTR $T232895[ebp]
  00a6e	50		 push	 eax
  00a6f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00a72	81 c1 44 01 00
	00		 add	 ecx, 324		; 00000144H
  00a78	e8 00 00 00 00	 call	 ?erase@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@0@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::erase

; 297  : 
; 298  : 	this->m_bHasData = FALSE;

  00a7d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00a80	c7 80 ec 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+236], 0

; 299  : 
; 300  : 	int Token;
; 301  : 	int type = -1;

  00a8a	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _type$[ebp], -1
$LN16@Load:

; 302  : 
; 303  : 	while ( true )

  00a91	b8 01 00 00 00	 mov	 eax, 1
  00a96	85 c0		 test	 eax, eax
  00a98	0f 84 5b 02 00
	00		 je	 $LN15@Load

; 304  : 	{
; 305  : 		Token = GetToken();

  00a9e	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00aa3	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 306  : 
; 307  : 		if ( Token == 2 )

  00aa6	83 7d f4 02	 cmp	 DWORD PTR _Token$[ebp], 2
  00aaa	75 05		 jne	 SHORT $LN14@Load

; 308  : 		{
; 309  : 			break;

  00aac	e9 48 02 00 00	 jmp	 $LN15@Load
$LN14@Load:

; 310  : 		}
; 311  : 
; 312  : 		type = (int)TokenNumber;

  00ab1	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00ab7	e8 00 00 00 00	 call	 __ftol2_sse
  00abc	89 45 f0	 mov	 DWORD PTR _type$[ebp], eax
$LN13@Load:

; 313  : 
; 314  : 		while ( true )

  00abf	b8 01 00 00 00	 mov	 eax, 1
  00ac4	85 c0		 test	 eax, eax
  00ac6	0f 84 28 02 00
	00		 je	 $LN12@Load

; 315  : 		{
; 316  : 			if ( type == 0 )

  00acc	83 7d f0 00	 cmp	 DWORD PTR _type$[ebp], 0
  00ad0	75 74		 jne	 SHORT $LN11@Load

; 317  : 			{
; 318  : 				Token = GetToken();

  00ad2	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00ad7	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 319  : 
; 320  : 				if ( strcmp("end", TokenString) == 0 )

  00ada	68 00 00 00 00	 push	 OFFSET _TokenString
  00adf	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  00ae4	e8 00 00 00 00	 call	 _strcmp
  00ae9	83 c4 08	 add	 esp, 8
  00aec	85 c0		 test	 eax, eax
  00aee	75 05		 jne	 SHORT $LN10@Load

; 321  : 				{
; 322  : 					break;

  00af0	e9 ff 01 00 00	 jmp	 $LN12@Load
$LN10@Load:

; 323  : 				}
; 324  : 
; 325  : 				this->m_iTIME_MIN_OPEN = (int)TokenNumber;

  00af5	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00afb	e8 00 00 00 00	 call	 __ftol2_sse
  00b00	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00b03	89 81 f8 00 00
	00		 mov	 DWORD PTR [ecx+248], eax

; 326  : 
; 327  : 				Token = GetToken();

  00b09	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00b0e	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 328  : 				this->m_iTIME_MIN_PLAY = (int)TokenNumber;

  00b11	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00b17	e8 00 00 00 00	 call	 __ftol2_sse
  00b1c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00b1f	89 81 fc 00 00
	00		 mov	 DWORD PTR [ecx+252], eax

; 329  : 
; 330  : 				Token = GetToken();

  00b25	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00b2a	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 331  : 				this->m_iTIME_MONSTER_TO_DEST = (int)TokenNumber;

  00b2d	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00b33	e8 00 00 00 00	 call	 __ftol2_sse
  00b38	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00b3b	89 81 00 01 00
	00		 mov	 DWORD PTR [ecx+256], eax
  00b41	e9 a9 01 00 00	 jmp	 $LN2@Load
$LN11@Load:

; 332  : 			}
; 333  : 			else if ( type == 1 )

  00b46	83 7d f0 01	 cmp	 DWORD PTR _type$[ebp], 1
  00b4a	75 74		 jne	 SHORT $LN8@Load

; 334  : 			{
; 335  : 				Token = GetToken();

  00b4c	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00b51	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 336  : 
; 337  : 				if ( strcmp("end", TokenString) == 0 )

  00b54	68 00 00 00 00	 push	 OFFSET _TokenString
  00b59	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  00b5e	e8 00 00 00 00	 call	 _strcmp
  00b63	83 c4 08	 add	 esp, 8
  00b66	85 c0		 test	 eax, eax
  00b68	75 05		 jne	 SHORT $LN7@Load

; 338  : 				{
; 339  : 					break;

  00b6a	e9 85 01 00 00	 jmp	 $LN12@Load
$LN7@Load:

; 340  : 				}
; 341  : 
; 342  : 				this->m_iMOVE_RAND_SIZE = (int)TokenNumber;

  00b6f	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00b75	e8 00 00 00 00	 call	 __ftol2_sse
  00b7a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00b7d	89 81 10 01 00
	00		 mov	 DWORD PTR [ecx+272], eax

; 343  : 
; 344  : 				Token = GetToken();

  00b83	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00b88	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 345  : 				this->m_iRADIUS_MIN = (int)TokenNumber;

  00b8b	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00b91	e8 00 00 00 00	 call	 __ftol2_sse
  00b96	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00b99	89 81 14 01 00
	00		 mov	 DWORD PTR [ecx+276], eax

; 346  : 
; 347  : 				Token = GetToken();

  00b9f	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00ba4	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 348  : 				this->m_iRADIUS_MAX = (int)TokenNumber;

  00ba7	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00bad	e8 00 00 00 00	 call	 __ftol2_sse
  00bb2	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00bb5	89 81 18 01 00
	00		 mov	 DWORD PTR [ecx+280], eax
  00bbb	e9 2f 01 00 00	 jmp	 $LN2@Load
$LN8@Load:

; 349  : 			}
; 350  : 			else if ( type == 2 )

  00bc0	83 7d f0 02	 cmp	 DWORD PTR _type$[ebp], 2
  00bc4	0f 85 c9 00 00
	00		 jne	 $LN5@Load

; 351  : 			{
; 352  : 				Token = GetToken();

  00bca	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00bcf	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 353  : 
; 354  : 				if ( strcmp("end", TokenString) == 0 )

  00bd2	68 00 00 00 00	 push	 OFFSET _TokenString
  00bd7	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  00bdc	e8 00 00 00 00	 call	 _strcmp
  00be1	83 c4 08	 add	 esp, 8
  00be4	85 c0		 test	 eax, eax
  00be6	75 05		 jne	 SHORT $LN4@Load

; 355  : 				{
; 356  : 					break;

  00be8	e9 07 01 00 00	 jmp	 $LN12@Load
$LN4@Load:

; 357  : 				}
; 358  : 
; 359  : 				RINGMONSTER_DATA pRMD;
; 360  : 
; 361  : 				pRMD.m_iType = (int)TokenNumber;

  00bed	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00bf3	e8 00 00 00 00	 call	 __ftol2_sse
  00bf8	89 45 e4	 mov	 DWORD PTR _pRMD$230991[ebp], eax

; 362  : 
; 363  : 				Token = GetToken();

  00bfb	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00c00	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 364  : 				pRMD.m_bDoRegen = (bool)TokenNumber;

  00c03	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00c09	d9 ee		 fldz
  00c0b	da e9		 fucompp
  00c0d	df e0		 fnstsw	 ax
  00c0f	f6 c4 44	 test	 ah, 68			; 00000044H
  00c12	7b 09		 jnp	 SHORT $LN20@Load
  00c14	c6 85 73 ff ff
	ff 01		 mov	 BYTE PTR tv196[ebp], 1
  00c1b	eb 07		 jmp	 SHORT $LN21@Load
$LN20@Load:
  00c1d	c6 85 73 ff ff
	ff 00		 mov	 BYTE PTR tv196[ebp], 0
$LN21@Load:
  00c24	0f b6 85 73 ff
	ff ff		 movzx	 eax, BYTE PTR tv196[ebp]
  00c2b	89 45 e8	 mov	 DWORD PTR _pRMD$230991[ebp+4], eax

; 365  : 
; 366  : 				Token= GetToken();

  00c2e	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00c33	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 367  : 				pRMD.m_bDoAttackFirst = (bool)TokenNumber;

  00c36	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00c3c	d9 ee		 fldz
  00c3e	da e9		 fucompp
  00c40	df e0		 fnstsw	 ax
  00c42	f6 c4 44	 test	 ah, 68			; 00000044H
  00c45	7b 09		 jnp	 SHORT $LN22@Load
  00c47	c6 85 73 ff ff
	ff 01		 mov	 BYTE PTR tv201[ebp], 1
  00c4e	eb 07		 jmp	 SHORT $LN23@Load
$LN22@Load:
  00c50	c6 85 73 ff ff
	ff 00		 mov	 BYTE PTR tv201[ebp], 0
$LN23@Load:
  00c57	0f b6 85 73 ff
	ff ff		 movzx	 eax, BYTE PTR tv201[ebp]
  00c5e	89 45 ec	 mov	 DWORD PTR _pRMD$230991[ebp+8], eax

; 368  : 
; 369  : 				EnterCriticalSection(&this->m_critMonsterAddData);

  00c61	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00c64	05 2c 01 00 00	 add	 eax, 300		; 0000012cH
  00c69	50		 push	 eax
  00c6a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 370  : 				this->m_vtMonsterAddData.push_back(pRMD);

  00c70	8d 45 e4	 lea	 eax, DWORD PTR _pRMD$230991[ebp]
  00c73	50		 push	 eax
  00c74	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00c77	81 c1 1c 01 00
	00		 add	 ecx, 284		; 0000011cH
  00c7d	e8 00 00 00 00	 call	 ?push_back@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAEXABURINGMONSTER_DATA@@@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::push_back

; 371  : 				LeaveCriticalSection(&this->m_critMonsterAddData);

  00c82	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00c85	05 2c 01 00 00	 add	 eax, 300		; 0000012cH
  00c8a	50		 push	 eax
  00c8b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00c91	eb 5c		 jmp	 SHORT $LN2@Load
$LN5@Load:

; 372  : 			}
; 373  : 			else if ( type == 3 )

  00c93	83 7d f0 03	 cmp	 DWORD PTR _type$[ebp], 3
  00c97	75 56		 jne	 SHORT $LN2@Load

; 374  : 			{
; 375  : 				Token = GetToken();

  00c99	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00c9e	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 376  : 
; 377  : 				if ( strcmp("end", TokenString) == 0 )

  00ca1	68 00 00 00 00	 push	 OFFSET _TokenString
  00ca6	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  00cab	e8 00 00 00 00	 call	 _strcmp
  00cb0	83 c4 08	 add	 esp, 8
  00cb3	85 c0		 test	 eax, eax
  00cb5	75 02		 jne	 SHORT $LN1@Load

; 378  : 				{
; 379  : 					break;

  00cb7	eb 3b		 jmp	 SHORT $LN12@Load
$LN1@Load:

; 380  : 				}
; 381  : 
; 382  : 				RINGMONSTER_EVENT_TIME pRET;
; 383  : 
; 384  : 				pRET.m_iHour = (int)TokenNumber;

  00cb9	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00cbf	e8 00 00 00 00	 call	 __ftol2_sse
  00cc4	89 45 dc	 mov	 DWORD PTR _pRET$230998[ebp], eax

; 385  : 
; 386  : 				Token = GetToken();

  00cc7	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00ccc	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 387  : 				pRET.m_iMinute = (int)TokenNumber;

  00ccf	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00cd5	e8 00 00 00 00	 call	 __ftol2_sse
  00cda	89 45 e0	 mov	 DWORD PTR _pRET$230998[ebp+4], eax

; 388  : 
; 389  : 				this->m_vtEventTime.push_back(pRET);

  00cdd	8d 45 dc	 lea	 eax, DWORD PTR _pRET$230998[ebp]
  00ce0	50		 push	 eax
  00ce1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00ce4	81 c1 44 01 00
	00		 add	 ecx, 324		; 00000144H
  00cea	e8 00 00 00 00	 call	 ?push_back@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAEXABURINGMONSTER_EVENT_TIME@@@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::push_back
$LN2@Load:

; 390  : 			}
; 391  : 		}

  00cef	e9 cb fd ff ff	 jmp	 $LN13@Load
$LN12@Load:

; 392  : 	}

  00cf4	e9 98 fd ff ff	 jmp	 $LN16@Load
$LN15@Load:

; 393  : 
; 394  : 	fclose(SMDFile);

  00cf9	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00cfe	50		 push	 eax
  00cff	e8 00 00 00 00	 call	 _fclose
  00d04	83 c4 04	 add	 esp, 4

; 395  : 	LogAdd("%s file load!", lpszFileName);

  00d07	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  00d0a	50		 push	 eax
  00d0b	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@
  00d10	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00d16	83 c4 08	 add	 esp, 8

; 396  : 	this->m_bHasData = TRUE;

  00d19	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00d1c	c7 80 ec 00 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+236], 1

; 397  : 
; 398  : 	return TRUE;

  00d26	b8 01 00 00 00	 mov	 eax, 1
$LN18@Load:

; 399  : }

  00d2b	5f		 pop	 edi
  00d2c	5e		 pop	 esi
  00d2d	5b		 pop	 ebx
  00d2e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00d31	33 cd		 xor	 ecx, ebp
  00d33	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00d38	8b e5		 mov	 esp, ebp
  00d3a	5d		 pop	 ebp
  00d3b	c2 04 00	 ret	 4
?Load@CRingAttackEvent@@UAEHPAD@Z ENDP			; CRingAttackEvent::Load
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_isalnum:PROC
EXTRN	_isalpha:PROC
EXTRN	_atof:PROC
EXTRN	_isdigit:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_isspace:PROC
EXTRN	_fgetc:PROC
_BSS	SEGMENT
_CurrentToken DD 01H DUP (?)
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\include\readscript.h
_BSS	ENDS
_TEXT	SEGMENT
tv90 = -180						; size = 4
_TempString$ = -112					; size = 100
_p$ = -12						; size = 4
_ch$ = -5						; size = 1
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken

; 24   : {

  00d40	55		 push	 ebp
  00d41	8b ec		 mov	 ebp, esp
  00d43	81 ec b4 00 00
	00		 sub	 esp, 180		; 000000b4H
  00d49	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00d4e	33 c5		 xor	 eax, ebp
  00d50	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00d53	53		 push	 ebx
  00d54	56		 push	 esi
  00d55	57		 push	 edi

; 25   : 	char ch;
; 26   : 	char* p;
; 27   : 	char TempString[100];
; 28   : 
; 29   : 	TokenString[0]=0;

  00d56	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _TokenString, 0
$LN31@GetToken:

; 30   : 
; 31   : 	do
; 32   : 	{
; 33   : 		if ((ch=fgetc(SMDFile)) == -1)

  00d5d	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00d62	50		 push	 eax
  00d63	e8 00 00 00 00	 call	 _fgetc
  00d68	83 c4 04	 add	 esp, 4
  00d6b	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00d6e	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00d72	83 f9 ff	 cmp	 ecx, -1
  00d75	75 0c		 jne	 SHORT $LN28@GetToken

; 34   : 		{
; 35   : 			return END;	// End of FILE (EOF)

  00d77	b8 02 00 00 00	 mov	 eax, 2
  00d7c	e9 f7 02 00 00	 jmp	 $LN32@GetToken

; 36   : 		}
; 37   : 		else

  00d81	eb 5b		 jmp	 SHORT $LN22@GetToken
$LN28@GetToken:

; 38   : 		{	
; 39   : 			if (ch=='/')		// this is /

  00d83	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00d87	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  00d8a	75 52		 jne	 SHORT $LN22@GetToken

; 40   : 			{
; 41   : 				if((ch=fgetc(SMDFile)) == '/')

  00d8c	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00d91	50		 push	 eax
  00d92	e8 00 00 00 00	 call	 _fgetc
  00d97	83 c4 04	 add	 esp, 4
  00d9a	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00d9d	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00da1	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  00da4	75 38		 jne	 SHORT $LN22@GetToken
$LN24@GetToken:

; 42   : 				{
; 43   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  00da6	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00daa	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00dad	74 1c		 je	 SHORT $LN23@GetToken
  00daf	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00db3	83 f8 ff	 cmp	 eax, -1
  00db6	74 13		 je	 SHORT $LN23@GetToken

; 44   : 					{
; 45   : 						ch=fgetc(SMDFile);

  00db8	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00dbd	50		 push	 eax
  00dbe	e8 00 00 00 00	 call	 _fgetc
  00dc3	83 c4 04	 add	 esp, 4
  00dc6	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al

; 46   : 					}

  00dc9	eb db		 jmp	 SHORT $LN24@GetToken
$LN23@GetToken:

; 47   : 	
; 48   : 					if (ch == -1)

  00dcb	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00dcf	83 f8 ff	 cmp	 eax, -1
  00dd2	75 0a		 jne	 SHORT $LN22@GetToken

; 49   : 					{
; 50   : 						return END;	// End of FILE

  00dd4	b8 02 00 00 00	 mov	 eax, 2
  00dd9	e9 9a 02 00 00	 jmp	 $LN32@GetToken
$LN22@GetToken:

; 51   : 					}
; 52   : 				}
; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : 	while (isspace(ch) != 0);

  00dde	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00de2	50		 push	 eax
  00de3	e8 00 00 00 00	 call	 _isspace
  00de8	83 c4 04	 add	 esp, 4
  00deb	85 c0		 test	 eax, eax
  00ded	0f 85 6a ff ff
	ff		 jne	 $LN31@GetToken

; 57   : 
; 58   : 	
; 59   : 	switch(ch)

  00df3	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00df7	89 85 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], eax
  00dfd	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR tv90[ebp]
  00e03	83 e9 22	 sub	 ecx, 34			; 00000022H
  00e06	89 8d 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], ecx
  00e0c	83 bd 4c ff ff
	ff 5b		 cmp	 DWORD PTR tv90[ebp], 91	; 0000005bH
  00e13	0f 87 a3 01 00
	00		 ja	 $LN6@GetToken
  00e19	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR tv90[ebp]
  00e1f	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN34@GetToken[edx]
  00e26	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN35@GetToken[eax*4]
$LN19@GetToken:

; 60   : 	{
; 61   : 
; 62   : 	case 0x23:	// #
; 63   : 		return CurrentToken=COMMAND;

  00e2d	c7 05 00 00 00
	00 23 00 00 00	 mov	 DWORD PTR _CurrentToken, 35 ; 00000023H
  00e37	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00e3c	e9 37 02 00 00	 jmp	 $LN32@GetToken

; 64   : 		break;

  00e41	e9 30 02 00 00	 jmp	 $LN20@GetToken
$LN18@GetToken:

; 65   : 	
; 66   : 	case 0x3B:	// ;
; 67   : 		return CurrentToken=SEMICOLON;

  00e46	c7 05 00 00 00
	00 3b 00 00 00	 mov	 DWORD PTR _CurrentToken, 59 ; 0000003bH
  00e50	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00e55	e9 1e 02 00 00	 jmp	 $LN32@GetToken

; 68   : 		break;

  00e5a	e9 17 02 00 00	 jmp	 $LN20@GetToken
$LN17@GetToken:

; 69   : 	
; 70   : 	case 0x2C:	// ,
; 71   : 
; 72   : 		return CurrentToken=COMMA;

  00e5f	c7 05 00 00 00
	00 2c 00 00 00	 mov	 DWORD PTR _CurrentToken, 44 ; 0000002cH
  00e69	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00e6e	e9 05 02 00 00	 jmp	 $LN32@GetToken

; 73   : 		break;

  00e73	e9 fe 01 00 00	 jmp	 $LN20@GetToken
$LN16@GetToken:

; 74   : 	
; 75   : 	case 0x7B:	// {
; 76   : 		return CurrentToken = LP;

  00e78	c7 05 00 00 00
	00 7b 00 00 00	 mov	 DWORD PTR _CurrentToken, 123 ; 0000007bH
  00e82	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00e87	e9 ec 01 00 00	 jmp	 $LN32@GetToken

; 77   : 		break;

  00e8c	e9 e5 01 00 00	 jmp	 $LN20@GetToken
$LN15@GetToken:

; 78   : 
; 79   : 	case 0x7D:	// }
; 80   : 		return CurrentToken = RP;

  00e91	c7 05 00 00 00
	00 7d 00 00 00	 mov	 DWORD PTR _CurrentToken, 125 ; 0000007dH
  00e9b	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00ea0	e9 d3 01 00 00	 jmp	 $LN32@GetToken

; 81   : 		break;

  00ea5	e9 cc 01 00 00	 jmp	 $LN20@GetToken
$LN14@GetToken:

; 82   : 	// Nice Index Table :)	by Deathway
; 83   : 	// Numbers Case
; 84   : 	case 0x2D:	//-
; 85   : 	case 0x2E:	//.
; 86   : 	case '0':	//0
; 87   : 	case '1':	//1
; 88   : 	case '2':	//2
; 89   : 	case '3':	//3
; 90   : 	case '4':	//4		
; 91   : 	case '5':	//5
; 92   : 	case '6':	//6
; 93   : 	case '7':	//7
; 94   : 	case '8':	//8
; 95   : 	case '9':	//9
; 96   : 		ungetc(ch, SMDFile);

  00eaa	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00eaf	50		 push	 eax
  00eb0	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00eb4	51		 push	 ecx
  00eb5	e8 00 00 00 00	 call	 _ungetc
  00eba	83 c4 08	 add	 esp, 8

; 97   : 		p = TempString;

  00ebd	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  00ec0	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN13@GetToken:

; 98   : 		
; 99   : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  00ec3	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00ec8	50		 push	 eax
  00ec9	e8 00 00 00 00	 call	 _getc
  00ece	83 c4 04	 add	 esp, 4
  00ed1	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00ed4	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00ed8	83 f9 ff	 cmp	 ecx, -1
  00edb	74 36		 je	 SHORT $LN12@GetToken
  00edd	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00ee1	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  00ee4	74 1a		 je	 SHORT $LN11@GetToken
  00ee6	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00eea	50		 push	 eax
  00eeb	e8 00 00 00 00	 call	 _isdigit
  00ef0	83 c4 04	 add	 esp, 4
  00ef3	85 c0		 test	 eax, eax
  00ef5	75 09		 jne	 SHORT $LN11@GetToken
  00ef7	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00efb	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00efe	75 13		 jne	 SHORT $LN12@GetToken
$LN11@GetToken:

; 100  : 		{
; 101  : 			*p = ch;	// Construct a String

  00f00	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00f03	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00f06	88 08		 mov	 BYTE PTR [eax], cl

; 102  : 			p++;

  00f08	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00f0b	83 c0 01	 add	 eax, 1
  00f0e	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 103  : 		}		

  00f11	eb b0		 jmp	 SHORT $LN13@GetToken
$LN12@GetToken:

; 104  : 		*p = 0;

  00f13	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00f16	c6 00 00	 mov	 BYTE PTR [eax], 0

; 105  : 		TokenNumber = atof( TempString);	// Select the first Byte as Main ID

  00f19	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  00f1c	50		 push	 eax
  00f1d	e8 00 00 00 00	 call	 _atof
  00f22	83 c4 04	 add	 esp, 4
  00f25	d9 1d 00 00 00
	00		 fstp	 DWORD PTR _TokenNumber

; 106  : 		return CurrentToken  = NUMBER ;

  00f2b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CurrentToken, 1
  00f35	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00f3a	e9 39 01 00 00	 jmp	 $LN32@GetToken

; 107  : 		break;

  00f3f	e9 32 01 00 00	 jmp	 $LN20@GetToken
$LN10@GetToken:

; 108  : 
; 109  : 	case '\"':	// "	String Case
; 110  : 		p=&TokenString[0];

  00f44	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString
$LN9@GetToken:

; 111  : 		
; 112  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  00f4b	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00f50	50		 push	 eax
  00f51	e8 00 00 00 00	 call	 _getc
  00f56	83 c4 04	 add	 esp, 4
  00f59	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00f5c	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00f60	83 f9 ff	 cmp	 ecx, -1
  00f63	74 1c		 je	 SHORT $LN8@GetToken
  00f65	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00f69	83 f8 22	 cmp	 eax, 34			; 00000022H
  00f6c	74 13		 je	 SHORT $LN8@GetToken

; 113  : 		{
; 114  : 			*p = ch;

  00f6e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00f71	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00f74	88 08		 mov	 BYTE PTR [eax], cl

; 115  : 			p++;

  00f76	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00f79	83 c0 01	 add	 eax, 1
  00f7c	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 116  : 		}

  00f7f	eb ca		 jmp	 SHORT $LN9@GetToken
$LN8@GetToken:

; 117  : 		if (ch != 0x22 )

  00f81	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00f85	83 f8 22	 cmp	 eax, 34			; 00000022H
  00f88	74 13		 je	 SHORT $LN7@GetToken

; 118  : 		{
; 119  : 			ungetc(ch, SMDFile);

  00f8a	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00f8f	50		 push	 eax
  00f90	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00f94	51		 push	 ecx
  00f95	e8 00 00 00 00	 call	 _ungetc
  00f9a	83 c4 08	 add	 esp, 8
$LN7@GetToken:

; 120  : 		}
; 121  : 		*p = 0;

  00f9d	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00fa0	c6 00 00	 mov	 BYTE PTR [eax], 0

; 122  : 		return CurrentToken = NAME;

  00fa3	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0
  00fad	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00fb2	e9 c1 00 00 00	 jmp	 $LN32@GetToken

; 123  : 		break;

  00fb7	e9 ba 00 00 00	 jmp	 $LN20@GetToken
$LN6@GetToken:

; 124  : 
; 125  : 	default:	// Others
; 126  : 		if (isalpha(ch))

  00fbc	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00fc0	50		 push	 eax
  00fc1	e8 00 00 00 00	 call	 _isalpha
  00fc6	83 c4 04	 add	 esp, 4
  00fc9	85 c0		 test	 eax, eax
  00fcb	0f 84 94 00 00
	00		 je	 $LN5@GetToken

; 127  : 		{
; 128  : 			p=&TokenString[0];

  00fd1	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString

; 129  : 			*p=ch;

  00fd8	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00fdb	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00fde	88 08		 mov	 BYTE PTR [eax], cl

; 130  : 			p++;

  00fe0	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00fe3	83 c0 01	 add	 eax, 1
  00fe6	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN4@GetToken:

; 131  : 
; 132  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  00fe9	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00fee	50		 push	 eax
  00fef	e8 00 00 00 00	 call	 _getc
  00ff4	83 c4 04	 add	 esp, 4
  00ff7	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00ffa	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00ffe	83 f9 ff	 cmp	 ecx, -1
  01001	74 36		 je	 SHORT $LN3@GetToken
  01003	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  01007	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  0100a	74 1a		 je	 SHORT $LN2@GetToken
  0100c	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  01010	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  01013	74 11		 je	 SHORT $LN2@GetToken
  01015	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  01019	50		 push	 eax
  0101a	e8 00 00 00 00	 call	 _isalnum
  0101f	83 c4 04	 add	 esp, 4
  01022	85 c0		 test	 eax, eax
  01024	74 13		 je	 SHORT $LN3@GetToken
$LN2@GetToken:

; 133  : 			{
; 134  : 				*p=ch;

  01026	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  01029	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  0102c	88 08		 mov	 BYTE PTR [eax], cl

; 135  : 				p++;

  0102e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  01031	83 c0 01	 add	 eax, 1
  01034	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 136  : 				
; 137  : 			}

  01037	eb b0		 jmp	 SHORT $LN4@GetToken
$LN3@GetToken:

; 138  : 
; 139  : 			ungetc(ch, SMDFile);

  01039	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0103e	50		 push	 eax
  0103f	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  01043	51		 push	 ecx
  01044	e8 00 00 00 00	 call	 _ungetc
  01049	83 c4 08	 add	 esp, 8

; 140  : 			*p=0;

  0104c	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0104f	c6 00 00	 mov	 BYTE PTR [eax], 0

; 141  : 			CurrentToken=NAME;

  01052	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0

; 142  : 			return CurrentToken;

  0105c	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  01061	eb 15		 jmp	 SHORT $LN32@GetToken

; 143  : 		}
; 144  : 		else

  01063	eb 11		 jmp	 SHORT $LN1@GetToken
$LN5@GetToken:

; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'

  01065	c7 05 00 00 00
	00 3c 00 00 00	 mov	 DWORD PTR _CurrentToken, 60 ; 0000003cH
  0106f	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  01074	eb 02		 jmp	 SHORT $LN32@GetToken
$LN1@GetToken:
$LN20@GetToken:

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;

  01076	33 c0		 xor	 eax, eax
$LN32@GetToken:

; 153  : }

  01078	5f		 pop	 edi
  01079	5e		 pop	 esi
  0107a	5b		 pop	 ebx
  0107b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0107e	33 cd		 xor	 ecx, ebp
  01080	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01085	8b e5		 mov	 esp, ebp
  01087	5d		 pop	 ebp
  01088	c3		 ret	 0
  01089	8d 49 00	 npad	 3
$LN35@GetToken:
  0108c	00 00 00 00	 DD	 $LN10@GetToken
  01090	00 00 00 00	 DD	 $LN19@GetToken
  01094	00 00 00 00	 DD	 $LN17@GetToken
  01098	00 00 00 00	 DD	 $LN14@GetToken
  0109c	00 00 00 00	 DD	 $LN18@GetToken
  010a0	00 00 00 00	 DD	 $LN16@GetToken
  010a4	00 00 00 00	 DD	 $LN15@GetToken
  010a8	00 00 00 00	 DD	 $LN6@GetToken
$LN34@GetToken:
  010ac	00		 DB	 0
  010ad	01		 DB	 1
  010ae	07		 DB	 7
  010af	07		 DB	 7
  010b0	07		 DB	 7
  010b1	07		 DB	 7
  010b2	07		 DB	 7
  010b3	07		 DB	 7
  010b4	07		 DB	 7
  010b5	07		 DB	 7
  010b6	02		 DB	 2
  010b7	03		 DB	 3
  010b8	03		 DB	 3
  010b9	07		 DB	 7
  010ba	03		 DB	 3
  010bb	03		 DB	 3
  010bc	03		 DB	 3
  010bd	03		 DB	 3
  010be	03		 DB	 3
  010bf	03		 DB	 3
  010c0	03		 DB	 3
  010c1	03		 DB	 3
  010c2	03		 DB	 3
  010c3	03		 DB	 3
  010c4	07		 DB	 7
  010c5	04		 DB	 4
  010c6	07		 DB	 7
  010c7	07		 DB	 7
  010c8	07		 DB	 7
  010c9	07		 DB	 7
  010ca	07		 DB	 7
  010cb	07		 DB	 7
  010cc	07		 DB	 7
  010cd	07		 DB	 7
  010ce	07		 DB	 7
  010cf	07		 DB	 7
  010d0	07		 DB	 7
  010d1	07		 DB	 7
  010d2	07		 DB	 7
  010d3	07		 DB	 7
  010d4	07		 DB	 7
  010d5	07		 DB	 7
  010d6	07		 DB	 7
  010d7	07		 DB	 7
  010d8	07		 DB	 7
  010d9	07		 DB	 7
  010da	07		 DB	 7
  010db	07		 DB	 7
  010dc	07		 DB	 7
  010dd	07		 DB	 7
  010de	07		 DB	 7
  010df	07		 DB	 7
  010e0	07		 DB	 7
  010e1	07		 DB	 7
  010e2	07		 DB	 7
  010e3	07		 DB	 7
  010e4	07		 DB	 7
  010e5	07		 DB	 7
  010e6	07		 DB	 7
  010e7	07		 DB	 7
  010e8	07		 DB	 7
  010e9	07		 DB	 7
  010ea	07		 DB	 7
  010eb	07		 DB	 7
  010ec	07		 DB	 7
  010ed	07		 DB	 7
  010ee	07		 DB	 7
  010ef	07		 DB	 7
  010f0	07		 DB	 7
  010f1	07		 DB	 7
  010f2	07		 DB	 7
  010f3	07		 DB	 7
  010f4	07		 DB	 7
  010f5	07		 DB	 7
  010f6	07		 DB	 7
  010f7	07		 DB	 7
  010f8	07		 DB	 7
  010f9	07		 DB	 7
  010fa	07		 DB	 7
  010fb	07		 DB	 7
  010fc	07		 DB	 7
  010fd	07		 DB	 7
  010fe	07		 DB	 7
  010ff	07		 DB	 7
  01100	07		 DB	 7
  01101	07		 DB	 7
  01102	07		 DB	 7
  01103	07		 DB	 7
  01104	07		 DB	 7
  01105	05		 DB	 5
  01106	07		 DB	 7
  01107	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
PUBLIC	?ProcState_Playing@CRingAttackEvent@@QAEXXZ	; CRingAttackEvent::ProcState_Playing
PUBLIC	?ProcState_Closed@CRingAttackEvent@@QAEXXZ	; CRingAttackEvent::ProcState_Closed
PUBLIC	?ProcState_None@CRingAttackEvent@@QAEXXZ	; CRingAttackEvent::ProcState_None
PUBLIC	?Run@CRingAttackEvent@@QAEXXZ			; CRingAttackEvent::Run
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\ringattackevent.cpp
_TEXT	SEGMENT
tv69 = -72						; size = 4
_this$ = -4						; size = 4
?Run@CRingAttackEvent@@QAEXXZ PROC			; CRingAttackEvent::Run
; _this$ = ecx

; 403  : {

  01110	55		 push	 ebp
  01111	8b ec		 mov	 ebp, esp
  01113	83 ec 48	 sub	 esp, 72			; 00000048H
  01116	53		 push	 ebx
  01117	56		 push	 esi
  01118	57		 push	 edi
  01119	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 404  : 	if ( this->m_bMenualStart )

  0111c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0111f	83 b8 54 01 00
	00 00		 cmp	 DWORD PTR [eax+340], 0
  01126	74 02		 je	 SHORT $LN7@Run

; 405  : 		return;

  01128	eb 48		 jmp	 SHORT $LN8@Run
$LN7@Run:

; 406  : 
; 407  : 	if ( this->m_bDoEvent )

  0112a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0112d	83 b8 e8 00 00
	00 00		 cmp	 DWORD PTR [eax+232], 0
  01134	74 3c		 je	 SHORT $LN8@Run

; 408  : 	{
; 409  : 		switch ( this->m_iEVENT_STATE )

  01136	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01139	8b 88 0c 01 00
	00		 mov	 ecx, DWORD PTR [eax+268]
  0113f	89 4d b8	 mov	 DWORD PTR tv69[ebp], ecx
  01142	83 7d b8 00	 cmp	 DWORD PTR tv69[ebp], 0
  01146	74 0e		 je	 SHORT $LN3@Run
  01148	83 7d b8 01	 cmp	 DWORD PTR tv69[ebp], 1
  0114c	74 12		 je	 SHORT $LN2@Run
  0114e	83 7d b8 02	 cmp	 DWORD PTR tv69[ebp], 2
  01152	74 16		 je	 SHORT $LN1@Run
  01154	eb 1c		 jmp	 SHORT $LN8@Run
$LN3@Run:

; 410  : 		{
; 411  : 			case 0:
; 412  : 				this->ProcState_None();

  01156	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01159	e8 00 00 00 00	 call	 ?ProcState_None@CRingAttackEvent@@QAEXXZ ; CRingAttackEvent::ProcState_None

; 413  : 				break;

  0115e	eb 12		 jmp	 SHORT $LN8@Run
$LN2@Run:

; 414  : 			case 1:
; 415  : 				this->ProcState_Closed();

  01160	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01163	e8 00 00 00 00	 call	 ?ProcState_Closed@CRingAttackEvent@@QAEXXZ ; CRingAttackEvent::ProcState_Closed

; 416  : 				break;

  01168	eb 08		 jmp	 SHORT $LN8@Run
$LN1@Run:

; 417  : 			case 2:
; 418  : 				this->ProcState_Playing();

  0116a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0116d	e8 00 00 00 00	 call	 ?ProcState_Playing@CRingAttackEvent@@QAEXXZ ; CRingAttackEvent::ProcState_Playing
$LN8@Run:

; 419  : 		}
; 420  : 	}
; 421  : }	

  01172	5f		 pop	 edi
  01173	5e		 pop	 esi
  01174	5b		 pop	 ebx
  01175	8b e5		 mov	 esp, ebp
  01177	5d		 pop	 ebp
  01178	c3		 ret	 0
?Run@CRingAttackEvent@@QAEXXZ ENDP			; CRingAttackEvent::Run
_TEXT	ENDS
PUBLIC	??_C@_0EG@KMBELKMF@?$FLRing?5Event?$FN?5Sync?5Start?5Time?4?5?$FL?$CF@ ; `string'
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEAAURINGMONSTER_EVENT_TIME@@XZ ; std::_Vector_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::operator*
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::operator!=
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::operator++
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::_Vector_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >
PUBLIC	??_C@_0CD@BNKPBCAA@?$FLRing?5Event?$FN?5No?5Schedule?5Time?5Da@ ; `string'
PUBLIC	?empty@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QBE_NXZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::empty
PUBLIC	__$ArrayPad$
PUBLIC	?CheckSync@CRingAttackEvent@@QAEXXZ		; CRingAttackEvent::CheckSync
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	__imp__GetLocalTime@4:PROC
EXTRN	?LogAddC@@3P6AXEPADZZA:DWORD			; LogAddC
;	COMDAT ??_C@_0EG@KMBELKMF@?$FLRing?5Event?$FN?5Sync?5Start?5Time?4?5?$FL?$CF@
CONST	SEGMENT
??_C@_0EG@KMBELKMF@?$FLRing?5Event?$FN?5Sync?5Start?5Time?4?5?$FL?$CF@ DB '['
	DB	'Ring Event] Sync Start Time. [%d] min remain (START HOUR:%d, '
	DB	'MIN:%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@BNKPBCAA@?$FLRing?5Event?$FN?5No?5Schedule?5Time?5Da@
CONST	SEGMENT
??_C@_0CD@BNKPBCAA@?$FLRing?5Event?$FN?5No?5Schedule?5Time?5Da@ DB '[Ring'
	DB	' Event] No Schedule Time Data', 00H		; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv184 = -140						; size = 4
$T232911 = -136						; size = 4
$T232912 = -132						; size = 4
$T232913 = -128						; size = 4
$T232914 = -124						; size = 4
$T232915 = -120						; size = 4
$T232916 = -116						; size = 4
_pRET$231060 = -48					; size = 4
_pRET$231050 = -44					; size = 4
_it$ = -40						; size = 4
_bTIME_CHANGED$ = -36					; size = 4
_iMIN_MINUTE$ = -32					; size = 4
_iMIN_HOUR$ = -28					; size = 4
_sysTime$ = -24						; size = 16
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?CheckSync@CRingAttackEvent@@QAEXXZ PROC		; CRingAttackEvent::CheckSync
; _this$ = ecx

; 424  : {

  01180	55		 push	 ebp
  01181	8b ec		 mov	 ebp, esp
  01183	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  01189	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0118e	33 c5		 xor	 eax, ebp
  01190	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  01193	53		 push	 ebx
  01194	56		 push	 esi
  01195	57		 push	 edi
  01196	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 425  : 	if ( this->m_vtEventTime.empty() != 0 )

  01199	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0119c	81 c1 44 01 00
	00		 add	 ecx, 324		; 00000144H
  011a2	e8 00 00 00 00	 call	 ?empty@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QBE_NXZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::empty
  011a7	0f b6 c0	 movzx	 eax, al
  011aa	85 c0		 test	 eax, eax
  011ac	74 1f		 je	 SHORT $LN16@CheckSync

; 426  : 	{
; 427  : 		LogAddC(2, "[Ring Event] No Schedule Time Data");

  011ae	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@BNKPBCAA@?$FLRing?5Event?$FN?5No?5Schedule?5Time?5Da@
  011b3	6a 02		 push	 2
  011b5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  011bb	83 c4 08	 add	 esp, 8

; 428  : 		this->SetState(0);

  011be	6a 00		 push	 0
  011c0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  011c3	e8 00 00 00 00	 call	 ?SetState@CRingAttackEvent@@QAEXH@Z ; CRingAttackEvent::SetState

; 429  : 
; 430  : 		return;

  011c8	e9 78 02 00 00	 jmp	 $LN17@CheckSync
$LN16@CheckSync:

; 431  : 	}
; 432  : 
; 433  : 	SYSTEMTIME sysTime;
; 434  : 	GetLocalTime(&sysTime);

  011cd	8d 45 e8	 lea	 eax, DWORD PTR _sysTime$[ebp]
  011d0	50		 push	 eax
  011d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocalTime@4

; 435  : 
; 436  : 	int iMIN_HOUR = 24;

  011d7	c7 45 e4 18 00
	00 00		 mov	 DWORD PTR _iMIN_HOUR$[ebp], 24 ; 00000018H

; 437  : 	int iMIN_MINUTE = 60;

  011de	c7 45 e0 3c 00
	00 00		 mov	 DWORD PTR _iMIN_MINUTE$[ebp], 60 ; 0000003cH

; 438  : 	BOOL bTIME_CHANGED = FALSE;

  011e5	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _bTIME_CHANGED$[ebp], 0

; 439  : 	std::vector<RINGMONSTER_EVENT_TIME>::iterator it;

  011ec	8d 4d d8	 lea	 ecx, DWORD PTR _it$[ebp]
  011ef	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::_Vector_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >

; 440  : 	for ( it = this->m_vtEventTime.begin(); it != this->m_vtEventTime.end() ; it++ )

  011f4	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR $T232911[ebp]
  011fa	50		 push	 eax
  011fb	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  011fe	81 c1 44 01 00
	00		 add	 ecx, 324		; 00000144H
  01204	e8 00 00 00 00	 call	 ?begin@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@XZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::begin
  01209	8b 08		 mov	 ecx, DWORD PTR [eax]
  0120b	89 4d d8	 mov	 DWORD PTR _it$[ebp], ecx
  0120e	eb 11		 jmp	 SHORT $LN15@CheckSync
$LN14@CheckSync:
  01210	6a 00		 push	 0
  01212	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR $T232912[ebp]
  01218	50		 push	 eax
  01219	8d 4d d8	 lea	 ecx, DWORD PTR _it$[ebp]
  0121c	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::operator++
$LN15@CheckSync:
  01221	8d 45 80	 lea	 eax, DWORD PTR $T232913[ebp]
  01224	50		 push	 eax
  01225	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01228	81 c1 44 01 00
	00		 add	 ecx, 324		; 00000144H
  0122e	e8 00 00 00 00	 call	 ?end@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@XZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::end
  01233	50		 push	 eax
  01234	8d 4d d8	 lea	 ecx, DWORD PTR _it$[ebp]
  01237	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::operator!=
  0123c	0f b6 c8	 movzx	 ecx, al
  0123f	85 c9		 test	 ecx, ecx
  01241	74 62		 je	 SHORT $LN13@CheckSync

; 441  : 	{
; 442  : 		RINGMONSTER_EVENT_TIME & pRET = *it;

  01243	8d 4d d8	 lea	 ecx, DWORD PTR _it$[ebp]
  01246	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEAAURINGMONSTER_EVENT_TIME@@XZ ; std::_Vector_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::operator*
  0124b	89 45 d4	 mov	 DWORD PTR _pRET$231050[ebp], eax

; 443  : 
; 444  : 		if ( (sysTime.wHour * 60 + sysTime.wMinute) < (pRET.m_iHour * 60 + pRET.m_iMinute ))

  0124e	0f b7 45 f0	 movzx	 eax, WORD PTR _sysTime$[ebp+8]
  01252	6b c0 3c	 imul	 eax, 60			; 0000003cH
  01255	0f b7 4d f2	 movzx	 ecx, WORD PTR _sysTime$[ebp+10]
  01259	03 c1		 add	 eax, ecx
  0125b	8b 55 d4	 mov	 edx, DWORD PTR _pRET$231050[ebp]
  0125e	8b 0a		 mov	 ecx, DWORD PTR [edx]
  01260	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  01263	8b 55 d4	 mov	 edx, DWORD PTR _pRET$231050[ebp]
  01266	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  01269	3b c1		 cmp	 eax, ecx
  0126b	7d 33		 jge	 SHORT $LN12@CheckSync

; 445  : 		{
; 446  : 			if ( (iMIN_HOUR * 60 + iMIN_MINUTE) > (pRET.m_iHour * 60 + pRET.m_iMinute) )

  0126d	8b 45 e4	 mov	 eax, DWORD PTR _iMIN_HOUR$[ebp]
  01270	6b c0 3c	 imul	 eax, 60			; 0000003cH
  01273	03 45 e0	 add	 eax, DWORD PTR _iMIN_MINUTE$[ebp]
  01276	8b 4d d4	 mov	 ecx, DWORD PTR _pRET$231050[ebp]
  01279	8b 11		 mov	 edx, DWORD PTR [ecx]
  0127b	6b d2 3c	 imul	 edx, 60			; 0000003cH
  0127e	8b 4d d4	 mov	 ecx, DWORD PTR _pRET$231050[ebp]
  01281	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  01284	3b c2		 cmp	 eax, edx
  01286	7e 18		 jle	 SHORT $LN12@CheckSync

; 447  : 			{
; 448  : 				bTIME_CHANGED = TRUE;

  01288	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _bTIME_CHANGED$[ebp], 1

; 449  : 				iMIN_HOUR = pRET.m_iHour;

  0128f	8b 45 d4	 mov	 eax, DWORD PTR _pRET$231050[ebp]
  01292	8b 08		 mov	 ecx, DWORD PTR [eax]
  01294	89 4d e4	 mov	 DWORD PTR _iMIN_HOUR$[ebp], ecx

; 450  : 				iMIN_MINUTE = pRET.m_iMinute;

  01297	8b 45 d4	 mov	 eax, DWORD PTR _pRET$231050[ebp]
  0129a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0129d	89 4d e0	 mov	 DWORD PTR _iMIN_MINUTE$[ebp], ecx
$LN12@CheckSync:

; 451  : 			}
; 452  : 		}
; 453  : 	}

  012a0	e9 6b ff ff ff	 jmp	 $LN14@CheckSync
$LN13@CheckSync:

; 454  : 
; 455  : 	if ( bTIME_CHANGED == FALSE )

  012a5	83 7d dc 00	 cmp	 DWORD PTR _bTIME_CHANGED$[ebp], 0
  012a9	0f 85 97 00 00
	00		 jne	 $LN10@CheckSync

; 456  : 	{
; 457  : 		it = this->m_vtEventTime.begin();

  012af	8d 45 84	 lea	 eax, DWORD PTR $T232914[ebp]
  012b2	50		 push	 eax
  012b3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  012b6	81 c1 44 01 00
	00		 add	 ecx, 324		; 00000144H
  012bc	e8 00 00 00 00	 call	 ?begin@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@XZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::begin
  012c1	8b 08		 mov	 ecx, DWORD PTR [eax]
  012c3	89 4d d8	 mov	 DWORD PTR _it$[ebp], ecx

; 458  : 		iMIN_HOUR = 24;

  012c6	c7 45 e4 18 00
	00 00		 mov	 DWORD PTR _iMIN_HOUR$[ebp], 24 ; 00000018H

; 459  : 		iMIN_MINUTE = 60;

  012cd	c7 45 e0 3c 00
	00 00		 mov	 DWORD PTR _iMIN_MINUTE$[ebp], 60 ; 0000003cH
  012d4	eb 0e		 jmp	 SHORT $LN9@CheckSync
$LN8@CheckSync:

; 460  : 
; 461  : 		for ( ; it != this->m_vtEventTime.end() ; it++ )

  012d6	6a 00		 push	 0
  012d8	8d 45 88	 lea	 eax, DWORD PTR $T232915[ebp]
  012db	50		 push	 eax
  012dc	8d 4d d8	 lea	 ecx, DWORD PTR _it$[ebp]
  012df	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::operator++
$LN9@CheckSync:
  012e4	8d 45 8c	 lea	 eax, DWORD PTR $T232916[ebp]
  012e7	50		 push	 eax
  012e8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  012eb	81 c1 44 01 00
	00		 add	 ecx, 324		; 00000144H
  012f1	e8 00 00 00 00	 call	 ?end@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@XZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::end
  012f6	50		 push	 eax
  012f7	8d 4d d8	 lea	 ecx, DWORD PTR _it$[ebp]
  012fa	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::operator!=
  012ff	0f b6 c8	 movzx	 ecx, al
  01302	85 c9		 test	 ecx, ecx
  01304	74 40		 je	 SHORT $LN10@CheckSync

; 462  : 		{
; 463  : 			RINGMONSTER_EVENT_TIME & pRET = *it;

  01306	8d 4d d8	 lea	 ecx, DWORD PTR _it$[ebp]
  01309	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEAAURINGMONSTER_EVENT_TIME@@XZ ; std::_Vector_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::operator*
  0130e	89 45 d0	 mov	 DWORD PTR _pRET$231060[ebp], eax

; 464  : 
; 465  : 			if ( (iMIN_HOUR * 60 + iMIN_MINUTE) > (pRET.m_iHour * 60 + pRET.m_iMinute) )

  01311	8b 45 e4	 mov	 eax, DWORD PTR _iMIN_HOUR$[ebp]
  01314	6b c0 3c	 imul	 eax, 60			; 0000003cH
  01317	03 45 e0	 add	 eax, DWORD PTR _iMIN_MINUTE$[ebp]
  0131a	8b 4d d0	 mov	 ecx, DWORD PTR _pRET$231060[ebp]
  0131d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0131f	6b d2 3c	 imul	 edx, 60			; 0000003cH
  01322	8b 4d d0	 mov	 ecx, DWORD PTR _pRET$231060[ebp]
  01325	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  01328	3b c2		 cmp	 eax, edx
  0132a	7e 18		 jle	 SHORT $LN6@CheckSync

; 466  : 			{
; 467  : 				bTIME_CHANGED = 2;

  0132c	c7 45 dc 02 00
	00 00		 mov	 DWORD PTR _bTIME_CHANGED$[ebp], 2

; 468  : 				iMIN_HOUR = pRET.m_iHour;

  01333	8b 45 d0	 mov	 eax, DWORD PTR _pRET$231060[ebp]
  01336	8b 08		 mov	 ecx, DWORD PTR [eax]
  01338	89 4d e4	 mov	 DWORD PTR _iMIN_HOUR$[ebp], ecx

; 469  : 				iMIN_MINUTE = pRET.m_iMinute;

  0133b	8b 45 d0	 mov	 eax, DWORD PTR _pRET$231060[ebp]
  0133e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01341	89 4d e0	 mov	 DWORD PTR _iMIN_MINUTE$[ebp], ecx
$LN6@CheckSync:

; 470  : 			}
; 471  : 		}

  01344	eb 90		 jmp	 SHORT $LN8@CheckSync
$LN10@CheckSync:

; 472  : 	}
; 473  : 
; 474  : 	switch ( bTIME_CHANGED )

  01346	8b 45 dc	 mov	 eax, DWORD PTR _bTIME_CHANGED$[ebp]
  01349	89 85 74 ff ff
	ff		 mov	 DWORD PTR tv184[ebp], eax
  0134f	83 bd 74 ff ff
	ff 01		 cmp	 DWORD PTR tv184[ebp], 1
  01356	74 0b		 je	 SHORT $LN3@CheckSync
  01358	83 bd 74 ff ff
	ff 02		 cmp	 DWORD PTR tv184[ebp], 2
  0135f	74 3f		 je	 SHORT $LN2@CheckSync
  01361	eb 7d		 jmp	 SHORT $LN1@CheckSync
$LN3@CheckSync:

; 475  : 	{
; 476  : 		case 1:
; 477  : 			this->m_iTIME_MSEC_REMAIN = ((iMIN_HOUR * 60 * 60 + iMIN_MINUTE * 60) - (sysTime.wHour * 60 * 60 + sysTime.wMinute * 60 + sysTime.wSecond)) * 1000;

  01363	8b 45 e4	 mov	 eax, DWORD PTR _iMIN_HOUR$[ebp]
  01366	6b c0 3c	 imul	 eax, 60			; 0000003cH
  01369	6b c0 3c	 imul	 eax, 60			; 0000003cH
  0136c	8b 4d e0	 mov	 ecx, DWORD PTR _iMIN_MINUTE$[ebp]
  0136f	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  01372	03 c1		 add	 eax, ecx
  01374	0f b7 55 f0	 movzx	 edx, WORD PTR _sysTime$[ebp+8]
  01378	6b d2 3c	 imul	 edx, 60			; 0000003cH
  0137b	6b d2 3c	 imul	 edx, 60			; 0000003cH
  0137e	0f b7 4d f2	 movzx	 ecx, WORD PTR _sysTime$[ebp+10]
  01382	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  01385	03 d1		 add	 edx, ecx
  01387	0f b7 4d f4	 movzx	 ecx, WORD PTR _sysTime$[ebp+12]
  0138b	03 d1		 add	 edx, ecx
  0138d	2b c2		 sub	 eax, edx
  0138f	69 c0 e8 03 00
	00		 imul	 eax, 1000		; 000003e8H
  01395	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  01398	89 82 f4 00 00
	00		 mov	 DWORD PTR [edx+244], eax

; 478  : 			break;

  0139e	eb 5c		 jmp	 SHORT $LN4@CheckSync
$LN2@CheckSync:

; 479  : 		case 2:
; 480  : 			this->m_iTIME_MSEC_REMAIN = (((iMIN_HOUR + 24) * 60 * 60 + iMIN_MINUTE * 60) - (sysTime.wHour * 60 * 60 + sysTime.wMinute * 60 + sysTime.wSecond)) * 1000;

  013a0	8b 45 e4	 mov	 eax, DWORD PTR _iMIN_HOUR$[ebp]
  013a3	83 c0 18	 add	 eax, 24			; 00000018H
  013a6	6b c0 3c	 imul	 eax, 60			; 0000003cH
  013a9	6b c0 3c	 imul	 eax, 60			; 0000003cH
  013ac	8b 4d e0	 mov	 ecx, DWORD PTR _iMIN_MINUTE$[ebp]
  013af	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  013b2	03 c1		 add	 eax, ecx
  013b4	0f b7 55 f0	 movzx	 edx, WORD PTR _sysTime$[ebp+8]
  013b8	6b d2 3c	 imul	 edx, 60			; 0000003cH
  013bb	6b d2 3c	 imul	 edx, 60			; 0000003cH
  013be	0f b7 4d f2	 movzx	 ecx, WORD PTR _sysTime$[ebp+10]
  013c2	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  013c5	03 d1		 add	 edx, ecx
  013c7	0f b7 4d f4	 movzx	 ecx, WORD PTR _sysTime$[ebp+12]
  013cb	03 d1		 add	 edx, ecx
  013cd	2b c2		 sub	 eax, edx
  013cf	69 c0 e8 03 00
	00		 imul	 eax, 1000		; 000003e8H
  013d5	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  013d8	89 82 f4 00 00
	00		 mov	 DWORD PTR [edx+244], eax

; 481  : 			break;

  013de	eb 1c		 jmp	 SHORT $LN4@CheckSync
$LN1@CheckSync:

; 482  : 		default:
; 483  : 			LogAddC(2, "[Ring Event] No Schedule Time Data");

  013e0	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@BNKPBCAA@?$FLRing?5Event?$FN?5No?5Schedule?5Time?5Da@
  013e5	6a 02		 push	 2
  013e7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  013ed	83 c4 08	 add	 esp, 8

; 484  : 			this->SetState(0);

  013f0	6a 00		 push	 0
  013f2	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  013f5	e8 00 00 00 00	 call	 ?SetState@CRingAttackEvent@@QAEXH@Z ; CRingAttackEvent::SetState

; 485  : 			return;

  013fa	eb 49		 jmp	 SHORT $LN17@CheckSync
$LN4@CheckSync:

; 486  : 	}
; 487  : 
; 488  : 	this->m_iTIME_TICK_COUNT = GetTickCount();

  013fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  01402	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01405	89 81 04 01 00
	00		 mov	 DWORD PTR [ecx+260], eax

; 489  : 
; 490  : 	LogAddTD("[Ring Event] Sync Start Time. [%d] min remain (START HOUR:%d, MIN:%d)",
; 491  : 		this->m_iTIME_MSEC_REMAIN/60000, iMIN_HOUR, iMIN_MINUTE);

  0140b	8b 45 e0	 mov	 eax, DWORD PTR _iMIN_MINUTE$[ebp]
  0140e	50		 push	 eax
  0140f	8b 4d e4	 mov	 ecx, DWORD PTR _iMIN_HOUR$[ebp]
  01412	51		 push	 ecx
  01413	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  01416	8b 82 f4 00 00
	00		 mov	 eax, DWORD PTR [edx+244]
  0141c	99		 cdq
  0141d	b9 60 ea 00 00	 mov	 ecx, 60000		; 0000ea60H
  01422	f7 f9		 idiv	 ecx
  01424	50		 push	 eax
  01425	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@KMBELKMF@?$FLRing?5Event?$FN?5Sync?5Start?5Time?4?5?$FL?$CF@
  0142a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01430	83 c4 10	 add	 esp, 16			; 00000010H

; 492  : 
; 493  : 	this->m_iTIME_NOTIFY_COUNT = this->m_iTIME_MIN_OPEN;

  01433	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  01436	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01439	8b 91 f8 00 00
	00		 mov	 edx, DWORD PTR [ecx+248]
  0143f	89 90 08 01 00
	00		 mov	 DWORD PTR [eax+264], edx
$LN17@CheckSync:

; 494  : }

  01445	5f		 pop	 edi
  01446	5e		 pop	 esi
  01447	5b		 pop	 ebx
  01448	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0144b	33 cd		 xor	 ecx, ebp
  0144d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01452	8b e5		 mov	 esp, ebp
  01454	5d		 pop	 ebp
  01455	c3		 ret	 0
?CheckSync@CRingAttackEvent@@QAEXXZ ENDP		; CRingAttackEvent::CheckSync
_TEXT	ENDS
PUBLIC	?SetState_Playing@CRingAttackEvent@@QAEXXZ	; CRingAttackEvent::SetState_Playing
PUBLIC	?SetState_Closed@CRingAttackEvent@@QAEXXZ	; CRingAttackEvent::SetState_Closed
PUBLIC	?SetState_None@CRingAttackEvent@@QAEXXZ		; CRingAttackEvent::SetState_None
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv70 = -72						; size = 4
_this$ = -4						; size = 4
_iSTATE$ = 8						; size = 4
?SetState@CRingAttackEvent@@QAEXH@Z PROC		; CRingAttackEvent::SetState
; _this$ = ecx

; 498  : {

  01460	55		 push	 ebp
  01461	8b ec		 mov	 ebp, esp
  01463	83 ec 48	 sub	 esp, 72			; 00000048H
  01466	53		 push	 ebx
  01467	56		 push	 esi
  01468	57		 push	 edi
  01469	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 499  : 	if ( this->m_iEVENT_STATE < 0 || this->m_iEVENT_STATE > 2 )

  0146c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0146f	83 b8 0c 01 00
	00 00		 cmp	 DWORD PTR [eax+268], 0
  01476	7c 0c		 jl	 SHORT $LN6@SetState
  01478	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0147b	83 b8 0c 01 00
	00 02		 cmp	 DWORD PTR [eax+268], 2
  01482	7e 02		 jle	 SHORT $LN7@SetState
$LN6@SetState:

; 500  : 		return;

  01484	eb 48		 jmp	 SHORT $LN8@SetState
$LN7@SetState:

; 501  : 
; 502  : 	this->m_iEVENT_STATE = iSTATE;

  01486	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01489	8b 4d 08	 mov	 ecx, DWORD PTR _iSTATE$[ebp]
  0148c	89 88 0c 01 00
	00		 mov	 DWORD PTR [eax+268], ecx

; 503  : 
; 504  : 	switch ( this->m_iEVENT_STATE )

  01492	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01495	8b 88 0c 01 00
	00		 mov	 ecx, DWORD PTR [eax+268]
  0149b	89 4d b8	 mov	 DWORD PTR tv70[ebp], ecx
  0149e	83 7d b8 00	 cmp	 DWORD PTR tv70[ebp], 0
  014a2	74 0e		 je	 SHORT $LN3@SetState
  014a4	83 7d b8 01	 cmp	 DWORD PTR tv70[ebp], 1
  014a8	74 12		 je	 SHORT $LN2@SetState
  014aa	83 7d b8 02	 cmp	 DWORD PTR tv70[ebp], 2
  014ae	74 16		 je	 SHORT $LN1@SetState
  014b0	eb 1c		 jmp	 SHORT $LN8@SetState
$LN3@SetState:

; 505  : 	{
; 506  : 		case 0:
; 507  : 			this->SetState_None();

  014b2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  014b5	e8 00 00 00 00	 call	 ?SetState_None@CRingAttackEvent@@QAEXXZ ; CRingAttackEvent::SetState_None

; 508  : 			break;

  014ba	eb 12		 jmp	 SHORT $LN8@SetState
$LN2@SetState:

; 509  : 		case 1:
; 510  : 			this->SetState_Closed();

  014bc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  014bf	e8 00 00 00 00	 call	 ?SetState_Closed@CRingAttackEvent@@QAEXXZ ; CRingAttackEvent::SetState_Closed

; 511  : 			break;

  014c4	eb 08		 jmp	 SHORT $LN8@SetState
$LN1@SetState:

; 512  : 		case 2:
; 513  : 			this->SetState_Playing();

  014c6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  014c9	e8 00 00 00 00	 call	 ?SetState_Playing@CRingAttackEvent@@QAEXXZ ; CRingAttackEvent::SetState_Playing
$LN8@SetState:

; 514  : 			break;
; 515  : 	}
; 516  : }

  014ce	5f		 pop	 edi
  014cf	5e		 pop	 esi
  014d0	5b		 pop	 ebx
  014d1	8b e5		 mov	 esp, ebp
  014d3	5d		 pop	 ebp
  014d4	c2 04 00	 ret	 4
?SetState@CRingAttackEvent@@QAEXH@Z ENDP		; CRingAttackEvent::SetState
; Function compile flags: /Odtp /ZI
_this$ = -4						; size = 4
?ProcState_None@CRingAttackEvent@@QAEXXZ PROC		; CRingAttackEvent::ProcState_None
; _this$ = ecx

; 520  : {

  014e0	55		 push	 ebp
  014e1	8b ec		 mov	 ebp, esp
  014e3	83 ec 44	 sub	 esp, 68			; 00000044H
  014e6	53		 push	 ebx
  014e7	56		 push	 esi
  014e8	57		 push	 edi
  014e9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 521  : 	return;
; 522  : }

  014ec	5f		 pop	 edi
  014ed	5e		 pop	 esi
  014ee	5b		 pop	 ebx
  014ef	8b e5		 mov	 esp, ebp
  014f1	5d		 pop	 ebp
  014f2	c3		 ret	 0
?ProcState_None@CRingAttackEvent@@QAEXXZ ENDP		; CRingAttackEvent::ProcState_None
_TEXT	ENDS
PUBLIC	??_C@_0BN@HLGPJCPM@?$FLRing?5Event?$FN?5?9?5Event?5Started?$AA@ ; `string'
PUBLIC	??_C@_0CM@NAOFHPPM@?$FLRing?5Event?$FN?5?9?5Before?53?5minutes?5@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?DataSendAll@@YAXPAEH@Z:PROC			; DataSendAll
;	COMDAT ??_C@_0BN@HLGPJCPM@?$FLRing?5Event?$FN?5?9?5Event?5Started?$AA@
CONST	SEGMENT
??_C@_0BN@HLGPJCPM@?$FLRing?5Event?$FN?5?9?5Event?5Started?$AA@ DB '[Ring'
	DB	' Event] - Event Started', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@NAOFHPPM@?$FLRing?5Event?$FN?5?9?5Before?53?5minutes?5@
CONST	SEGMENT
??_C@_0CM@NAOFHPPM@?$FLRing?5Event?$FN?5?9?5Before?53?5minutes?5@ DB '[Ri'
	DB	'ng Event] - Before 3 minutes - Advertise', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_pMsg$231110 = -540					; size = 6
_szTemp$231109 = -532					; size = 256
_pMsg$231104 = -276					; size = 6
_szTemp$231103 = -268					; size = 256
_iTICK_MSEC$ = -12					; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?ProcState_Closed@CRingAttackEvent@@QAEXXZ PROC		; CRingAttackEvent::ProcState_Closed
; _this$ = ecx

; 532  : {

  01500	55		 push	 ebp
  01501	8b ec		 mov	 ebp, esp
  01503	81 ec 5c 02 00
	00		 sub	 esp, 604		; 0000025cH
  01509	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0150e	33 c5		 xor	 eax, ebp
  01510	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  01513	53		 push	 ebx
  01514	56		 push	 esi
  01515	57		 push	 edi
  01516	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 533  : 	int iTICK_MSEC = GetTickCount() - this->m_iTIME_TICK_COUNT;

  01519	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0151f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01522	2b 81 04 01 00
	00		 sub	 eax, DWORD PTR [ecx+260]
  01528	89 45 f4	 mov	 DWORD PTR _iTICK_MSEC$[ebp], eax

; 534  : 
; 535  : 	if ( iTICK_MSEC >= 1000 )

  0152b	81 7d f4 e8 03
	00 00		 cmp	 DWORD PTR _iTICK_MSEC$[ebp], 1000 ; 000003e8H
  01532	0f 8c 23 01 00
	00		 jl	 $LN7@ProcState_

; 536  : 	{
; 537  : 		this->m_iTIME_MSEC_REMAIN -= iTICK_MSEC;

  01538	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0153b	8b 88 f4 00 00
	00		 mov	 ecx, DWORD PTR [eax+244]
  01541	2b 4d f4	 sub	 ecx, DWORD PTR _iTICK_MSEC$[ebp]
  01544	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  01547	89 8a f4 00 00
	00		 mov	 DWORD PTR [edx+244], ecx

; 538  : 		this->m_iTIME_TICK_COUNT = GetTickCount();

  0154d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  01553	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01556	89 81 04 01 00
	00		 mov	 DWORD PTR [ecx+260], eax

; 539  : 
; 540  : 		if ( this->m_bDoEvent )

  0155c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0155f	83 b8 e8 00 00
	00 00		 cmp	 DWORD PTR [eax+232], 0
  01566	0f 84 ef 00 00
	00		 je	 $LN7@ProcState_

; 541  : 		{
; 542  : 			if ( this->m_iTIME_MSEC_REMAIN <= (this->m_iTIME_MIN_OPEN * 60 * 1000 ) &&
; 543  : 				 this->m_iTIME_MSEC_REMAIN > 0 &&
; 544  : 				 (this->m_iTIME_MSEC_REMAIN / 60000 ) != this->m_iTIME_NOTIFY_COUNT )

  0156c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0156f	8b 88 f8 00 00
	00		 mov	 ecx, DWORD PTR [eax+248]
  01575	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  01578	69 c9 e8 03 00
	00		 imul	 ecx, 1000		; 000003e8H
  0157e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  01581	39 8a f4 00 00
	00		 cmp	 DWORD PTR [edx+244], ecx
  01587	0f 8f ce 00 00
	00		 jg	 $LN7@ProcState_
  0158d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  01590	83 b8 f4 00 00
	00 00		 cmp	 DWORD PTR [eax+244], 0
  01597	0f 8e be 00 00
	00		 jle	 $LN7@ProcState_
  0159d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  015a0	8b 80 f4 00 00
	00		 mov	 eax, DWORD PTR [eax+244]
  015a6	99		 cdq
  015a7	b9 60 ea 00 00	 mov	 ecx, 60000		; 0000ea60H
  015ac	f7 f9		 idiv	 ecx
  015ae	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  015b1	3b 82 08 01 00
	00		 cmp	 eax, DWORD PTR [edx+264]
  015b7	0f 84 9e 00 00
	00		 je	 $LN7@ProcState_

; 545  : 			{
; 546  : 				this->m_iTIME_NOTIFY_COUNT = this->m_iTIME_MSEC_REMAIN / 60000;

  015bd	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  015c0	8b 80 f4 00 00
	00		 mov	 eax, DWORD PTR [eax+244]
  015c6	99		 cdq
  015c7	b9 60 ea 00 00	 mov	 ecx, 60000		; 0000ea60H
  015cc	f7 f9		 idiv	 ecx
  015ce	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  015d1	89 82 08 01 00
	00		 mov	 DWORD PTR [edx+264], eax

; 547  : 
; 548  : 				if ( (this->m_iTIME_NOTIFY_COUNT+1) == 3 )

  015d7	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  015da	8b 88 08 01 00
	00		 mov	 ecx, DWORD PTR [eax+264]
  015e0	83 c1 01	 add	 ecx, 1
  015e3	83 f9 03	 cmp	 ecx, 3
  015e6	75 73		 jne	 SHORT $LN7@ProcState_

; 549  : 				{
; 550  : 					char szTemp[256];
; 551  : 					wsprintf(szTemp, lMsg.Get(MSGGET(4, 183)));

  015e8	68 b7 04 00 00	 push	 1207			; 000004b7H
  015ed	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  015f2	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  015f7	50		 push	 eax
  015f8	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$231103[ebp]
  015fe	50		 push	 eax
  015ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  01605	83 c4 08	 add	 esp, 8

; 552  : 					AllSendServerMsg(szTemp);

  01608	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$231103[ebp]
  0160e	50		 push	 eax
  0160f	e8 00 00 00 00	 call	 ?AllSendServerMsg@@YAXPAD@Z ; AllSendServerMsg
  01614	83 c4 04	 add	 esp, 4

; 553  : 
; 554  : 					PMSG_ANS_CL_EFFECT pMsg;
; 555  : 
; 556  : 					PHeadSetB((LPBYTE)&pMsg, 0x9E, sizeof(pMsg));

  01617	6a 06		 push	 6
  01619	68 9e 00 00 00	 push	 158			; 0000009eH
  0161e	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$231104[ebp]
  01624	50		 push	 eax
  01625	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  0162a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 557  : 					pMsg.wEffectNum = 0;

  0162d	33 c0		 xor	 eax, eax
  0162f	66 89 85 f0 fe
	ff ff		 mov	 WORD PTR _pMsg$231104[ebp+4], ax

; 558  : 
; 559  : 					DataSendAll((LPBYTE)&pMsg, pMsg.h.size);

  01636	0f b6 85 ed fe
	ff ff		 movzx	 eax, BYTE PTR _pMsg$231104[ebp+1]
  0163d	50		 push	 eax
  0163e	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _pMsg$231104[ebp]
  01644	51		 push	 ecx
  01645	e8 00 00 00 00	 call	 ?DataSendAll@@YAXPAEH@Z	; DataSendAll
  0164a	83 c4 08	 add	 esp, 8

; 560  : 
; 561  : 					LogAddTD("[Ring Event] - Before 3 minutes - Advertise");

  0164d	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@NAOFHPPM@?$FLRing?5Event?$FN?5?9?5Before?53?5minutes?5@
  01652	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01658	83 c4 04	 add	 esp, 4
$LN7@ProcState_:

; 562  : 				}
; 563  : 			}
; 564  : 		}
; 565  : 	}
; 566  : 
; 567  : 	if ( this->m_iTIME_MSEC_REMAIN <= 0 )

  0165b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0165e	83 b8 f4 00 00
	00 00		 cmp	 DWORD PTR [eax+244], 0
  01665	0f 8f 98 00 00
	00		 jg	 $LN8@ProcState_

; 568  : 	{
; 569  : 		char szTemp[256];
; 570  : 		wsprintf(szTemp, lMsg.Get(MSGGET(4, 184)));

  0166b	68 b8 04 00 00	 push	 1208			; 000004b8H
  01670	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  01675	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0167a	50		 push	 eax
  0167b	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _szTemp$231109[ebp]
  01681	50		 push	 eax
  01682	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  01688	83 c4 08	 add	 esp, 8

; 571  : 		AllSendServerMsg(szTemp);

  0168b	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _szTemp$231109[ebp]
  01691	50		 push	 eax
  01692	e8 00 00 00 00	 call	 ?AllSendServerMsg@@YAXPAD@Z ; AllSendServerMsg
  01697	83 c4 04	 add	 esp, 4

; 572  : 
; 573  : 		PMSG_ANS_CL_EFFECT pMsg;
; 574  : 
; 575  : 		PHeadSetB((LPBYTE)&pMsg, 0x9E, sizeof(pMsg));

  0169a	6a 06		 push	 6
  0169c	68 9e 00 00 00	 push	 158			; 0000009eH
  016a1	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _pMsg$231110[ebp]
  016a7	50		 push	 eax
  016a8	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  016ad	83 c4 0c	 add	 esp, 12			; 0000000cH

; 576  : 		pMsg.wEffectNum = 1;

  016b0	b8 01 00 00 00	 mov	 eax, 1
  016b5	66 89 85 e8 fd
	ff ff		 mov	 WORD PTR _pMsg$231110[ebp+4], ax

; 577  : 
; 578  : 		DataSendAll((LPBYTE)&pMsg, pMsg.h.size);

  016bc	0f b6 85 e5 fd
	ff ff		 movzx	 eax, BYTE PTR _pMsg$231110[ebp+1]
  016c3	50		 push	 eax
  016c4	8d 8d e4 fd ff
	ff		 lea	 ecx, DWORD PTR _pMsg$231110[ebp]
  016ca	51		 push	 ecx
  016cb	e8 00 00 00 00	 call	 ?DataSendAll@@YAXPAEH@Z	; DataSendAll
  016d0	83 c4 08	 add	 esp, 8

; 579  : 
; 580  : 		if ( this->m_bDoEvent )

  016d3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  016d6	83 b8 e8 00 00
	00 00		 cmp	 DWORD PTR [eax+232], 0
  016dd	74 0c		 je	 SHORT $LN2@ProcState_

; 581  : 		{
; 582  : 			this->SetState(2);

  016df	6a 02		 push	 2
  016e1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  016e4	e8 00 00 00 00	 call	 ?SetState@CRingAttackEvent@@QAEXH@Z ; CRingAttackEvent::SetState

; 583  : 		}
; 584  : 		else

  016e9	eb 0a		 jmp	 SHORT $LN1@ProcState_
$LN2@ProcState_:

; 585  : 		{
; 586  : 			this->SetState(0);

  016eb	6a 00		 push	 0
  016ed	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  016f0	e8 00 00 00 00	 call	 ?SetState@CRingAttackEvent@@QAEXH@Z ; CRingAttackEvent::SetState
$LN1@ProcState_:

; 587  : 		}
; 588  : 
; 589  : 		LogAddTD("[Ring Event] - Event Started");

  016f5	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@HLGPJCPM@?$FLRing?5Event?$FN?5?9?5Event?5Started?$AA@
  016fa	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01700	83 c4 04	 add	 esp, 4
$LN8@ProcState_:

; 590  : 	}
; 591  : }

  01703	5f		 pop	 edi
  01704	5e		 pop	 esi
  01705	5b		 pop	 ebx
  01706	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01709	33 cd		 xor	 ecx, ebp
  0170b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01710	8b e5		 mov	 esp, ebp
  01712	5d		 pop	 ebp
  01713	c3		 ret	 0
?ProcState_Closed@CRingAttackEvent@@QAEXXZ ENDP		; CRingAttackEvent::ProcState_Closed
_TEXT	ENDS
PUBLIC	??_C@_0BL@KELOKDGN@?$FLRing?5Event?$FN?5?9?5Event?5Ended?$AA@ ; `string'
PUBLIC	??_C@_0DK@PFGAPPAF@?$FLRing?5Event?$FN?5?9?5Monster?5Herd?5Move@ ; `string'
PUBLIC	??_C@_0EG@MJJALBNB@?$FLRing?5Event?$FN?5?9?5per?530?8S?5Inform?5M@ ; `string'
PUBLIC	?GetX@CRingMonsterHerd@@QAEEXZ			; CRingMonsterHerd::GetX
PUBLIC	?GetY@CRingMonsterHerd@@QAEEXZ			; CRingMonsterHerd::GetY
PUBLIC	?Move@CRingAttackEvent@@QAEXXZ			; CRingAttackEvent::Move
PUBLIC	__$ArrayPad$
;	COMDAT ??_C@_0BL@KELOKDGN@?$FLRing?5Event?$FN?5?9?5Event?5Ended?$AA@
CONST	SEGMENT
??_C@_0BL@KELOKDGN@?$FLRing?5Event?$FN?5?9?5Event?5Ended?$AA@ DB '[Ring E'
	DB	'vent] - Event Ended', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@PFGAPPAF@?$FLRing?5Event?$FN?5?9?5Monster?5Herd?5Move@
CONST	SEGMENT
??_C@_0DK@PFGAPPAF@?$FLRing?5Event?$FN?5?9?5Monster?5Herd?5Move@ DB '[Rin'
	DB	'g Event] - Monster Herd Move MapNumber:%d, X:%d, Y:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@MJJALBNB@?$FLRing?5Event?$FN?5?9?5per?530?8S?5Inform?5M@
CONST	SEGMENT
??_C@_0EG@MJJALBNB@?$FLRing?5Event?$FN?5?9?5per?530?8S?5Inform?5M@ DB '[R'
	DB	'ing Event] - per 30''S Inform MapNumber:%d, X:%d, Y:%d, Boss '
	DB	'Live:%d', 00H				; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_pMsg$231150 = -296					; size = 6
_szTemp$231149 = -288					; size = 256
_ucRAND$231145 = -31					; size = 1
_iRandY$231144 = -30					; size = 1
_iRandX$231143 = -29					; size = 1
_i$231139 = -28						; size = 4
_n$231130 = -24						; size = 4
_bLive$231129 = -20					; size = 4
_i$231125 = -16						; size = 4
_iTICK_MSEC$ = -12					; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?ProcState_Playing@CRingAttackEvent@@QAEXXZ PROC	; CRingAttackEvent::ProcState_Playing
; _this$ = ecx

; 595  : {

  01720	55		 push	 ebp
  01721	8b ec		 mov	 ebp, esp
  01723	81 ec 68 01 00
	00		 sub	 esp, 360		; 00000168H
  01729	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0172e	33 c5		 xor	 eax, ebp
  01730	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  01733	53		 push	 ebx
  01734	56		 push	 esi
  01735	57		 push	 edi
  01736	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 596  : 	int iTICK_MSEC = GetTickCount() - this->m_iTIME_TICK_COUNT;

  01739	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0173f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01742	2b 81 04 01 00
	00		 sub	 eax, DWORD PTR [ecx+260]
  01748	89 45 f4	 mov	 DWORD PTR _iTICK_MSEC$[ebp], eax

; 597  : 
; 598  : 	if ( iTICK_MSEC >= 1000 )

  0174b	81 7d f4 e8 03
	00 00		 cmp	 DWORD PTR _iTICK_MSEC$[ebp], 1000 ; 000003e8H
  01752	7c 3d		 jl	 SHORT $LN20@ProcState_@2

; 599  : 	{
; 600  : 		this->m_iTIME_MSEC_REMAIN -= iTICK_MSEC;

  01754	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  01757	8b 88 f4 00 00
	00		 mov	 ecx, DWORD PTR [eax+244]
  0175d	2b 4d f4	 sub	 ecx, DWORD PTR _iTICK_MSEC$[ebp]
  01760	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  01763	89 8a f4 00 00
	00		 mov	 DWORD PTR [edx+244], ecx

; 601  : 		this->m_iTIME_TICK_COUNT = GetTickCount();

  01769	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0176f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01772	89 81 04 01 00
	00		 mov	 DWORD PTR [ecx+260], eax

; 602  : 
; 603  : 		if ( (rand()%10) == 0 )

  01778	e8 00 00 00 00	 call	 _rand
  0177d	99		 cdq
  0177e	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  01783	f7 f9		 idiv	 ecx
  01785	85 d2		 test	 edx, edx
  01787	75 08		 jne	 SHORT $LN20@ProcState_@2

; 604  : 		{
; 605  : 			this->Move();

  01789	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0178c	e8 00 00 00 00	 call	 ?Move@CRingAttackEvent@@QAEXXZ ; CRingAttackEvent::Move
$LN20@ProcState_@2:

; 606  : 		}
; 607  : 	}
; 608  : 
; 609  : 	static int s_iTIME_REMAIN = -1;
; 610  : 
; 611  : 	if ( ((this->m_iTIME_MSEC_REMAIN / 1000 ) % 30 ) == 0 && ((this->m_iTIME_MSEC_REMAIN / 1000) / 30) != s_iTIME_REMAIN  )

  01791	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  01794	8b 80 f4 00 00
	00		 mov	 eax, DWORD PTR [eax+244]
  0179a	99		 cdq
  0179b	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  017a0	f7 f9		 idiv	 ecx
  017a2	99		 cdq
  017a3	b9 1e 00 00 00	 mov	 ecx, 30			; 0000001eH
  017a8	f7 f9		 idiv	 ecx
  017aa	85 d2		 test	 edx, edx
  017ac	0f 85 4e 01 00
	00		 jne	 $LN18@ProcState_@2
  017b2	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  017b5	8b 80 f4 00 00
	00		 mov	 eax, DWORD PTR [eax+244]
  017bb	99		 cdq
  017bc	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  017c1	f7 f9		 idiv	 ecx
  017c3	99		 cdq
  017c4	b9 1e 00 00 00	 mov	 ecx, 30			; 0000001eH
  017c9	f7 f9		 idiv	 ecx
  017cb	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?s_iTIME_REMAIN@?7??ProcState_Playing@CRingAttackEvent@@QAEXXZ@4HA
  017d1	0f 84 29 01 00
	00		 je	 $LN18@ProcState_@2

; 612  : 	{
; 613  : 		s_iTIME_REMAIN = this->m_iTIME_MSEC_REMAIN / 1000 / 30;

  017d7	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  017da	8b 80 f4 00 00
	00		 mov	 eax, DWORD PTR [eax+244]
  017e0	99		 cdq
  017e1	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  017e6	f7 f9		 idiv	 ecx
  017e8	99		 cdq
  017e9	b9 1e 00 00 00	 mov	 ecx, 30			; 0000001eH
  017ee	f7 f9		 idiv	 ecx
  017f0	a3 00 00 00 00	 mov	 DWORD PTR ?s_iTIME_REMAIN@?7??ProcState_Playing@CRingAttackEvent@@QAEXXZ@4HA, eax

; 614  : 
; 615  : 		for ( int i=0;i<MAX_RINGMONSTER_MAP;i++)

  017f5	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$231125[ebp], 0
  017fc	eb 09		 jmp	 SHORT $LN17@ProcState_@2
$LN16@ProcState_@2:
  017fe	8b 45 f0	 mov	 eax, DWORD PTR _i$231125[ebp]
  01801	83 c0 01	 add	 eax, 1
  01804	89 45 f0	 mov	 DWORD PTR _i$231125[ebp], eax
$LN17@ProcState_@2:
  01807	83 7d f0 03	 cmp	 DWORD PTR _i$231125[ebp], 3
  0180b	0f 8d ef 00 00
	00		 jge	 $LN18@ProcState_@2

; 616  : 		{
; 617  : 			BOOL bLive = FALSE;

  01811	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _bLive$231129[ebp], 0

; 618  : 
; 619  : 			for ( int n=0;n<OBJ_STARTUSERINDEX;n++)

  01818	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _n$231130[ebp], 0
  0181f	eb 09		 jmp	 SHORT $LN14@ProcState_@2
$LN13@ProcState_@2:
  01821	8b 45 e8	 mov	 eax, DWORD PTR _n$231130[ebp]
  01824	83 c0 01	 add	 eax, 1
  01827	89 45 e8	 mov	 DWORD PTR _n$231130[ebp], eax
$LN14@ProcState_@2:
  0182a	81 7d e8 b0 36
	00 00		 cmp	 DWORD PTR _n$231130[ebp], 14000 ; 000036b0H
  01831	7d 7f		 jge	 SHORT $LN12@ProcState_@2

; 620  : 			{
; 621  : 				if ( gObj[n].Class == 135 )

  01833	8b 45 e8	 mov	 eax, DWORD PTR _n$231130[ebp]
  01836	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0183c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01842	0f b7 94 01 b8
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+184]
  0184a	81 fa 87 00 00
	00		 cmp	 edx, 135		; 00000087H
  01850	75 5b		 jne	 SHORT $LN11@ProcState_@2

; 622  : 				{
; 623  : 					if ( gObj[n].m_bIsInMonsterHerd )

  01852	8b 45 e8	 mov	 eax, DWORD PTR _n$231130[ebp]
  01855	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0185b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01861	83 bc 01 e8 10
	00 00 00	 cmp	 DWORD PTR [ecx+eax+4328], 0
  01869	74 42		 je	 SHORT $LN11@ProcState_@2

; 624  : 					{
; 625  : 						if ( gObj[n].Live && gObj[n].MapNumber == g_RingEventMapNum[i] )

  0186b	8b 45 e8	 mov	 eax, DWORD PTR _n$231130[ebp]
  0186e	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01874	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0187a	0f b6 54 01 6a	 movzx	 edx, BYTE PTR [ecx+eax+106]
  0187f	85 d2		 test	 edx, edx
  01881	74 2a		 je	 SHORT $LN11@ProcState_@2
  01883	8b 45 e8	 mov	 eax, DWORD PTR _n$231130[ebp]
  01886	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0188c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01892	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  0189a	8b 45 f0	 mov	 eax, DWORD PTR _i$231125[ebp]
  0189d	3b 14 85 00 00
	00 00		 cmp	 edx, DWORD PTR _g_RingEventMapNum[eax*4]
  018a4	75 07		 jne	 SHORT $LN11@ProcState_@2

; 626  : 						{
; 627  : 							bLive = TRUE;

  018a6	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _bLive$231129[ebp], 1
$LN11@ProcState_@2:

; 628  : 						}
; 629  : 					}
; 630  : 				}
; 631  : 			}

  018ad	e9 6f ff ff ff	 jmp	 $LN13@ProcState_@2
$LN12@ProcState_@2:

; 632  : 
; 633  : 			LogAddTD("[Ring Event] - per 30'S Inform MapNumber:%d, X:%d, Y:%d, Boss Live:%d",
; 634  : 				g_RingEventMapNum[i], this->m_RingMonsterHerd[i].GetX(), this->m_RingMonsterHerd[i].GetY(), bLive);

  018b2	8b 45 ec	 mov	 eax, DWORD PTR _bLive$231129[ebp]
  018b5	50		 push	 eax
  018b6	8b 4d f0	 mov	 ecx, DWORD PTR _i$231125[ebp]
  018b9	6b c9 4c	 imul	 ecx, 76			; 0000004cH
  018bc	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  018bf	8d 4c 0a 04	 lea	 ecx, DWORD PTR [edx+ecx+4]
  018c3	e8 00 00 00 00	 call	 ?GetY@CRingMonsterHerd@@QAEEXZ ; CRingMonsterHerd::GetY
  018c8	0f b6 c0	 movzx	 eax, al
  018cb	50		 push	 eax
  018cc	8b 4d f0	 mov	 ecx, DWORD PTR _i$231125[ebp]
  018cf	6b c9 4c	 imul	 ecx, 76			; 0000004cH
  018d2	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  018d5	8d 4c 0a 04	 lea	 ecx, DWORD PTR [edx+ecx+4]
  018d9	e8 00 00 00 00	 call	 ?GetX@CRingMonsterHerd@@QAEEXZ ; CRingMonsterHerd::GetX
  018de	0f b6 c0	 movzx	 eax, al
  018e1	50		 push	 eax
  018e2	8b 4d f0	 mov	 ecx, DWORD PTR _i$231125[ebp]
  018e5	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _g_RingEventMapNum[ecx*4]
  018ec	52		 push	 edx
  018ed	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@MJJALBNB@?$FLRing?5Event?$FN?5?9?5per?530?8S?5Inform?5M@
  018f2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  018f8	83 c4 14	 add	 esp, 20			; 00000014H

; 635  : 		}

  018fb	e9 fe fe ff ff	 jmp	 $LN16@ProcState_@2
$LN18@ProcState_@2:

; 636  : 	}
; 637  : 
; 638  : 	if ( this->m_iTIME_MSEC_REMAIN <= (this->m_iTIME_MONSTER_TO_DEST * 60 * 1000) && this->m_bMonsterToDest == FALSE )

  01900	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  01903	8b 88 00 01 00
	00		 mov	 ecx, DWORD PTR [eax+256]
  01909	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  0190c	69 c9 e8 03 00
	00		 imul	 ecx, 1000		; 000003e8H
  01912	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  01915	39 8a f4 00 00
	00		 cmp	 DWORD PTR [edx+244], ecx
  0191b	0f 8f ce 00 00
	00		 jg	 $LN8@ProcState_@2
  01921	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  01924	83 b8 f0 00 00
	00 00		 cmp	 DWORD PTR [eax+240], 0
  0192b	0f 85 be 00 00
	00		 jne	 $LN8@ProcState_@2

; 639  : 	{
; 640  : 		
; 641  : 		for ( int i=0;i<MAX_RINGMONSTER_MAP;i++)

  01931	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _i$231139[ebp], 0
  01938	eb 09		 jmp	 SHORT $LN7@ProcState_@2
$LN6@ProcState_@2:
  0193a	8b 45 e4	 mov	 eax, DWORD PTR _i$231139[ebp]
  0193d	83 c0 01	 add	 eax, 1
  01940	89 45 e4	 mov	 DWORD PTR _i$231139[ebp], eax
$LN7@ProcState_@2:
  01943	83 7d e4 03	 cmp	 DWORD PTR _i$231139[ebp], 3
  01947	0f 8d 95 00 00
	00		 jge	 $LN5@ProcState_@2

; 642  : 		{
; 643  : 			BYTE iRandX;
; 644  : 			BYTE iRandY;
; 645  : 			BYTE ucRAND;
; 646  : 
; 647  : 			ucRAND = rand()%4;

  0194d	e8 00 00 00 00	 call	 _rand
  01952	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  01957	79 05		 jns	 SHORT $LN23@ProcState_@2
  01959	48		 dec	 eax
  0195a	83 c8 fc	 or	 eax, -4			; fffffffcH
  0195d	40		 inc	 eax
$LN23@ProcState_@2:
  0195e	88 45 e1	 mov	 BYTE PTR _ucRAND$231145[ebp], al

; 648  : 			iRandX = g_RingMapDestPosition[i][ucRAND*2];

  01961	8b 45 e4	 mov	 eax, DWORD PTR _i$231139[ebp]
  01964	c1 e0 05	 shl	 eax, 5
  01967	0f b6 4d e1	 movzx	 ecx, BYTE PTR _ucRAND$231145[ebp]
  0196b	d1 e1		 shl	 ecx, 1
  0196d	8a 94 88 00 00
	00 00		 mov	 dl, BYTE PTR _g_RingMapDestPosition[eax+ecx*4]
  01974	88 55 e3	 mov	 BYTE PTR _iRandX$231143[ebp], dl

; 649  : 			iRandY = g_RingMapDestPosition[i][ucRAND*2+1];

  01977	8b 45 e4	 mov	 eax, DWORD PTR _i$231139[ebp]
  0197a	c1 e0 05	 shl	 eax, 5
  0197d	0f b6 4d e1	 movzx	 ecx, BYTE PTR _ucRAND$231145[ebp]
  01981	d1 e1		 shl	 ecx, 1
  01983	8a 94 88 04 00
	00 00		 mov	 dl, BYTE PTR _g_RingMapDestPosition[eax+ecx*4+4]
  0198a	88 55 e2	 mov	 BYTE PTR _iRandY$231144[ebp], dl

; 650  : 
; 651  : 			if ( this->m_RingMonsterHerd[i].MoveHerd(iRandX, iRandY) != FALSE )

  0198d	0f b6 45 e2	 movzx	 eax, BYTE PTR _iRandY$231144[ebp]
  01991	50		 push	 eax
  01992	0f b6 4d e3	 movzx	 ecx, BYTE PTR _iRandX$231143[ebp]
  01996	51		 push	 ecx
  01997	8b 55 e4	 mov	 edx, DWORD PTR _i$231139[ebp]
  0199a	6b d2 4c	 imul	 edx, 76			; 0000004cH
  0199d	8b 45 e4	 mov	 eax, DWORD PTR _i$231139[ebp]
  019a0	6b c0 4c	 imul	 eax, 76			; 0000004cH
  019a3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  019a6	8d 4c 01 04	 lea	 ecx, DWORD PTR [ecx+eax+4]
  019aa	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  019ad	8b 54 10 04	 mov	 edx, DWORD PTR [eax+edx+4]
  019b1	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  019b4	ff d0		 call	 eax
  019b6	85 c0		 test	 eax, eax
  019b8	74 23		 je	 SHORT $LN4@ProcState_@2

; 652  : 			{
; 653  : 				LogAddTD("[Ring Event] - Monster Herd Move MapNumber:%d, X:%d, Y:%d",
; 654  : 					g_RingEventMapNum[i], iRandX, iRandY);

  019ba	0f b6 45 e2	 movzx	 eax, BYTE PTR _iRandY$231144[ebp]
  019be	50		 push	 eax
  019bf	0f b6 4d e3	 movzx	 ecx, BYTE PTR _iRandX$231143[ebp]
  019c3	51		 push	 ecx
  019c4	8b 55 e4	 mov	 edx, DWORD PTR _i$231139[ebp]
  019c7	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR _g_RingEventMapNum[edx*4]
  019ce	50		 push	 eax
  019cf	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@PFGAPPAF@?$FLRing?5Event?$FN?5?9?5Monster?5Herd?5Move@
  019d4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  019da	83 c4 10	 add	 esp, 16			; 00000010H
$LN4@ProcState_@2:

; 655  : 			}
; 656  : 		}

  019dd	e9 58 ff ff ff	 jmp	 $LN6@ProcState_@2
$LN5@ProcState_@2:

; 657  : 
; 658  : 		this->m_bMonsterToDest = TRUE;

  019e2	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  019e5	c7 80 f0 00 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+240], 1
$LN8@ProcState_@2:

; 659  : 	}
; 660  : 
; 661  : 	if ( this->m_iTIME_MSEC_REMAIN <= 0 )

  019ef	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  019f2	83 b8 f4 00 00
	00 00		 cmp	 DWORD PTR [eax+244], 0
  019f9	0f 8f 98 00 00
	00		 jg	 $LN21@ProcState_@2

; 662  : 	{
; 663  : 		char szTemp[256];
; 664  : 		wsprintf(szTemp, lMsg.Get(MSGGET(4, 185)));

  019ff	68 b9 04 00 00	 push	 1209			; 000004b9H
  01a04	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  01a09	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  01a0e	50		 push	 eax
  01a0f	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$231149[ebp]
  01a15	50		 push	 eax
  01a16	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  01a1c	83 c4 08	 add	 esp, 8

; 665  : 		AllSendServerMsg(szTemp);

  01a1f	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$231149[ebp]
  01a25	50		 push	 eax
  01a26	e8 00 00 00 00	 call	 ?AllSendServerMsg@@YAXPAD@Z ; AllSendServerMsg
  01a2b	83 c4 04	 add	 esp, 4

; 666  : 
; 667  : 		PMSG_ANS_CL_EFFECT pMsg;
; 668  : 
; 669  : 		PHeadSetB((LPBYTE)&pMsg, 0x9E, sizeof(pMsg));

  01a2e	6a 06		 push	 6
  01a30	68 9e 00 00 00	 push	 158			; 0000009eH
  01a35	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$231150[ebp]
  01a3b	50		 push	 eax
  01a3c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  01a41	83 c4 0c	 add	 esp, 12			; 0000000cH

; 670  : 		pMsg.wEffectNum = 2;

  01a44	b8 02 00 00 00	 mov	 eax, 2
  01a49	66 89 85 dc fe
	ff ff		 mov	 WORD PTR _pMsg$231150[ebp+4], ax

; 671  : 
; 672  : 		DataSendAll((LPBYTE)&pMsg, pMsg.h.size);

  01a50	0f b6 85 d9 fe
	ff ff		 movzx	 eax, BYTE PTR _pMsg$231150[ebp+1]
  01a57	50		 push	 eax
  01a58	8d 8d d8 fe ff
	ff		 lea	 ecx, DWORD PTR _pMsg$231150[ebp]
  01a5e	51		 push	 ecx
  01a5f	e8 00 00 00 00	 call	 ?DataSendAll@@YAXPAEH@Z	; DataSendAll
  01a64	83 c4 08	 add	 esp, 8

; 673  : 
; 674  : 		if ( this->m_bDoEvent )

  01a67	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  01a6a	83 b8 e8 00 00
	00 00		 cmp	 DWORD PTR [eax+232], 0
  01a71	74 0c		 je	 SHORT $LN2@ProcState_@2

; 675  : 		{
; 676  : 			this->SetState(1);

  01a73	6a 01		 push	 1
  01a75	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01a78	e8 00 00 00 00	 call	 ?SetState@CRingAttackEvent@@QAEXH@Z ; CRingAttackEvent::SetState

; 677  : 		}
; 678  : 		else

  01a7d	eb 0a		 jmp	 SHORT $LN1@ProcState_@2
$LN2@ProcState_@2:

; 679  : 		{
; 680  : 			this->SetState(0);

  01a7f	6a 00		 push	 0
  01a81	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01a84	e8 00 00 00 00	 call	 ?SetState@CRingAttackEvent@@QAEXH@Z ; CRingAttackEvent::SetState
$LN1@ProcState_@2:

; 681  : 		}
; 682  : 
; 683  : 		LogAddTD("[Ring Event] - Event Ended");

  01a89	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@KELOKDGN@?$FLRing?5Event?$FN?5?9?5Event?5Ended?$AA@
  01a8e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01a94	83 c4 04	 add	 esp, 4
$LN21@ProcState_@2:

; 684  : 	}
; 685  : }

  01a97	5f		 pop	 edi
  01a98	5e		 pop	 esi
  01a99	5b		 pop	 ebx
  01a9a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01a9d	33 cd		 xor	 ecx, ebp
  01a9f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01aa4	8b e5		 mov	 esp, ebp
  01aa6	5d		 pop	 ebp
  01aa7	c3		 ret	 0
?ProcState_Playing@CRingAttackEvent@@QAEXXZ ENDP	; CRingAttackEvent::ProcState_Playing
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\ringattackevent.h
_TEXT	ENDS
;	COMDAT ?GetX@CRingMonsterHerd@@QAEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetX@CRingMonsterHerd@@QAEEXZ PROC			; CRingMonsterHerd::GetX, COMDAT
; _this$ = ecx

; 22   : 	BYTE GetX(){return this->m_iCUR_X;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8a 40 0c	 mov	 al, BYTE PTR [eax+12]
  00012	5f		 pop	 edi
  00013	5e		 pop	 esi
  00014	5b		 pop	 ebx
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?GetX@CRingMonsterHerd@@QAEEXZ ENDP			; CRingMonsterHerd::GetX
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?GetY@CRingMonsterHerd@@QAEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetY@CRingMonsterHerd@@QAEEXZ PROC			; CRingMonsterHerd::GetY, COMDAT
; _this$ = ecx

; 23   : 	BYTE GetY(){return this->m_iCUR_Y;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8a 40 10	 mov	 al, BYTE PTR [eax+16]
  00012	5f		 pop	 edi
  00013	5e		 pop	 esi
  00014	5b		 pop	 ebx
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?GetY@CRingMonsterHerd@@QAEEXZ ENDP			; CRingMonsterHerd::GetY
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\ringattackevent.cpp
_TEXT	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetState_None@CRingAttackEvent@@QAEXXZ PROC		; CRingAttackEvent::SetState_None
; _this$ = ecx

; 689  : {

  01ab0	55		 push	 ebp
  01ab1	8b ec		 mov	 ebp, esp
  01ab3	83 ec 44	 sub	 esp, 68			; 00000044H
  01ab6	53		 push	 ebx
  01ab7	56		 push	 esi
  01ab8	57		 push	 edi
  01ab9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 690  : 	this->StopEvent();

  01abc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01abf	e8 00 00 00 00	 call	 ?StopEvent@CRingAttackEvent@@QAEXXZ ; CRingAttackEvent::StopEvent

; 691  : }

  01ac4	5f		 pop	 edi
  01ac5	5e		 pop	 esi
  01ac6	5b		 pop	 ebx
  01ac7	8b e5		 mov	 esp, ebp
  01ac9	5d		 pop	 ebp
  01aca	c3		 ret	 0
?SetState_None@CRingAttackEvent@@QAEXXZ ENDP		; CRingAttackEvent::SetState_None
; Function compile flags: /Odtp /ZI
_this$ = -4						; size = 4
?SetState_Closed@CRingAttackEvent@@QAEXXZ PROC		; CRingAttackEvent::SetState_Closed
; _this$ = ecx

; 695  : {

  01ad0	55		 push	 ebp
  01ad1	8b ec		 mov	 ebp, esp
  01ad3	83 ec 44	 sub	 esp, 68			; 00000044H
  01ad6	53		 push	 ebx
  01ad7	56		 push	 esi
  01ad8	57		 push	 edi
  01ad9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 696  : 	this->StopEvent();

  01adc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01adf	e8 00 00 00 00	 call	 ?StopEvent@CRingAttackEvent@@QAEXXZ ; CRingAttackEvent::StopEvent

; 697  : 
; 698  : 	if ( this->m_bDoEvent )

  01ae4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01ae7	83 b8 e8 00 00
	00 00		 cmp	 DWORD PTR [eax+232], 0
  01aee	74 0a		 je	 SHORT $LN2@SetState_C

; 699  : 	{
; 700  : 		this->CheckSync();

  01af0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01af3	e8 00 00 00 00	 call	 ?CheckSync@CRingAttackEvent@@QAEXXZ ; CRingAttackEvent::CheckSync

; 701  : 	}
; 702  : 	else

  01af8	eb 0a		 jmp	 SHORT $LN3@SetState_C
$LN2@SetState_C:

; 703  : 	{
; 704  : 		this->SetState(0);

  01afa	6a 00		 push	 0
  01afc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01aff	e8 00 00 00 00	 call	 ?SetState@CRingAttackEvent@@QAEXH@Z ; CRingAttackEvent::SetState
$LN3@SetState_C:

; 705  : 	}
; 706  : }

  01b04	5f		 pop	 edi
  01b05	5e		 pop	 esi
  01b06	5b		 pop	 ebx
  01b07	8b e5		 mov	 esp, ebp
  01b09	5d		 pop	 ebp
  01b0a	c3		 ret	 0
?SetState_Closed@CRingAttackEvent@@QAEXXZ ENDP		; CRingAttackEvent::SetState_Closed
; Function compile flags: /Odtp /ZI
_this$ = -4						; size = 4
?SetState_Playing@CRingAttackEvent@@QAEXXZ PROC		; CRingAttackEvent::SetState_Playing
; _this$ = ecx

; 710  : {

  01b10	55		 push	 ebp
  01b11	8b ec		 mov	 ebp, esp
  01b13	83 ec 44	 sub	 esp, 68			; 00000044H
  01b16	53		 push	 ebx
  01b17	56		 push	 esi
  01b18	57		 push	 edi
  01b19	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 711  : 	this->m_iTIME_MSEC_REMAIN = this->m_iTIME_MIN_PLAY * 60 * 1000;

  01b1c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01b1f	8b 88 fc 00 00
	00		 mov	 ecx, DWORD PTR [eax+252]
  01b25	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  01b28	69 c9 e8 03 00
	00		 imul	 ecx, 1000		; 000003e8H
  01b2e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01b31	89 8a f4 00 00
	00		 mov	 DWORD PTR [edx+244], ecx

; 712  : 	this->StartEvent();

  01b37	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01b3a	e8 00 00 00 00	 call	 ?StartEvent@CRingAttackEvent@@QAEXXZ ; CRingAttackEvent::StartEvent

; 713  : }

  01b3f	5f		 pop	 edi
  01b40	5e		 pop	 esi
  01b41	5b		 pop	 ebx
  01b42	8b e5		 mov	 esp, ebp
  01b44	5d		 pop	 ebp
  01b45	c3		 ret	 0
?SetState_Playing@CRingAttackEvent@@QAEXXZ ENDP		; CRingAttackEvent::SetState_Playing
; Function compile flags: /Odtp /ZI
_iRADIUS$231193 = -24					; size = 4
_iDIVIDE$231191 = -20					; size = 4
_iCount$231180 = -16					; size = 4
_i$231176 = -12						; size = 4
_iCY$231175 = -8					; size = 1
_iCX$231174 = -7					; size = 1
_iRandY$231173 = -6					; size = 1
_iRandX$231172 = -5					; size = 1
_this$ = -4						; size = 4
?Move@CRingAttackEvent@@QAEXXZ PROC			; CRingAttackEvent::Move
; _this$ = ecx

; 717  : {

  01b50	55		 push	 ebp
  01b51	8b ec		 mov	 ebp, esp
  01b53	83 ec 58	 sub	 esp, 88			; 00000058H
  01b56	53		 push	 ebx
  01b57	56		 push	 esi
  01b58	57		 push	 edi
  01b59	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 718  : 	if ( this->m_bDoEvent )

  01b5c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01b5f	83 b8 e8 00 00
	00 00		 cmp	 DWORD PTR [eax+232], 0
  01b66	0f 84 34 02 00
	00		 je	 $LN17@Move

; 719  : 	{
; 720  : 		if ( this->m_bMonsterToDest )

  01b6c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01b6f	83 b8 f0 00 00
	00 00		 cmp	 DWORD PTR [eax+240], 0
  01b76	74 05		 je	 SHORT $LN15@Move

; 721  : 			return;

  01b78	e9 23 02 00 00	 jmp	 $LN17@Move
$LN15@Move:

; 722  : 
; 723  : 		BYTE iRandX;
; 724  : 		BYTE iRandY;
; 725  : 		BYTE iCX;
; 726  : 		BYTE iCY;
; 727  : 
; 728  : 		for ( int i=0;i<MAX_RINGMONSTER_MAP;i++)

  01b7d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$231176[ebp], 0
  01b84	eb 09		 jmp	 SHORT $LN14@Move
$LN13@Move:
  01b86	8b 45 f4	 mov	 eax, DWORD PTR _i$231176[ebp]
  01b89	83 c0 01	 add	 eax, 1
  01b8c	89 45 f4	 mov	 DWORD PTR _i$231176[ebp], eax
$LN14@Move:
  01b8f	83 7d f4 03	 cmp	 DWORD PTR _i$231176[ebp], 3
  01b93	0f 8d 07 02 00
	00		 jge	 $LN17@Move

; 729  : 		{
; 730  : 			int iCount = 1000;

  01b99	c7 45 f0 e8 03
	00 00		 mov	 DWORD PTR _iCount$231180[ebp], 1000 ; 000003e8H

; 731  : 
; 732  : 			if ( this->m_RingMonsterHerd[i].GetCurrentLocation(iCX, iCY) == FALSE )

  01ba0	8d 45 f8	 lea	 eax, DWORD PTR _iCY$231175[ebp]
  01ba3	50		 push	 eax
  01ba4	8d 4d f9	 lea	 ecx, DWORD PTR _iCX$231174[ebp]
  01ba7	51		 push	 ecx
  01ba8	8b 55 f4	 mov	 edx, DWORD PTR _i$231176[ebp]
  01bab	6b d2 4c	 imul	 edx, 76			; 0000004cH
  01bae	8b 45 f4	 mov	 eax, DWORD PTR _i$231176[ebp]
  01bb1	6b c0 4c	 imul	 eax, 76			; 0000004cH
  01bb4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01bb7	8d 4c 01 04	 lea	 ecx, DWORD PTR [ecx+eax+4]
  01bbb	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01bbe	8b 54 10 04	 mov	 edx, DWORD PTR [eax+edx+4]
  01bc2	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  01bc5	ff d0		 call	 eax
  01bc7	85 c0		 test	 eax, eax
  01bc9	75 05		 jne	 SHORT $LN10@Move

; 733  : 				return;

  01bcb	e9 d0 01 00 00	 jmp	 $LN17@Move
$LN10@Move:

; 734  : 
; 735  : 			while ( iCount-- != 0 )

  01bd0	8b 45 f0	 mov	 eax, DWORD PTR _iCount$231180[ebp]
  01bd3	8b 4d f0	 mov	 ecx, DWORD PTR _iCount$231180[ebp]
  01bd6	83 e9 01	 sub	 ecx, 1
  01bd9	89 4d f0	 mov	 DWORD PTR _iCount$231180[ebp], ecx
  01bdc	85 c0		 test	 eax, eax
  01bde	0f 84 e4 00 00
	00		 je	 $LN9@Move

; 736  : 			{
; 737  : 				iRandX = (rand() % this->m_iMOVE_RAND_SIZE) * ( (rand() % 3 -1) * -1 ) + iCX;

  01be4	e8 00 00 00 00	 call	 _rand
  01be9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01bec	99		 cdq
  01bed	f7 b9 10 01 00
	00		 idiv	 DWORD PTR [ecx+272]
  01bf3	8b da		 mov	 ebx, edx
  01bf5	e8 00 00 00 00	 call	 _rand
  01bfa	99		 cdq
  01bfb	b9 03 00 00 00	 mov	 ecx, 3
  01c00	f7 f9		 idiv	 ecx
  01c02	83 ea 01	 sub	 edx, 1
  01c05	6b d2 ff	 imul	 edx, -1
  01c08	0f af da	 imul	 ebx, edx
  01c0b	0f b6 55 f9	 movzx	 edx, BYTE PTR _iCX$231174[ebp]
  01c0f	03 da		 add	 ebx, edx
  01c11	88 5d fb	 mov	 BYTE PTR _iRandX$231172[ebp], bl

; 738  : 				iRandY = (rand() % this->m_iMOVE_RAND_SIZE) * ( (rand() % 3 -1) * -1 ) + iCY;

  01c14	e8 00 00 00 00	 call	 _rand
  01c19	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01c1c	99		 cdq
  01c1d	f7 b9 10 01 00
	00		 idiv	 DWORD PTR [ecx+272]
  01c23	8b da		 mov	 ebx, edx
  01c25	e8 00 00 00 00	 call	 _rand
  01c2a	99		 cdq
  01c2b	b9 03 00 00 00	 mov	 ecx, 3
  01c30	f7 f9		 idiv	 ecx
  01c32	83 ea 01	 sub	 edx, 1
  01c35	6b d2 ff	 imul	 edx, -1
  01c38	0f af da	 imul	 ebx, edx
  01c3b	0f b6 55 f8	 movzx	 edx, BYTE PTR _iCY$231175[ebp]
  01c3f	03 da		 add	 ebx, edx
  01c41	88 5d fa	 mov	 BYTE PTR _iRandY$231173[ebp], bl

; 739  : 
; 740  : 				if ( iRandX < g_RingMapPosition[i][0] || iRandX > g_RingMapPosition[i][2] )

  01c44	0f b6 45 fb	 movzx	 eax, BYTE PTR _iRandX$231172[ebp]
  01c48	8b 4d f4	 mov	 ecx, DWORD PTR _i$231176[ebp]
  01c4b	c1 e1 04	 shl	 ecx, 4
  01c4e	3b 81 00 00 00
	00		 cmp	 eax, DWORD PTR _g_RingMapPosition[ecx]
  01c54	7c 12		 jl	 SHORT $LN7@Move
  01c56	0f b6 45 fb	 movzx	 eax, BYTE PTR _iRandX$231172[ebp]
  01c5a	8b 4d f4	 mov	 ecx, DWORD PTR _i$231176[ebp]
  01c5d	c1 e1 04	 shl	 ecx, 4
  01c60	3b 81 08 00 00
	00		 cmp	 eax, DWORD PTR _g_RingMapPosition[ecx+8]
  01c66	7e 05		 jle	 SHORT $LN8@Move
$LN7@Move:

; 741  : 					continue;

  01c68	e9 63 ff ff ff	 jmp	 $LN10@Move
$LN8@Move:

; 742  : 
; 743  : 				if ( iRandY < g_RingMapPosition[i][1] || iRandY > g_RingMapPosition[i][3] )

  01c6d	0f b6 45 fa	 movzx	 eax, BYTE PTR _iRandY$231173[ebp]
  01c71	8b 4d f4	 mov	 ecx, DWORD PTR _i$231176[ebp]
  01c74	c1 e1 04	 shl	 ecx, 4
  01c77	3b 81 04 00 00
	00		 cmp	 eax, DWORD PTR _g_RingMapPosition[ecx+4]
  01c7d	7c 12		 jl	 SHORT $LN5@Move
  01c7f	0f b6 45 fa	 movzx	 eax, BYTE PTR _iRandY$231173[ebp]
  01c83	8b 4d f4	 mov	 ecx, DWORD PTR _i$231176[ebp]
  01c86	c1 e1 04	 shl	 ecx, 4
  01c89	3b 81 0c 00 00
	00		 cmp	 eax, DWORD PTR _g_RingMapPosition[ecx+12]
  01c8f	7e 05		 jle	 SHORT $LN6@Move
$LN5@Move:

; 744  : 					continue;

  01c91	e9 3a ff ff ff	 jmp	 $LN10@Move
$LN6@Move:

; 745  : 
; 746  : 				if ( this->m_RingMonsterHerd[i].CheckLocation(iRandX, iRandY) != FALSE )

  01c96	8d 45 fa	 lea	 eax, DWORD PTR _iRandY$231173[ebp]
  01c99	50		 push	 eax
  01c9a	8d 4d fb	 lea	 ecx, DWORD PTR _iRandX$231172[ebp]
  01c9d	51		 push	 ecx
  01c9e	8b 55 f4	 mov	 edx, DWORD PTR _i$231176[ebp]
  01ca1	6b d2 4c	 imul	 edx, 76			; 0000004cH
  01ca4	8b 45 f4	 mov	 eax, DWORD PTR _i$231176[ebp]
  01ca7	6b c0 4c	 imul	 eax, 76			; 0000004cH
  01caa	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01cad	8d 4c 01 04	 lea	 ecx, DWORD PTR [ecx+eax+4]
  01cb1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01cb4	8b 54 10 04	 mov	 edx, DWORD PTR [eax+edx+4]
  01cb8	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  01cbb	ff d0		 call	 eax
  01cbd	85 c0		 test	 eax, eax
  01cbf	74 02		 je	 SHORT $LN4@Move

; 747  : 					break;

  01cc1	eb 05		 jmp	 SHORT $LN9@Move
$LN4@Move:

; 748  : 			}

  01cc3	e9 08 ff ff ff	 jmp	 $LN10@Move
$LN9@Move:

; 749  : 
; 750  : 			if ( this->m_RingMonsterHerd[i].MoveHerd(iRandX, iRandY) != FALSE )

  01cc8	0f b6 45 fa	 movzx	 eax, BYTE PTR _iRandY$231173[ebp]
  01ccc	50		 push	 eax
  01ccd	0f b6 4d fb	 movzx	 ecx, BYTE PTR _iRandX$231172[ebp]
  01cd1	51		 push	 ecx
  01cd2	8b 55 f4	 mov	 edx, DWORD PTR _i$231176[ebp]
  01cd5	6b d2 4c	 imul	 edx, 76			; 0000004cH
  01cd8	8b 45 f4	 mov	 eax, DWORD PTR _i$231176[ebp]
  01cdb	6b c0 4c	 imul	 eax, 76			; 0000004cH
  01cde	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01ce1	8d 4c 01 04	 lea	 ecx, DWORD PTR [ecx+eax+4]
  01ce5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01ce8	8b 54 10 04	 mov	 edx, DWORD PTR [eax+edx+4]
  01cec	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  01cef	ff d0		 call	 eax
  01cf1	85 c0		 test	 eax, eax
  01cf3	74 23		 je	 SHORT $LN3@Move

; 751  : 			{
; 752  : 				LogAddTD("[Ring Event] - Monster Herd Move MapNumber:%d, X:%d, Y:%d",
; 753  : 					g_RingEventMapNum[i], iRandX, iRandY);

  01cf5	0f b6 45 fa	 movzx	 eax, BYTE PTR _iRandY$231173[ebp]
  01cf9	50		 push	 eax
  01cfa	0f b6 4d fb	 movzx	 ecx, BYTE PTR _iRandX$231172[ebp]
  01cfe	51		 push	 ecx
  01cff	8b 55 f4	 mov	 edx, DWORD PTR _i$231176[ebp]
  01d02	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR _g_RingEventMapNum[edx*4]
  01d09	50		 push	 eax
  01d0a	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@PFGAPPAF@?$FLRing?5Event?$FN?5?9?5Monster?5Herd?5Move@
  01d0f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01d15	83 c4 10	 add	 esp, 16			; 00000010H
$LN3@Move:

; 754  : 			}
; 755  : 
; 756  : 			int iDIVIDE = this->m_iRADIUS_MAX - this->m_iRADIUS_MIN;

  01d18	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01d1b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01d1e	8b 90 18 01 00
	00		 mov	 edx, DWORD PTR [eax+280]
  01d24	2b 91 14 01 00
	00		 sub	 edx, DWORD PTR [ecx+276]
  01d2a	89 55 ec	 mov	 DWORD PTR _iDIVIDE$231191[ebp], edx

; 757  : 
; 758  : 			if ( iDIVIDE <= 0 )

  01d2d	83 7d ec 00	 cmp	 DWORD PTR _iDIVIDE$231191[ebp], 0
  01d31	7f 07		 jg	 SHORT $LN2@Move

; 759  : 				iDIVIDE = 1;

  01d33	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _iDIVIDE$231191[ebp], 1
$LN2@Move:

; 760  : 
; 761  : 			int iRADIUS = iDIVIDE + this->m_iRADIUS_MIN;

  01d3a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01d3d	8b 4d ec	 mov	 ecx, DWORD PTR _iDIVIDE$231191[ebp]
  01d40	03 88 14 01 00
	00		 add	 ecx, DWORD PTR [eax+276]
  01d46	89 4d e8	 mov	 DWORD PTR _iRADIUS$231193[ebp], ecx

; 762  : 
; 763  : 			if ( iRADIUS <= 3 )

  01d49	83 7d e8 03	 cmp	 DWORD PTR _iRADIUS$231193[ebp], 3
  01d4d	7f 07		 jg	 SHORT $LN1@Move

; 764  : 				iRADIUS = 3;

  01d4f	c7 45 e8 03 00
	00 00		 mov	 DWORD PTR _iRADIUS$231193[ebp], 3
$LN1@Move:

; 765  : 
; 766  : 			this->m_RingMonsterHerd[i].SetRadius((rand() % (this->m_iRADIUS_MAX - this->m_iRADIUS_MIN)) + this->m_iRADIUS_MIN);

  01d56	e8 00 00 00 00	 call	 _rand
  01d5b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01d5e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01d61	8b 89 18 01 00
	00		 mov	 ecx, DWORD PTR [ecx+280]
  01d67	2b 8a 14 01 00
	00		 sub	 ecx, DWORD PTR [edx+276]
  01d6d	99		 cdq
  01d6e	f7 f9		 idiv	 ecx
  01d70	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01d73	03 90 14 01 00
	00		 add	 edx, DWORD PTR [eax+276]
  01d79	52		 push	 edx
  01d7a	8b 4d f4	 mov	 ecx, DWORD PTR _i$231176[ebp]
  01d7d	6b c9 4c	 imul	 ecx, 76			; 0000004cH
  01d80	8b 55 f4	 mov	 edx, DWORD PTR _i$231176[ebp]
  01d83	6b d2 4c	 imul	 edx, 76			; 0000004cH
  01d86	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01d89	8d 54 10 04	 lea	 edx, DWORD PTR [eax+edx+4]
  01d8d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01d90	8b 44 08 04	 mov	 eax, DWORD PTR [eax+ecx+4]
  01d94	8b ca		 mov	 ecx, edx
  01d96	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  01d99	ff d2		 call	 edx

; 767  : 		}

  01d9b	e9 e6 fd ff ff	 jmp	 $LN13@Move
$LN17@Move:

; 768  : 	}
; 769  : }

  01da0	5f		 pop	 edi
  01da1	5e		 pop	 esi
  01da2	5b		 pop	 ebx
  01da3	8b e5		 mov	 esp, ebp
  01da5	5d		 pop	 ebp
  01da6	c3		 ret	 0
?Move@CRingAttackEvent@@QAEXXZ ENDP			; CRingAttackEvent::Move
_TEXT	ENDS
PUBLIC	??_C@_0DB@PHNKOJF@?$KB?$NL?$KB?$NM?$FLEvent?5Management?$FN?5?$FLStart?$FN?5R@ ; `string'
PUBLIC	?SetMenualStart@CRingAttackEvent@@QAEXH@Z	; CRingAttackEvent::SetMenualStart
PUBLIC	__$ArrayPad$
PUBLIC	?Start_Menual@CRingAttackEvent@@QAEXXZ		; CRingAttackEvent::Start_Menual
;	COMDAT ??_C@_0DB@PHNKOJF@?$KB?$NL?$KB?$NM?$FLEvent?5Management?$FN?5?$FLStart?$FN?5R@
CONST	SEGMENT
??_C@_0DB@PHNKOJF@?$KB?$NL?$KB?$NM?$FLEvent?5Management?$FN?5?$FLStart?$FN?5R@ DB 0a1H
	DB	0dbH, 0a1H, 0dcH, '[Event Management] [Start] RingAttack Event'
	DB	'!', 00H					; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_pMsg$ = -272						; size = 6
_szTemp$ = -264						; size = 256
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?Start_Menual@CRingAttackEvent@@QAEXXZ PROC		; CRingAttackEvent::Start_Menual
; _this$ = ecx

; 773  : {

  01db0	55		 push	 ebp
  01db1	8b ec		 mov	 ebp, esp
  01db3	81 ec 50 01 00
	00		 sub	 esp, 336		; 00000150H
  01db9	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  01dbe	33 c5		 xor	 eax, ebp
  01dc0	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  01dc3	53		 push	 ebx
  01dc4	56		 push	 esi
  01dc5	57		 push	 edi
  01dc6	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 774  : 	this->SetMenualStart(TRUE);

  01dc9	6a 01		 push	 1
  01dcb	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01dce	e8 00 00 00 00	 call	 ?SetMenualStart@CRingAttackEvent@@QAEXH@Z ; CRingAttackEvent::SetMenualStart

; 775  : 	this->StopEvent();

  01dd3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01dd6	e8 00 00 00 00	 call	 ?StopEvent@CRingAttackEvent@@QAEXXZ ; CRingAttackEvent::StopEvent

; 776  : 
; 777  : 	LogAddTD("[Event Management] [Start] RingAttack Event!");

  01ddb	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@PHNKOJF@?$KB?$NL?$KB?$NM?$FLEvent?5Management?$FN?5?$FLStart?$FN?5R@
  01de0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01de6	83 c4 04	 add	 esp, 4

; 778  : 	this->m_iTIME_MIN_PLAY = 30;

  01de9	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  01dec	c7 80 fc 00 00
	00 1e 00 00 00	 mov	 DWORD PTR [eax+252], 30	; 0000001eH

; 779  : 
; 780  : 	char szTemp[256];
; 781  : 
; 782  : 	wsprintf(szTemp, lMsg.Get(MSGGET(4, 184)));

  01df6	68 b8 04 00 00	 push	 1208			; 000004b8H
  01dfb	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  01e00	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  01e05	50		 push	 eax
  01e06	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  01e0c	50		 push	 eax
  01e0d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  01e13	83 c4 08	 add	 esp, 8

; 783  : 	AllSendServerMsg(szTemp);

  01e16	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  01e1c	50		 push	 eax
  01e1d	e8 00 00 00 00	 call	 ?AllSendServerMsg@@YAXPAD@Z ; AllSendServerMsg
  01e22	83 c4 04	 add	 esp, 4

; 784  : 
; 785  : 	PMSG_ANS_CL_EFFECT pMsg;
; 786  : 
; 787  : 	PHeadSetB((LPBYTE)&pMsg, 0x9E, sizeof(pMsg));

  01e25	6a 06		 push	 6
  01e27	68 9e 00 00 00	 push	 158			; 0000009eH
  01e2c	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  01e32	50		 push	 eax
  01e33	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  01e38	83 c4 0c	 add	 esp, 12			; 0000000cH

; 788  : 	pMsg.wEffectNum = 1;

  01e3b	b8 01 00 00 00	 mov	 eax, 1
  01e40	66 89 85 f4 fe
	ff ff		 mov	 WORD PTR _pMsg$[ebp+4], ax

; 789  : 
; 790  : 	DataSendAll((LPBYTE)&pMsg, pMsg.h.size);

  01e47	0f b6 85 f1 fe
	ff ff		 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  01e4e	50		 push	 eax
  01e4f	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  01e55	51		 push	 ecx
  01e56	e8 00 00 00 00	 call	 ?DataSendAll@@YAXPAEH@Z	; DataSendAll
  01e5b	83 c4 08	 add	 esp, 8

; 791  : 	this->SetState(2);

  01e5e	6a 02		 push	 2
  01e60	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01e63	e8 00 00 00 00	 call	 ?SetState@CRingAttackEvent@@QAEXH@Z ; CRingAttackEvent::SetState

; 792  : }

  01e68	5f		 pop	 edi
  01e69	5e		 pop	 esi
  01e6a	5b		 pop	 ebx
  01e6b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01e6e	33 cd		 xor	 ecx, ebp
  01e70	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01e75	8b e5		 mov	 esp, ebp
  01e77	5d		 pop	 ebp
  01e78	c3		 ret	 0
?Start_Menual@CRingAttackEvent@@QAEXXZ ENDP		; CRingAttackEvent::Start_Menual
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\ringattackevent.h
_TEXT	ENDS
;	COMDAT ?SetMenualStart@CRingAttackEvent@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bMenualStart$ = 8					; size = 4
?SetMenualStart@CRingAttackEvent@@QAEXH@Z PROC		; CRingAttackEvent::SetMenualStart, COMDAT
; _this$ = ecx

; 71   : 	void SetMenualStart(BOOL bMenualStart){this->m_bMenualStart = bMenualStart;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _bMenualStart$[ebp]
  00012	89 88 54 01 00
	00		 mov	 DWORD PTR [eax+340], ecx
  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?SetMenualStart@CRingAttackEvent@@QAEXH@Z ENDP		; CRingAttackEvent::SetMenualStart
_TEXT	ENDS
PUBLIC	?End_Menual@CRingAttackEvent@@QAEXXZ		; CRingAttackEvent::End_Menual
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\ringattackevent.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?End_Menual@CRingAttackEvent@@QAEXXZ PROC		; CRingAttackEvent::End_Menual
; _this$ = ecx

; 797  : {

  01e80	55		 push	 ebp
  01e81	8b ec		 mov	 ebp, esp
  01e83	83 ec 44	 sub	 esp, 68			; 00000044H
  01e86	53		 push	 ebx
  01e87	56		 push	 esi
  01e88	57		 push	 edi
  01e89	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 798  : 	this->SetMenualStart(0);

  01e8c	6a 00		 push	 0
  01e8e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01e91	e8 00 00 00 00	 call	 ?SetMenualStart@CRingAttackEvent@@QAEXH@Z ; CRingAttackEvent::SetMenualStart

; 799  : }

  01e96	5f		 pop	 edi
  01e97	5e		 pop	 esi
  01e98	5b		 pop	 ebx
  01e99	8b e5		 mov	 esp, ebp
  01e9b	5d		 pop	 ebp
  01e9c	c3		 ret	 0
?End_Menual@CRingAttackEvent@@QAEXXZ ENDP		; CRingAttackEvent::End_Menual
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE@V?$allocator@URINGMONSTER_DATA@@@1@@Z ; std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >
PUBLIC	??0?$allocator@URINGMONSTER_DATA@@@std@@QAE@XZ	; std::allocator<RINGMONSTER_DATA>::allocator<RINGMONSTER_DATA>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T232940 = -72						; size = 4
_this$ = -4						; size = 4
??0?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE@XZ PROC ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	51		 push	 ecx
  0000d	8b cc		 mov	 ecx, esp
  0000f	89 65 b8	 mov	 DWORD PTR $T232940[ebp], esp
  00012	e8 00 00 00 00	 call	 ??0?$allocator@URINGMONSTER_DATA@@@std@@QAE@XZ ; std::allocator<RINGMONSTER_DATA>::allocator<RINGMONSTER_DATA>
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE@V?$allocator@URINGMONSTER_DATA@@@1@@Z ; std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >

; 508  : 		}

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE@XZ ENDP ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE@XZ ; std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::~_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >
PUBLIC	?_Tidy@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@IAEXXZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??1?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE@XZ PROC ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::~vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >, COMDAT
; _this$ = ecx

; 704  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 705  : 		_Tidy();

  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?_Tidy@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@IAEXXZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Tidy

; 706  : 		}

  0003a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??1?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE@XZ ; std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::~_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >
  00049	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE@XZ ; std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::~_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >
__ehhandler$??1?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE@XZ ENDP ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::~vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QAE@PAURINGMONSTER_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >::_Vector_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ?begin@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@2@XZ PROC ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 782  : 		return (iterator(this->_Myfirst, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	52		 push	 edx
  00016	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00019	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QAE@PAURINGMONSTER_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >::_Vector_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >
  0001e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 783  : 		}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?begin@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@2@XZ ENDP ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::begin
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?end@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@2@XZ PROC ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 792  : 		return (iterator(this->_Mylast, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	52		 push	 edx
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QAE@PAURINGMONSTER_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >::_Vector_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >
  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 793  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?end@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@2@XZ ENDP ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::end
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?empty@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?empty@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QBE_NXZ PROC ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::empty, COMDAT
; _this$ = ecx

; 888  : 		{	// test if sequence is empty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 889  : 		return (this->_Myfirst == this->_Mylast);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 10		 mov	 edx, DWORD PTR [eax]
  00014	33 c0		 xor	 eax, eax
  00016	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00019	0f 94 c0	 sete	 al

; 890  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
?empty@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QBE_NXZ ENDP ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::empty
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@URINGMONSTER_DATA@@@std@@URINGMONSTER_DATA@@ABU3@@std@@YAXAAV?$allocator@URINGMONSTER_DATA@@@0@PAURINGMONSTER_DATA@@ABU2@@Z ; std::_Cons_val<std::allocator<RINGMONSTER_DATA>,RINGMONSTER_DATA,RINGMONSTER_DATA const &>
PUBLIC	??$_Cons_val@V?$allocator@URINGMONSTER_DATA@@@std@@URINGMONSTER_DATA@@AAU3@@std@@YAXAAV?$allocator@URINGMONSTER_DATA@@@0@PAURINGMONSTER_DATA@@AAU2@@Z ; std::_Cons_val<std::allocator<RINGMONSTER_DATA>,RINGMONSTER_DATA,RINGMONSTER_DATA &>
PUBLIC	?_Orphan_range@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@IBEXPAURINGMONSTER_DATA@@0@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Orphan_range
PUBLIC	?_Reserve@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@IAEXI@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Reserve
PUBLIC	?_Inside@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@IBE_NPBURINGMONSTER_DATA@@@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Inside
PUBLIC	??$addressof@$$CBURINGMONSTER_DATA@@@std@@YAPBURINGMONSTER_DATA@@ABU1@@Z ; std::addressof<RINGMONSTER_DATA const >
; Function compile flags: /Odtp /ZI
;	COMDAT ?push_back@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAEXABURINGMONSTER_DATA@@@Z
_TEXT	SEGMENT
__Idx$231235 = -8					; size = 4
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAEXABURINGMONSTER_DATA@@@Z PROC ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$addressof@$$CBURINGMONSTER_DATA@@@std@@YAPBURINGMONSTER_DATA@@ABU1@@Z ; std::addressof<RINGMONSTER_DATA const >
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Inside@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@IBE_NPBURINGMONSTER_DATA@@@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Inside
  00021	0f b6 c8	 movzx	 ecx, al
  00024	85 c9		 test	 ecx, ecx
  00026	74 7d		 je	 SHORT $LN4@push_back

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$addressof@$$CBURINGMONSTER_DATA@@@std@@YAPBURINGMONSTER_DATA@@ABU1@@Z ; std::addressof<RINGMONSTER_DATA const >
  00031	83 c4 04	 add	 esp, 4
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	2b 01		 sub	 eax, DWORD PTR [ecx]
  00039	99		 cdq
  0003a	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  0003f	f7 f9		 idiv	 ecx
  00041	89 45 f8	 mov	 DWORD PTR __Idx$231235[ebp], eax

; 980  : 			if (this->_Mylast == this->_Myend)

  00044	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0004d	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00050	75 0a		 jne	 SHORT $LN3@push_back

; 981  : 				_Reserve(1);

  00052	6a 01		 push	 1
  00054	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	e8 00 00 00 00	 call	 ?_Reserve@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@IAEXI@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Reserve
$LN3@push_back:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  0005c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00062	51		 push	 ecx
  00063	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00066	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00069	50		 push	 eax
  0006a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006d	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@IBEXPAURINGMONSTER_DATA@@0@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Orphan_range

; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  00072	8b 45 f8	 mov	 eax, DWORD PTR __Idx$231235[ebp]
  00075	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00078	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	03 01		 add	 eax, DWORD PTR [ecx]
  0007d	50		 push	 eax
  0007e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00081	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00084	50		 push	 eax
  00085	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00088	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0008b	51		 push	 ecx
  0008c	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@URINGMONSTER_DATA@@@std@@URINGMONSTER_DATA@@AAU3@@std@@YAXAAV?$allocator@URINGMONSTER_DATA@@@0@PAURINGMONSTER_DATA@@AAU2@@Z ; std::_Cons_val<std::allocator<RINGMONSTER_DATA>,RINGMONSTER_DATA,RINGMONSTER_DATA &>
  00091	83 c4 0c	 add	 esp, 12			; 0000000cH

; 986  : 			++this->_Mylast;

  00094	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00097	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0009a	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0009d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000a0	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 987  : 			}
; 988  : 		else

  000a3	eb 57		 jmp	 SHORT $LN5@push_back
$LN4@push_back:

; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  000a5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ab	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000ae	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  000b1	75 0a		 jne	 SHORT $LN1@push_back

; 991  : 				_Reserve(1);

  000b3	6a 01		 push	 1
  000b5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b8	e8 00 00 00 00	 call	 ?_Reserve@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@IAEXI@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Reserve
$LN1@push_back:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  000bd	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000c3	51		 push	 ecx
  000c4	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c7	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000ca	50		 push	 eax
  000cb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ce	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@IBEXPAURINGMONSTER_DATA@@0@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Orphan_range

; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  000d3	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  000d6	50		 push	 eax
  000d7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000da	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000dd	52		 push	 edx
  000de	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000e1	83 c0 0c	 add	 eax, 12			; 0000000cH
  000e4	50		 push	 eax
  000e5	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@URINGMONSTER_DATA@@@std@@URINGMONSTER_DATA@@ABU3@@std@@YAXAAV?$allocator@URINGMONSTER_DATA@@@0@PAURINGMONSTER_DATA@@ABU2@@Z ; std::_Cons_val<std::allocator<RINGMONSTER_DATA>,RINGMONSTER_DATA,RINGMONSTER_DATA const &>
  000ea	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  000ed	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000f0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000f3	83 c1 0c	 add	 ecx, 12			; 0000000cH
  000f6	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000f9	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN5@push_back:

; 997  : 			}
; 998  : 		}

  000fc	5f		 pop	 edi
  000fd	5e		 pop	 esi
  000fe	5b		 pop	 ebx
  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c2 04 00	 ret	 4
?push_back@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAEXABURINGMONSTER_DATA@@@Z ENDP ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::push_back
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@IAEXPAURINGMONSTER_DATA@@0@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Destroy
PUBLIC	??$_Move@PAURINGMONSTER_DATA@@PAU1@@std@@YAPAURINGMONSTER_DATA@@PAU1@00@Z ; std::_Move<RINGMONSTER_DATA *,RINGMONSTER_DATA *>
PUBLIC	?_Make_iter@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@2@@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Make_iter
; Function compile flags: /Odtp /ZI
;	COMDAT ?erase@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T232961 = -84						; size = 4
__Ptr$231263 = -16					; size = 4
__Last$ = -12						; size = 4
__First$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@2@0@Z PROC ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::erase, COMDAT
; _this$ = ecx

; 1190 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1191 : 		iterator _First = _Make_iter(_First_arg);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __First_arg$[ebp]
  0000f	50		 push	 eax
  00010	8d 4d f8	 lea	 ecx, DWORD PTR __First$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@2@@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Make_iter

; 1192 : 		iterator _Last = _Make_iter(_Last_arg);

  0001c	8b 45 10	 mov	 eax, DWORD PTR __Last_arg$[ebp]
  0001f	50		 push	 eax
  00020	8d 4d f4	 lea	 ecx, DWORD PTR __Last$[ebp]
  00023	51		 push	 ecx
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@2@@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Make_iter

; 1193 : 
; 1194 : 		if (_First != _Last)

  0002c	8d 45 f4	 lea	 eax, DWORD PTR __Last$[ebp]
  0002f	50		 push	 eax
  00030	8d 4d f8	 lea	 ecx, DWORD PTR __First$[ebp]
  00033	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >::operator!=
  00038	0f b6 c8	 movzx	 ecx, al
  0003b	85 c9		 test	 ecx, ecx
  0003d	74 36		 je	 SHORT $LN1@erase

; 1195 : 			{	// worth doing, copy down over hole
; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 			if (_Last < _First || _VICONT(_First) != this
; 1198 : 				|| _VIPTR(_First) < this->_Myfirst
; 1199 : 				|| this->_Mylast < _VIPTR(_Last))
; 1200 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1201 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1202 : 				_VIPTR(_First));
; 1203 : 			_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1204 : 
; 1205 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1206 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1207 : 				_VIPTR(_First));

  0003f	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00042	50		 push	 eax
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00049	52		 push	 edx
  0004a	8b 45 f4	 mov	 eax, DWORD PTR __Last$[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ??$_Move@PAURINGMONSTER_DATA@@PAU1@@std@@YAPAURINGMONSTER_DATA@@PAU1@00@Z ; std::_Move<RINGMONSTER_DATA *,RINGMONSTER_DATA *>
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH
  00056	89 45 f0	 mov	 DWORD PTR __Ptr$231263[ebp], eax

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 			_Destroy(_Ptr, this->_Mylast);

  00059	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005f	51		 push	 ecx
  00060	8b 55 f0	 mov	 edx, DWORD PTR __Ptr$231263[ebp]
  00063	52		 push	 edx
  00064	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	e8 00 00 00 00	 call	 ?_Destroy@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@IAEXPAURINGMONSTER_DATA@@0@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Destroy

; 1211 : 			this->_Mylast = _Ptr;

  0006c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006f	8b 4d f0	 mov	 ecx, DWORD PTR __Ptr$231263[ebp]
  00072	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@erase:

; 1212 : 			}
; 1213 : 		return (_Make_iter(_First));

  00075	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00078	89 45 ac	 mov	 DWORD PTR $T232961[ebp], eax
  0007b	8b 4d ac	 mov	 ecx, DWORD PTR $T232961[ebp]
  0007e	51		 push	 ecx
  0007f	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00082	52		 push	 edx
  00083	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@2@@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Make_iter
  0008b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1214 : 		}

  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@2@0@Z ENDP ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::erase
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@V?$allocator@URINGMONSTER_EVENT_TIME@@@1@@Z ; std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >
PUBLIC	??0?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAE@XZ ; std::allocator<RINGMONSTER_EVENT_TIME>::allocator<RINGMONSTER_EVENT_TIME>
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T232964 = -72						; size = 4
_this$ = -4						; size = 4
??0?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ PROC ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	51		 push	 ecx
  0000d	8b cc		 mov	 ecx, esp
  0000f	89 65 b8	 mov	 DWORD PTR $T232964[ebp], esp
  00012	e8 00 00 00 00	 call	 ??0?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAE@XZ ; std::allocator<RINGMONSTER_EVENT_TIME>::allocator<RINGMONSTER_EVENT_TIME>
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@V?$allocator@URINGMONSTER_EVENT_TIME@@@1@@Z ; std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >

; 508  : 		}

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ ENDP ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ ; std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::~_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >
PUBLIC	?_Tidy@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@IAEXXZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??1?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ PROC ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::~vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >, COMDAT
; _this$ = ecx

; 704  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 705  : 		_Tidy();

  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?_Tidy@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@IAEXXZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Tidy

; 706  : 		}

  0003a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??1?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ ; std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::~_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >
  00049	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ ; std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::~_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >
__ehhandler$??1?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ ENDP ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::~vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@PAURINGMONSTER_EVENT_TIME@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::_Vector_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ?begin@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@XZ PROC ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 782  : 		return (iterator(this->_Myfirst, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	52		 push	 edx
  00016	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00019	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@PAURINGMONSTER_EVENT_TIME@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::_Vector_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >
  0001e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 783  : 		}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?begin@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@XZ ENDP ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::begin
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?end@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@XZ PROC ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 792  : 		return (iterator(this->_Mylast, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	52		 push	 edx
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@PAURINGMONSTER_EVENT_TIME@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::_Vector_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >
  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 793  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?end@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@XZ ENDP ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::end
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?empty@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?empty@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QBE_NXZ PROC ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::empty, COMDAT
; _this$ = ecx

; 888  : 		{	// test if sequence is empty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 889  : 		return (this->_Myfirst == this->_Mylast);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 10		 mov	 edx, DWORD PTR [eax]
  00014	33 c0		 xor	 eax, eax
  00016	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00019	0f 94 c0	 sete	 al

; 890  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
?empty@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QBE_NXZ ENDP ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::empty
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@URINGMONSTER_EVENT_TIME@@ABU3@@std@@YAXAAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@PAURINGMONSTER_EVENT_TIME@@ABU2@@Z ; std::_Cons_val<std::allocator<RINGMONSTER_EVENT_TIME>,RINGMONSTER_EVENT_TIME,RINGMONSTER_EVENT_TIME const &>
PUBLIC	??$_Cons_val@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@URINGMONSTER_EVENT_TIME@@AAU3@@std@@YAXAAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@PAURINGMONSTER_EVENT_TIME@@AAU2@@Z ; std::_Cons_val<std::allocator<RINGMONSTER_EVENT_TIME>,RINGMONSTER_EVENT_TIME,RINGMONSTER_EVENT_TIME &>
PUBLIC	?_Orphan_range@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@IBEXPAURINGMONSTER_EVENT_TIME@@0@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Orphan_range
PUBLIC	?_Reserve@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@IAEXI@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Reserve
PUBLIC	?_Inside@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@IBE_NPBURINGMONSTER_EVENT_TIME@@@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Inside
PUBLIC	??$addressof@$$CBURINGMONSTER_EVENT_TIME@@@std@@YAPBURINGMONSTER_EVENT_TIME@@ABU1@@Z ; std::addressof<RINGMONSTER_EVENT_TIME const >
; Function compile flags: /Odtp /ZI
;	COMDAT ?push_back@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAEXABURINGMONSTER_EVENT_TIME@@@Z
_TEXT	SEGMENT
__Idx$231302 = -8					; size = 4
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAEXABURINGMONSTER_EVENT_TIME@@@Z PROC ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$addressof@$$CBURINGMONSTER_EVENT_TIME@@@std@@YAPBURINGMONSTER_EVENT_TIME@@ABU1@@Z ; std::addressof<RINGMONSTER_EVENT_TIME const >
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Inside@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@IBE_NPBURINGMONSTER_EVENT_TIME@@@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Inside
  00021	0f b6 c8	 movzx	 ecx, al
  00024	85 c9		 test	 ecx, ecx
  00026	74 78		 je	 SHORT $LN4@push_back@2

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$addressof@$$CBURINGMONSTER_EVENT_TIME@@@std@@YAPBURINGMONSTER_EVENT_TIME@@ABU1@@Z ; std::addressof<RINGMONSTER_EVENT_TIME const >
  00031	83 c4 04	 add	 esp, 4
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	2b 01		 sub	 eax, DWORD PTR [ecx]
  00039	c1 f8 03	 sar	 eax, 3
  0003c	89 45 f8	 mov	 DWORD PTR __Idx$231302[ebp], eax

; 980  : 			if (this->_Mylast == this->_Myend)

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00048	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0004b	75 0a		 jne	 SHORT $LN3@push_back@2

; 981  : 				_Reserve(1);

  0004d	6a 01		 push	 1
  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	e8 00 00 00 00	 call	 ?_Reserve@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@IAEXI@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Reserve
$LN3@push_back@2:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  00057	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005d	51		 push	 ecx
  0005e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00061	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00064	50		 push	 eax
  00065	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@IBEXPAURINGMONSTER_EVENT_TIME@@0@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Orphan_range

; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  0006d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00070	8b 08		 mov	 ecx, DWORD PTR [eax]
  00072	8b 55 f8	 mov	 edx, DWORD PTR __Idx$231302[ebp]
  00075	8d 04 d1	 lea	 eax, DWORD PTR [ecx+edx*8]
  00078	50		 push	 eax
  00079	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007f	52		 push	 edx
  00080	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00083	83 c0 0c	 add	 eax, 12			; 0000000cH
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@URINGMONSTER_EVENT_TIME@@AAU3@@std@@YAXAAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@PAURINGMONSTER_EVENT_TIME@@AAU2@@Z ; std::_Cons_val<std::allocator<RINGMONSTER_EVENT_TIME>,RINGMONSTER_EVENT_TIME,RINGMONSTER_EVENT_TIME &>
  0008c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 986  : 			++this->_Mylast;

  0008f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00092	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00095	83 c1 08	 add	 ecx, 8
  00098	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0009b	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 987  : 			}
; 988  : 		else

  0009e	eb 57		 jmp	 SHORT $LN5@push_back@2
$LN4@push_back@2:

; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  000a0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a9	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  000ac	75 0a		 jne	 SHORT $LN1@push_back@2

; 991  : 				_Reserve(1);

  000ae	6a 01		 push	 1
  000b0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b3	e8 00 00 00 00	 call	 ?_Reserve@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@IAEXI@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Reserve
$LN1@push_back@2:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  000b8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000bb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000be	51		 push	 ecx
  000bf	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c2	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000c5	50		 push	 eax
  000c6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c9	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@IBEXPAURINGMONSTER_EVENT_TIME@@0@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Orphan_range

; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  000ce	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  000d1	50		 push	 eax
  000d2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d5	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000d8	52		 push	 edx
  000d9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000dc	83 c0 0c	 add	 eax, 12			; 0000000cH
  000df	50		 push	 eax
  000e0	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@URINGMONSTER_EVENT_TIME@@ABU3@@std@@YAXAAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@PAURINGMONSTER_EVENT_TIME@@ABU2@@Z ; std::_Cons_val<std::allocator<RINGMONSTER_EVENT_TIME>,RINGMONSTER_EVENT_TIME,RINGMONSTER_EVENT_TIME const &>
  000e5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  000e8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000eb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ee	83 c1 08	 add	 ecx, 8
  000f1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000f4	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN5@push_back@2:

; 997  : 			}
; 998  : 		}

  000f7	5f		 pop	 edi
  000f8	5e		 pop	 esi
  000f9	5b		 pop	 ebx
  000fa	8b e5		 mov	 esp, ebp
  000fc	5d		 pop	 ebp
  000fd	c2 04 00	 ret	 4
?push_back@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAEXABURINGMONSTER_EVENT_TIME@@@Z ENDP ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::push_back
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@IAEXPAURINGMONSTER_EVENT_TIME@@0@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Destroy
PUBLIC	??$_Move@PAURINGMONSTER_EVENT_TIME@@PAU1@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@00@Z ; std::_Move<RINGMONSTER_EVENT_TIME *,RINGMONSTER_EVENT_TIME *>
PUBLIC	?_Make_iter@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Make_iter
; Function compile flags: /Odtp /ZI
;	COMDAT ?erase@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T232985 = -84						; size = 4
__Ptr$231330 = -16					; size = 4
__Last$ = -12						; size = 4
__First$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@0@Z PROC ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::erase, COMDAT
; _this$ = ecx

; 1190 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1191 : 		iterator _First = _Make_iter(_First_arg);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __First_arg$[ebp]
  0000f	50		 push	 eax
  00010	8d 4d f8	 lea	 ecx, DWORD PTR __First$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Make_iter

; 1192 : 		iterator _Last = _Make_iter(_Last_arg);

  0001c	8b 45 10	 mov	 eax, DWORD PTR __Last_arg$[ebp]
  0001f	50		 push	 eax
  00020	8d 4d f4	 lea	 ecx, DWORD PTR __Last$[ebp]
  00023	51		 push	 ecx
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Make_iter

; 1193 : 
; 1194 : 		if (_First != _Last)

  0002c	8d 45 f4	 lea	 eax, DWORD PTR __Last$[ebp]
  0002f	50		 push	 eax
  00030	8d 4d f8	 lea	 ecx, DWORD PTR __First$[ebp]
  00033	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::operator!=
  00038	0f b6 c8	 movzx	 ecx, al
  0003b	85 c9		 test	 ecx, ecx
  0003d	74 36		 je	 SHORT $LN1@erase@2

; 1195 : 			{	// worth doing, copy down over hole
; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 			if (_Last < _First || _VICONT(_First) != this
; 1198 : 				|| _VIPTR(_First) < this->_Myfirst
; 1199 : 				|| this->_Mylast < _VIPTR(_Last))
; 1200 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1201 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1202 : 				_VIPTR(_First));
; 1203 : 			_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1204 : 
; 1205 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1206 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1207 : 				_VIPTR(_First));

  0003f	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00042	50		 push	 eax
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00049	52		 push	 edx
  0004a	8b 45 f4	 mov	 eax, DWORD PTR __Last$[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ??$_Move@PAURINGMONSTER_EVENT_TIME@@PAU1@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@00@Z ; std::_Move<RINGMONSTER_EVENT_TIME *,RINGMONSTER_EVENT_TIME *>
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH
  00056	89 45 f0	 mov	 DWORD PTR __Ptr$231330[ebp], eax

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 			_Destroy(_Ptr, this->_Mylast);

  00059	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005f	51		 push	 ecx
  00060	8b 55 f0	 mov	 edx, DWORD PTR __Ptr$231330[ebp]
  00063	52		 push	 edx
  00064	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	e8 00 00 00 00	 call	 ?_Destroy@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@IAEXPAURINGMONSTER_EVENT_TIME@@0@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Destroy

; 1211 : 			this->_Mylast = _Ptr;

  0006c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006f	8b 4d f0	 mov	 ecx, DWORD PTR __Ptr$231330[ebp]
  00072	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@erase@2:

; 1212 : 			}
; 1213 : 		return (_Make_iter(_First));

  00075	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00078	89 45 ac	 mov	 DWORD PTR $T232985[ebp], eax
  0007b	8b 4d ac	 mov	 ecx, DWORD PTR $T232985[ebp]
  0007e	51		 push	 ecx
  0007f	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00082	52		 push	 edx
  00083	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Make_iter
  0008b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1214 : 		}

  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@0@Z ENDP ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::erase
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QBEABURINGMONSTER_DATA@@XZ ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >::operator*
; Function compile flags: /Odtp /ZI
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QBEAAURINGMONSTER_DATA@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QBEAAURINGMONSTER_DATA@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >::operator*, COMDAT
; _this$ = ecx

; 321  : 		{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 322  : 		return ((reference)**(_Mybase *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QBEABURINGMONSTER_DATA@@XZ ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >::operator*

; 323  : 		}

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QBEAAURINGMONSTER_DATA@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >::operator++
; Function compile flags: /Odtp /ZI
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >::operator++, COMDAT
; _this$ = ecx

; 337  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 338  : 		_Myiter _Tmp = *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	89 4d f8	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 339  : 		++*this;

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >::operator++

; 340  : 		return (_Tmp);

  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Tmp$[ebp]
  00022	89 08		 mov	 DWORD PTR [eax], ecx
  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 341  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
??E?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >::operator==
; Function compile flags: /Odtp /ZI
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 208  : 		return (!(*this == _Right));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??8?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >::operator==
  00018	0f b6 c0	 movzx	 eax, al
  0001b	f7 d8		 neg	 eax
  0001d	1b c0		 sbb	 eax, eax
  0001f	83 c0 01	 add	 eax, 1

; 209  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >::operator!=
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::_Vector_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >, COMDAT
; _this$ = ecx

; 298  : 	_Vector_iterator()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >

; 299  : 		{	// construct with null vector pointer
; 300  : 		}

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::_Vector_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEABURINGMONSTER_EVENT_TIME@@XZ ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::operator*
; Function compile flags: /Odtp /ZI
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEAAURINGMONSTER_EVENT_TIME@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEAAURINGMONSTER_EVENT_TIME@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::operator*, COMDAT
; _this$ = ecx

; 321  : 		{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 322  : 		return ((reference)**(_Mybase *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEABURINGMONSTER_EVENT_TIME@@XZ ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::operator*

; 323  : 		}

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEAAURINGMONSTER_EVENT_TIME@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::operator++
; Function compile flags: /Odtp /ZI
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::operator++, COMDAT
; _this$ = ecx

; 337  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 338  : 		_Myiter _Tmp = *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	89 4d f8	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 339  : 		++*this;

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::operator++

; 340  : 		return (_Tmp);

  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Tmp$[ebp]
  00022	89 08		 mov	 DWORD PTR [eax], ecx
  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 341  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
??E?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::operator==
; Function compile flags: /Odtp /ZI
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 208  : 		return (!(*this == _Right));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??8?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::operator==
  00018	0f b6 c0	 movzx	 eax, al
  0001b	f7 d8		 neg	 eax
  0001d	1b c0		 sbb	 eax, eax
  0001f	83 c0 01	 add	 eax, 1

; 209  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::operator!=
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@2@@Z PROC ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Make_iter, COMDAT
; _this$ = ecx

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  : 		return (iterator(_Where._Ptr, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QAE@PAURINGMONSTER_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >::_Vector_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 803  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
?_Make_iter@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@2@@Z ENDP ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Make_iter
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@YAXPAURINGMONSTER_DATA@@0AAV?$allocator@URINGMONSTER_DATA@@@0@@Z ; std::_Destroy_range<std::allocator<RINGMONSTER_DATA> >
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Destroy@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@IAEXPAURINGMONSTER_DATA@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@IAEXPAURINGMONSTER_DATA@@0@Z PROC ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Destroy, COMDAT
; _this$ = ecx

; 1269 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@YAXPAURINGMONSTER_DATA@@0AAV?$allocator@URINGMONSTER_DATA@@@0@@Z ; std::_Destroy_range<std::allocator<RINGMONSTER_DATA> >
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1271 : 		}

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
?_Destroy@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@IAEXPAURINGMONSTER_DATA@@0@Z ENDP ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Destroy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Inside@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@IBE_NPBURINGMONSTER_DATA@@@Z
_TEXT	SEGMENT
tv76 = -72						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@IBE_NPBURINGMONSTER_DATA@@@Z PROC ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00012	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00015	73 13		 jae	 SHORT $LN3@Inside
  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	3b 45 08	 cmp	 eax, DWORD PTR __Ptr$[ebp]
  0001f	77 09		 ja	 SHORT $LN3@Inside
  00021	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  00028	eb 07		 jmp	 SHORT $LN4@Inside
$LN3@Inside:
  0002a	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN4@Inside:
  00031	8a 45 b8	 mov	 al, BYTE PTR tv76[ebp]

; 1287 : 		}

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?_Inside@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@IBE_NPBURINGMONSTER_DATA@@@Z ENDP ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Inside
_TEXT	ENDS
PUBLIC	?reserve@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAEXI@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::reserve
PUBLIC	?_Grow_to@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@IBEII@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Grow_to
PUBLIC	?capacity@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QBEIXZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::capacity
PUBLIC	?_Xlen@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@IBEXXZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Xlen
PUBLIC	?max_size@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QBEIXZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::max_size
PUBLIC	?size@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QBEIXZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::size
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Reserve@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$ = -8						; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@IAEXI@Z PROC ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1291 : 		size_type _Size = size();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?size@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QBEIXZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::size
  00014	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax

; 1292 : 		if (max_size() - _Count < _Size)

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QBEIXZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::max_size
  0001f	2b 45 08	 sub	 eax, DWORD PTR __Count$[ebp]
  00022	3b 45 f8	 cmp	 eax, DWORD PTR __Size$[ebp]
  00025	73 0a		 jae	 SHORT $LN4@Reserve

; 1293 : 			_Xlen();

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Xlen@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@IBEXXZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Xlen
  0002f	eb 2d		 jmp	 SHORT $LN6@Reserve
$LN4@Reserve:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00031	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  00034	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]
  00037	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?capacity@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QBEIXZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::capacity
  00042	39 45 f8	 cmp	 DWORD PTR __Size$[ebp], eax
  00045	77 02		 ja	 SHORT $LN2@Reserve

; 1295 : 			;
; 1296 : 		else

  00047	eb 15		 jmp	 SHORT $LN6@Reserve
$LN2@Reserve:

; 1297 : 			reserve(_Grow_to(_Size));

  00049	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?_Grow_to@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@IBEII@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Grow_to
  00055	50		 push	 eax
  00056	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ?reserve@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAEXI@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::reserve
$LN6@Reserve:

; 1298 : 		}

  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?_Reserve@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@IAEXI@Z ENDP ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Reserve
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@URINGMONSTER_DATA@@@std@@QAEXPAURINGMONSTER_DATA@@I@Z ; std::allocator<RINGMONSTER_DATA>::deallocate
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Tidy@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@IAEXXZ PROC ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1302 : 		if (this->_Myfirst != 0)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00012	74 42		 je	 SHORT $LN1@Tidy

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00022	51		 push	 ecx
  00023	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00026	8b 02		 mov	 eax, DWORD PTR [edx]
  00028	50		 push	 eax
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?_Destroy@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@IAEXPAURINGMONSTER_DATA@@0@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Destroy

; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0003a	2b 01		 sub	 eax, DWORD PTR [ecx]
  0003c	99		 cdq
  0003d	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00042	f7 f9		 idiv	 ecx
  00044	50		 push	 eax
  00045	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00048	8b 02		 mov	 eax, DWORD PTR [edx]
  0004a	50		 push	 eax
  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00051	e8 00 00 00 00	 call	 ?deallocate@?$allocator@URINGMONSTER_DATA@@@std@@QAEXPAURINGMONSTER_DATA@@I@Z ; std::allocator<RINGMONSTER_DATA>::deallocate
$LN1@Tidy:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00056	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00059	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1310 : 		this->_Mylast = 0;

  0005f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00062	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1311 : 		this->_Myend = 0;

  00069	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 1312 : 		}

  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	5b		 pop	 ebx
  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
?_Tidy@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@IAEXXZ ENDP ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Tidy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Orphan_range@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@IBEXPAURINGMONSTER_DATA@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@IBEXPAURINGMONSTER_DATA@@0@Z PROC ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1453 : 		{	// orphan iterators within specified (inclusive) range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1454 : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?_Orphan_range@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@IBEXPAURINGMONSTER_DATA@@0@Z ENDP ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??0?$allocator@URINGMONSTER_DATA@@@std@@QAE@ABV01@@Z ; std::allocator<RINGMONSTER_DATA>::allocator<RINGMONSTER_DATA>
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE@V?$allocator@URINGMONSTER_DATA@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE@V?$allocator@URINGMONSTER_DATA@@@1@@Z PROC ; std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00016	e8 00 00 00 00	 call	 ??0?$allocator@URINGMONSTER_DATA@@@std@@QAE@ABV01@@Z ; std::allocator<RINGMONSTER_DATA>::allocator<RINGMONSTER_DATA>

; 427  : 		_Myfirst = 0;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 428  : 		_Mylast = 0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 429  : 		_Myend = 0;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 430  : 		}

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
??0?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE@V?$allocator@URINGMONSTER_DATA@@@1@@Z ENDP ; std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::~_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >, COMDAT
; _this$ = ecx

; 433  : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 434  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::~_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@URINGMONSTER_DATA@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@URINGMONSTER_DATA@@@std@@QAE@XZ PROC	; std::allocator<RINGMONSTER_DATA>::allocator<RINGMONSTER_DATA>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@URINGMONSTER_DATA@@@std@@QAE@XZ ENDP	; std::allocator<RINGMONSTER_DATA>::allocator<RINGMONSTER_DATA>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@@Z PROC ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Make_iter, COMDAT
; _this$ = ecx

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  : 		return (iterator(_Where._Ptr, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@PAURINGMONSTER_EVENT_TIME@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::_Vector_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 803  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
?_Make_iter@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@@Z ENDP ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Make_iter
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@YAXPAURINGMONSTER_EVENT_TIME@@0AAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@@Z ; std::_Destroy_range<std::allocator<RINGMONSTER_EVENT_TIME> >
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Destroy@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@IAEXPAURINGMONSTER_EVENT_TIME@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@IAEXPAURINGMONSTER_EVENT_TIME@@0@Z PROC ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Destroy, COMDAT
; _this$ = ecx

; 1269 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@YAXPAURINGMONSTER_EVENT_TIME@@0AAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@@Z ; std::_Destroy_range<std::allocator<RINGMONSTER_EVENT_TIME> >
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1271 : 		}

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
?_Destroy@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@IAEXPAURINGMONSTER_EVENT_TIME@@0@Z ENDP ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Destroy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Inside@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@IBE_NPBURINGMONSTER_EVENT_TIME@@@Z
_TEXT	SEGMENT
tv76 = -72						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@IBE_NPBURINGMONSTER_EVENT_TIME@@@Z PROC ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00012	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00015	73 13		 jae	 SHORT $LN3@Inside@2
  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	3b 45 08	 cmp	 eax, DWORD PTR __Ptr$[ebp]
  0001f	77 09		 ja	 SHORT $LN3@Inside@2
  00021	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  00028	eb 07		 jmp	 SHORT $LN4@Inside@2
$LN3@Inside@2:
  0002a	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN4@Inside@2:
  00031	8a 45 b8	 mov	 al, BYTE PTR tv76[ebp]

; 1287 : 		}

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?_Inside@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@IBE_NPBURINGMONSTER_EVENT_TIME@@@Z ENDP ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Inside
_TEXT	ENDS
PUBLIC	?reserve@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAEXI@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::reserve
PUBLIC	?_Grow_to@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@IBEII@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Grow_to
PUBLIC	?capacity@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::capacity
PUBLIC	?_Xlen@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@IBEXXZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Xlen
PUBLIC	?max_size@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::max_size
PUBLIC	?size@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::size
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Reserve@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$ = -8						; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@IAEXI@Z PROC ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1291 : 		size_type _Size = size();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?size@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::size
  00014	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax

; 1292 : 		if (max_size() - _Count < _Size)

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::max_size
  0001f	2b 45 08	 sub	 eax, DWORD PTR __Count$[ebp]
  00022	3b 45 f8	 cmp	 eax, DWORD PTR __Size$[ebp]
  00025	73 0a		 jae	 SHORT $LN4@Reserve@2

; 1293 : 			_Xlen();

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Xlen@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@IBEXXZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Xlen
  0002f	eb 2d		 jmp	 SHORT $LN6@Reserve@2
$LN4@Reserve@2:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00031	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  00034	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]
  00037	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?capacity@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::capacity
  00042	39 45 f8	 cmp	 DWORD PTR __Size$[ebp], eax
  00045	77 02		 ja	 SHORT $LN2@Reserve@2

; 1295 : 			;
; 1296 : 		else

  00047	eb 15		 jmp	 SHORT $LN6@Reserve@2
$LN2@Reserve@2:

; 1297 : 			reserve(_Grow_to(_Size));

  00049	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?_Grow_to@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@IBEII@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Grow_to
  00055	50		 push	 eax
  00056	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ?reserve@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAEXI@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::reserve
$LN6@Reserve@2:

; 1298 : 		}

  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?_Reserve@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@IAEXI@Z ENDP ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Reserve
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXPAURINGMONSTER_EVENT_TIME@@I@Z ; std::allocator<RINGMONSTER_EVENT_TIME>::deallocate
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Tidy@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@IAEXXZ PROC ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1302 : 		if (this->_Myfirst != 0)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00012	74 3d		 je	 SHORT $LN1@Tidy@2

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00022	51		 push	 ecx
  00023	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00026	8b 02		 mov	 eax, DWORD PTR [edx]
  00028	50		 push	 eax
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?_Destroy@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@IAEXPAURINGMONSTER_EVENT_TIME@@0@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Destroy

; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0003a	2b 11		 sub	 edx, DWORD PTR [ecx]
  0003c	c1 fa 03	 sar	 edx, 3
  0003f	52		 push	 edx
  00040	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b 08		 mov	 ecx, DWORD PTR [eax]
  00045	51		 push	 ecx
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0004c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXPAURINGMONSTER_EVENT_TIME@@I@Z ; std::allocator<RINGMONSTER_EVENT_TIME>::deallocate
$LN1@Tidy@2:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00051	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00054	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1310 : 		this->_Mylast = 0;

  0005a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1311 : 		this->_Myend = 0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 1312 : 		}

  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
?_Tidy@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@IAEXXZ ENDP ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Tidy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Orphan_range@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@IBEXPAURINGMONSTER_EVENT_TIME@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@IBEXPAURINGMONSTER_EVENT_TIME@@0@Z PROC ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1453 : 		{	// orphan iterators within specified (inclusive) range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1454 : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?_Orphan_range@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@IBEXPAURINGMONSTER_EVENT_TIME@@0@Z ENDP ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??0?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAE@ABV01@@Z ; std::allocator<RINGMONSTER_EVENT_TIME>::allocator<RINGMONSTER_EVENT_TIME>
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@V?$allocator@URINGMONSTER_EVENT_TIME@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@V?$allocator@URINGMONSTER_EVENT_TIME@@@1@@Z PROC ; std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00016	e8 00 00 00 00	 call	 ??0?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAE@ABV01@@Z ; std::allocator<RINGMONSTER_EVENT_TIME>::allocator<RINGMONSTER_EVENT_TIME>

; 427  : 		_Myfirst = 0;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 428  : 		_Mylast = 0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 429  : 		_Myend = 0;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 430  : 		}

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
??0?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@V?$allocator@URINGMONSTER_EVENT_TIME@@@1@@Z ENDP ; std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::~_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >, COMDAT
; _this$ = ecx

; 433  : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 434  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::~_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAE@XZ PROC ; std::allocator<RINGMONSTER_EVENT_TIME>::allocator<RINGMONSTER_EVENT_TIME>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAE@XZ ENDP ; std::allocator<RINGMONSTER_EVENT_TIME>::allocator<RINGMONSTER_EVENT_TIME>
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QAE@PAURINGMONSTER_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QAE@PAURINGMONSTER_DATA@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QAE@PAURINGMONSTER_DATA@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >::_Vector_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QAE@PAURINGMONSTER_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >

; 305  : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QAE@PAURINGMONSTER_DATA@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >::_Vector_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >::operator++
; Function compile flags: /Odtp /ZI
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >::operator++, COMDAT
; _this$ = ecx

; 331  : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 332  : 		++*(_Mybase *)this;

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??E?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >::operator++

; 333  : 		return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 334  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??E?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >::operator++
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QBEABURINGMONSTER_DATA@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QBEABURINGMONSTER_DATA@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >::operator*, COMDAT
; _this$ = ecx

; 63   : 		{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
$LN2@operator:

; 64   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 65   : 		if (this->_Getcont() == 0
; 66   : 			|| this->_Ptr == 0
; 67   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 68   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 69   : 			{	// report error
; 70   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 71   : 			_SCL_SECURE_OUT_OF_RANGE;
; 72   : 			}
; 73   : 
; 74   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 75   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 76   : 		_SCL_SECURE_VALIDATE_RANGE(
; 77   : 			this->_Ptr != 0
; 78   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 79   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 80   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 81   : 
; 82   : 		__analysis_assume(this->_Ptr != 0);

  0000c	33 c0		 xor	 eax, eax
  0000e	75 fc		 jne	 SHORT $LN2@operator

; 83   : 
; 84   : 		return (*this->_Ptr);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 00		 mov	 eax, DWORD PTR [eax]

; 85   : 		}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QBEABURINGMONSTER_DATA@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >::operator*
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >::_Compat
; Function compile flags: /Odtp /ZI
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		_Compat(_Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >::_Compat

; 203  : 		return (this->_Ptr == _Right._Ptr);

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001e	8b 10		 mov	 edx, DWORD PTR [eax]
  00020	33 c0		 xor	 eax, eax
  00022	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00024	0f 94 c0	 sete	 al

; 204  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >::operator==
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@PAURINGMONSTER_EVENT_TIME@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@PAURINGMONSTER_EVENT_TIME@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@PAURINGMONSTER_EVENT_TIME@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::_Vector_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@PAURINGMONSTER_EVENT_TIME@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >

; 305  : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@PAURINGMONSTER_EVENT_TIME@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::_Vector_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::operator++
; Function compile flags: /Odtp /ZI
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::operator++, COMDAT
; _this$ = ecx

; 331  : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 332  : 		++*(_Mybase *)this;

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??E?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::operator++

; 333  : 		return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 334  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??E?$_Vector_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::operator++
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >, COMDAT
; _this$ = ecx

; 40   : 		{	// construct with null pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 41   : 		}

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEABURINGMONSTER_EVENT_TIME@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEABURINGMONSTER_EVENT_TIME@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::operator*, COMDAT
; _this$ = ecx

; 63   : 		{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
$LN2@operator@2:

; 64   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 65   : 		if (this->_Getcont() == 0
; 66   : 			|| this->_Ptr == 0
; 67   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 68   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 69   : 			{	// report error
; 70   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 71   : 			_SCL_SECURE_OUT_OF_RANGE;
; 72   : 			}
; 73   : 
; 74   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 75   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 76   : 		_SCL_SECURE_VALIDATE_RANGE(
; 77   : 			this->_Ptr != 0
; 78   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 79   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 80   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 81   : 
; 82   : 		__analysis_assume(this->_Ptr != 0);

  0000c	33 c0		 xor	 eax, eax
  0000e	75 fc		 jne	 SHORT $LN2@operator@2

; 83   : 
; 84   : 		return (*this->_Ptr);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 00		 mov	 eax, DWORD PTR [eax]

; 85   : 		}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEABURINGMONSTER_EVENT_TIME@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::operator*
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::_Compat
; Function compile flags: /Odtp /ZI
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		_Compat(_Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::_Compat

; 203  : 		return (this->_Ptr == _Right._Ptr);

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001e	8b 10		 mov	 edx, DWORD PTR [eax]
  00020	33 c0		 xor	 eax, eax
  00022	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00024	0f 94 c0	 sete	 al

; 204  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::operator==
_TEXT	ENDS
PUBLIC	??$_Umove@PAURINGMONSTER_DATA@@@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@IAEPAURINGMONSTER_DATA@@PAU2@00@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Umove<RINGMONSTER_DATA *>
PUBLIC	?allocate@?$allocator@URINGMONSTER_DATA@@@std@@QAEPAURINGMONSTER_DATA@@I@Z ; std::allocator<RINGMONSTER_DATA>::allocate
EXTRN	__CxxThrowException@8:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Size$231502 = -28					; size = 4
__Ptr$231495 = -24					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?reserve@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAEXI@Z PROC ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?reserve@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 747  : 		if (max_size() < _Count)

  0002f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?max_size@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QBEIXZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::max_size
  00037	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0003a	73 0d		 jae	 SHORT $LN5@reserve

; 748  : 			_Xlen();	// result too long

  0003c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Xlen@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@IBEXXZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Xlen
  00044	e9 f0 00 00 00	 jmp	 $LN7@reserve
$LN5@reserve:

; 749  : 		else if (capacity() < _Count)

  00049	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?capacity@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QBEIXZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::capacity
  00051	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  00054	0f 83 df 00 00
	00		 jae	 $LN7@reserve

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  0005a	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00064	e8 00 00 00 00	 call	 ?allocate@?$allocator@URINGMONSTER_DATA@@@std@@QAEPAURINGMONSTER_DATA@@I@Z ; std::allocator<RINGMONSTER_DATA>::allocate
  00069	89 45 e8	 mov	 DWORD PTR __Ptr$231495[ebp], eax

; 752  : 
; 753  : 			_TRY_BEGIN

  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00073	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$231495[ebp]
  00076	50		 push	 eax
  00077	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007d	52		 push	 edx
  0007e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 08		 mov	 ecx, DWORD PTR [eax]
  00083	51		 push	 ecx
  00084	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	e8 00 00 00 00	 call	 ??$_Umove@PAURINGMONSTER_DATA@@@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@IAEPAURINGMONSTER_DATA@@PAU2@00@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Umove<RINGMONSTER_DATA *>
  0008c	eb 29		 jmp	 SHORT $LN8@reserve
__catch$?reserve@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  0008e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00091	50		 push	 eax
  00092	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$231495[ebp]
  00095	51		 push	 ecx
  00096	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0009c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@URINGMONSTER_DATA@@@std@@QAEXPAURINGMONSTER_DATA@@I@Z ; std::allocator<RINGMONSTER_DATA>::deallocate

; 757  : 			_RERAISE;

  000a1	6a 00		 push	 0
  000a3	6a 00		 push	 0
  000a5	e8 00 00 00 00	 call	 __CxxThrowException@8

; 758  : 			_CATCH_END

  000aa	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000b1	b8 00 00 00 00	 mov	 eax, __tryend$?reserve@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAEXI@Z$1
  000b6	c3		 ret	 0
$LN8@reserve:
  000b7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?reserve@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAEXI@Z$1:

; 759  : 
; 760  : 			size_type _Size = size();

  000be	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	e8 00 00 00 00	 call	 ?size@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QBEIXZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::size
  000c6	89 45 e4	 mov	 DWORD PTR __Size$231502[ebp], eax

; 761  : 			if (this->_Myfirst != 0)

  000c9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000cc	83 38 00	 cmp	 DWORD PTR [eax], 0
  000cf	74 3a		 je	 SHORT $LN1@reserve

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);

  000d1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d7	51		 push	 ecx
  000d8	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000db	8b 02		 mov	 eax, DWORD PTR [edx]
  000dd	50		 push	 eax
  000de	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	e8 00 00 00 00	 call	 ?_Destroy@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@IAEXPAURINGMONSTER_DATA@@0@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Destroy

; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  000e6	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000ef	2b 01		 sub	 eax, DWORD PTR [ecx]
  000f1	99		 cdq
  000f2	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  000f7	f7 f9		 idiv	 ecx
  000f9	50		 push	 eax
  000fa	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000fd	8b 02		 mov	 eax, DWORD PTR [edx]
  000ff	50		 push	 eax
  00100	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00103	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00106	e8 00 00 00 00	 call	 ?deallocate@?$allocator@URINGMONSTER_DATA@@@std@@QAEXPAURINGMONSTER_DATA@@I@Z ; std::allocator<RINGMONSTER_DATA>::deallocate
$LN1@reserve:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();

  0010b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0010e	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 769  : 			this->_Myend = _Ptr + _Count;

  00113	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00116	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00119	03 45 e8	 add	 eax, DWORD PTR __Ptr$231495[ebp]
  0011c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0011f	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 770  : 			this->_Mylast = _Ptr + _Size;

  00122	8b 45 e4	 mov	 eax, DWORD PTR __Size$231502[ebp]
  00125	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00128	03 45 e8	 add	 eax, DWORD PTR __Ptr$231495[ebp]
  0012b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0012e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 771  : 			this->_Myfirst = _Ptr;

  00131	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00134	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$231495[ebp]
  00137	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@reserve:

; 772  : 			}
; 773  : 		}

  00139	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0013c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00143	59		 pop	 ecx
  00144	5f		 pop	 edi
  00145	5e		 pop	 esi
  00146	5b		 pop	 ebx
  00147	8b e5		 mov	 esp, ebp
  00149	5d		 pop	 ebp
  0014a	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAEXI@Z ENDP ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::reserve
; Function compile flags: /Odtp /ZI
;	COMDAT ?capacity@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?capacity@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QBEIXZ PROC ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::capacity, COMDAT
; _this$ = ecx

; 776  : 		{	// return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	99		 cdq
  00018	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  0001d	f7 f9		 idiv	 ecx

; 778  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?capacity@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::capacity
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?size@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QBEIXZ PROC ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::size, COMDAT
; _this$ = ecx

; 878  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	99		 cdq
  00018	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  0001d	f7 f9		 idiv	 ecx

; 880  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?size@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@URINGMONSTER_DATA@@@std@@QBEIXZ ; std::allocator<RINGMONSTER_DATA>::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?max_size@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QBEIXZ PROC ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::max_size, COMDAT
; _this$ = ecx

; 883  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		return (this->_Alval.max_size());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00012	e8 00 00 00 00	 call	 ?max_size@?$allocator@URINGMONSTER_DATA@@@std@@QBEIXZ ; std::allocator<RINGMONSTER_DATA>::max_size

; 885  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?max_size@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::max_size
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Grow_to@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -76						; size = 4
__Capacity$ = -8					; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@IBEII@Z PROC ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1275 : 		size_type _Capacity = capacity();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?capacity@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QBEIXZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::capacity
  00014	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QBEIXZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::max_size
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  00022	d1 e9		 shr	 ecx, 1
  00024	2b c1		 sub	 eax, ecx
  00026	3b 45 f8	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  00029	73 09		 jae	 SHORT $LN4@Grow_to
  0002b	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  00032	eb 0b		 jmp	 SHORT $LN5@Grow_to
$LN4@Grow_to:
  00034	8b 55 f8	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00037	d1 ea		 shr	 edx, 1
  00039	03 55 f8	 add	 edx, DWORD PTR __Capacity$[ebp]
  0003c	89 55 b4	 mov	 DWORD PTR tv73[ebp], edx
$LN5@Grow_to:
  0003f	8b 45 b4	 mov	 eax, DWORD PTR tv73[ebp]
  00042	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1279 : 		if (_Capacity < _Count)

  00045	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00048	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0004b	73 06		 jae	 SHORT $LN1@Grow_to

; 1280 : 			_Capacity = _Count;

  0004d	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00050	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax
$LN1@Grow_to:

; 1281 : 		return (_Capacity);

  00053	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]

; 1282 : 		}

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
?_Grow_to@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@IBEII@Z ENDP ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Grow_to
_TEXT	ENDS
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ?_Xlen@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@IBEXXZ PROC ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Xlen, COMDAT
; _this$ = ecx

; 1426 : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00011	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen:

; 1428 : 		}

  00016	5f		 pop	 edi
  00017	5e		 pop	 esi
  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Xlen@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@IBEXXZ ENDP ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Xlen
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@URINGMONSTER_DATA@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@URINGMONSTER_DATA@@@std@@QAE@ABV01@@Z PROC ; std::allocator<RINGMONSTER_DATA>::allocator<RINGMONSTER_DATA>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$allocator@URINGMONSTER_DATA@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<RINGMONSTER_DATA>::allocator<RINGMONSTER_DATA>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@URINGMONSTER_DATA@@@std@@QAEXPAURINGMONSTER_DATA@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@URINGMONSTER_DATA@@@std@@QAEXPAURINGMONSTER_DATA@@I@Z PROC ; std::allocator<RINGMONSTER_DATA>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 182  : 		::operator delete(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4

; 183  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?deallocate@?$allocator@URINGMONSTER_DATA@@@std@@QAEXPAURINGMONSTER_DATA@@I@Z ENDP ; std::allocator<RINGMONSTER_DATA>::deallocate
_TEXT	ENDS
PUBLIC	??$_Umove@PAURINGMONSTER_EVENT_TIME@@@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@IAEPAURINGMONSTER_EVENT_TIME@@PAU2@00@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Umove<RINGMONSTER_EVENT_TIME *>
PUBLIC	?allocate@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEPAURINGMONSTER_EVENT_TIME@@I@Z ; std::allocator<RINGMONSTER_EVENT_TIME>::allocate
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\vector
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Size$231533 = -28					; size = 4
__Ptr$231526 = -24					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?reserve@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAEXI@Z PROC ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?reserve@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 747  : 		if (max_size() < _Count)

  0002f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?max_size@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::max_size
  00037	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0003a	73 0d		 jae	 SHORT $LN5@reserve@2

; 748  : 			_Xlen();	// result too long

  0003c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Xlen@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@IBEXXZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Xlen
  00044	e9 eb 00 00 00	 jmp	 $LN7@reserve@2
$LN5@reserve@2:

; 749  : 		else if (capacity() < _Count)

  00049	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?capacity@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::capacity
  00051	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  00054	0f 83 da 00 00
	00		 jae	 $LN7@reserve@2

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  0005a	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00064	e8 00 00 00 00	 call	 ?allocate@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEPAURINGMONSTER_EVENT_TIME@@I@Z ; std::allocator<RINGMONSTER_EVENT_TIME>::allocate
  00069	89 45 e8	 mov	 DWORD PTR __Ptr$231526[ebp], eax

; 752  : 
; 753  : 			_TRY_BEGIN

  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00073	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$231526[ebp]
  00076	50		 push	 eax
  00077	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007d	52		 push	 edx
  0007e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 08		 mov	 ecx, DWORD PTR [eax]
  00083	51		 push	 ecx
  00084	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	e8 00 00 00 00	 call	 ??$_Umove@PAURINGMONSTER_EVENT_TIME@@@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@IAEPAURINGMONSTER_EVENT_TIME@@PAU2@00@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Umove<RINGMONSTER_EVENT_TIME *>
  0008c	eb 29		 jmp	 SHORT $LN8@reserve@2
__catch$?reserve@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  0008e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00091	50		 push	 eax
  00092	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$231526[ebp]
  00095	51		 push	 ecx
  00096	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0009c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXPAURINGMONSTER_EVENT_TIME@@I@Z ; std::allocator<RINGMONSTER_EVENT_TIME>::deallocate

; 757  : 			_RERAISE;

  000a1	6a 00		 push	 0
  000a3	6a 00		 push	 0
  000a5	e8 00 00 00 00	 call	 __CxxThrowException@8

; 758  : 			_CATCH_END

  000aa	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000b1	b8 00 00 00 00	 mov	 eax, __tryend$?reserve@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAEXI@Z$1
  000b6	c3		 ret	 0
$LN8@reserve@2:
  000b7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?reserve@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAEXI@Z$1:

; 759  : 
; 760  : 			size_type _Size = size();

  000be	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	e8 00 00 00 00	 call	 ?size@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::size
  000c6	89 45 e4	 mov	 DWORD PTR __Size$231533[ebp], eax

; 761  : 			if (this->_Myfirst != 0)

  000c9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000cc	83 38 00	 cmp	 DWORD PTR [eax], 0
  000cf	74 35		 je	 SHORT $LN1@reserve@2

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);

  000d1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d7	51		 push	 ecx
  000d8	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000db	8b 02		 mov	 eax, DWORD PTR [edx]
  000dd	50		 push	 eax
  000de	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	e8 00 00 00 00	 call	 ?_Destroy@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@IAEXPAURINGMONSTER_EVENT_TIME@@0@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Destroy

; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  000e6	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000ef	2b 11		 sub	 edx, DWORD PTR [ecx]
  000f1	c1 fa 03	 sar	 edx, 3
  000f4	52		 push	 edx
  000f5	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000f8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fa	51		 push	 ecx
  000fb	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000fe	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00101	e8 00 00 00 00	 call	 ?deallocate@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXPAURINGMONSTER_EVENT_TIME@@I@Z ; std::allocator<RINGMONSTER_EVENT_TIME>::deallocate
$LN1@reserve@2:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();

  00106	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 769  : 			this->_Myend = _Ptr + _Count;

  0010e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00111	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$231526[ebp]
  00114	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  00117	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0011a	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 770  : 			this->_Mylast = _Ptr + _Size;

  0011d	8b 45 e4	 mov	 eax, DWORD PTR __Size$231533[ebp]
  00120	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$231526[ebp]
  00123	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  00126	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00129	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 771  : 			this->_Myfirst = _Ptr;

  0012c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0012f	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$231526[ebp]
  00132	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@reserve@2:

; 772  : 			}
; 773  : 		}

  00134	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00137	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0013e	59		 pop	 ecx
  0013f	5f		 pop	 edi
  00140	5e		 pop	 esi
  00141	5b		 pop	 ebx
  00142	8b e5		 mov	 esp, ebp
  00144	5d		 pop	 ebp
  00145	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAEXI@Z ENDP ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::reserve
; Function compile flags: /Odtp /ZI
;	COMDAT ?capacity@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?capacity@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ PROC ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::capacity, COMDAT
; _this$ = ecx

; 776  : 		{	// return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	c1 f8 03	 sar	 eax, 3

; 778  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?capacity@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ ENDP ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::capacity
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?size@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ PROC ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::size, COMDAT
; _this$ = ecx

; 878  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	c1 f8 03	 sar	 eax, 3

; 880  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?size@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ ENDP ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QBEIXZ ; std::allocator<RINGMONSTER_EVENT_TIME>::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?max_size@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ PROC ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::max_size, COMDAT
; _this$ = ecx

; 883  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		return (this->_Alval.max_size());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00012	e8 00 00 00 00	 call	 ?max_size@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QBEIXZ ; std::allocator<RINGMONSTER_EVENT_TIME>::max_size

; 885  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?max_size@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ ENDP ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::max_size
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Grow_to@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -76						; size = 4
__Capacity$ = -8					; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@IBEII@Z PROC ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1275 : 		size_type _Capacity = capacity();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?capacity@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::capacity
  00014	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::max_size
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  00022	d1 e9		 shr	 ecx, 1
  00024	2b c1		 sub	 eax, ecx
  00026	3b 45 f8	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  00029	73 09		 jae	 SHORT $LN4@Grow_to@2
  0002b	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  00032	eb 0b		 jmp	 SHORT $LN5@Grow_to@2
$LN4@Grow_to@2:
  00034	8b 55 f8	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00037	d1 ea		 shr	 edx, 1
  00039	03 55 f8	 add	 edx, DWORD PTR __Capacity$[ebp]
  0003c	89 55 b4	 mov	 DWORD PTR tv73[ebp], edx
$LN5@Grow_to@2:
  0003f	8b 45 b4	 mov	 eax, DWORD PTR tv73[ebp]
  00042	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1279 : 		if (_Capacity < _Count)

  00045	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00048	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0004b	73 06		 jae	 SHORT $LN1@Grow_to@2

; 1280 : 			_Capacity = _Count;

  0004d	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00050	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax
$LN1@Grow_to@2:

; 1281 : 		return (_Capacity);

  00053	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]

; 1282 : 		}

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
?_Grow_to@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@IBEII@Z ENDP ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Grow_to
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@IBEXXZ PROC ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Xlen, COMDAT
; _this$ = ecx

; 1426 : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00011	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen@2:

; 1428 : 		}

  00016	5f		 pop	 edi
  00017	5e		 pop	 esi
  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Xlen@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@IBEXXZ ENDP ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Xlen
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAE@ABV01@@Z PROC ; std::allocator<RINGMONSTER_EVENT_TIME>::allocator<RINGMONSTER_EVENT_TIME>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<RINGMONSTER_EVENT_TIME>::allocator<RINGMONSTER_EVENT_TIME>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXPAURINGMONSTER_EVENT_TIME@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXPAURINGMONSTER_EVENT_TIME@@I@Z PROC ; std::allocator<RINGMONSTER_EVENT_TIME>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 182  : 		::operator delete(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4

; 183  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?deallocate@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXPAURINGMONSTER_EVENT_TIME@@I@Z ENDP ; std::allocator<RINGMONSTER_EVENT_TIME>::deallocate
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QAE@PAURINGMONSTER_DATA@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QAE@PAURINGMONSTER_DATA@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 47   : 		}

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QAE@PAURINGMONSTER_DATA@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >::operator++, COMDAT
; _this$ = ecx

; 93   : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 94   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 95   : 		if (this->_Getcont() == 0
; 96   : 			|| this->_Ptr == 0
; 97   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 98   : 			{	// report error
; 99   : 			_DEBUG_ERROR("vector iterator not incrementable");
; 100  : 			_SCL_SECURE_OUT_OF_RANGE;
; 101  : 			}
; 102  : 
; 103  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 104  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 105  : 		_SCL_SECURE_VALIDATE_RANGE(
; 106  : 			this->_Ptr != 0
; 107  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 108  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 109  : 
; 110  : 		++this->_Ptr;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	89 0a		 mov	 DWORD PTR [edx], ecx

; 111  : 		return (*this);

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 112  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >::operator++
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >::_Compat, COMDAT
; _this$ = ecx

; 252  : 		{	// test for compatible iterator pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 253  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> > >::_Compat
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@PAURINGMONSTER_EVENT_TIME@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@PAURINGMONSTER_EVENT_TIME@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 47   : 		}

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@PAURINGMONSTER_EVENT_TIME@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::operator++, COMDAT
; _this$ = ecx

; 93   : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 94   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 95   : 		if (this->_Getcont() == 0
; 96   : 			|| this->_Ptr == 0
; 97   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 98   : 			{	// report error
; 99   : 			_DEBUG_ERROR("vector iterator not incrementable");
; 100  : 			_SCL_SECURE_OUT_OF_RANGE;
; 101  : 			}
; 102  : 
; 103  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 104  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 105  : 		_SCL_SECURE_VALIDATE_RANGE(
; 106  : 			this->_Ptr != 0
; 107  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 108  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 109  : 
; 110  : 		++this->_Ptr;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	83 c1 08	 add	 ecx, 8
  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	89 0a		 mov	 DWORD PTR [edx], ecx

; 111  : 		return (*this);

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 112  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::operator++
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::_Compat, COMDAT
; _this$ = ecx

; 252  : 		{	// test for compatible iterator pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 253  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> > >::_Compat
_TEXT	ENDS
PUBLIC	??$_Allocate@URINGMONSTER_DATA@@@std@@YAPAURINGMONSTER_DATA@@IPAU1@@Z ; std::_Allocate<RINGMONSTER_DATA>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@URINGMONSTER_DATA@@@std@@QAEPAURINGMONSTER_DATA@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@URINGMONSTER_DATA@@@std@@QAEPAURINGMONSTER_DATA@@I@Z PROC ; std::allocator<RINGMONSTER_DATA>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 187  : 		return (_Allocate(_Count, (pointer)0));

  0000c	6a 00		 push	 0
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Allocate@URINGMONSTER_DATA@@@std@@YAPAURINGMONSTER_DATA@@IPAU1@@Z ; std::_Allocate<RINGMONSTER_DATA>
  00017	83 c4 08	 add	 esp, 8

; 188  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?allocate@?$allocator@URINGMONSTER_DATA@@@std@@QAEPAURINGMONSTER_DATA@@I@Z ENDP ; std::allocator<RINGMONSTER_DATA>::allocate
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@URINGMONSTER_DATA@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -76						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@URINGMONSTER_DATA@@@std@@QBEIXZ PROC ; std::allocator<RINGMONSTER_DATA>::max_size, COMDAT
; _this$ = ecx

; 217  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  0000c	c7 45 f8 55 55
	55 15		 mov	 DWORD PTR __Count$[ebp], 357913941 ; 15555555H

; 219  : 		return (0 < _Count ? _Count : 1);

  00013	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00017	76 08		 jbe	 SHORT $LN3@max_size
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0001c	89 45 b4	 mov	 DWORD PTR tv65[ebp], eax
  0001f	eb 07		 jmp	 SHORT $LN4@max_size
$LN3@max_size:
  00021	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$LN4@max_size:
  00028	8b 45 b4	 mov	 eax, DWORD PTR tv65[ebp]

; 220  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?max_size@?$allocator@URINGMONSTER_DATA@@@std@@QBEIXZ ENDP ; std::allocator<RINGMONSTER_DATA>::max_size
_TEXT	ENDS
PUBLIC	??$_Allocate@URINGMONSTER_EVENT_TIME@@@std@@YAPAURINGMONSTER_EVENT_TIME@@IPAU1@@Z ; std::_Allocate<RINGMONSTER_EVENT_TIME>
; Function compile flags: /Odtp /ZI
;	COMDAT ?allocate@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEPAURINGMONSTER_EVENT_TIME@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEPAURINGMONSTER_EVENT_TIME@@I@Z PROC ; std::allocator<RINGMONSTER_EVENT_TIME>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 187  : 		return (_Allocate(_Count, (pointer)0));

  0000c	6a 00		 push	 0
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Allocate@URINGMONSTER_EVENT_TIME@@@std@@YAPAURINGMONSTER_EVENT_TIME@@IPAU1@@Z ; std::_Allocate<RINGMONSTER_EVENT_TIME>
  00017	83 c4 08	 add	 esp, 8

; 188  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?allocate@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEPAURINGMONSTER_EVENT_TIME@@I@Z ENDP ; std::allocator<RINGMONSTER_EVENT_TIME>::allocate
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -76						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QBEIXZ PROC ; std::allocator<RINGMONSTER_EVENT_TIME>::max_size, COMDAT
; _this$ = ecx

; 217  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  0000c	c7 45 f8 ff ff
	ff 1f		 mov	 DWORD PTR __Count$[ebp], 536870911 ; 1fffffffH

; 219  : 		return (0 < _Count ? _Count : 1);

  00013	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00017	76 08		 jbe	 SHORT $LN3@max_size@2
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0001c	89 45 b4	 mov	 DWORD PTR tv65[ebp], eax
  0001f	eb 07		 jmp	 SHORT $LN4@max_size@2
$LN3@max_size@2:
  00021	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$LN4@max_size@2:
  00028	8b 45 b4	 mov	 eax, DWORD PTR tv65[ebp]

; 220  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?max_size@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QBEIXZ ENDP ; std::allocator<RINGMONSTER_EVENT_TIME>::max_size
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$addressof@$$CBURINGMONSTER_DATA@@@std@@YAPBURINGMONSTER_DATA@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBURINGMONSTER_DATA@@@std@@YAPBURINGMONSTER_DATA@@ABU1@@Z PROC ; std::addressof<RINGMONSTER_DATA const >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 111  : 	return ((_Ty *) &(char&)_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@$$CBURINGMONSTER_DATA@@@std@@YAPBURINGMONSTER_DATA@@ABU1@@Z ENDP ; std::addressof<RINGMONSTER_DATA const >
_TEXT	ENDS
PUBLIC	??$construct@AAURINGMONSTER_DATA@@@?$allocator@URINGMONSTER_DATA@@@std@@QAEXPAURINGMONSTER_DATA@@AAU2@@Z ; std::allocator<RINGMONSTER_DATA>::construct<RINGMONSTER_DATA &>
PUBLIC	??$forward@AAURINGMONSTER_DATA@@@std@@YAAAURINGMONSTER_DATA@@AAU1@@Z ; std::forward<RINGMONSTER_DATA &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@URINGMONSTER_DATA@@@std@@URINGMONSTER_DATA@@AAU3@@std@@YAXAAV?$allocator@URINGMONSTER_DATA@@@0@PAURINGMONSTER_DATA@@AAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@URINGMONSTER_DATA@@@std@@URINGMONSTER_DATA@@AAU3@@std@@YAXAAV?$allocator@URINGMONSTER_DATA@@@0@PAURINGMONSTER_DATA@@AAU2@@Z PROC ; std::_Cons_val<std::allocator<RINGMONSTER_DATA>,RINGMONSTER_DATA,RINGMONSTER_DATA &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@AAURINGMONSTER_DATA@@@std@@YAAAURINGMONSTER_DATA@@AAU1@@Z ; std::forward<RINGMONSTER_DATA &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ??$construct@AAURINGMONSTER_DATA@@@?$allocator@URINGMONSTER_DATA@@@std@@QAEXPAURINGMONSTER_DATA@@AAU2@@Z ; std::allocator<RINGMONSTER_DATA>::construct<RINGMONSTER_DATA &>

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@URINGMONSTER_DATA@@@std@@URINGMONSTER_DATA@@AAU3@@std@@YAXAAV?$allocator@URINGMONSTER_DATA@@@0@PAURINGMONSTER_DATA@@AAU2@@Z ENDP ; std::_Cons_val<std::allocator<RINGMONSTER_DATA>,RINGMONSTER_DATA,RINGMONSTER_DATA &>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@URINGMONSTER_DATA@@@std@@QAEXPAURINGMONSTER_DATA@@ABU3@@Z ; std::allocator<RINGMONSTER_DATA>::construct
PUBLIC	??$forward@ABURINGMONSTER_DATA@@@std@@YAABURINGMONSTER_DATA@@ABU1@@Z ; std::forward<RINGMONSTER_DATA const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@URINGMONSTER_DATA@@@std@@URINGMONSTER_DATA@@ABU3@@std@@YAXAAV?$allocator@URINGMONSTER_DATA@@@0@PAURINGMONSTER_DATA@@ABU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@URINGMONSTER_DATA@@@std@@URINGMONSTER_DATA@@ABU3@@std@@YAXAAV?$allocator@URINGMONSTER_DATA@@@0@PAURINGMONSTER_DATA@@ABU2@@Z PROC ; std::_Cons_val<std::allocator<RINGMONSTER_DATA>,RINGMONSTER_DATA,RINGMONSTER_DATA const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@ABURINGMONSTER_DATA@@@std@@YAABURINGMONSTER_DATA@@ABU1@@Z ; std::forward<RINGMONSTER_DATA const &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@URINGMONSTER_DATA@@@std@@QAEXPAURINGMONSTER_DATA@@ABU3@@Z ; std::allocator<RINGMONSTER_DATA>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@URINGMONSTER_DATA@@@std@@URINGMONSTER_DATA@@ABU3@@std@@YAXAAV?$allocator@URINGMONSTER_DATA@@@0@PAURINGMONSTER_DATA@@ABU2@@Z ENDP ; std::_Cons_val<std::allocator<RINGMONSTER_DATA>,RINGMONSTER_DATA,RINGMONSTER_DATA const &>
_TEXT	ENDS
PUBLIC	??$_Move@PAURINGMONSTER_DATA@@PAU1@@std@@YAPAURINGMONSTER_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<RINGMONSTER_DATA *,RINGMONSTER_DATA *>
PUBLIC	??$_Ptr_cat@URINGMONSTER_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAURINGMONSTER_DATA@@0@Z ; std::_Ptr_cat<RINGMONSTER_DATA,RINGMONSTER_DATA>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAURINGMONSTER_DATA@@PAU1@@std@@YAPAURINGMONSTER_DATA@@PAU1@00@Z
_TEXT	SEGMENT
$T233153 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAURINGMONSTER_DATA@@PAU1@@std@@YAPAURINGMONSTER_DATA@@PAU1@00@Z PROC ; std::_Move<RINGMONSTER_DATA *,RINGMONSTER_DATA *>, COMDAT

; 2533 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2534 : 	return (_Move(_First, _Last,
; 2535 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@URINGMONSTER_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAURINGMONSTER_DATA@@0@Z ; std::_Ptr_cat<RINGMONSTER_DATA,RINGMONSTER_DATA>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T233153[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T233153[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Move@PAURINGMONSTER_DATA@@PAU1@@std@@YAPAURINGMONSTER_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<RINGMONSTER_DATA *,RINGMONSTER_DATA *>
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 2536 : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Move@PAURINGMONSTER_DATA@@PAU1@@std@@YAPAURINGMONSTER_DATA@@PAU1@00@Z ENDP ; std::_Move<RINGMONSTER_DATA *,RINGMONSTER_DATA *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$addressof@$$CBURINGMONSTER_EVENT_TIME@@@std@@YAPBURINGMONSTER_EVENT_TIME@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBURINGMONSTER_EVENT_TIME@@@std@@YAPBURINGMONSTER_EVENT_TIME@@ABU1@@Z PROC ; std::addressof<RINGMONSTER_EVENT_TIME const >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 111  : 	return ((_Ty *) &(char&)_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@$$CBURINGMONSTER_EVENT_TIME@@@std@@YAPBURINGMONSTER_EVENT_TIME@@ABU1@@Z ENDP ; std::addressof<RINGMONSTER_EVENT_TIME const >
_TEXT	ENDS
PUBLIC	??$construct@AAURINGMONSTER_EVENT_TIME@@@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXPAURINGMONSTER_EVENT_TIME@@AAU2@@Z ; std::allocator<RINGMONSTER_EVENT_TIME>::construct<RINGMONSTER_EVENT_TIME &>
PUBLIC	??$forward@AAURINGMONSTER_EVENT_TIME@@@std@@YAAAURINGMONSTER_EVENT_TIME@@AAU1@@Z ; std::forward<RINGMONSTER_EVENT_TIME &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@URINGMONSTER_EVENT_TIME@@AAU3@@std@@YAXAAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@PAURINGMONSTER_EVENT_TIME@@AAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@URINGMONSTER_EVENT_TIME@@AAU3@@std@@YAXAAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@PAURINGMONSTER_EVENT_TIME@@AAU2@@Z PROC ; std::_Cons_val<std::allocator<RINGMONSTER_EVENT_TIME>,RINGMONSTER_EVENT_TIME,RINGMONSTER_EVENT_TIME &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@AAURINGMONSTER_EVENT_TIME@@@std@@YAAAURINGMONSTER_EVENT_TIME@@AAU1@@Z ; std::forward<RINGMONSTER_EVENT_TIME &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ??$construct@AAURINGMONSTER_EVENT_TIME@@@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXPAURINGMONSTER_EVENT_TIME@@AAU2@@Z ; std::allocator<RINGMONSTER_EVENT_TIME>::construct<RINGMONSTER_EVENT_TIME &>

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@URINGMONSTER_EVENT_TIME@@AAU3@@std@@YAXAAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@PAURINGMONSTER_EVENT_TIME@@AAU2@@Z ENDP ; std::_Cons_val<std::allocator<RINGMONSTER_EVENT_TIME>,RINGMONSTER_EVENT_TIME,RINGMONSTER_EVENT_TIME &>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXPAURINGMONSTER_EVENT_TIME@@ABU3@@Z ; std::allocator<RINGMONSTER_EVENT_TIME>::construct
PUBLIC	??$forward@ABURINGMONSTER_EVENT_TIME@@@std@@YAABURINGMONSTER_EVENT_TIME@@ABU1@@Z ; std::forward<RINGMONSTER_EVENT_TIME const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@URINGMONSTER_EVENT_TIME@@ABU3@@std@@YAXAAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@PAURINGMONSTER_EVENT_TIME@@ABU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@URINGMONSTER_EVENT_TIME@@ABU3@@std@@YAXAAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@PAURINGMONSTER_EVENT_TIME@@ABU2@@Z PROC ; std::_Cons_val<std::allocator<RINGMONSTER_EVENT_TIME>,RINGMONSTER_EVENT_TIME,RINGMONSTER_EVENT_TIME const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@ABURINGMONSTER_EVENT_TIME@@@std@@YAABURINGMONSTER_EVENT_TIME@@ABU1@@Z ; std::forward<RINGMONSTER_EVENT_TIME const &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXPAURINGMONSTER_EVENT_TIME@@ABU3@@Z ; std::allocator<RINGMONSTER_EVENT_TIME>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@URINGMONSTER_EVENT_TIME@@ABU3@@std@@YAXAAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@PAURINGMONSTER_EVENT_TIME@@ABU2@@Z ENDP ; std::_Cons_val<std::allocator<RINGMONSTER_EVENT_TIME>,RINGMONSTER_EVENT_TIME,RINGMONSTER_EVENT_TIME const &>
_TEXT	ENDS
PUBLIC	??$_Move@PAURINGMONSTER_EVENT_TIME@@PAU1@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<RINGMONSTER_EVENT_TIME *,RINGMONSTER_EVENT_TIME *>
PUBLIC	??$_Ptr_cat@URINGMONSTER_EVENT_TIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAURINGMONSTER_EVENT_TIME@@0@Z ; std::_Ptr_cat<RINGMONSTER_EVENT_TIME,RINGMONSTER_EVENT_TIME>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAURINGMONSTER_EVENT_TIME@@PAU1@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@00@Z
_TEXT	SEGMENT
$T233162 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAURINGMONSTER_EVENT_TIME@@PAU1@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@00@Z PROC ; std::_Move<RINGMONSTER_EVENT_TIME *,RINGMONSTER_EVENT_TIME *>, COMDAT

; 2533 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2534 : 	return (_Move(_First, _Last,
; 2535 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@URINGMONSTER_EVENT_TIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAURINGMONSTER_EVENT_TIME@@0@Z ; std::_Ptr_cat<RINGMONSTER_EVENT_TIME,RINGMONSTER_EVENT_TIME>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T233162[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T233162[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Move@PAURINGMONSTER_EVENT_TIME@@PAU1@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<RINGMONSTER_EVENT_TIME *,RINGMONSTER_EVENT_TIME *>
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 2536 : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Move@PAURINGMONSTER_EVENT_TIME@@PAU1@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@00@Z ENDP ; std::_Move<RINGMONSTER_EVENT_TIME *,RINGMONSTER_EVENT_TIME *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@YAXPAURINGMONSTER_DATA@@0AAV?$allocator@URINGMONSTER_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<RINGMONSTER_DATA> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@YAXPAURINGMONSTER_DATA@@0AAV?$allocator@URINGMONSTER_DATA@@@0@@Z
_TEXT	SEGMENT
$T233165 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@YAXPAURINGMONSTER_DATA@@0AAV?$allocator@URINGMONSTER_DATA@@@0@@Z PROC ; std::_Destroy_range<std::allocator<RINGMONSTER_DATA> >, COMDAT

; 87   : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@URINGMONSTER_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAURINGMONSTER_DATA@@0@Z ; std::_Ptr_cat<RINGMONSTER_DATA,RINGMONSTER_DATA>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T233165[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T233165[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@YAXPAURINGMONSTER_DATA@@0AAV?$allocator@URINGMONSTER_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<RINGMONSTER_DATA> >
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 89   : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Destroy_range@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@YAXPAURINGMONSTER_DATA@@0AAV?$allocator@URINGMONSTER_DATA@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<RINGMONSTER_DATA> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@YAXPAURINGMONSTER_EVENT_TIME@@0AAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<RINGMONSTER_EVENT_TIME> >
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Destroy_range@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@YAXPAURINGMONSTER_EVENT_TIME@@0AAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@@Z
_TEXT	SEGMENT
$T233168 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@YAXPAURINGMONSTER_EVENT_TIME@@0AAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@@Z PROC ; std::_Destroy_range<std::allocator<RINGMONSTER_EVENT_TIME> >, COMDAT

; 87   : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@URINGMONSTER_EVENT_TIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAURINGMONSTER_EVENT_TIME@@0@Z ; std::_Ptr_cat<RINGMONSTER_EVENT_TIME,RINGMONSTER_EVENT_TIME>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T233168[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T233168[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@YAXPAURINGMONSTER_EVENT_TIME@@0AAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<RINGMONSTER_EVENT_TIME> >
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 89   : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Destroy_range@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@YAXPAURINGMONSTER_EVENT_TIME@@0AAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<RINGMONSTER_EVENT_TIME> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAURINGMONSTER_DATA@@PAU1@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@YAPAURINGMONSTER_DATA@@PAU1@00AAV?$allocator@URINGMONSTER_DATA@@@0@@Z ; std::_Uninitialized_move<RINGMONSTER_DATA *,RINGMONSTER_DATA *,std::allocator<RINGMONSTER_DATA> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??$_Umove@PAURINGMONSTER_DATA@@@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@IAEPAURINGMONSTER_DATA@@PAU2@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAURINGMONSTER_DATA@@@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@IAEPAURINGMONSTER_DATA@@PAU2@00@Z PROC ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Umove<RINGMONSTER_DATA *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAURINGMONSTER_DATA@@PAU1@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@YAPAURINGMONSTER_DATA@@PAU1@00AAV?$allocator@URINGMONSTER_DATA@@@0@@Z ; std::_Uninitialized_move<RINGMONSTER_DATA *,RINGMONSTER_DATA *,std::allocator<RINGMONSTER_DATA> >
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 1326 : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAURINGMONSTER_DATA@@@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@IAEPAURINGMONSTER_DATA@@PAU2@00@Z ENDP ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Umove<RINGMONSTER_DATA *>
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAURINGMONSTER_EVENT_TIME@@PAU1@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@00AAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@@Z ; std::_Uninitialized_move<RINGMONSTER_EVENT_TIME *,RINGMONSTER_EVENT_TIME *,std::allocator<RINGMONSTER_EVENT_TIME> >
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Umove@PAURINGMONSTER_EVENT_TIME@@@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@IAEPAURINGMONSTER_EVENT_TIME@@PAU2@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAURINGMONSTER_EVENT_TIME@@@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@IAEPAURINGMONSTER_EVENT_TIME@@PAU2@00@Z PROC ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Umove<RINGMONSTER_EVENT_TIME *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAURINGMONSTER_EVENT_TIME@@PAU1@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@00AAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@@Z ; std::_Uninitialized_move<RINGMONSTER_EVENT_TIME *,RINGMONSTER_EVENT_TIME *,std::allocator<RINGMONSTER_EVENT_TIME> >
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 1326 : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAURINGMONSTER_EVENT_TIME@@@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@IAEPAURINGMONSTER_EVENT_TIME@@PAU2@00@Z ENDP ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Umove<RINGMONSTER_EVENT_TIME *>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Allocate@URINGMONSTER_DATA@@@std@@YAPAURINGMONSTER_DATA@@IPAU1@@Z
_TEXT	SEGMENT
$T233175 = -80						; size = 12
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@URINGMONSTER_DATA@@@std@@YAPAURINGMONSTER_DATA@@IPAU1@@Z PROC ; std::_Allocate<RINGMONSTER_DATA>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 31   : 	void *_Ptr = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 32   : 
; 33   : 	if (_Count <= 0)

  00010	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	77 09		 ja	 SHORT $LN4@Allocate

; 34   : 		_Count = 0;

  00016	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __Count$[ebp], 0

; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0001d	eb 39		 jmp	 SHORT $LN3@Allocate
$LN4@Allocate:

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0001f	81 7d 08 55 55
	55 15		 cmp	 DWORD PTR __Count$[ebp], 357913941 ; 15555555H
  00026	77 18		 ja	 SHORT $LN1@Allocate
  00028	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002b	6b c0 0c	 imul	 eax, 12			; 0000000cH
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 fc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0003a	83 7d fc 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  0003e	75 18		 jne	 SHORT $LN3@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00040	6a 00		 push	 0
  00042	8d 4d b0	 lea	 ecx, DWORD PTR $T233175[ebp]
  00045	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0004a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0004f	8d 45 b0	 lea	 eax, DWORD PTR $T233175[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Allocate:

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00058	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 40   : 	}

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
??$_Allocate@URINGMONSTER_DATA@@@std@@YAPAURINGMONSTER_DATA@@IPAU1@@Z ENDP ; std::_Allocate<RINGMONSTER_DATA>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Allocate@URINGMONSTER_EVENT_TIME@@@std@@YAPAURINGMONSTER_EVENT_TIME@@IPAU1@@Z
_TEXT	SEGMENT
$T233178 = -80						; size = 12
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@URINGMONSTER_EVENT_TIME@@@std@@YAPAURINGMONSTER_EVENT_TIME@@IPAU1@@Z PROC ; std::_Allocate<RINGMONSTER_EVENT_TIME>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 31   : 	void *_Ptr = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 32   : 
; 33   : 	if (_Count <= 0)

  00010	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	77 09		 ja	 SHORT $LN4@Allocate@2

; 34   : 		_Count = 0;

  00016	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __Count$[ebp], 0

; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0001d	eb 39		 jmp	 SHORT $LN3@Allocate@2
$LN4@Allocate@2:

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0001f	81 7d 08 ff ff
	ff 1f		 cmp	 DWORD PTR __Count$[ebp], 536870911 ; 1fffffffH
  00026	77 18		 ja	 SHORT $LN1@Allocate@2
  00028	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002b	c1 e0 03	 shl	 eax, 3
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 fc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0003a	83 7d fc 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  0003e	75 18		 jne	 SHORT $LN3@Allocate@2
$LN1@Allocate@2:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00040	6a 00		 push	 0
  00042	8d 4d b0	 lea	 ecx, DWORD PTR $T233178[ebp]
  00045	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0004a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0004f	8d 45 b0	 lea	 eax, DWORD PTR $T233178[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Allocate@2:

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00058	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate@2:

; 40   : 	}

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
??$_Allocate@URINGMONSTER_EVENT_TIME@@@std@@YAPAURINGMONSTER_EVENT_TIME@@IPAU1@@Z ENDP ; std::_Allocate<RINGMONSTER_EVENT_TIME>
_TEXT	ENDS
PUBLIC	??$_Construct@URINGMONSTER_DATA@@ABU1@@std@@YAXPAURINGMONSTER_DATA@@ABU1@@Z ; std::_Construct<RINGMONSTER_DATA,RINGMONSTER_DATA const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ?construct@?$allocator@URINGMONSTER_DATA@@@std@@QAEXPAURINGMONSTER_DATA@@ABU3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@URINGMONSTER_DATA@@@std@@QAEXPAURINGMONSTER_DATA@@ABU3@@Z PROC ; std::allocator<RINGMONSTER_DATA>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 197  : 		_Construct(_Ptr, _Val);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ??$_Construct@URINGMONSTER_DATA@@ABU1@@std@@YAXPAURINGMONSTER_DATA@@ABU1@@Z ; std::_Construct<RINGMONSTER_DATA,RINGMONSTER_DATA const &>
  00019	83 c4 08	 add	 esp, 8

; 198  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
?construct@?$allocator@URINGMONSTER_DATA@@@std@@QAEXPAURINGMONSTER_DATA@@ABU3@@Z ENDP ; std::allocator<RINGMONSTER_DATA>::construct
_TEXT	ENDS
PUBLIC	??$_Construct@URINGMONSTER_EVENT_TIME@@ABU1@@std@@YAXPAURINGMONSTER_EVENT_TIME@@ABU1@@Z ; std::_Construct<RINGMONSTER_EVENT_TIME,RINGMONSTER_EVENT_TIME const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ?construct@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXPAURINGMONSTER_EVENT_TIME@@ABU3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXPAURINGMONSTER_EVENT_TIME@@ABU3@@Z PROC ; std::allocator<RINGMONSTER_EVENT_TIME>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 197  : 		_Construct(_Ptr, _Val);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ??$_Construct@URINGMONSTER_EVENT_TIME@@ABU1@@std@@YAXPAURINGMONSTER_EVENT_TIME@@ABU1@@Z ; std::_Construct<RINGMONSTER_EVENT_TIME,RINGMONSTER_EVENT_TIME const &>
  00019	83 c4 08	 add	 esp, 8

; 198  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
?construct@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXPAURINGMONSTER_EVENT_TIME@@ABU3@@Z ENDP ; std::allocator<RINGMONSTER_EVENT_TIME>::construct
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@AAURINGMONSTER_DATA@@@std@@YAAAURINGMONSTER_DATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAURINGMONSTER_DATA@@@std@@YAAAURINGMONSTER_DATA@@AAU1@@Z PROC ; std::forward<RINGMONSTER_DATA &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAURINGMONSTER_DATA@@@std@@YAAAURINGMONSTER_DATA@@AAU1@@Z ENDP ; std::forward<RINGMONSTER_DATA &>
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??2@YAPAXIPAX@Z					; operator new
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$construct@AAURINGMONSTER_DATA@@@?$allocator@URINGMONSTER_DATA@@@std@@QAEXPAURINGMONSTER_DATA@@AAU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@AAURINGMONSTER_DATA@@@?$allocator@URINGMONSTER_DATA@@@std@@QAEXPAURINGMONSTER_DATA@@AAU2@@Z$0
__ehfuncinfo$??$construct@AAURINGMONSTER_DATA@@@?$allocator@URINGMONSTER_DATA@@@std@@QAEXPAURINGMONSTER_DATA@@AAU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@AAURINGMONSTER_DATA@@@?$allocator@URINGMONSTER_DATA@@@std@@QAEXPAURINGMONSTER_DATA@@AAU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$construct@AAURINGMONSTER_DATA@@@?$allocator@URINGMONSTER_DATA@@@std@@QAEXPAURINGMONSTER_DATA@@AAU2@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T233187 = -88						; size = 4
$T233188 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAURINGMONSTER_DATA@@@?$allocator@URINGMONSTER_DATA@@@std@@QAEXPAURINGMONSTER_DATA@@AAU2@@Z PROC ; std::allocator<RINGMONSTER_DATA>::construct<RINGMONSTER_DATA &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@AAURINGMONSTER_DATA@@@?$allocator@URINGMONSTER_DATA@@@std@@QAEXPAURINGMONSTER_DATA@@AAU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 0c		 push	 12			; 0000000cH
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T233188[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T233188[ebp], 0
  00047	74 27		 je	 SHORT $LN3@construct
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@AAURINGMONSTER_DATA@@@std@@YAAAURINGMONSTER_DATA@@AAU1@@Z ; std::forward<RINGMONSTER_DATA &>
  00052	83 c4 04	 add	 esp, 4
  00055	8b 55 ac	 mov	 edx, DWORD PTR $T233188[ebp]
  00058	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005a	89 0a		 mov	 DWORD PTR [edx], ecx
  0005c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005f	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00062	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00065	89 42 08	 mov	 DWORD PTR [edx+8], eax
  00068	8b 4d ac	 mov	 ecx, DWORD PTR $T233188[ebp]
  0006b	89 4d a4	 mov	 DWORD PTR tv74[ebp], ecx
  0006e	eb 07		 jmp	 SHORT $LN4@construct
$LN3@construct:
  00070	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct:
  00077	8b 55 a4	 mov	 edx, DWORD PTR tv74[ebp]
  0007a	89 55 a8	 mov	 DWORD PTR $T233187[ebp], edx
  0007d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 209  : 		}

  00084	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00087	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008e	59		 pop	 ecx
  0008f	5f		 pop	 edi
  00090	5e		 pop	 esi
  00091	5b		 pop	 ebx
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@AAURINGMONSTER_DATA@@@?$allocator@URINGMONSTER_DATA@@@std@@QAEXPAURINGMONSTER_DATA@@AAU2@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T233188[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@AAURINGMONSTER_DATA@@@?$allocator@URINGMONSTER_DATA@@@std@@QAEXPAURINGMONSTER_DATA@@AAU2@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@AAURINGMONSTER_DATA@@@?$allocator@URINGMONSTER_DATA@@@std@@QAEXPAURINGMONSTER_DATA@@AAU2@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@AAURINGMONSTER_DATA@@@?$allocator@URINGMONSTER_DATA@@@std@@QAEXPAURINGMONSTER_DATA@@AAU2@@Z ENDP ; std::allocator<RINGMONSTER_DATA>::construct<RINGMONSTER_DATA &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 81   :         {return (_Where); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 83   :         {return; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@ABURINGMONSTER_DATA@@@std@@YAABURINGMONSTER_DATA@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABURINGMONSTER_DATA@@@std@@YAABURINGMONSTER_DATA@@ABU1@@Z PROC ; std::forward<RINGMONSTER_DATA const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@ABURINGMONSTER_DATA@@@std@@YAABURINGMONSTER_DATA@@ABU1@@Z ENDP ; std::forward<RINGMONSTER_DATA const &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@URINGMONSTER_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAURINGMONSTER_DATA@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@URINGMONSTER_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAURINGMONSTER_DATA@@0@Z PROC ; std::_Ptr_cat<RINGMONSTER_DATA,RINGMONSTER_DATA>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00009	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Ptr_cat@URINGMONSTER_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAURINGMONSTER_DATA@@0@Z ENDP ; std::_Ptr_cat<RINGMONSTER_DATA,RINGMONSTER_DATA>
_TEXT	ENDS
PUBLIC	??$move@AAURINGMONSTER_DATA@@@std@@YA$$QAURINGMONSTER_DATA@@AAU1@@Z ; std::move<RINGMONSTER_DATA &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Move@PAURINGMONSTER_DATA@@PAU1@@std@@YAPAURINGMONSTER_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAURINGMONSTER_DATA@@PAU1@@std@@YAPAURINGMONSTER_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<RINGMONSTER_DATA *,RINGMONSTER_DATA *>, COMDAT

; 2512 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2513 : 	for (; _First != _Last; ++_Dest, ++_First)

  00009	eb 12		 jmp	 SHORT $LN3@Move@2
$LN2@Move@2:
  0000b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000e	83 c0 0c	 add	 eax, 12			; 0000000cH
  00011	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00017	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0001a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN3@Move@2:
  0001d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00020	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00023	74 21		 je	 SHORT $LN1@Move@2

; 2514 : 		*_Dest = _STD move(*_First);

  00025	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??$move@AAURINGMONSTER_DATA@@@std@@YA$$QAURINGMONSTER_DATA@@AAU1@@Z ; std::move<RINGMONSTER_DATA &>
  0002e	83 c4 04	 add	 esp, 4
  00031	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00034	8b 10		 mov	 edx, DWORD PTR [eax]
  00036	89 11		 mov	 DWORD PTR [ecx], edx
  00038	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0003b	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0003e	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00041	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00044	eb c5		 jmp	 SHORT $LN2@Move@2
$LN1@Move@2:

; 2515 : 	return (_Dest);

  00046	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 2516 : 	}

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
??$_Move@PAURINGMONSTER_DATA@@PAU1@@std@@YAPAURINGMONSTER_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<RINGMONSTER_DATA *,RINGMONSTER_DATA *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@AAURINGMONSTER_EVENT_TIME@@@std@@YAAAURINGMONSTER_EVENT_TIME@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAURINGMONSTER_EVENT_TIME@@@std@@YAAAURINGMONSTER_EVENT_TIME@@AAU1@@Z PROC ; std::forward<RINGMONSTER_EVENT_TIME &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAURINGMONSTER_EVENT_TIME@@@std@@YAAAURINGMONSTER_EVENT_TIME@@AAU1@@Z ENDP ; std::forward<RINGMONSTER_EVENT_TIME &>
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$construct@AAURINGMONSTER_EVENT_TIME@@@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXPAURINGMONSTER_EVENT_TIME@@AAU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@AAURINGMONSTER_EVENT_TIME@@@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXPAURINGMONSTER_EVENT_TIME@@AAU2@@Z$0
__ehfuncinfo$??$construct@AAURINGMONSTER_EVENT_TIME@@@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXPAURINGMONSTER_EVENT_TIME@@AAU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@AAURINGMONSTER_EVENT_TIME@@@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXPAURINGMONSTER_EVENT_TIME@@AAU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$construct@AAURINGMONSTER_EVENT_TIME@@@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXPAURINGMONSTER_EVENT_TIME@@AAU2@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T233212 = -88						; size = 4
$T233213 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAURINGMONSTER_EVENT_TIME@@@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXPAURINGMONSTER_EVENT_TIME@@AAU2@@Z PROC ; std::allocator<RINGMONSTER_EVENT_TIME>::construct<RINGMONSTER_EVENT_TIME &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@AAURINGMONSTER_EVENT_TIME@@@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXPAURINGMONSTER_EVENT_TIME@@AAU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 08		 push	 8
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T233213[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T233213[ebp], 0
  00047	74 21		 je	 SHORT $LN3@construct@2
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@AAURINGMONSTER_EVENT_TIME@@@std@@YAAAURINGMONSTER_EVENT_TIME@@AAU1@@Z ; std::forward<RINGMONSTER_EVENT_TIME &>
  00052	83 c4 04	 add	 esp, 4
  00055	8b 10		 mov	 edx, DWORD PTR [eax]
  00057	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005a	8b 4d ac	 mov	 ecx, DWORD PTR $T233213[ebp]
  0005d	89 11		 mov	 DWORD PTR [ecx], edx
  0005f	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00062	8b 55 ac	 mov	 edx, DWORD PTR $T233213[ebp]
  00065	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  00068	eb 07		 jmp	 SHORT $LN4@construct@2
$LN3@construct@2:
  0006a	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct@2:
  00071	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00074	89 45 a8	 mov	 DWORD PTR $T233212[ebp], eax
  00077	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 209  : 		}

  0007e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00081	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00088	59		 pop	 ecx
  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@AAURINGMONSTER_EVENT_TIME@@@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXPAURINGMONSTER_EVENT_TIME@@AAU2@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T233213[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@AAURINGMONSTER_EVENT_TIME@@@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXPAURINGMONSTER_EVENT_TIME@@AAU2@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@AAURINGMONSTER_EVENT_TIME@@@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXPAURINGMONSTER_EVENT_TIME@@AAU2@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@AAURINGMONSTER_EVENT_TIME@@@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXPAURINGMONSTER_EVENT_TIME@@AAU2@@Z ENDP ; std::allocator<RINGMONSTER_EVENT_TIME>::construct<RINGMONSTER_EVENT_TIME &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@ABURINGMONSTER_EVENT_TIME@@@std@@YAABURINGMONSTER_EVENT_TIME@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABURINGMONSTER_EVENT_TIME@@@std@@YAABURINGMONSTER_EVENT_TIME@@ABU1@@Z PROC ; std::forward<RINGMONSTER_EVENT_TIME const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@ABURINGMONSTER_EVENT_TIME@@@std@@YAABURINGMONSTER_EVENT_TIME@@ABU1@@Z ENDP ; std::forward<RINGMONSTER_EVENT_TIME const &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@URINGMONSTER_EVENT_TIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAURINGMONSTER_EVENT_TIME@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@URINGMONSTER_EVENT_TIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAURINGMONSTER_EVENT_TIME@@0@Z PROC ; std::_Ptr_cat<RINGMONSTER_EVENT_TIME,RINGMONSTER_EVENT_TIME>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00009	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Ptr_cat@URINGMONSTER_EVENT_TIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAURINGMONSTER_EVENT_TIME@@0@Z ENDP ; std::_Ptr_cat<RINGMONSTER_EVENT_TIME,RINGMONSTER_EVENT_TIME>
_TEXT	ENDS
PUBLIC	??$move@AAURINGMONSTER_EVENT_TIME@@@std@@YA$$QAURINGMONSTER_EVENT_TIME@@AAU1@@Z ; std::move<RINGMONSTER_EVENT_TIME &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Move@PAURINGMONSTER_EVENT_TIME@@PAU1@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAURINGMONSTER_EVENT_TIME@@PAU1@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<RINGMONSTER_EVENT_TIME *,RINGMONSTER_EVENT_TIME *>, COMDAT

; 2512 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2513 : 	for (; _First != _Last; ++_Dest, ++_First)

  00009	eb 12		 jmp	 SHORT $LN3@Move@3
$LN2@Move@3:
  0000b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000e	83 c0 08	 add	 eax, 8
  00011	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00017	83 c1 08	 add	 ecx, 8
  0001a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN3@Move@3:
  0001d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00020	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00023	74 1b		 je	 SHORT $LN1@Move@3

; 2514 : 		*_Dest = _STD move(*_First);

  00025	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??$move@AAURINGMONSTER_EVENT_TIME@@@std@@YA$$QAURINGMONSTER_EVENT_TIME@@AAU1@@Z ; std::move<RINGMONSTER_EVENT_TIME &>
  0002e	83 c4 04	 add	 esp, 4
  00031	8b 08		 mov	 ecx, DWORD PTR [eax]
  00033	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00036	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00039	89 08		 mov	 DWORD PTR [eax], ecx
  0003b	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0003e	eb cb		 jmp	 SHORT $LN2@Move@3
$LN1@Move@3:

; 2515 : 	return (_Dest);

  00040	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 2516 : 	}

  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
??$_Move@PAURINGMONSTER_EVENT_TIME@@PAU1@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<RINGMONSTER_EVENT_TIME *,RINGMONSTER_EVENT_TIME *>
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@URINGMONSTER_DATA@@@std@@URINGMONSTER_DATA@@@std@@YAXAAV?$allocator@URINGMONSTER_DATA@@@0@PAURINGMONSTER_DATA@@@Z ; std::_Dest_val<std::allocator<RINGMONSTER_DATA>,RINGMONSTER_DATA>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@YAXPAURINGMONSTER_DATA@@0AAV?$allocator@URINGMONSTER_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@YAXPAURINGMONSTER_DATA@@0AAV?$allocator@URINGMONSTER_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<RINGMONSTER_DATA> >, COMDAT

; 95   : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 96   : 	for (; _First != _Last; ++_First)

  00009	eb 09		 jmp	 SHORT $LN3@Destroy_ra
$LN2@Destroy_ra:
  0000b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000e	83 c0 0c	 add	 eax, 12			; 0000000cH
  00011	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra:
  00014	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00017	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0001a	74 12		 je	 SHORT $LN4@Destroy_ra

; 97   : 		_Dest_val(_Al, _First);

  0001c	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@URINGMONSTER_DATA@@@std@@URINGMONSTER_DATA@@@std@@YAXAAV?$allocator@URINGMONSTER_DATA@@@0@PAURINGMONSTER_DATA@@@Z ; std::_Dest_val<std::allocator<RINGMONSTER_DATA>,RINGMONSTER_DATA>
  00029	83 c4 08	 add	 esp, 8
  0002c	eb dd		 jmp	 SHORT $LN2@Destroy_ra
$LN4@Destroy_ra:

; 98   : 	}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$_Destroy_range@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@YAXPAURINGMONSTER_DATA@@0AAV?$allocator@URINGMONSTER_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<RINGMONSTER_DATA> >
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@URINGMONSTER_EVENT_TIME@@@std@@YAXAAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@PAURINGMONSTER_EVENT_TIME@@@Z ; std::_Dest_val<std::allocator<RINGMONSTER_EVENT_TIME>,RINGMONSTER_EVENT_TIME>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Destroy_range@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@YAXPAURINGMONSTER_EVENT_TIME@@0AAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@YAXPAURINGMONSTER_EVENT_TIME@@0AAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<RINGMONSTER_EVENT_TIME> >, COMDAT

; 95   : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 96   : 	for (; _First != _Last; ++_First)

  00009	eb 09		 jmp	 SHORT $LN3@Destroy_ra@2
$LN2@Destroy_ra@2:
  0000b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000e	83 c0 08	 add	 eax, 8
  00011	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra@2:
  00014	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00017	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0001a	74 12		 je	 SHORT $LN4@Destroy_ra@2

; 97   : 		_Dest_val(_Al, _First);

  0001c	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@URINGMONSTER_EVENT_TIME@@@std@@YAXAAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@PAURINGMONSTER_EVENT_TIME@@@Z ; std::_Dest_val<std::allocator<RINGMONSTER_EVENT_TIME>,RINGMONSTER_EVENT_TIME>
  00029	83 c4 08	 add	 esp, 8
  0002c	eb dd		 jmp	 SHORT $LN2@Destroy_ra@2
$LN4@Destroy_ra@2:

; 98   : 	}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$_Destroy_range@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@YAXPAURINGMONSTER_EVENT_TIME@@0AAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<RINGMONSTER_EVENT_TIME> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAURINGMONSTER_DATA@@PAU1@V?$allocator@URINGMONSTER_DATA@@@std@@U1@@std@@YAPAURINGMONSTER_DATA@@PAU1@00AAV?$allocator@URINGMONSTER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<RINGMONSTER_DATA *,RINGMONSTER_DATA *,std::allocator<RINGMONSTER_DATA>,RINGMONSTER_DATA>
PUBLIC	??$_Val_type@PAURINGMONSTER_DATA@@@std@@YAPAURINGMONSTER_DATA@@PAU1@@Z ; std::_Val_type<RINGMONSTER_DATA *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_move@PAURINGMONSTER_DATA@@PAU1@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@YAPAURINGMONSTER_DATA@@PAU1@00AAV?$allocator@URINGMONSTER_DATA@@@0@@Z
_TEXT	SEGMENT
$T233235 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAURINGMONSTER_DATA@@PAU1@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@YAPAURINGMONSTER_DATA@@PAU1@00AAV?$allocator@URINGMONSTER_DATA@@@0@@Z PROC ; std::_Uninitialized_move<RINGMONSTER_DATA *,RINGMONSTER_DATA *,std::allocator<RINGMONSTER_DATA> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@URINGMONSTER_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAURINGMONSTER_DATA@@0@Z ; std::_Ptr_cat<RINGMONSTER_DATA,RINGMONSTER_DATA>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T233235[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T233235[ebp]
  00020	52		 push	 edx
  00021	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??$_Val_type@PAURINGMONSTER_DATA@@@std@@YAPAURINGMONSTER_DATA@@PAU1@@Z ; std::_Val_type<RINGMONSTER_DATA *>
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00031	51		 push	 ecx
  00032	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00035	52		 push	 edx
  00036	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 ??$_Uninit_move@PAURINGMONSTER_DATA@@PAU1@V?$allocator@URINGMONSTER_DATA@@@std@@U1@@std@@YAPAURINGMONSTER_DATA@@PAU1@00AAV?$allocator@URINGMONSTER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<RINGMONSTER_DATA *,RINGMONSTER_DATA *,std::allocator<RINGMONSTER_DATA>,RINGMONSTER_DATA>
  00043	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
??$_Uninitialized_move@PAURINGMONSTER_DATA@@PAU1@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@YAPAURINGMONSTER_DATA@@PAU1@00AAV?$allocator@URINGMONSTER_DATA@@@0@@Z ENDP ; std::_Uninitialized_move<RINGMONSTER_DATA *,RINGMONSTER_DATA *,std::allocator<RINGMONSTER_DATA> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAURINGMONSTER_EVENT_TIME@@PAU1@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@U1@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@00AAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<RINGMONSTER_EVENT_TIME *,RINGMONSTER_EVENT_TIME *,std::allocator<RINGMONSTER_EVENT_TIME>,RINGMONSTER_EVENT_TIME>
PUBLIC	??$_Val_type@PAURINGMONSTER_EVENT_TIME@@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@@Z ; std::_Val_type<RINGMONSTER_EVENT_TIME *>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Uninitialized_move@PAURINGMONSTER_EVENT_TIME@@PAU1@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@00AAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@@Z
_TEXT	SEGMENT
$T233238 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAURINGMONSTER_EVENT_TIME@@PAU1@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@00AAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@@Z PROC ; std::_Uninitialized_move<RINGMONSTER_EVENT_TIME *,RINGMONSTER_EVENT_TIME *,std::allocator<RINGMONSTER_EVENT_TIME> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@URINGMONSTER_EVENT_TIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAURINGMONSTER_EVENT_TIME@@0@Z ; std::_Ptr_cat<RINGMONSTER_EVENT_TIME,RINGMONSTER_EVENT_TIME>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T233238[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T233238[ebp]
  00020	52		 push	 edx
  00021	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??$_Val_type@PAURINGMONSTER_EVENT_TIME@@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@@Z ; std::_Val_type<RINGMONSTER_EVENT_TIME *>
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00031	51		 push	 ecx
  00032	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00035	52		 push	 edx
  00036	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 ??$_Uninit_move@PAURINGMONSTER_EVENT_TIME@@PAU1@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@U1@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@00AAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<RINGMONSTER_EVENT_TIME *,RINGMONSTER_EVENT_TIME *,std::allocator<RINGMONSTER_EVENT_TIME>,RINGMONSTER_EVENT_TIME>
  00043	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
??$_Uninitialized_move@PAURINGMONSTER_EVENT_TIME@@PAU1@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@00AAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@@Z ENDP ; std::_Uninitialized_move<RINGMONSTER_EVENT_TIME *,RINGMONSTER_EVENT_TIME *,std::allocator<RINGMONSTER_EVENT_TIME> >
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$_Construct@URINGMONSTER_DATA@@ABU1@@std@@YAXPAURINGMONSTER_DATA@@ABU1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@URINGMONSTER_DATA@@ABU1@@std@@YAXPAURINGMONSTER_DATA@@ABU1@@Z$0
__ehfuncinfo$??$_Construct@URINGMONSTER_DATA@@ABU1@@std@@YAXPAURINGMONSTER_DATA@@ABU1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@URINGMONSTER_DATA@@ABU1@@std@@YAXPAURINGMONSTER_DATA@@ABU1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Construct@URINGMONSTER_DATA@@ABU1@@std@@YAXPAURINGMONSTER_DATA@@ABU1@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T233241 = -88						; size = 4
$T233242 = -84						; size = 4
__Vptr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@URINGMONSTER_DATA@@ABU1@@std@@YAXPAURINGMONSTER_DATA@@ABU1@@Z PROC ; std::_Construct<RINGMONSTER_DATA,RINGMONSTER_DATA const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Construct@URINGMONSTER_DATA@@ABU1@@std@@YAXPAURINGMONSTER_DATA@@ABU1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 47   : 	void _FARQ *_Vptr = _Ptr;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002b	89 45 f0	 mov	 DWORD PTR __Vptr$[ebp], eax

; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  0002e	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00031	50		 push	 eax
  00032	6a 0c		 push	 12			; 0000000cH
  00034	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00039	83 c4 08	 add	 esp, 8
  0003c	89 45 ac	 mov	 DWORD PTR $T233242[ebp], eax
  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00046	83 7d ac 00	 cmp	 DWORD PTR $T233242[ebp], 0
  0004a	74 27		 je	 SHORT $LN3@Construct
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ??$forward@ABURINGMONSTER_DATA@@@std@@YAABURINGMONSTER_DATA@@ABU1@@Z ; std::forward<RINGMONSTER_DATA const &>
  00055	83 c4 04	 add	 esp, 4
  00058	8b 55 ac	 mov	 edx, DWORD PTR $T233242[ebp]
  0005b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005d	89 0a		 mov	 DWORD PTR [edx], ecx
  0005f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00062	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00065	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00068	89 42 08	 mov	 DWORD PTR [edx+8], eax
  0006b	8b 4d ac	 mov	 ecx, DWORD PTR $T233242[ebp]
  0006e	89 4d a4	 mov	 DWORD PTR tv74[ebp], ecx
  00071	eb 07		 jmp	 SHORT $LN4@Construct
$LN3@Construct:
  00073	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@Construct:
  0007a	8b 55 a4	 mov	 edx, DWORD PTR tv74[ebp]
  0007d	89 55 a8	 mov	 DWORD PTR $T233241[ebp], edx
  00080	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 49   : 	}

  00087	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0008a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00091	59		 pop	 ecx
  00092	5f		 pop	 edi
  00093	5e		 pop	 esi
  00094	5b		 pop	 ebx
  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@URINGMONSTER_DATA@@ABU1@@std@@YAXPAURINGMONSTER_DATA@@ABU1@@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T233242[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Construct@URINGMONSTER_DATA@@ABU1@@std@@YAXPAURINGMONSTER_DATA@@ABU1@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Construct@URINGMONSTER_DATA@@ABU1@@std@@YAXPAURINGMONSTER_DATA@@ABU1@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Construct@URINGMONSTER_DATA@@ABU1@@std@@YAXPAURINGMONSTER_DATA@@ABU1@@Z ENDP ; std::_Construct<RINGMONSTER_DATA,RINGMONSTER_DATA const &>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Construct@URINGMONSTER_EVENT_TIME@@ABU1@@std@@YAXPAURINGMONSTER_EVENT_TIME@@ABU1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@URINGMONSTER_EVENT_TIME@@ABU1@@std@@YAXPAURINGMONSTER_EVENT_TIME@@ABU1@@Z$0
__ehfuncinfo$??$_Construct@URINGMONSTER_EVENT_TIME@@ABU1@@std@@YAXPAURINGMONSTER_EVENT_TIME@@ABU1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@URINGMONSTER_EVENT_TIME@@ABU1@@std@@YAXPAURINGMONSTER_EVENT_TIME@@ABU1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Construct@URINGMONSTER_EVENT_TIME@@ABU1@@std@@YAXPAURINGMONSTER_EVENT_TIME@@ABU1@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T233254 = -88						; size = 4
$T233255 = -84						; size = 4
__Vptr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@URINGMONSTER_EVENT_TIME@@ABU1@@std@@YAXPAURINGMONSTER_EVENT_TIME@@ABU1@@Z PROC ; std::_Construct<RINGMONSTER_EVENT_TIME,RINGMONSTER_EVENT_TIME const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Construct@URINGMONSTER_EVENT_TIME@@ABU1@@std@@YAXPAURINGMONSTER_EVENT_TIME@@ABU1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 47   : 	void _FARQ *_Vptr = _Ptr;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002b	89 45 f0	 mov	 DWORD PTR __Vptr$[ebp], eax

; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  0002e	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00031	50		 push	 eax
  00032	6a 08		 push	 8
  00034	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00039	83 c4 08	 add	 esp, 8
  0003c	89 45 ac	 mov	 DWORD PTR $T233255[ebp], eax
  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00046	83 7d ac 00	 cmp	 DWORD PTR $T233255[ebp], 0
  0004a	74 21		 je	 SHORT $LN3@Construct@2
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ??$forward@ABURINGMONSTER_EVENT_TIME@@@std@@YAABURINGMONSTER_EVENT_TIME@@ABU1@@Z ; std::forward<RINGMONSTER_EVENT_TIME const &>
  00055	83 c4 04	 add	 esp, 4
  00058	8b 10		 mov	 edx, DWORD PTR [eax]
  0005a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005d	8b 4d ac	 mov	 ecx, DWORD PTR $T233255[ebp]
  00060	89 11		 mov	 DWORD PTR [ecx], edx
  00062	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00065	8b 55 ac	 mov	 edx, DWORD PTR $T233255[ebp]
  00068	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  0006b	eb 07		 jmp	 SHORT $LN4@Construct@2
$LN3@Construct@2:
  0006d	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@Construct@2:
  00074	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00077	89 45 a8	 mov	 DWORD PTR $T233254[ebp], eax
  0007a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 49   : 	}

  00081	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00084	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008b	59		 pop	 ecx
  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi
  0008e	5b		 pop	 ebx
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@URINGMONSTER_EVENT_TIME@@ABU1@@std@@YAXPAURINGMONSTER_EVENT_TIME@@ABU1@@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T233255[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Construct@URINGMONSTER_EVENT_TIME@@ABU1@@std@@YAXPAURINGMONSTER_EVENT_TIME@@ABU1@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Construct@URINGMONSTER_EVENT_TIME@@ABU1@@std@@YAXPAURINGMONSTER_EVENT_TIME@@ABU1@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Construct@URINGMONSTER_EVENT_TIME@@ABU1@@std@@YAXPAURINGMONSTER_EVENT_TIME@@ABU1@@Z ENDP ; std::_Construct<RINGMONSTER_EVENT_TIME,RINGMONSTER_EVENT_TIME const &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$move@AAURINGMONSTER_DATA@@@std@@YA$$QAURINGMONSTER_DATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAURINGMONSTER_DATA@@@std@@YA$$QAURINGMONSTER_DATA@@AAU1@@Z PROC ; std::move<RINGMONSTER_DATA &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$move@AAURINGMONSTER_DATA@@@std@@YA$$QAURINGMONSTER_DATA@@AAU1@@Z ENDP ; std::move<RINGMONSTER_DATA &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$move@AAURINGMONSTER_EVENT_TIME@@@std@@YA$$QAURINGMONSTER_EVENT_TIME@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAURINGMONSTER_EVENT_TIME@@@std@@YA$$QAURINGMONSTER_EVENT_TIME@@AAU1@@Z PROC ; std::move<RINGMONSTER_EVENT_TIME &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$move@AAURINGMONSTER_EVENT_TIME@@@std@@YA$$QAURINGMONSTER_EVENT_TIME@@AAU1@@Z ENDP ; std::move<RINGMONSTER_EVENT_TIME &>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@URINGMONSTER_DATA@@@std@@QAEXPAURINGMONSTER_DATA@@@Z ; std::allocator<RINGMONSTER_DATA>::destroy
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Dest_val@V?$allocator@URINGMONSTER_DATA@@@std@@URINGMONSTER_DATA@@@std@@YAXAAV?$allocator@URINGMONSTER_DATA@@@0@PAURINGMONSTER_DATA@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@URINGMONSTER_DATA@@@std@@URINGMONSTER_DATA@@@std@@YAXAAV?$allocator@URINGMONSTER_DATA@@@0@PAURINGMONSTER_DATA@@@Z PROC ; std::_Dest_val<std::allocator<RINGMONSTER_DATA>,RINGMONSTER_DATA>, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 287  : 	_Alval.destroy(_Pdest);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  00010	e8 00 00 00 00	 call	 ?destroy@?$allocator@URINGMONSTER_DATA@@@std@@QAEXPAURINGMONSTER_DATA@@@Z ; std::allocator<RINGMONSTER_DATA>::destroy

; 288  : 	}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Dest_val@V?$allocator@URINGMONSTER_DATA@@@std@@URINGMONSTER_DATA@@@std@@YAXAAV?$allocator@URINGMONSTER_DATA@@@0@PAURINGMONSTER_DATA@@@Z ENDP ; std::_Dest_val<std::allocator<RINGMONSTER_DATA>,RINGMONSTER_DATA>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXPAURINGMONSTER_EVENT_TIME@@@Z ; std::allocator<RINGMONSTER_EVENT_TIME>::destroy
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Dest_val@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@URINGMONSTER_EVENT_TIME@@@std@@YAXAAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@PAURINGMONSTER_EVENT_TIME@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@URINGMONSTER_EVENT_TIME@@@std@@YAXAAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@PAURINGMONSTER_EVENT_TIME@@@Z PROC ; std::_Dest_val<std::allocator<RINGMONSTER_EVENT_TIME>,RINGMONSTER_EVENT_TIME>, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 287  : 	_Alval.destroy(_Pdest);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  00010	e8 00 00 00 00	 call	 ?destroy@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXPAURINGMONSTER_EVENT_TIME@@@Z ; std::allocator<RINGMONSTER_EVENT_TIME>::destroy

; 288  : 	}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Dest_val@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@URINGMONSTER_EVENT_TIME@@@std@@YAXAAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@PAURINGMONSTER_EVENT_TIME@@@Z ENDP ; std::_Dest_val<std::allocator<RINGMONSTER_EVENT_TIME>,RINGMONSTER_EVENT_TIME>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Val_type@PAURINGMONSTER_DATA@@@std@@YAPAURINGMONSTER_DATA@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAURINGMONSTER_DATA@@@std@@YAPAURINGMONSTER_DATA@@PAU1@@Z PROC ; std::_Val_type<RINGMONSTER_DATA *>, COMDAT

; 789  : 	{	// return value type from arbitrary argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 790  : 	return (0);

  00009	33 c0		 xor	 eax, eax

; 791  : 	}

  0000b	5f		 pop	 edi
  0000c	5e		 pop	 esi
  0000d	5b		 pop	 ebx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Val_type@PAURINGMONSTER_DATA@@@std@@YAPAURINGMONSTER_DATA@@PAU1@@Z ENDP ; std::_Val_type<RINGMONSTER_DATA *>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@URINGMONSTER_DATA@@@std@@URINGMONSTER_DATA@@U3@@std@@YAXAAV?$allocator@URINGMONSTER_DATA@@@0@PAURINGMONSTER_DATA@@$$QAU2@@Z ; std::_Cons_val<std::allocator<RINGMONSTER_DATA>,RINGMONSTER_DATA,RINGMONSTER_DATA>
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_move@PAURINGMONSTER_DATA@@PAU1@V?$allocator@URINGMONSTER_DATA@@@std@@U1@@std@@YAPAURINGMONSTER_DATA@@PAU1@00AAV?$allocator@URINGMONSTER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_move@PAURINGMONSTER_DATA@@PAU1@V?$allocator@URINGMONSTER_DATA@@@std@@U1@@std@@YAPAURINGMONSTER_DATA@@PAU1@00AAV?$allocator@URINGMONSTER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_move@PAURINGMONSTER_DATA@@PAU1@V?$allocator@URINGMONSTER_DATA@@@std@@U1@@std@@YAPAURINGMONSTER_DATA@@PAU1@00AAV?$allocator@URINGMONSTER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_move@PAURINGMONSTER_DATA@@PAU1@V?$allocator@URINGMONSTER_DATA@@@std@@U1@@std@@YAPAURINGMONSTER_DATA@@PAU1@00AAV?$allocator@URINGMONSTER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_move@PAURINGMONSTER_DATA@@PAU1@V?$allocator@URINGMONSTER_DATA@@@std@@U1@@std@@YAPAURINGMONSTER_DATA@@PAU1@00AAV?$allocator@URINGMONSTER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_move@PAURINGMONSTER_DATA@@PAU1@V?$allocator@URINGMONSTER_DATA@@@std@@U1@@std@@YAPAURINGMONSTER_DATA@@PAU1@00AAV?$allocator@URINGMONSTER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_move@PAURINGMONSTER_DATA@@PAU1@V?$allocator@URINGMONSTER_DATA@@@std@@U1@@std@@YAPAURINGMONSTER_DATA@@PAU1@00AAV?$allocator@URINGMONSTER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_move@PAURINGMONSTER_DATA@@PAU1@V?$allocator@URINGMONSTER_DATA@@@std@@U1@@std@@YAPAURINGMONSTER_DATA@@PAU1@00AAV?$allocator@URINGMONSTER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Uninit_move@PAURINGMONSTER_DATA@@PAU1@V?$allocator@URINGMONSTER_DATA@@@std@@U1@@std@@YAPAURINGMONSTER_DATA@@PAU1@00AAV?$allocator@URINGMONSTER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAURINGMONSTER_DATA@@PAU1@V?$allocator@URINGMONSTER_DATA@@@std@@U1@@std@@YAPAURINGMONSTER_DATA@@PAU1@00AAV?$allocator@URINGMONSTER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<RINGMONSTER_DATA *,RINGMONSTER_DATA *,std::allocator<RINGMONSTER_DATA>,RINGMONSTER_DATA>, COMDAT

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_move@PAURINGMONSTER_DATA@@PAU1@V?$allocator@URINGMONSTER_DATA@@@std@@U1@@std@@YAPAURINGMONSTER_DATA@@PAU1@00AAV?$allocator@URINGMONSTER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 44	 sub	 esp, 68			; 00000044H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;

  0002c	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0002f	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 428  : 
; 429  : 	_TRY_BEGIN

  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00039	eb 12		 jmp	 SHORT $LN6@Uninit_mov
$LN5@Uninit_mov:

; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  0003b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0003e	83 c0 0c	 add	 eax, 12			; 0000000cH
  00041	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00044	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00047	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0004a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN6@Uninit_mov:
  0004d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00050	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00053	74 16		 je	 SHORT $LN4@Uninit_mov

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

  00055	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00058	50		 push	 eax
  00059	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0005c	51		 push	 ecx
  0005d	8b 55 14	 mov	 edx, DWORD PTR __Al$[ebp]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@URINGMONSTER_DATA@@@std@@URINGMONSTER_DATA@@U3@@std@@YAXAAV?$allocator@URINGMONSTER_DATA@@@0@PAURINGMONSTER_DATA@@$$QAU2@@Z ; std::_Cons_val<std::allocator<RINGMONSTER_DATA>,RINGMONSTER_DATA,RINGMONSTER_DATA>
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
  00069	eb d0		 jmp	 SHORT $LN5@Uninit_mov
$LN4@Uninit_mov:
  0006b	eb 3b		 jmp	 SHORT $LN10@Uninit_mov
__catch$??$_Uninit_move@PAURINGMONSTER_DATA@@PAU1@V?$allocator@URINGMONSTER_DATA@@@std@@U1@@std@@YAPAURINGMONSTER_DATA@@PAU1@00AAV?$allocator@URINGMONSTER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 432  : 	_CATCH_ALL

  0006d	eb 09		 jmp	 SHORT $LN3@Uninit_mov
$LN2@Uninit_mov:

; 433  : 	for (; _Next != _Dest; ++_Next)

  0006f	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00072	83 c0 0c	 add	 eax, 12			; 0000000cH
  00075	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax
$LN3@Uninit_mov:
  00078	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  0007b	3b 45 10	 cmp	 eax, DWORD PTR __Dest$[ebp]
  0007e	74 12		 je	 SHORT $LN1@Uninit_mov

; 434  : 		_Dest_val(_Al, _Next);

  00080	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00083	50		 push	 eax
  00084	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@URINGMONSTER_DATA@@@std@@URINGMONSTER_DATA@@@std@@YAXAAV?$allocator@URINGMONSTER_DATA@@@0@PAURINGMONSTER_DATA@@@Z ; std::_Dest_val<std::allocator<RINGMONSTER_DATA>,RINGMONSTER_DATA>
  0008d	83 c4 08	 add	 esp, 8
  00090	eb dd		 jmp	 SHORT $LN2@Uninit_mov
$LN1@Uninit_mov:

; 435  : 	_RERAISE;

  00092	6a 00		 push	 0
  00094	6a 00		 push	 0
  00096	e8 00 00 00 00	 call	 __CxxThrowException@8

; 436  : 	_CATCH_END

  0009b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000a2	b8 00 00 00 00	 mov	 eax, __tryend$??$_Uninit_move@PAURINGMONSTER_DATA@@PAU1@V?$allocator@URINGMONSTER_DATA@@@std@@U1@@std@@YAPAURINGMONSTER_DATA@@PAU1@00AAV?$allocator@URINGMONSTER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1
  000a7	c3		 ret	 0
$LN10@Uninit_mov:
  000a8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_move@PAURINGMONSTER_DATA@@PAU1@V?$allocator@URINGMONSTER_DATA@@@std@@U1@@std@@YAPAURINGMONSTER_DATA@@PAU1@00AAV?$allocator@URINGMONSTER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1:

; 437  : 	return (_Dest);

  000af	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_mov:

; 438  : 	}

  000b2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000b5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000bc	59		 pop	 ecx
  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_move@PAURINGMONSTER_DATA@@PAU1@V?$allocator@URINGMONSTER_DATA@@@std@@U1@@std@@YAPAURINGMONSTER_DATA@@PAU1@00AAV?$allocator@URINGMONSTER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninit_move@PAURINGMONSTER_DATA@@PAU1@V?$allocator@URINGMONSTER_DATA@@@std@@U1@@std@@YAPAURINGMONSTER_DATA@@PAU1@00AAV?$allocator@URINGMONSTER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninit_move@PAURINGMONSTER_DATA@@PAU1@V?$allocator@URINGMONSTER_DATA@@@std@@U1@@std@@YAPAURINGMONSTER_DATA@@PAU1@00AAV?$allocator@URINGMONSTER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<RINGMONSTER_DATA *,RINGMONSTER_DATA *,std::allocator<RINGMONSTER_DATA>,RINGMONSTER_DATA>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAURINGMONSTER_EVENT_TIME@@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAURINGMONSTER_EVENT_TIME@@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@@Z PROC ; std::_Val_type<RINGMONSTER_EVENT_TIME *>, COMDAT

; 789  : 	{	// return value type from arbitrary argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 790  : 	return (0);

  00009	33 c0		 xor	 eax, eax

; 791  : 	}

  0000b	5f		 pop	 edi
  0000c	5e		 pop	 esi
  0000d	5b		 pop	 ebx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Val_type@PAURINGMONSTER_EVENT_TIME@@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@@Z ENDP ; std::_Val_type<RINGMONSTER_EVENT_TIME *>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@URINGMONSTER_EVENT_TIME@@U3@@std@@YAXAAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@PAURINGMONSTER_EVENT_TIME@@$$QAU2@@Z ; std::_Cons_val<std::allocator<RINGMONSTER_EVENT_TIME>,RINGMONSTER_EVENT_TIME,RINGMONSTER_EVENT_TIME>
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_move@PAURINGMONSTER_EVENT_TIME@@PAU1@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@U1@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@00AAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_move@PAURINGMONSTER_EVENT_TIME@@PAU1@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@U1@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@00AAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_move@PAURINGMONSTER_EVENT_TIME@@PAU1@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@U1@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@00AAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_move@PAURINGMONSTER_EVENT_TIME@@PAU1@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@U1@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@00AAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_move@PAURINGMONSTER_EVENT_TIME@@PAU1@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@U1@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@00AAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_move@PAURINGMONSTER_EVENT_TIME@@PAU1@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@U1@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@00AAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_move@PAURINGMONSTER_EVENT_TIME@@PAU1@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@U1@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@00AAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_move@PAURINGMONSTER_EVENT_TIME@@PAU1@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@U1@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@00AAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Uninit_move@PAURINGMONSTER_EVENT_TIME@@PAU1@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@U1@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@00AAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAURINGMONSTER_EVENT_TIME@@PAU1@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@U1@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@00AAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<RINGMONSTER_EVENT_TIME *,RINGMONSTER_EVENT_TIME *,std::allocator<RINGMONSTER_EVENT_TIME>,RINGMONSTER_EVENT_TIME>, COMDAT

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_move@PAURINGMONSTER_EVENT_TIME@@PAU1@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@U1@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@00AAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 44	 sub	 esp, 68			; 00000044H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;

  0002c	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0002f	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 428  : 
; 429  : 	_TRY_BEGIN

  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00039	eb 12		 jmp	 SHORT $LN6@Uninit_mov@2
$LN5@Uninit_mov@2:

; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  0003b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0003e	83 c0 08	 add	 eax, 8
  00041	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00044	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00047	83 c1 08	 add	 ecx, 8
  0004a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN6@Uninit_mov@2:
  0004d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00050	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00053	74 16		 je	 SHORT $LN4@Uninit_mov@2

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

  00055	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00058	50		 push	 eax
  00059	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0005c	51		 push	 ecx
  0005d	8b 55 14	 mov	 edx, DWORD PTR __Al$[ebp]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@URINGMONSTER_EVENT_TIME@@U3@@std@@YAXAAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@PAURINGMONSTER_EVENT_TIME@@$$QAU2@@Z ; std::_Cons_val<std::allocator<RINGMONSTER_EVENT_TIME>,RINGMONSTER_EVENT_TIME,RINGMONSTER_EVENT_TIME>
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
  00069	eb d0		 jmp	 SHORT $LN5@Uninit_mov@2
$LN4@Uninit_mov@2:
  0006b	eb 3b		 jmp	 SHORT $LN10@Uninit_mov@2
__catch$??$_Uninit_move@PAURINGMONSTER_EVENT_TIME@@PAU1@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@U1@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@00AAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 432  : 	_CATCH_ALL

  0006d	eb 09		 jmp	 SHORT $LN3@Uninit_mov@2
$LN2@Uninit_mov@2:

; 433  : 	for (; _Next != _Dest; ++_Next)

  0006f	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00072	83 c0 08	 add	 eax, 8
  00075	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax
$LN3@Uninit_mov@2:
  00078	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  0007b	3b 45 10	 cmp	 eax, DWORD PTR __Dest$[ebp]
  0007e	74 12		 je	 SHORT $LN1@Uninit_mov@2

; 434  : 		_Dest_val(_Al, _Next);

  00080	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00083	50		 push	 eax
  00084	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@URINGMONSTER_EVENT_TIME@@@std@@YAXAAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@PAURINGMONSTER_EVENT_TIME@@@Z ; std::_Dest_val<std::allocator<RINGMONSTER_EVENT_TIME>,RINGMONSTER_EVENT_TIME>
  0008d	83 c4 08	 add	 esp, 8
  00090	eb dd		 jmp	 SHORT $LN2@Uninit_mov@2
$LN1@Uninit_mov@2:

; 435  : 	_RERAISE;

  00092	6a 00		 push	 0
  00094	6a 00		 push	 0
  00096	e8 00 00 00 00	 call	 __CxxThrowException@8

; 436  : 	_CATCH_END

  0009b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000a2	b8 00 00 00 00	 mov	 eax, __tryend$??$_Uninit_move@PAURINGMONSTER_EVENT_TIME@@PAU1@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@U1@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@00AAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1
  000a7	c3		 ret	 0
$LN10@Uninit_mov@2:
  000a8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_move@PAURINGMONSTER_EVENT_TIME@@PAU1@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@U1@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@00AAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1:

; 437  : 	return (_Dest);

  000af	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_mov@2:

; 438  : 	}

  000b2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000b5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000bc	59		 pop	 ecx
  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_move@PAURINGMONSTER_EVENT_TIME@@PAU1@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@U1@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@00AAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninit_move@PAURINGMONSTER_EVENT_TIME@@PAU1@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@U1@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@00AAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninit_move@PAURINGMONSTER_EVENT_TIME@@PAU1@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@U1@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@00AAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<RINGMONSTER_EVENT_TIME *,RINGMONSTER_EVENT_TIME *,std::allocator<RINGMONSTER_EVENT_TIME>,RINGMONSTER_EVENT_TIME>
PUBLIC	??$_Destroy@URINGMONSTER_DATA@@@std@@YAXPAURINGMONSTER_DATA@@@Z ; std::_Destroy<RINGMONSTER_DATA>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@URINGMONSTER_DATA@@@std@@QAEXPAURINGMONSTER_DATA@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@URINGMONSTER_DATA@@@std@@QAEXPAURINGMONSTER_DATA@@@Z PROC ; std::allocator<RINGMONSTER_DATA>::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 213  : 		_Destroy(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Destroy@URINGMONSTER_DATA@@@std@@YAXPAURINGMONSTER_DATA@@@Z ; std::_Destroy<RINGMONSTER_DATA>
  00015	83 c4 04	 add	 esp, 4

; 214  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?destroy@?$allocator@URINGMONSTER_DATA@@@std@@QAEXPAURINGMONSTER_DATA@@@Z ENDP ; std::allocator<RINGMONSTER_DATA>::destroy
_TEXT	ENDS
PUBLIC	??$_Destroy@URINGMONSTER_EVENT_TIME@@@std@@YAXPAURINGMONSTER_EVENT_TIME@@@Z ; std::_Destroy<RINGMONSTER_EVENT_TIME>
; Function compile flags: /Odtp /ZI
;	COMDAT ?destroy@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXPAURINGMONSTER_EVENT_TIME@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXPAURINGMONSTER_EVENT_TIME@@@Z PROC ; std::allocator<RINGMONSTER_EVENT_TIME>::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 213  : 		_Destroy(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Destroy@URINGMONSTER_EVENT_TIME@@@std@@YAXPAURINGMONSTER_EVENT_TIME@@@Z ; std::_Destroy<RINGMONSTER_EVENT_TIME>
  00015	83 c4 04	 add	 esp, 4

; 214  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?destroy@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXPAURINGMONSTER_EVENT_TIME@@@Z ENDP ; std::allocator<RINGMONSTER_EVENT_TIME>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@URINGMONSTER_DATA@@@std@@QAEXPAURINGMONSTER_DATA@@$$QAU3@@Z ; std::allocator<RINGMONSTER_DATA>::construct
PUBLIC	??$forward@URINGMONSTER_DATA@@@std@@YA$$QAURINGMONSTER_DATA@@AAU1@@Z ; std::forward<RINGMONSTER_DATA>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@URINGMONSTER_DATA@@@std@@URINGMONSTER_DATA@@U3@@std@@YAXAAV?$allocator@URINGMONSTER_DATA@@@0@PAURINGMONSTER_DATA@@$$QAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@URINGMONSTER_DATA@@@std@@URINGMONSTER_DATA@@U3@@std@@YAXAAV?$allocator@URINGMONSTER_DATA@@@0@PAURINGMONSTER_DATA@@$$QAU2@@Z PROC ; std::_Cons_val<std::allocator<RINGMONSTER_DATA>,RINGMONSTER_DATA,RINGMONSTER_DATA>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@URINGMONSTER_DATA@@@std@@YA$$QAURINGMONSTER_DATA@@AAU1@@Z ; std::forward<RINGMONSTER_DATA>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@URINGMONSTER_DATA@@@std@@QAEXPAURINGMONSTER_DATA@@$$QAU3@@Z ; std::allocator<RINGMONSTER_DATA>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@URINGMONSTER_DATA@@@std@@URINGMONSTER_DATA@@U3@@std@@YAXAAV?$allocator@URINGMONSTER_DATA@@@0@PAURINGMONSTER_DATA@@$$QAU2@@Z ENDP ; std::_Cons_val<std::allocator<RINGMONSTER_DATA>,RINGMONSTER_DATA,RINGMONSTER_DATA>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXPAURINGMONSTER_EVENT_TIME@@$$QAU3@@Z ; std::allocator<RINGMONSTER_EVENT_TIME>::construct
PUBLIC	??$forward@URINGMONSTER_EVENT_TIME@@@std@@YA$$QAURINGMONSTER_EVENT_TIME@@AAU1@@Z ; std::forward<RINGMONSTER_EVENT_TIME>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@URINGMONSTER_EVENT_TIME@@U3@@std@@YAXAAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@PAURINGMONSTER_EVENT_TIME@@$$QAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@URINGMONSTER_EVENT_TIME@@U3@@std@@YAXAAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@PAURINGMONSTER_EVENT_TIME@@$$QAU2@@Z PROC ; std::_Cons_val<std::allocator<RINGMONSTER_EVENT_TIME>,RINGMONSTER_EVENT_TIME,RINGMONSTER_EVENT_TIME>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@URINGMONSTER_EVENT_TIME@@@std@@YA$$QAURINGMONSTER_EVENT_TIME@@AAU1@@Z ; std::forward<RINGMONSTER_EVENT_TIME>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXPAURINGMONSTER_EVENT_TIME@@$$QAU3@@Z ; std::allocator<RINGMONSTER_EVENT_TIME>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@URINGMONSTER_EVENT_TIME@@U3@@std@@YAXAAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@PAURINGMONSTER_EVENT_TIME@@$$QAU2@@Z ENDP ; std::_Cons_val<std::allocator<RINGMONSTER_EVENT_TIME>,RINGMONSTER_EVENT_TIME,RINGMONSTER_EVENT_TIME>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Destroy@URINGMONSTER_DATA@@@std@@YAXPAURINGMONSTER_DATA@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@URINGMONSTER_DATA@@@std@@YAXPAURINGMONSTER_DATA@@@Z PROC ; std::_Destroy<RINGMONSTER_DATA>, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Destroy@URINGMONSTER_DATA@@@std@@YAXPAURINGMONSTER_DATA@@@Z ENDP ; std::_Destroy<RINGMONSTER_DATA>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Destroy@URINGMONSTER_EVENT_TIME@@@std@@YAXPAURINGMONSTER_EVENT_TIME@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@URINGMONSTER_EVENT_TIME@@@std@@YAXPAURINGMONSTER_EVENT_TIME@@@Z PROC ; std::_Destroy<RINGMONSTER_EVENT_TIME>, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Destroy@URINGMONSTER_EVENT_TIME@@@std@@YAXPAURINGMONSTER_EVENT_TIME@@@Z ENDP ; std::_Destroy<RINGMONSTER_EVENT_TIME>
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@URINGMONSTER_DATA@@@std@@QAEXPAURINGMONSTER_DATA@@$$QAU3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@URINGMONSTER_DATA@@@std@@QAEXPAURINGMONSTER_DATA@@$$QAU3@@Z$0
__ehfuncinfo$?construct@?$allocator@URINGMONSTER_DATA@@@std@@QAEXPAURINGMONSTER_DATA@@$$QAU3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@URINGMONSTER_DATA@@@std@@QAEXPAURINGMONSTER_DATA@@$$QAU3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@URINGMONSTER_DATA@@@std@@QAEXPAURINGMONSTER_DATA@@$$QAU3@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T233321 = -88						; size = 4
$T233322 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@URINGMONSTER_DATA@@@std@@QAEXPAURINGMONSTER_DATA@@$$QAU3@@Z PROC ; std::allocator<RINGMONSTER_DATA>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?construct@?$allocator@URINGMONSTER_DATA@@@std@@QAEXPAURINGMONSTER_DATA@@$$QAU3@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 0c		 push	 12			; 0000000cH
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T233322[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T233322[ebp], 0
  00047	74 27		 je	 SHORT $LN3@construct@3
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@URINGMONSTER_DATA@@@std@@YA$$QAURINGMONSTER_DATA@@AAU1@@Z ; std::forward<RINGMONSTER_DATA>
  00052	83 c4 04	 add	 esp, 4
  00055	8b 55 ac	 mov	 edx, DWORD PTR $T233322[ebp]
  00058	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005a	89 0a		 mov	 DWORD PTR [edx], ecx
  0005c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005f	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00062	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00065	89 42 08	 mov	 DWORD PTR [edx+8], eax
  00068	8b 4d ac	 mov	 ecx, DWORD PTR $T233322[ebp]
  0006b	89 4d a4	 mov	 DWORD PTR tv74[ebp], ecx
  0006e	eb 07		 jmp	 SHORT $LN4@construct@3
$LN3@construct@3:
  00070	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct@3:
  00077	8b 55 a4	 mov	 edx, DWORD PTR tv74[ebp]
  0007a	89 55 a8	 mov	 DWORD PTR $T233321[ebp], edx
  0007d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 203  : 		}

  00084	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00087	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008e	59		 pop	 ecx
  0008f	5f		 pop	 edi
  00090	5e		 pop	 esi
  00091	5b		 pop	 ebx
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@URINGMONSTER_DATA@@@std@@QAEXPAURINGMONSTER_DATA@@$$QAU3@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T233322[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$?construct@?$allocator@URINGMONSTER_DATA@@@std@@QAEXPAURINGMONSTER_DATA@@$$QAU3@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?construct@?$allocator@URINGMONSTER_DATA@@@std@@QAEXPAURINGMONSTER_DATA@@$$QAU3@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@URINGMONSTER_DATA@@@std@@QAEXPAURINGMONSTER_DATA@@$$QAU3@@Z ENDP ; std::allocator<RINGMONSTER_DATA>::construct
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXPAURINGMONSTER_EVENT_TIME@@$$QAU3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXPAURINGMONSTER_EVENT_TIME@@$$QAU3@@Z$0
__ehfuncinfo$?construct@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXPAURINGMONSTER_EVENT_TIME@@$$QAU3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXPAURINGMONSTER_EVENT_TIME@@$$QAU3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXPAURINGMONSTER_EVENT_TIME@@$$QAU3@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T233334 = -88						; size = 4
$T233335 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXPAURINGMONSTER_EVENT_TIME@@$$QAU3@@Z PROC ; std::allocator<RINGMONSTER_EVENT_TIME>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?construct@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXPAURINGMONSTER_EVENT_TIME@@$$QAU3@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 08		 push	 8
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T233335[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T233335[ebp], 0
  00047	74 21		 je	 SHORT $LN3@construct@4
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@URINGMONSTER_EVENT_TIME@@@std@@YA$$QAURINGMONSTER_EVENT_TIME@@AAU1@@Z ; std::forward<RINGMONSTER_EVENT_TIME>
  00052	83 c4 04	 add	 esp, 4
  00055	8b 10		 mov	 edx, DWORD PTR [eax]
  00057	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005a	8b 4d ac	 mov	 ecx, DWORD PTR $T233335[ebp]
  0005d	89 11		 mov	 DWORD PTR [ecx], edx
  0005f	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00062	8b 55 ac	 mov	 edx, DWORD PTR $T233335[ebp]
  00065	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  00068	eb 07		 jmp	 SHORT $LN4@construct@4
$LN3@construct@4:
  0006a	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct@4:
  00071	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00074	89 45 a8	 mov	 DWORD PTR $T233334[ebp], eax
  00077	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 203  : 		}

  0007e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00081	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00088	59		 pop	 ecx
  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXPAURINGMONSTER_EVENT_TIME@@$$QAU3@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T233335[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$?construct@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXPAURINGMONSTER_EVENT_TIME@@$$QAU3@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?construct@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXPAURINGMONSTER_EVENT_TIME@@$$QAU3@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXPAURINGMONSTER_EVENT_TIME@@$$QAU3@@Z ENDP ; std::allocator<RINGMONSTER_EVENT_TIME>::construct
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@URINGMONSTER_DATA@@@std@@YA$$QAURINGMONSTER_DATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@URINGMONSTER_DATA@@@std@@YA$$QAURINGMONSTER_DATA@@AAU1@@Z PROC ; std::forward<RINGMONSTER_DATA>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@URINGMONSTER_DATA@@@std@@YA$$QAURINGMONSTER_DATA@@AAU1@@Z ENDP ; std::forward<RINGMONSTER_DATA>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@URINGMONSTER_EVENT_TIME@@@std@@YA$$QAURINGMONSTER_EVENT_TIME@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@URINGMONSTER_EVENT_TIME@@@std@@YA$$QAURINGMONSTER_EVENT_TIME@@AAU1@@Z PROC ; std::forward<RINGMONSTER_EVENT_TIME>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@URINGMONSTER_EVENT_TIME@@@std@@YA$$QAURINGMONSTER_EVENT_TIME@@AAU1@@Z ENDP ; std::forward<RINGMONSTER_EVENT_TIME>
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File d:\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
; Function compile flags: /Odtp /ZI
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ ; std::bad_alloc::~bad_alloc
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar@3
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar@3:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 37   : 		{	// orphan all iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 38   : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 48   : 		{	// adopt this iterator by parent

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 49   : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
END
