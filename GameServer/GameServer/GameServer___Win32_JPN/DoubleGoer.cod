; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	D:\Projects\ExTeam6.3\Source\GameServer\GameServer\DoubleGoer.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?DGEnabled@@3HA					; DGEnabled
PUBLIC	?DGCoolDown@@3HA				; DGCoolDown
PUBLIC	?DGUseAutoStat@@3HA				; DGUseAutoStat
PUBLIC	?DGEnterMoney@@3HA				; DGEnterMoney
PUBLIC	?DGSilverChestOpenRate@@3HA			; DGSilverChestOpenRate
PUBLIC	?TickCount@@3HA					; TickCount
_BSS	SEGMENT
?DGEnabled@@3HA DD 01H DUP (?)				; DGEnabled
?DGCoolDown@@3HA DD 01H DUP (?)				; DGCoolDown
?DGUseAutoStat@@3HA DD 01H DUP (?)			; DGUseAutoStat
?DGEnterMoney@@3HA DD 01H DUP (?)			; DGEnterMoney
?TickCount@@3HA DD 01H DUP (?)				; TickCount
_BSS	ENDS
_DATA	SEGMENT
_g_sttBLOODCASTLE_LEVEL DD 0fH
	DD	050H
	DD	0aH
	DD	03cH
	DD	051H
	DD	082H
	DD	03dH
	DD	06eH
	DD	083H
	DD	0b4H
	DD	06fH
	DD	0a0H
	DD	0b5H
	DD	0e6H
	DD	0a1H
	DD	0d2H
	DD	0e7H
	DD	0118H
	DD	0d3H
	DD	0104H
	DD	0119H
	DD	014aH
	DD	0105H
	DD	0136H
	DD	014bH
	DD	0190H
	DD	0137H
	DD	0190H
	DD	0fH
	DD	0257H
	DD	0aH
	DD	0257H
_g_sttDEVILSQUARE_LEVEL DD 0fH
	DD	082H
	DD	0aH
	DD	06eH
	DD	03aH
	DD	083H
	DD	0b4H
	DD	06fH
	DD	0a0H
	DD	03bH
	DD	0b5H
	DD	0e6H
	DD	0a1H
	DD	0d2H
	DD	03cH
	DD	0e7H
	DD	0118H
	DD	0d3H
	DD	0104H
	DD	03dH
	DD	0119H
	DD	014aH
	DD	0105H
	DD	0136H
	DD	06fH
	DD	014bH
	DD	0190H
	DD	0137H
	DD	0190H
	DD	070H
	DD	0fH
	DD	0257H
	DD	0aH
	DD	0257H
	DD	010eH
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
?DGSilverChestOpenRate@@3HA DD 01388H			; DGSilverChestOpenRate
_DATA	ENDS
CONST	SEGMENT
_g_DGEntrance DD 0c3H
	DD	022H
	DD	0c7H
	DD	028H
	DD	086H
	DD	04eH
	DD	08bH
	DD	054H
	DD	06aH
	DD	041H
	DD	06fH
	DD	047H
	DD	05dH
	DD	017H
	DD	061H
	DD	019H
_g_DGPortal DB	0c5H
	DB	01eH
	DB	085H
	DB	044H
	DB	06eH
	DB	03cH
	DB	05fH
	DB	0fH
CONST	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Odtp /ZI
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@vector:
  00009	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000c	83 e8 01	 sub	 eax, 1
  0000f	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00012	78 11		 js	 SHORT $LN3@vector
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00017	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  0001d	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00020	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00023	eb e4		 jmp	 SHORT $LN2@vector
$LN3@vector:
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?SetState@CDoppelGanger@@QAEXH@Z		; CDoppelGanger::SetState
PUBLIC	?LoadConfigFile@CDoppelGanger@@QAE_NPAD@Z	; CDoppelGanger::LoadConfigFile
PUBLIC	??_C@_0BH@MHAMEAEE@?2Events?2DoubleGoer?4dat?$AA@ ; `string'
PUBLIC	?Clear@DOPPELGANGEREVENT@@QAEXXZ		; DOPPELGANGEREVENT::Clear
PUBLIC	?Init@CDoppelGanger@@QAEXXZ			; CDoppelGanger::Init
EXTRN	?GetNewPath@CDirPath@@QAEPADPAD@Z:PROC		; CDirPath::GetNewPath
EXTRN	?gDirPath@@3VCDirPath@@A:BYTE			; gDirPath
;	COMDAT ??_C@_0BH@MHAMEAEE@?2Events?2DoubleGoer?4dat?$AA@
; File d:\projects\exteam6.3\source\gameserver\gameserver\doublegoer.cpp
CONST	SEGMENT
??_C@_0BH@MHAMEAEE@?2Events?2DoubleGoer?4dat?$AA@ DB '\Events\DoubleGoer.'
	DB	'dat', 00H					; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Init@CDoppelGanger@@QAEXXZ PROC			; CDoppelGanger::Init
; _this$ = ecx

; 38   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 39   : 
; 40   : 	// player pos
; 41   : 	this->POSX[0] = 197,	this->POSY[0] = 30;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 40 04 c5 00
	00 00		 mov	 DWORD PTR [eax+4], 197	; 000000c5H
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	c7 41 14 1e 00
	00 00		 mov	 DWORD PTR [ecx+20], 30	; 0000001eH

; 42   : 	this->POSX[1] = 133,	this->POSY[1] = 68;

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	c7 40 08 85 00
	00 00		 mov	 DWORD PTR [eax+8], 133	; 00000085H
  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	c7 41 18 44 00
	00 00		 mov	 DWORD PTR [ecx+24], 68	; 00000044H

; 43   : 	this->POSX[2] = 110,	this->POSY[2] = 60;

  00034	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00037	c7 40 0c 6e 00
	00 00		 mov	 DWORD PTR [eax+12], 110	; 0000006eH
  0003e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	c7 41 1c 3c 00
	00 00		 mov	 DWORD PTR [ecx+28], 60	; 0000003cH

; 44   : 	this->POSX[3] = 95,		this->POSY[3] = 15;

  00048	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	c7 40 10 5f 00
	00 00		 mov	 DWORD PTR [eax+16], 95	; 0000005fH
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	c7 41 20 0f 00
	00 00		 mov	 DWORD PTR [ecx+32], 15	; 0000000fH

; 45   : 
; 46   : 	// monster pos
; 47   : 	this->MPOSX[0] = 224,	this->MPOSY[0] = 100;

  0005c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	c7 40 24 e0 00
	00 00		 mov	 DWORD PTR [eax+36], 224	; 000000e0H
  00066	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00069	c7 41 34 64 00
	00 00		 mov	 DWORD PTR [ecx+52], 100	; 00000064H

; 48   : 	this->MPOSX[1] = 113,	this->MPOSY[1] = 180;

  00070	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00073	c7 40 28 71 00
	00 00		 mov	 DWORD PTR [eax+40], 113	; 00000071H
  0007a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	c7 41 38 b4 00
	00 00		 mov	 DWORD PTR [ecx+56], 180	; 000000b4H

; 49   : 	this->MPOSX[2] = 110,	this->MPOSY[2] = 150;

  00084	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00087	c7 40 2c 6e 00
	00 00		 mov	 DWORD PTR [eax+44], 110	; 0000006eH
  0008e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00091	c7 41 3c 96 00
	00 00		 mov	 DWORD PTR [ecx+60], 150	; 00000096H

; 50   : 	this->MPOSX[3] = 43,	this->MPOSY[3] = 108;

  00098	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009b	c7 40 30 2b 00
	00 00		 mov	 DWORD PTR [eax+48], 43	; 0000002bH
  000a2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	c7 41 40 6c 00
	00 00		 mov	 DWORD PTR [ecx+64], 108	; 0000006cH

; 51   : 
; 52   : 	this->m_DGData.Clear();

  000ac	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000af	83 c1 44	 add	 ecx, 68			; 00000044H
  000b2	e8 00 00 00 00	 call	 ?Clear@DOPPELGANGEREVENT@@QAEXXZ ; DOPPELGANGEREVENT::Clear

; 53   : 
; 54   : 	this->LoadConfigFile(gDirPath.GetNewPath("\\Events\\DoubleGoer.dat"));

  000b7	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@MHAMEAEE@?2Events?2DoubleGoer?4dat?$AA@
  000bc	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  000c1	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  000c6	50		 push	 eax
  000c7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ca	e8 00 00 00 00	 call	 ?LoadConfigFile@CDoppelGanger@@QAE_NPAD@Z ; CDoppelGanger::LoadConfigFile

; 55   : 
; 56   : 	if(!DGEnabled)

  000cf	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?DGEnabled@@3HA, 0 ; DGEnabled
  000d6	75 0c		 jne	 SHORT $LN2@Init

; 57   : 	{
; 58   : 		this->SetState(DG_STATE_NONE);

  000d8	6a 00		 push	 0
  000da	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000dd	e8 00 00 00 00	 call	 ?SetState@CDoppelGanger@@QAEXH@Z ; CDoppelGanger::SetState

; 59   : 	}
; 60   : 	else

  000e2	eb 0a		 jmp	 SHORT $LN3@Init
$LN2@Init:

; 61   : 	{
; 62   : 		this->SetState(DG_STATE_OPEN);

  000e4	6a 01		 push	 1
  000e6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e9	e8 00 00 00 00	 call	 ?SetState@CDoppelGanger@@QAEXH@Z ; CDoppelGanger::SetState
$LN3@Init:

; 63   : 	}
; 64   : }

  000ee	5f		 pop	 edi
  000ef	5e		 pop	 esi
  000f0	5b		 pop	 ebx
  000f1	8b e5		 mov	 esp, ebp
  000f3	5d		 pop	 ebp
  000f4	c3		 ret	 0
?Init@CDoppelGanger@@QAEXXZ ENDP			; CDoppelGanger::Init
_TEXT	ENDS
EXTRN	_memset:PROC
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\doublegoer.h
;	COMDAT ?Clear@DOPPELGANGEREVENT@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@DOPPELGANGEREVENT@@QAEXXZ PROC			; DOPPELGANGEREVENT::Clear, COMDAT
; _this$ = ecx

; 41   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 42   : 		this->PlayerCount	= 0;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c6 00 00	 mov	 BYTE PTR [eax], 0

; 43   : 		this->BossCount		= 0;

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0

; 44   : 		this->MonsterCount	= 0;

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	c6 40 02 00	 mov	 BYTE PTR [eax+2], 0

; 45   : 		this->CreateMonsterDelay = 0;

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0

; 46   : 		this->MoveProcDelay = 0;

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c6 40 05 00	 mov	 BYTE PTR [eax+5], 0

; 47   : 		this->GoldBoxIndex  = -1;

  0002e	83 c8 ff	 or	 eax, -1
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	66 89 41 08	 mov	 WORD PTR [ecx+8], ax

; 48   : 		this->PhazesPassed	= 0;

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	c6 80 df 01 00
	00 00		 mov	 BYTE PTR [eax+479], 0

; 49   : 		this->eDuration = 0;

  00042	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00045	c7 80 c4 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+452], 0

; 50   : 		this->IceWalkerPhazeTime = 0;

  0004f	33 c0		 xor	 eax, eax
  00051	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	66 89 81 da 01
	00 00		 mov	 WORD PTR [ecx+474], ax

; 51   : 		this->btPhaze = 0;

  0005b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	c6 40 07 00	 mov	 BYTE PTR [eax+7], 0

; 52   : 		this->btPlayState = 0;

  00062	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00065	c6 40 06 00	 mov	 BYTE PTR [eax+6], 0

; 53   : 		this->TickCount = 0;

  00069	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	c7 80 d4 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+468], 0

; 54   : 		// ----
; 55   : 		memset(PlayerIndex, -1, sizeof(PlayerIndex));

  00076	6a 14		 push	 20			; 00000014H
  00078	6a ff		 push	 -1
  0007a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007d	83 c0 10	 add	 eax, 16			; 00000010H
  00080	50		 push	 eax
  00081	e8 00 00 00 00	 call	 _memset
  00086	83 c4 0c	 add	 esp, 12			; 0000000cH

; 56   : 		memset(MonsterIndex, -1, sizeof(MonsterIndex));	

  00089	68 9a 01 00 00	 push	 410			; 0000019aH
  0008e	6a ff		 push	 -1
  00090	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00093	83 c0 24	 add	 eax, 36			; 00000024H
  00096	50		 push	 eax
  00097	e8 00 00 00 00	 call	 _memset
  0009c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 57   : 		memset(SilverBoxIndex,-1,sizeof(SilverBoxIndex));

  0009f	6a 06		 push	 6
  000a1	6a ff		 push	 -1
  000a3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a6	05 be 01 00 00	 add	 eax, 446		; 000001beH
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 _memset
  000b1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 58   : 		// ----
; 59   : 		IceWalkerLive		= 0;

  000b4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b7	c6 80 de 01 00
	00 00		 mov	 BYTE PTR [eax+478], 0

; 60   : 		this->MapNumber = -1;

  000be	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c1	c7 80 cc 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+460], -1

; 61   : 		this->PartyNumber = -1;

  000cb	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ce	c7 80 d0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+464], -1

; 62   : 		this->HalfTimeInfoSent = false;

  000d8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000db	c6 80 d8 01 00
	00 00		 mov	 BYTE PTR [eax+472], 0

; 63   : 		this->IceWalkerIndex = -1;

  000e2	83 c8 ff	 or	 eax, -1
  000e5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e8	66 89 41 0e	 mov	 WORD PTR [ecx+14], ax

; 64   : 		this->AngryButcherIndex = -1;

  000ec	83 c8 ff	 or	 eax, -1
  000ef	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f2	66 89 41 0c	 mov	 WORD PTR [ecx+12], ax

; 65   : 		this->ButcherIndex = -1;

  000f6	83 c8 ff	 or	 eax, -1
  000f9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000fc	66 89 41 0a	 mov	 WORD PTR [ecx+10], ax

; 66   : 
; 67   : 
; 68   : 	};

  00100	5f		 pop	 edi
  00101	5e		 pop	 esi
  00102	5b		 pop	 ebx
  00103	8b e5		 mov	 esp, ebp
  00105	5d		 pop	 ebp
  00106	c3		 ret	 0
?Clear@DOPPELGANGEREVENT@@QAEXXZ ENDP			; DOPPELGANGEREVENT::Clear
_TEXT	ENDS
PUBLIC	?SetState_ENDED@CDoppelGanger@@QAEXXZ		; CDoppelGanger::SetState_ENDED
PUBLIC	?SetState_STARTED@CDoppelGanger@@QAEXXZ		; CDoppelGanger::SetState_STARTED
PUBLIC	?SetState_WAITING@CDoppelGanger@@QAEXXZ		; CDoppelGanger::SetState_WAITING
PUBLIC	?SetState_OPEN@CDoppelGanger@@QAEXXZ		; CDoppelGanger::SetState_OPEN
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\doublegoer.cpp
_TEXT	SEGMENT
tv64 = -72						; size = 4
_this$ = -4						; size = 4
_iState$ = 8						; size = 4
?SetState@CDoppelGanger@@QAEXH@Z PROC			; CDoppelGanger::SetState
; _this$ = ecx

; 67   : {

  00100	55		 push	 ebp
  00101	8b ec		 mov	 ebp, esp
  00103	83 ec 48	 sub	 esp, 72			; 00000048H
  00106	53		 push	 ebx
  00107	56		 push	 esi
  00108	57		 push	 edi
  00109	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 68   : 	switch(iState)

  0010c	8b 45 08	 mov	 eax, DWORD PTR _iState$[ebp]
  0010f	89 45 b8	 mov	 DWORD PTR tv64[ebp], eax
  00112	83 7d b8 04	 cmp	 DWORD PTR tv64[ebp], 4
  00116	77 32		 ja	 SHORT $LN8@SetState
  00118	8b 4d b8	 mov	 ecx, DWORD PTR tv64[ebp]
  0011b	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN10@SetState[ecx*4]
$LN5@SetState:

; 69   : 	{
; 70   : 	case DG_STATE_NONE:
; 71   : 		return;

  00122	eb 26		 jmp	 SHORT $LN8@SetState
$LN4@SetState:

; 72   : 	case DG_STATE_OPEN:
; 73   : 		this->SetState_OPEN();

  00124	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00127	e8 00 00 00 00	 call	 ?SetState_OPEN@CDoppelGanger@@QAEXXZ ; CDoppelGanger::SetState_OPEN

; 74   : 		break;

  0012c	eb 1c		 jmp	 SHORT $LN8@SetState
$LN3@SetState:

; 75   : 	case DG_STATE_WAITING:
; 76   : 		this->SetState_WAITING();

  0012e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00131	e8 00 00 00 00	 call	 ?SetState_WAITING@CDoppelGanger@@QAEXXZ ; CDoppelGanger::SetState_WAITING

; 77   : 		break;

  00136	eb 12		 jmp	 SHORT $LN8@SetState
$LN2@SetState:

; 78   : 	case DG_STATE_STARTED:
; 79   : 		this->SetState_STARTED();

  00138	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0013b	e8 00 00 00 00	 call	 ?SetState_STARTED@CDoppelGanger@@QAEXXZ ; CDoppelGanger::SetState_STARTED

; 80   : 		break;

  00140	eb 08		 jmp	 SHORT $LN8@SetState
$LN1@SetState:

; 81   : 	case DG_STATE_ENDED:
; 82   : 		this->SetState_ENDED();

  00142	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00145	e8 00 00 00 00	 call	 ?SetState_ENDED@CDoppelGanger@@QAEXXZ ; CDoppelGanger::SetState_ENDED
$LN8@SetState:

; 83   : 		break;
; 84   : 	}
; 85   : }

  0014a	5f		 pop	 edi
  0014b	5e		 pop	 esi
  0014c	5b		 pop	 ebx
  0014d	8b e5		 mov	 esp, ebp
  0014f	5d		 pop	 ebp
  00150	c2 04 00	 ret	 4
  00153	90		 npad	 1
$LN10@SetState:
  00154	00 00 00 00	 DD	 $LN5@SetState
  00158	00 00 00 00	 DD	 $LN4@SetState
  0015c	00 00 00 00	 DD	 $LN3@SetState
  00160	00 00 00 00	 DD	 $LN2@SetState
  00164	00 00 00 00	 DD	 $LN1@SetState
?SetState@CDoppelGanger@@QAEXH@Z ENDP			; CDoppelGanger::SetState
_TEXT	ENDS
PUBLIC	??_C@_0BN@JEHNLCPA@?$FLDoppelGanger?$FN?5SetState?5OPEN?$AA@ ; `string'
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?gObjDel@@YAFH@Z:PROC				; gObjDel
EXTRN	?gObjIsConnected@@YAHH@Z:PROC			; gObjIsConnected
EXTRN	?gObjMoveGate@@YAHHH@Z:PROC			; gObjMoveGate
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
;	COMDAT ??_C@_0BN@JEHNLCPA@?$FLDoppelGanger?$FN?5SetState?5OPEN?$AA@
CONST	SEGMENT
??_C@_0BN@JEHNLCPA@?$FLDoppelGanger?$FN?5SetState?5OPEN?$AA@ DB '[DoppelG'
	DB	'anger] SetState OPEN', 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv136 = -80						; size = 4
tv80 = -80						; size = 4
_i$231349 = -12						; size = 4
_i$231344 = -8						; size = 4
_this$ = -4						; size = 4
?SetState_OPEN@CDoppelGanger@@QAEXXZ PROC		; CDoppelGanger::SetState_OPEN
; _this$ = ecx

; 88   : {

  00170	55		 push	 ebp
  00171	8b ec		 mov	 ebp, esp
  00173	83 ec 50	 sub	 esp, 80			; 00000050H
  00176	53		 push	 ebx
  00177	56		 push	 esi
  00178	57		 push	 edi
  00179	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   : 	for(int i=OBJ_STARTUSERINDEX;i<OBJMAX;++i)

  0017c	c7 45 f8 b0 36
	00 00		 mov	 DWORD PTR _i$231344[ebp], 14000 ; 000036b0H
  00183	eb 09		 jmp	 SHORT $LN8@SetState_O
$LN7@SetState_O:
  00185	8b 45 f8	 mov	 eax, DWORD PTR _i$231344[ebp]
  00188	83 c0 01	 add	 eax, 1
  0018b	89 45 f8	 mov	 DWORD PTR _i$231344[ebp], eax
$LN8@SetState_O:
  0018e	81 7d f8 98 3a
	00 00		 cmp	 DWORD PTR _i$231344[ebp], 15000 ; 00003a98H
  00195	0f 8d 90 00 00
	00		 jge	 $LN6@SetState_O

; 90   : 	{
; 91   : 		gObj[i].m_btDoubleGoerRoom = -1;

  0019b	8b 45 f8	 mov	 eax, DWORD PTR _i$231344[ebp]
  0019e	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  001a4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001aa	c6 84 01 b9 21
	00 00 ff	 mov	 BYTE PTR [ecx+eax+8633], 255 ; 000000ffH

; 92   : 		if(DG_MAP_RANGE(gObj[i].MapNumber) && gObj[i].Connected == PLAYER_PLAYING)

  001b2	8b 45 f8	 mov	 eax, DWORD PTR _i$231344[ebp]
  001b5	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  001bb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001c1	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  001c9	83 fa 41	 cmp	 edx, 65			; 00000041H
  001cc	7d 09		 jge	 SHORT $LN11@SetState_O
  001ce	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv80[ebp], 0
  001d5	eb 22		 jmp	 SHORT $LN12@SetState_O
$LN11@SetState_O:
  001d7	8b 45 f8	 mov	 eax, DWORD PTR _i$231344[ebp]
  001da	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  001e0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001e6	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  001ee	33 c0		 xor	 eax, eax
  001f0	83 fa 44	 cmp	 edx, 68			; 00000044H
  001f3	0f 9e c0	 setle	 al
  001f6	89 45 b0	 mov	 DWORD PTR tv80[ebp], eax
$LN12@SetState_O:
  001f9	83 7d b0 00	 cmp	 DWORD PTR tv80[ebp], 0
  001fd	74 27		 je	 SHORT $LN5@SetState_O
  001ff	8b 45 f8	 mov	 eax, DWORD PTR _i$231344[ebp]
  00202	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00208	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0020e	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  00213	75 11		 jne	 SHORT $LN5@SetState_O

; 93   : 		{
; 94   : 			gObjMoveGate(i, 267);

  00215	68 0b 01 00 00	 push	 267			; 0000010bH
  0021a	8b 45 f8	 mov	 eax, DWORD PTR _i$231344[ebp]
  0021d	50		 push	 eax
  0021e	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  00223	83 c4 08	 add	 esp, 8
$LN5@SetState_O:

; 95   : 		}
; 96   : 	}

  00226	e9 5a ff ff ff	 jmp	 $LN7@SetState_O
$LN6@SetState_O:

; 97   : 	for(int i=0;i<OBJ_MAXMONSTER;++i)

  0022b	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$231349[ebp], 0
  00232	eb 09		 jmp	 SHORT $LN4@SetState_O
$LN3@SetState_O:
  00234	8b 45 f4	 mov	 eax, DWORD PTR _i$231349[ebp]
  00237	83 c0 01	 add	 eax, 1
  0023a	89 45 f4	 mov	 DWORD PTR _i$231349[ebp], eax
$LN4@SetState_O:
  0023d	81 7d f4 c8 32
	00 00		 cmp	 DWORD PTR _i$231349[ebp], 13000 ; 000032c8H
  00244	7d 6b		 jge	 SHORT $LN2@SetState_O

; 98   : 	{
; 99   : 		if(gObjIsConnected(i) && DG_MAP_RANGE(gObj[i].MapNumber))

  00246	8b 45 f4	 mov	 eax, DWORD PTR _i$231349[ebp]
  00249	50		 push	 eax
  0024a	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0024f	83 c4 04	 add	 esp, 4
  00252	85 c0		 test	 eax, eax
  00254	74 59		 je	 SHORT $LN1@SetState_O
  00256	8b 45 f4	 mov	 eax, DWORD PTR _i$231349[ebp]
  00259	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0025f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00265	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  0026d	83 fa 41	 cmp	 edx, 65			; 00000041H
  00270	7d 09		 jge	 SHORT $LN13@SetState_O
  00272	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv136[ebp], 0
  00279	eb 22		 jmp	 SHORT $LN14@SetState_O
$LN13@SetState_O:
  0027b	8b 45 f4	 mov	 eax, DWORD PTR _i$231349[ebp]
  0027e	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00284	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0028a	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  00292	33 c0		 xor	 eax, eax
  00294	83 fa 44	 cmp	 edx, 68			; 00000044H
  00297	0f 9e c0	 setle	 al
  0029a	89 45 b0	 mov	 DWORD PTR tv136[ebp], eax
$LN14@SetState_O:
  0029d	83 7d b0 00	 cmp	 DWORD PTR tv136[ebp], 0
  002a1	74 0c		 je	 SHORT $LN1@SetState_O

; 100  : 			gObjDel(i);

  002a3	8b 45 f4	 mov	 eax, DWORD PTR _i$231349[ebp]
  002a6	50		 push	 eax
  002a7	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  002ac	83 c4 04	 add	 esp, 4
$LN1@SetState_O:

; 101  : 	}

  002af	eb 83		 jmp	 SHORT $LN3@SetState_O
$LN2@SetState_O:

; 102  : 	this->m_DGData.Clear();

  002b1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002b4	83 c1 44	 add	 ecx, 68			; 00000044H
  002b7	e8 00 00 00 00	 call	 ?Clear@DOPPELGANGEREVENT@@QAEXXZ ; DOPPELGANGEREVENT::Clear

; 103  : 	this->m_DGData.btPlayState = DG_STATE_OPEN;

  002bc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002bf	c6 40 4a 01	 mov	 BYTE PTR [eax+74], 1

; 104  : 	LogAddTD("[DoppelGanger] SetState OPEN");

  002c3	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@JEHNLCPA@?$FLDoppelGanger?$FN?5SetState?5OPEN?$AA@
  002c8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  002ce	83 c4 04	 add	 esp, 4

; 105  : }

  002d1	5f		 pop	 edi
  002d2	5e		 pop	 esi
  002d3	5b		 pop	 ebx
  002d4	8b e5		 mov	 esp, ebp
  002d6	5d		 pop	 ebp
  002d7	c3		 ret	 0
?SetState_OPEN@CDoppelGanger@@QAEXXZ ENDP		; CDoppelGanger::SetState_OPEN
_TEXT	ENDS
PUBLIC	??_C@_0CA@FNMGCOPM@?$FLDoppelGanger?$FN?5SetState?5WAITING?$AA@ ; `string'
EXTRN	__imp__GetTickCount@0:PROC
;	COMDAT ??_C@_0CA@FNMGCOPM@?$FLDoppelGanger?$FN?5SetState?5WAITING?$AA@
CONST	SEGMENT
??_C@_0CA@FNMGCOPM@?$FLDoppelGanger?$FN?5SetState?5WAITING?$AA@ DB '[Dopp'
	DB	'elGanger] SetState WAITING', 00H		; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetState_WAITING@CDoppelGanger@@QAEXXZ PROC		; CDoppelGanger::SetState_WAITING
; _this$ = ecx

; 108  : {

  002e0	55		 push	 ebp
  002e1	8b ec		 mov	 ebp, esp
  002e3	83 ec 44	 sub	 esp, 68			; 00000044H
  002e6	53		 push	 ebx
  002e7	56		 push	 esi
  002e8	57		 push	 edi
  002e9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 109  : 	this->m_DGData.eDuration = 660000; // 11 minutes (10 for event, 1 for cooldown)

  002ec	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002ef	c7 80 08 02 00
	00 20 12 0a 00	 mov	 DWORD PTR [eax+520], 660000 ; 000a1220H

; 110  : 	this->m_DGData.TickCount = GetTickCount();

  002f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  002ff	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00302	89 81 18 02 00
	00		 mov	 DWORD PTR [ecx+536], eax

; 111  : 	this->m_DGData.btPlayState = DG_STATE_WAITING;

  00308	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0030b	c6 40 4a 02	 mov	 BYTE PTR [eax+74], 2

; 112  : 	LogAddTD("[DoppelGanger] SetState WAITING");

  0030f	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@FNMGCOPM@?$FLDoppelGanger?$FN?5SetState?5WAITING?$AA@
  00314	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0031a	83 c4 04	 add	 esp, 4

; 113  : }

  0031d	5f		 pop	 edi
  0031e	5e		 pop	 esi
  0031f	5b		 pop	 ebx
  00320	8b e5		 mov	 esp, ebp
  00322	5d		 pop	 ebp
  00323	c3		 ret	 0
?SetState_WAITING@CDoppelGanger@@QAEXXZ ENDP		; CDoppelGanger::SetState_WAITING
_TEXT	ENDS
PUBLIC	??_C@_0EA@IKMKDNOO@?$FLDoppelGanger?$FN?5SetState?5STARTED?5@ ; `string'
PUBLIC	?SetMonsterCountOnInterface@CDoppelGanger@@QAEXXZ ; CDoppelGanger::SetMonsterCountOnInterface
PUBLIC	?SetEventInterface@CDoppelGanger@@QAEXXZ	; CDoppelGanger::SetEventInterface
PUBLIC	?SetMapAttr@CDoppelGanger@@QAEX_NPAUOBJECTSTRUCT@@@Z ; CDoppelGanger::SetMapAttr
PUBLIC	?SetEventLevel@CDoppelGanger@@QAE_NXZ		; CDoppelGanger::SetEventLevel
;	COMDAT ??_C@_0EA@IKMKDNOO@?$FLDoppelGanger?$FN?5SetState?5STARTED?5@
CONST	SEGMENT
??_C@_0EA@IKMKDNOO@?$FLDoppelGanger?$FN?5SetState?5STARTED?5@ DB '[Doppel'
	DB	'Ganger] SetState STARTED | Players: (%d) MapNumber: (%d)', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetState_STARTED@CDoppelGanger@@QAEXXZ PROC		; CDoppelGanger::SetState_STARTED
; _this$ = ecx

; 116  : {

  00330	55		 push	 ebp
  00331	8b ec		 mov	 ebp, esp
  00333	83 ec 44	 sub	 esp, 68			; 00000044H
  00336	53		 push	 ebx
  00337	56		 push	 esi
  00338	57		 push	 edi
  00339	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 117  : 	this->m_DGData.eDuration = 600000; // for certainly..

  0033c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0033f	c7 80 08 02 00
	00 c0 27 09 00	 mov	 DWORD PTR [eax+520], 600000 ; 000927c0H

; 118  : 	this->m_DGData.HalfTimeInfoSent = false; // for Ice Walker msg

  00349	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0034c	c6 80 1c 02 00
	00 00		 mov	 BYTE PTR [eax+540], 0

; 119  : 	this->m_DGData.CreateMonsterDelay = 2; // first monster create

  00353	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00356	c6 40 48 02	 mov	 BYTE PTR [eax+72], 2

; 120  : 	this->m_DGData.MonsterPassed = 0; // set monster passed portal to 0

  0035a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0035d	c6 40 47 00	 mov	 BYTE PTR [eax+71], 0

; 121  : 	if(this->SetEventLevel() == false)

  00361	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00364	e8 00 00 00 00	 call	 ?SetEventLevel@CDoppelGanger@@QAE_NXZ ; CDoppelGanger::SetEventLevel
  00369	0f b6 c0	 movzx	 eax, al
  0036c	85 c0		 test	 eax, eax
  0036e	75 0c		 jne	 SHORT $LN1@SetState_S

; 122  : 	{
; 123  : 		this->SetState(DG_STATE_ENDED);

  00370	6a 04		 push	 4
  00372	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00375	e8 00 00 00 00	 call	 ?SetState@CDoppelGanger@@QAEXH@Z ; CDoppelGanger::SetState

; 124  : 		return;

  0037a	eb 52		 jmp	 SHORT $LN2@SetState_S
$LN1@SetState_S:

; 125  : 	}
; 126  : 	this->SetMapAttr(false, NULL); // unblock portal zone exit

  0037c	6a 00		 push	 0
  0037e	6a 00		 push	 0
  00380	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00383	e8 00 00 00 00	 call	 ?SetMapAttr@CDoppelGanger@@QAEX_NPAUOBJECTSTRUCT@@@Z ; CDoppelGanger::SetMapAttr

; 127  : 	this->SetEventInterface(); // activate interface

  00388	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0038b	e8 00 00 00 00	 call	 ?SetEventInterface@CDoppelGanger@@QAEXXZ ; CDoppelGanger::SetEventInterface

; 128  : 	this->SetMonsterCountOnInterface();

  00390	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00393	e8 00 00 00 00	 call	 ?SetMonsterCountOnInterface@CDoppelGanger@@QAEXXZ ; CDoppelGanger::SetMonsterCountOnInterface

; 129  : 	this->m_DGData.TickCount = GetTickCount();

  00398	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0039e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003a1	89 81 18 02 00
	00		 mov	 DWORD PTR [ecx+536], eax

; 130  : 	this->m_DGData.btPlayState = DG_STATE_STARTED;

  003a7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  003aa	c6 40 4a 03	 mov	 BYTE PTR [eax+74], 3

; 131  : 	LogAddTD("[DoppelGanger] SetState STARTED | Players: (%d) MapNumber: (%d)", this->m_DGData.PlayerCount, this->m_DGData.MapNumber);

  003ae	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  003b1	8b 88 10 02 00
	00		 mov	 ecx, DWORD PTR [eax+528]
  003b7	51		 push	 ecx
  003b8	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  003bb	0f b6 42 44	 movzx	 eax, BYTE PTR [edx+68]
  003bf	50		 push	 eax
  003c0	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@IKMKDNOO@?$FLDoppelGanger?$FN?5SetState?5STARTED?5@
  003c5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  003cb	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@SetState_S:

; 132  : }

  003ce	5f		 pop	 edi
  003cf	5e		 pop	 esi
  003d0	5b		 pop	 ebx
  003d1	8b e5		 mov	 esp, ebp
  003d3	5d		 pop	 ebp
  003d4	c3		 ret	 0
?SetState_STARTED@CDoppelGanger@@QAEXXZ ENDP		; CDoppelGanger::SetState_STARTED
_TEXT	ENDS
PUBLIC	??_C@_0BO@ODJOIHKO@?$FLDoppelGanger?$FN?5SetState?5ENDED?$AA@ ; `string'
PUBLIC	?DeleteMonster@CDoppelGanger@@QAEXXZ		; CDoppelGanger::DeleteMonster
;	COMDAT ??_C@_0BO@ODJOIHKO@?$FLDoppelGanger?$FN?5SetState?5ENDED?$AA@
CONST	SEGMENT
??_C@_0BO@ODJOIHKO@?$FLDoppelGanger?$FN?5SetState?5ENDED?$AA@ DB '[Doppel'
	DB	'Ganger] SetState ENDED', 00H		; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetState_ENDED@CDoppelGanger@@QAEXXZ PROC		; CDoppelGanger::SetState_ENDED
; _this$ = ecx

; 135  : {

  003e0	55		 push	 ebp
  003e1	8b ec		 mov	 ebp, esp
  003e3	83 ec 44	 sub	 esp, 68			; 00000044H
  003e6	53		 push	 ebx
  003e7	56		 push	 esi
  003e8	57		 push	 edi
  003e9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 136  : 	this->m_DGData.eDuration = DGCoolDown * 60 * 1000;

  003ec	a1 00 00 00 00	 mov	 eax, DWORD PTR ?DGCoolDown@@3HA ; DGCoolDown
  003f1	6b c0 3c	 imul	 eax, 60			; 0000003cH
  003f4	69 c0 e8 03 00
	00		 imul	 eax, 1000		; 000003e8H
  003fa	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003fd	89 81 08 02 00
	00		 mov	 DWORD PTR [ecx+520], eax

; 137  : 	this->DeleteMonster();

  00403	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00406	e8 00 00 00 00	 call	 ?DeleteMonster@CDoppelGanger@@QAEXXZ ; CDoppelGanger::DeleteMonster

; 138  : 	this->m_DGData.TickCount = GetTickCount();

  0040b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00411	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00414	89 81 18 02 00
	00		 mov	 DWORD PTR [ecx+536], eax

; 139  : 	this->m_DGData.btPlayState = DG_STATE_ENDED;

  0041a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0041d	c6 40 4a 04	 mov	 BYTE PTR [eax+74], 4

; 140  : 	LogAddTD("[DoppelGanger] SetState ENDED");

  00421	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@ODJOIHKO@?$FLDoppelGanger?$FN?5SetState?5ENDED?$AA@
  00426	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0042c	83 c4 04	 add	 esp, 4

; 141  : }

  0042f	5f		 pop	 edi
  00430	5e		 pop	 esi
  00431	5b		 pop	 ebx
  00432	8b e5		 mov	 esp, ebp
  00434	5d		 pop	 ebp
  00435	c3		 ret	 0
?SetState_ENDED@CDoppelGanger@@QAEXXZ ENDP		; CDoppelGanger::SetState_ENDED
_TEXT	ENDS
PUBLIC	?ProcState_ENDED@CDoppelGanger@@QAEXXZ		; CDoppelGanger::ProcState_ENDED
PUBLIC	?ProcState_STARTED@CDoppelGanger@@QAEXXZ	; CDoppelGanger::ProcState_STARTED
PUBLIC	?ProcState_WAITING@CDoppelGanger@@QAEXXZ	; CDoppelGanger::ProcState_WAITING
PUBLIC	?ProcState_OPEN@CDoppelGanger@@QAEXXZ		; CDoppelGanger::ProcState_OPEN
PUBLIC	?Run@CDoppelGanger@@QAEXXZ			; CDoppelGanger::Run
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv67 = -72						; size = 4
_this$ = -4						; size = 4
?Run@CDoppelGanger@@QAEXXZ PROC				; CDoppelGanger::Run
; _this$ = ecx

; 144  : {

  00440	55		 push	 ebp
  00441	8b ec		 mov	 ebp, esp
  00443	83 ec 48	 sub	 esp, 72			; 00000048H
  00446	53		 push	 ebx
  00447	56		 push	 esi
  00448	57		 push	 edi
  00449	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 145  : 	switch ( this->m_DGData.btPlayState )

  0044c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0044f	0f b6 48 4a	 movzx	 ecx, BYTE PTR [eax+74]
  00453	89 4d b8	 mov	 DWORD PTR tv67[ebp], ecx
  00456	83 7d b8 04	 cmp	 DWORD PTR tv67[ebp], 4
  0045a	77 32		 ja	 SHORT $LN8@Run
  0045c	8b 55 b8	 mov	 edx, DWORD PTR tv67[ebp]
  0045f	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN10@Run[edx*4]
$LN5@Run:

; 146  : 	{
; 147  : 	case DG_STATE_NONE:
; 148  : 		return;

  00466	eb 26		 jmp	 SHORT $LN8@Run
$LN4@Run:

; 149  : 	case DG_STATE_OPEN:
; 150  : 		this->ProcState_OPEN();

  00468	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0046b	e8 00 00 00 00	 call	 ?ProcState_OPEN@CDoppelGanger@@QAEXXZ ; CDoppelGanger::ProcState_OPEN

; 151  : 		break;

  00470	eb 1c		 jmp	 SHORT $LN8@Run
$LN3@Run:

; 152  : 	case DG_STATE_WAITING:
; 153  : 		this->ProcState_WAITING();

  00472	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00475	e8 00 00 00 00	 call	 ?ProcState_WAITING@CDoppelGanger@@QAEXXZ ; CDoppelGanger::ProcState_WAITING

; 154  : 		break;

  0047a	eb 12		 jmp	 SHORT $LN8@Run
$LN2@Run:

; 155  : 	case DG_STATE_STARTED:
; 156  : 		this->ProcState_STARTED();

  0047c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0047f	e8 00 00 00 00	 call	 ?ProcState_STARTED@CDoppelGanger@@QAEXXZ ; CDoppelGanger::ProcState_STARTED

; 157  : 		break;

  00484	eb 08		 jmp	 SHORT $LN8@Run
$LN1@Run:

; 158  : 	case DG_STATE_ENDED:
; 159  : 		this->ProcState_ENDED();

  00486	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00489	e8 00 00 00 00	 call	 ?ProcState_ENDED@CDoppelGanger@@QAEXXZ ; CDoppelGanger::ProcState_ENDED
$LN8@Run:

; 160  : 		break;
; 161  : 	}
; 162  : }

  0048e	5f		 pop	 edi
  0048f	5e		 pop	 esi
  00490	5b		 pop	 ebx
  00491	8b e5		 mov	 esp, ebp
  00493	5d		 pop	 ebp
  00494	c3		 ret	 0
  00495	8d 49 00	 npad	 3
$LN10@Run:
  00498	00 00 00 00	 DD	 $LN5@Run
  0049c	00 00 00 00	 DD	 $LN4@Run
  004a0	00 00 00 00	 DD	 $LN3@Run
  004a4	00 00 00 00	 DD	 $LN2@Run
  004a8	00 00 00 00	 DD	 $LN1@Run
?Run@CDoppelGanger@@QAEXXZ ENDP				; CDoppelGanger::Run
; Function compile flags: /Odtp /ZI
_this$ = -4						; size = 4
?ProcState_OPEN@CDoppelGanger@@QAEXXZ PROC		; CDoppelGanger::ProcState_OPEN
; _this$ = ecx

; 165  : {

  004b0	55		 push	 ebp
  004b1	8b ec		 mov	 ebp, esp
  004b3	83 ec 44	 sub	 esp, 68			; 00000044H
  004b6	53		 push	 ebx
  004b7	56		 push	 esi
  004b8	57		 push	 edi
  004b9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 166  : 	if(this->m_DGData.PlayerCount > 0)

  004bc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  004bf	0f b6 48 44	 movzx	 ecx, BYTE PTR [eax+68]
  004c3	85 c9		 test	 ecx, ecx
  004c5	7e 0a		 jle	 SHORT $LN2@ProcState_

; 167  : 	{
; 168  : 		this->SetState(DG_STATE_WAITING);

  004c7	6a 02		 push	 2
  004c9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  004cc	e8 00 00 00 00	 call	 ?SetState@CDoppelGanger@@QAEXH@Z ; CDoppelGanger::SetState
$LN2@ProcState_:

; 169  : 	}
; 170  : }

  004d1	5f		 pop	 edi
  004d2	5e		 pop	 esi
  004d3	5b		 pop	 ebx
  004d4	8b e5		 mov	 esp, ebp
  004d6	5d		 pop	 ebp
  004d7	c3		 ret	 0
?ProcState_OPEN@CDoppelGanger@@QAEXXZ ENDP		; CDoppelGanger::ProcState_OPEN
_TEXT	ENDS
PUBLIC	?SendHalfTimeInfo@CDoppelGanger@@QAEXH@Z	; CDoppelGanger::SendHalfTimeInfo
PUBLIC	??_C@_0CF@CBMNKJPH@?$FLDoppelGanger?$FN?5Reset?5Event?5?9?5No?5@ ; `string'
PUBLIC	?CheckUsers@CDoppelGanger@@QAEXXZ		; CDoppelGanger::CheckUsers
;	COMDAT ??_C@_0CF@CBMNKJPH@?$FLDoppelGanger?$FN?5Reset?5Event?5?9?5No?5@
CONST	SEGMENT
??_C@_0CF@CBMNKJPH@?$FLDoppelGanger?$FN?5Reset?5Event?5?9?5No?5@ DB '[Dop'
	DB	'pelGanger] Reset Event - No user', 00H	; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_Tick$ = -8						; size = 4
_this$ = -4						; size = 4
?ProcState_WAITING@CDoppelGanger@@QAEXXZ PROC		; CDoppelGanger::ProcState_WAITING
; _this$ = ecx

; 173  : {

  004e0	55		 push	 ebp
  004e1	8b ec		 mov	 ebp, esp
  004e3	83 ec 48	 sub	 esp, 72			; 00000048H
  004e6	53		 push	 ebx
  004e7	56		 push	 esi
  004e8	57		 push	 edi
  004e9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 174  : 	int Tick = GetTickCount() - this->m_DGData.TickCount;

  004ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  004f2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  004f5	2b 81 18 02 00
	00		 sub	 eax, DWORD PTR [ecx+536]
  004fb	89 45 f8	 mov	 DWORD PTR _Tick$[ebp], eax

; 175  : 
; 176  : 	if(Tick >= 1000)

  004fe	81 7d f8 e8 03
	00 00		 cmp	 DWORD PTR _Tick$[ebp], 1000 ; 000003e8H
  00505	0f 8c 91 00 00
	00		 jl	 $LN5@ProcState_@2

; 177  : 	{
; 178  : 		this->m_DGData.eDuration -= Tick;

  0050b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0050e	8b 88 08 02 00
	00		 mov	 ecx, DWORD PTR [eax+520]
  00514	2b 4d f8	 sub	 ecx, DWORD PTR _Tick$[ebp]
  00517	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0051a	89 8a 08 02 00
	00		 mov	 DWORD PTR [edx+520], ecx

; 179  : 		this->m_DGData.TickCount = GetTickCount();

  00520	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00526	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00529	89 81 18 02 00
	00		 mov	 DWORD PTR [ecx+536], eax

; 180  : 
; 181  : 		this->CheckUsers();

  0052f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00532	e8 00 00 00 00	 call	 ?CheckUsers@CDoppelGanger@@QAEXXZ ; CDoppelGanger::CheckUsers

; 182  : 
; 183  : 		if(this->m_DGData.PlayerCount <= 0)

  00537	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0053a	0f b6 48 44	 movzx	 ecx, BYTE PTR [eax+68]
  0053e	85 c9		 test	 ecx, ecx
  00540	7f 1a		 jg	 SHORT $LN3@ProcState_@2

; 184  : 		{
; 185  : 			LogAddTD("[DoppelGanger] Reset Event - No user");

  00542	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@CBMNKJPH@?$FLDoppelGanger?$FN?5Reset?5Event?5?9?5No?5@
  00547	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0054d	83 c4 04	 add	 esp, 4

; 186  : 			this->SetState(DG_STATE_ENDED);

  00550	6a 04		 push	 4
  00552	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00555	e8 00 00 00 00	 call	 ?SetState@CDoppelGanger@@QAEXH@Z ; CDoppelGanger::SetState

; 187  : 			return;

  0055a	eb 40		 jmp	 SHORT $LN5@ProcState_@2
$LN3@ProcState_@2:

; 188  : 		}
; 189  : 
; 190  : 
; 191  : 		if(this->m_DGData.eDuration <= 630000 && this->m_DGData.HalfTimeInfoSent == false)

  0055c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0055f	81 b8 08 02 00
	00 f0 9c 09 00	 cmp	 DWORD PTR [eax+520], 630000 ; 00099cf0H
  00569	7f 18		 jg	 SHORT $LN2@ProcState_@2
  0056b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0056e	0f b6 88 1c 02
	00 00		 movzx	 ecx, BYTE PTR [eax+540]
  00575	85 c9		 test	 ecx, ecx
  00577	75 0a		 jne	 SHORT $LN2@ProcState_@2

; 192  : 		{
; 193  : 			this->SendHalfTimeInfo(17);

  00579	6a 11		 push	 17			; 00000011H
  0057b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0057e	e8 00 00 00 00	 call	 ?SendHalfTimeInfo@CDoppelGanger@@QAEXH@Z ; CDoppelGanger::SendHalfTimeInfo
$LN2@ProcState_@2:

; 194  : 		}
; 195  : 
; 196  : 		if(this->m_DGData.eDuration <= 600000)

  00583	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00586	81 b8 08 02 00
	00 c0 27 09 00	 cmp	 DWORD PTR [eax+520], 600000 ; 000927c0H
  00590	7f 0a		 jg	 SHORT $LN5@ProcState_@2

; 197  : 		{
; 198  : 			this->SetState(DG_STATE_STARTED);

  00592	6a 03		 push	 3
  00594	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00597	e8 00 00 00 00	 call	 ?SetState@CDoppelGanger@@QAEXH@Z ; CDoppelGanger::SetState
$LN5@ProcState_@2:

; 199  : 		}
; 200  : 	}
; 201  : }

  0059c	5f		 pop	 edi
  0059d	5e		 pop	 esi
  0059e	5b		 pop	 ebx
  0059f	8b e5		 mov	 esp, ebp
  005a1	5d		 pop	 ebp
  005a2	c3		 ret	 0
?ProcState_WAITING@CDoppelGanger@@QAEXXZ ENDP		; CDoppelGanger::ProcState_WAITING
_TEXT	ENDS
PUBLIC	??_C@_0DB@IKIFAIFH@?$FLDoppelGanger?$FN?5Quest?5Success?5?$HM?5M@ ; `string'
PUBLIC	?CreateFinalChest@CDoppelGanger@@QAEXXZ		; CDoppelGanger::CreateFinalChest
PUBLIC	??_C@_0DO@EHJBCEFB@?$FLDoppelGanger?$FN?5Quest?5Failed?5?9?5to@ ; `string'
PUBLIC	?SendResultMessage@CDoppelGanger@@QAEXE_NH@Z	; CDoppelGanger::SendResultMessage
PUBLIC	?SendDoppelGangerPlayer@CDoppelGanger@@QAEXPAEH@Z ; CDoppelGanger::SendDoppelGangerPlayer
PUBLIC	??_C@_0BH@IKDDMHHM@Ice?5walker?5time?5passed?$AA@ ; `string'
PUBLIC	?SendIceWalkerPos@CDoppelGanger@@QAEXXZ		; CDoppelGanger::SendIceWalkerPos
PUBLIC	?CreateIceWalker@CDoppelGanger@@QAEXXZ		; CDoppelGanger::CreateIceWalker
PUBLIC	?CreateAngryButcher@CDoppelGanger@@QAEXXZ	; CDoppelGanger::CreateAngryButcher
PUBLIC	?CreateButcher@CDoppelGanger@@QAEXXZ		; CDoppelGanger::CreateButcher
PUBLIC	?CheckPosition@CDoppelGanger@@QAEXXZ		; CDoppelGanger::CheckPosition
PUBLIC	?SendMonsterPos@CDoppelGanger@@QAEXXZ		; CDoppelGanger::SendMonsterPos
PUBLIC	?SendPlayerPos@CDoppelGanger@@QAEXXZ		; CDoppelGanger::SendPlayerPos
PUBLIC	?CreateMonster@CDoppelGanger@@QAEXXZ		; CDoppelGanger::CreateMonster
PUBLIC	__$ArrayPad$
EXTRN	?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z:PROC	; TNotice::MakeNoticeMsg
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_0DB@IKIFAIFH@?$FLDoppelGanger?$FN?5Quest?5Success?5?$HM?5M@
CONST	SEGMENT
??_C@_0DB@IKIFAIFH@?$FLDoppelGanger?$FN?5Quest?5Success?5?$HM?5M@ DB '[Do'
	DB	'ppelGanger] Quest Success | Monsters: (%d/%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@EHJBCEFB@?$FLDoppelGanger?$FN?5Quest?5Failed?5?9?5to@
CONST	SEGMENT
??_C@_0DO@EHJBCEFB@?$FLDoppelGanger?$FN?5Quest?5Failed?5?9?5to@ DB '[Dopp'
	DB	'elGanger] Quest Failed - too many monsters passed portal', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@IKDDMHHM@Ice?5walker?5time?5passed?$AA@
CONST	SEGMENT
??_C@_0BH@IKDDMHHM@Ice?5walker?5time?5passed?$AA@ DB 'Ice walker time pas'
	DB	'sed', 00H					; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_pNotice$231408 = -284					; size = 272
_Tick$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?ProcState_STARTED@CDoppelGanger@@QAEXXZ PROC		; CDoppelGanger::ProcState_STARTED
; _this$ = ecx

; 204  : {

  005b0	55		 push	 ebp
  005b1	8b ec		 mov	 ebp, esp
  005b3	81 ec 5c 01 00
	00		 sub	 esp, 348		; 0000015cH
  005b9	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  005be	33 c5		 xor	 eax, ebp
  005c0	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  005c3	53		 push	 ebx
  005c4	56		 push	 esi
  005c5	57		 push	 edi
  005c6	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 205  : 	int Tick = GetTickCount() - this->m_DGData.TickCount;

  005c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  005cf	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  005d2	2b 81 18 02 00
	00		 sub	 eax, DWORD PTR [ecx+536]
  005d8	89 45 f4	 mov	 DWORD PTR _Tick$[ebp], eax

; 206  : 
; 207  : 	if(Tick >= 1000)

  005db	81 7d f4 e8 03
	00 00		 cmp	 DWORD PTR _Tick$[ebp], 1000 ; 000003e8H
  005e2	0f 8c 95 02 00
	00		 jl	 $LN14@ProcState_@3

; 208  : 	{
; 209  : 		this->m_DGData.eDuration -= Tick;

  005e8	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  005eb	8b 88 08 02 00
	00		 mov	 ecx, DWORD PTR [eax+520]
  005f1	2b 4d f4	 sub	 ecx, DWORD PTR _Tick$[ebp]
  005f4	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  005f7	89 8a 08 02 00
	00		 mov	 DWORD PTR [edx+520], ecx

; 210  : 		this->m_DGData.TickCount = GetTickCount();

  005fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00603	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00606	89 81 18 02 00
	00		 mov	 DWORD PTR [ecx+536], eax

; 211  : 		++this->m_DGData.CreateMonsterDelay;

  0060c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0060f	8a 48 48	 mov	 cl, BYTE PTR [eax+72]
  00612	80 c1 01	 add	 cl, 1
  00615	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00618	88 4a 48	 mov	 BYTE PTR [edx+72], cl

; 212  : 		if(this->m_DGData.CreateMonsterDelay == 3)

  0061b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0061e	0f b6 48 48	 movzx	 ecx, BYTE PTR [eax+72]
  00622	83 f9 03	 cmp	 ecx, 3
  00625	75 0f		 jne	 SHORT $LN12@ProcState_@3

; 213  : 		{
; 214  : 			this->CreateMonster();

  00627	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0062a	e8 00 00 00 00	 call	 ?CreateMonster@CDoppelGanger@@QAEXXZ ; CDoppelGanger::CreateMonster

; 215  : 			this->m_DGData.CreateMonsterDelay = 0;

  0062f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00632	c6 40 48 00	 mov	 BYTE PTR [eax+72], 0
$LN12@ProcState_@3:

; 216  : 		}
; 217  : 
; 218  : 		if(this->m_DGData.PlayerCount <= 0)

  00636	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00639	0f b6 48 44	 movzx	 ecx, BYTE PTR [eax+68]
  0063d	85 c9		 test	 ecx, ecx
  0063f	7f 1d		 jg	 SHORT $LN11@ProcState_@3

; 219  : 		{
; 220  : 			LogAddTD("[DoppelGanger] Reset Event - No user");

  00641	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@CBMNKJPH@?$FLDoppelGanger?$FN?5Reset?5Event?5?9?5No?5@
  00646	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0064c	83 c4 04	 add	 esp, 4

; 221  : 			this->SetState(DG_STATE_ENDED);

  0064f	6a 04		 push	 4
  00651	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00654	e8 00 00 00 00	 call	 ?SetState@CDoppelGanger@@QAEXH@Z ; CDoppelGanger::SetState

; 222  : 			return;

  00659	e9 1f 02 00 00	 jmp	 $LN14@ProcState_@3
$LN11@ProcState_@3:

; 223  : 		}
; 224  : 
; 225  : 		this->SendPlayerPos();

  0065e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00661	e8 00 00 00 00	 call	 ?SendPlayerPos@CDoppelGanger@@QAEXXZ ; CDoppelGanger::SendPlayerPos

; 226  : 		this->SendMonsterPos();

  00666	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00669	e8 00 00 00 00	 call	 ?SendMonsterPos@CDoppelGanger@@QAEXXZ ; CDoppelGanger::SendMonsterPos

; 227  : 		this->CheckPosition();

  0066e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00671	e8 00 00 00 00	 call	 ?CheckPosition@CDoppelGanger@@QAEXXZ ; CDoppelGanger::CheckPosition

; 228  : 		this->CheckUsers();

  00676	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00679	e8 00 00 00 00	 call	 ?CheckUsers@CDoppelGanger@@QAEXXZ ; CDoppelGanger::CheckUsers

; 229  : 		if(this->m_DGData.eDuration < 480000 && this->m_DGData.PhazesPassed == 0)

  0067e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00681	81 b8 08 02 00
	00 00 53 07 00	 cmp	 DWORD PTR [eax+520], 480000 ; 00075300H
  0068b	7d 16		 jge	 SHORT $LN10@ProcState_@3
  0068d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00690	0f b6 88 23 02
	00 00		 movzx	 ecx, BYTE PTR [eax+547]
  00697	85 c9		 test	 ecx, ecx
  00699	75 08		 jne	 SHORT $LN10@ProcState_@3

; 230  : 		{
; 231  : 			this->CreateButcher();

  0069b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0069e	e8 00 00 00 00	 call	 ?CreateButcher@CDoppelGanger@@QAEXXZ ; CDoppelGanger::CreateButcher
$LN10@ProcState_@3:

; 232  : 		}
; 233  : 
; 234  : 		if(this->m_DGData.eDuration < 360000 && this->m_DGData.PhazesPassed == 1)

  006a3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  006a6	81 b8 08 02 00
	00 40 7e 05 00	 cmp	 DWORD PTR [eax+520], 360000 ; 00057e40H
  006b0	7d 17		 jge	 SHORT $LN9@ProcState_@3
  006b2	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  006b5	0f b6 88 23 02
	00 00		 movzx	 ecx, BYTE PTR [eax+547]
  006bc	83 f9 01	 cmp	 ecx, 1
  006bf	75 08		 jne	 SHORT $LN9@ProcState_@3

; 235  : 		{
; 236  : 			this->CreateButcher();

  006c1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  006c4	e8 00 00 00 00	 call	 ?CreateButcher@CDoppelGanger@@QAEXXZ ; CDoppelGanger::CreateButcher
$LN9@ProcState_@3:

; 237  : 		}
; 238  : 
; 239  : 		if(this->m_DGData.eDuration < 300000 && this->m_DGData.PhazesPassed == 2)

  006c9	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  006cc	81 b8 08 02 00
	00 e0 93 04 00	 cmp	 DWORD PTR [eax+520], 300000 ; 000493e0H
  006d6	7d 17		 jge	 SHORT $LN8@ProcState_@3
  006d8	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  006db	0f b6 88 23 02
	00 00		 movzx	 ecx, BYTE PTR [eax+547]
  006e2	83 f9 02	 cmp	 ecx, 2
  006e5	75 08		 jne	 SHORT $LN8@ProcState_@3

; 240  : 		{
; 241  : 			this->CreateAngryButcher();

  006e7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  006ea	e8 00 00 00 00	 call	 ?CreateAngryButcher@CDoppelGanger@@QAEXXZ ; CDoppelGanger::CreateAngryButcher
$LN8@ProcState_@3:

; 242  : 		}
; 243  : 
; 244  : 		if(this->m_DGData.eDuration < 210000 && this->m_DGData.PhazesPassed == 3)

  006ef	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  006f2	81 b8 08 02 00
	00 50 34 03 00	 cmp	 DWORD PTR [eax+520], 210000 ; 00033450H
  006fc	7d 17		 jge	 SHORT $LN7@ProcState_@3
  006fe	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00701	0f b6 88 23 02
	00 00		 movzx	 ecx, BYTE PTR [eax+547]
  00708	83 f9 03	 cmp	 ecx, 3
  0070b	75 08		 jne	 SHORT $LN7@ProcState_@3

; 245  : 		{
; 246  : 			this->CreateIceWalker();

  0070d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00710	e8 00 00 00 00	 call	 ?CreateIceWalker@CDoppelGanger@@QAEXXZ ; CDoppelGanger::CreateIceWalker
$LN7@ProcState_@3:

; 247  : 		}
; 248  : 
; 249  : 		if(this->m_DGData.PhazesPassed == 4 && gObjIsConnected(this->m_DGData.IceWalkerIndex))

  00715	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00718	0f b6 88 23 02
	00 00		 movzx	 ecx, BYTE PTR [eax+547]
  0071f	83 f9 04	 cmp	 ecx, 4
  00722	0f 85 df 00 00
	00		 jne	 $LN6@ProcState_@3
  00728	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0072b	0f bf 48 52	 movsx	 ecx, WORD PTR [eax+82]
  0072f	51		 push	 ecx
  00730	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00735	83 c4 04	 add	 esp, 4
  00738	85 c0		 test	 eax, eax
  0073a	0f 84 c7 00 00
	00		 je	 $LN6@ProcState_@3

; 250  : 		{
; 251  : 			this->SendIceWalkerPos();

  00740	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00743	e8 00 00 00 00	 call	 ?SendIceWalkerPos@CDoppelGanger@@QAEXXZ ; CDoppelGanger::SendIceWalkerPos

; 252  : 			if(gObj[this->m_DGData.IceWalkerIndex].Live == true)

  00748	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0074b	0f bf 48 52	 movsx	 ecx, WORD PTR [eax+82]
  0074f	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  00755	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0075b	0f b6 44 0a 6a	 movzx	 eax, BYTE PTR [edx+ecx+106]
  00760	83 f8 01	 cmp	 eax, 1
  00763	0f 85 9e 00 00
	00		 jne	 $LN6@ProcState_@3

; 253  : 			{
; 254  : 				--this->m_DGData.IceWalkerPhazeTime;

  00769	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0076c	66 8b 88 1e 02
	00 00		 mov	 cx, WORD PTR [eax+542]
  00773	66 83 e9 01	 sub	 cx, 1
  00777	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0077a	66 89 8a 1e 02
	00 00		 mov	 WORD PTR [edx+542], cx

; 255  : 				if(this->m_DGData.IceWalkerPhazeTime <= 30 && this->m_DGData.HalfTimeInfoSent == false)

  00781	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00784	0f bf 88 1e 02
	00 00		 movsx	 ecx, WORD PTR [eax+542]
  0078b	83 f9 1e	 cmp	 ecx, 30			; 0000001eH
  0078e	7f 22		 jg	 SHORT $LN4@ProcState_@3
  00790	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00793	0f b6 88 1c 02
	00 00		 movzx	 ecx, BYTE PTR [eax+540]
  0079a	85 c9		 test	 ecx, ecx
  0079c	75 14		 jne	 SHORT $LN4@ProcState_@3

; 256  : 				{
; 257  : 					this->SendHalfTimeInfo(18);

  0079e	6a 12		 push	 18			; 00000012H
  007a0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  007a3	e8 00 00 00 00	 call	 ?SendHalfTimeInfo@CDoppelGanger@@QAEXH@Z ; CDoppelGanger::SendHalfTimeInfo

; 258  : 					this->m_DGData.HalfTimeInfoSent = true;

  007a8	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  007ab	c6 80 1c 02 00
	00 01		 mov	 BYTE PTR [eax+540], 1
$LN4@ProcState_@3:

; 259  : 				}
; 260  : 				if(this->m_DGData.IceWalkerPhazeTime <= 0)

  007b2	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  007b5	0f bf 88 1e 02
	00 00		 movsx	 ecx, WORD PTR [eax+542]
  007bc	85 c9		 test	 ecx, ecx
  007be	7f 47		 jg	 SHORT $LN6@ProcState_@3

; 261  : 				{
; 262  : 					PMSG_NOTICE pNotice;
; 263  : 					TNotice::MakeNoticeMsg(&pNotice, 0, "Ice walker time passed");

  007c0	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@IKDDMHHM@Ice?5walker?5time?5passed?$AA@
  007c5	6a 00		 push	 0
  007c7	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$231408[ebp]
  007cd	50		 push	 eax
  007ce	e8 00 00 00 00	 call	 ?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z ; TNotice::MakeNoticeMsg
  007d3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 264  : 					this->SendDoppelGangerPlayer((LPBYTE)&pNotice, pNotice.h.size);

  007d6	0f b6 85 e5 fe
	ff ff		 movzx	 eax, BYTE PTR _pNotice$231408[ebp+1]
  007dd	50		 push	 eax
  007de	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$231408[ebp]
  007e4	51		 push	 ecx
  007e5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  007e8	e8 00 00 00 00	 call	 ?SendDoppelGangerPlayer@CDoppelGanger@@QAEXPAEH@Z ; CDoppelGanger::SendDoppelGangerPlayer

; 265  : 					gObjDel(this->m_DGData.IceWalkerIndex);

  007ed	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  007f0	0f bf 48 52	 movsx	 ecx, WORD PTR [eax+82]
  007f4	51		 push	 ecx
  007f5	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  007fa	83 c4 04	 add	 esp, 4

; 266  : 					this->m_DGData.IceWalkerIndex = -1;

  007fd	83 c8 ff	 or	 eax, -1
  00800	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00803	66 89 41 52	 mov	 WORD PTR [ecx+82], ax
$LN6@ProcState_@3:

; 267  : 				}
; 268  : 			}
; 269  : 		}
; 270  : 
; 271  : 		if(this->m_DGData.MonsterPassed >= GOER_MAX_PASS_PORTAL)

  00807	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0080a	0f b6 48 47	 movzx	 ecx, BYTE PTR [eax+71]
  0080e	83 f9 03	 cmp	 ecx, 3
  00811	7c 26		 jl	 SHORT $LN2@ProcState_@3

; 272  : 		{
; 273  : 			this->SendResultMessage(DG_RESULT_DEFENSE_FAIL, true, -1);

  00813	6a ff		 push	 -1
  00815	6a 01		 push	 1
  00817	6a 02		 push	 2
  00819	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0081c	e8 00 00 00 00	 call	 ?SendResultMessage@CDoppelGanger@@QAEXE_NH@Z ; CDoppelGanger::SendResultMessage

; 274  : 			this->SetState(DG_STATE_ENDED);

  00821	6a 04		 push	 4
  00823	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00826	e8 00 00 00 00	 call	 ?SetState@CDoppelGanger@@QAEXH@Z ; CDoppelGanger::SetState

; 275  : 			LogAddTD("[DoppelGanger] Quest Failed - too many monsters passed portal");

  0082b	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@EHJBCEFB@?$FLDoppelGanger?$FN?5Quest?5Failed?5?9?5to@
  00830	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00836	83 c4 04	 add	 esp, 4
$LN2@ProcState_@3:

; 276  : 		}
; 277  : 
; 278  : 		if(this->m_DGData.eDuration <= 0)

  00839	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0083c	83 b8 08 02 00
	00 00		 cmp	 DWORD PTR [eax+520], 0
  00843	7f 38		 jg	 SHORT $LN14@ProcState_@3

; 279  : 		{
; 280  : 			this->CreateFinalChest();

  00845	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00848	e8 00 00 00 00	 call	 ?CreateFinalChest@CDoppelGanger@@QAEXXZ ; CDoppelGanger::CreateFinalChest

; 281  : 			this->SendResultMessage(DG_RESULT_SUCCESS, true, -1);

  0084d	6a ff		 push	 -1
  0084f	6a 01		 push	 1
  00851	6a 00		 push	 0
  00853	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00856	e8 00 00 00 00	 call	 ?SendResultMessage@CDoppelGanger@@QAEXE_NH@Z ; CDoppelGanger::SendResultMessage

; 282  : 			this->SetState(DG_STATE_ENDED);

  0085b	6a 04		 push	 4
  0085d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00860	e8 00 00 00 00	 call	 ?SetState@CDoppelGanger@@QAEXH@Z ; CDoppelGanger::SetState

; 283  : 			LogAddTD("[DoppelGanger] Quest Success | Monsters: (%d/%d)", this->m_DGData.MonsterPassed, GOER_MAX_PASS_PORTAL);

  00865	6a 03		 push	 3
  00867	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0086a	0f b6 48 47	 movzx	 ecx, BYTE PTR [eax+71]
  0086e	51		 push	 ecx
  0086f	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@IKIFAIFH@?$FLDoppelGanger?$FN?5Quest?5Success?5?$HM?5M@
  00874	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0087a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN14@ProcState_@3:

; 284  : 		}
; 285  : 	}
; 286  : }

  0087d	5f		 pop	 edi
  0087e	5e		 pop	 esi
  0087f	5b		 pop	 ebx
  00880	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00883	33 cd		 xor	 ecx, ebp
  00885	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0088a	8b e5		 mov	 esp, ebp
  0088c	5d		 pop	 ebp
  0088d	c3		 ret	 0
?ProcState_STARTED@CDoppelGanger@@QAEXXZ ENDP		; CDoppelGanger::ProcState_STARTED
; Function compile flags: /Odtp /ZI
_Tick$ = -8						; size = 4
_this$ = -4						; size = 4
?ProcState_ENDED@CDoppelGanger@@QAEXXZ PROC		; CDoppelGanger::ProcState_ENDED
; _this$ = ecx

; 289  : {

  00890	55		 push	 ebp
  00891	8b ec		 mov	 ebp, esp
  00893	83 ec 48	 sub	 esp, 72			; 00000048H
  00896	53		 push	 ebx
  00897	56		 push	 esi
  00898	57		 push	 edi
  00899	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 290  : 	int Tick = GetTickCount() - this->m_DGData.TickCount;

  0089c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  008a2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  008a5	2b 81 18 02 00
	00		 sub	 eax, DWORD PTR [ecx+536]
  008ab	89 45 f8	 mov	 DWORD PTR _Tick$[ebp], eax

; 291  : 
; 292  : 	if(Tick >= 1000)

  008ae	81 7d f8 e8 03
	00 00		 cmp	 DWORD PTR _Tick$[ebp], 1000 ; 000003e8H
  008b5	7c 3a		 jl	 SHORT $LN3@ProcState_@4

; 293  : 	{
; 294  : 		this->m_DGData.eDuration -= Tick;

  008b7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  008ba	8b 88 08 02 00
	00		 mov	 ecx, DWORD PTR [eax+520]
  008c0	2b 4d f8	 sub	 ecx, DWORD PTR _Tick$[ebp]
  008c3	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  008c6	89 8a 08 02 00
	00		 mov	 DWORD PTR [edx+520], ecx

; 295  : 		this->m_DGData.TickCount = GetTickCount();

  008cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  008d2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  008d5	89 81 18 02 00
	00		 mov	 DWORD PTR [ecx+536], eax

; 296  : 
; 297  : 		if(this->m_DGData.eDuration <= 0)

  008db	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  008de	83 b8 08 02 00
	00 00		 cmp	 DWORD PTR [eax+520], 0
  008e5	7f 0a		 jg	 SHORT $LN3@ProcState_@4

; 298  : 		{
; 299  : 			//this->CreateFinalChest();
; 300  : 			this->SetState(DG_STATE_OPEN);	

  008e7	6a 01		 push	 1
  008e9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  008ec	e8 00 00 00 00	 call	 ?SetState@CDoppelGanger@@QAEXH@Z ; CDoppelGanger::SetState
$LN3@ProcState_@4:

; 301  : 		}
; 302  : 	}
; 303  : }

  008f1	5f		 pop	 edi
  008f2	5e		 pop	 esi
  008f3	5b		 pop	 ebx
  008f4	8b e5		 mov	 esp, ebp
  008f6	5d		 pop	 ebp
  008f7	c3		 ret	 0
?ProcState_ENDED@CDoppelGanger@@QAEXXZ ENDP		; CDoppelGanger::ProcState_ENDED
_TEXT	ENDS
PUBLIC	??_C@_0DF@JEEBAHNK@?$FLDoppelGanger?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Entered?5@ ; `string'
PUBLIC	?SetMapNumber@CDoppelGanger@@QAEHXZ		; CDoppelGanger::SetMapNumber
PUBLIC	?AddPlayer@CDoppelGanger@@QAE_NPAUOBJECTSTRUCT@@@Z ; CDoppelGanger::AddPlayer
PUBLIC	??_C@_0BH@FNALGCI@You?5are?5short?5of?5money?$AA@ ; `string'
PUBLIC	?EnterEvent@CDoppelGanger@@QAEXPAUOBJECTSTRUCT@@@Z ; CDoppelGanger::EnterEvent
EXTRN	?GCInventoryItemDeleteSend@@YAXHEE@Z:PROC	; GCInventoryItemDeleteSend
EXTRN	?gObjInventoryDeleteItem@@YAEHH@Z:PROC		; gObjInventoryDeleteItem
EXTRN	?GCMoneySend@@YAXHK@Z:PROC			; GCMoneySend
EXTRN	?GCServerMsgStringSend@@YAXPADHE@Z:PROC		; GCServerMsgStringSend
;	COMDAT ??_C@_0DF@JEEBAHNK@?$FLDoppelGanger?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Entered?5@
CONST	SEGMENT
??_C@_0DF@JEEBAHNK@?$FLDoppelGanger?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Entered?5@ DB '['
	DB	'DoppelGanger] [%s][%s] Entered to DoppelGanger (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@FNALGCI@You?5are?5short?5of?5money?$AA@
CONST	SEGMENT
??_C@_0BH@FNALGCI@You?5are?5short?5of?5money?$AA@ DB 'You are short of mo'
	DB	'ney', 00H					; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_iGate$231455 = -16					; size = 4
_i$231444 = -12						; size = 2
_invitationpos$ = -8					; size = 4
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?EnterEvent@CDoppelGanger@@QAEXPAUOBJECTSTRUCT@@@Z PROC	; CDoppelGanger::EnterEvent
; _this$ = ecx

; 309  : {

  00900	55		 push	 ebp
  00901	8b ec		 mov	 ebp, esp
  00903	83 ec 50	 sub	 esp, 80			; 00000050H
  00906	53		 push	 ebx
  00907	56		 push	 esi
  00908	57		 push	 edi
  00909	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 310  : 
; 311  : 	if(this->m_DGData.btPlayState != DG_STATE_OPEN && this->m_DGData.btPlayState != DG_STATE_WAITING)

  0090c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0090f	0f b6 48 4a	 movzx	 ecx, BYTE PTR [eax+74]
  00913	83 f9 01	 cmp	 ecx, 1
  00916	74 11		 je	 SHORT $LN11@EnterEvent
  00918	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0091b	0f b6 48 4a	 movzx	 ecx, BYTE PTR [eax+74]
  0091f	83 f9 02	 cmp	 ecx, 2
  00922	74 05		 je	 SHORT $LN11@EnterEvent

; 312  : 	{
; 313  : 		return;

  00924	e9 a9 01 00 00	 jmp	 $LN12@EnterEvent
$LN11@EnterEvent:

; 314  : 	}
; 315  : 
; 316  : 	if(lpObj->TargetShopNumber != 540) // Lugard

  00929	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0092c	0f bf 88 5a 04
	00 00		 movsx	 ecx, WORD PTR [eax+1114]
  00933	81 f9 1c 02 00
	00		 cmp	 ecx, 540		; 0000021cH
  00939	74 05		 je	 SHORT $LN10@EnterEvent

; 317  : 	{
; 318  : 		return;

  0093b	e9 92 01 00 00	 jmp	 $LN12@EnterEvent
$LN10@EnterEvent:

; 319  : 	}
; 320  : 
; 321  : 	int invitationpos = -1;

  00940	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _invitationpos$[ebp], -1

; 322  : 
; 323  : 	for(short i = 12 ; i < 76; ++i)

  00947	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  0094c	66 89 45 f4	 mov	 WORD PTR _i$231444[ebp], ax
  00950	eb 0c		 jmp	 SHORT $LN9@EnterEvent
$LN8@EnterEvent:
  00952	66 8b 45 f4	 mov	 ax, WORD PTR _i$231444[ebp]
  00956	66 83 c0 01	 add	 ax, 1
  0095a	66 89 45 f4	 mov	 WORD PTR _i$231444[ebp], ax
$LN9@EnterEvent:
  0095e	0f bf 45 f4	 movsx	 eax, WORD PTR _i$231444[ebp]
  00962	83 f8 4c	 cmp	 eax, 76			; 0000004cH
  00965	7d 46		 jge	 SHORT $LN7@EnterEvent

; 324  : 	{
; 325  : 		if(lpObj->pInventory[i].m_Type > 0 && lpObj->pInventory[i].m_Type == ITEMGET(14,111))

  00967	0f bf 45 f4	 movsx	 eax, WORD PTR _i$231444[ebp]
  0096b	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00971	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00974	8b 91 24 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3620]
  0097a	0f bf 44 02 06	 movsx	 eax, WORD PTR [edx+eax+6]
  0097f	85 c0		 test	 eax, eax
  00981	7e 28		 jle	 SHORT $LN6@EnterEvent
  00983	0f bf 45 f4	 movsx	 eax, WORD PTR _i$231444[ebp]
  00987	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  0098d	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00990	8b 91 24 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3620]
  00996	0f bf 44 02 06	 movsx	 eax, WORD PTR [edx+eax+6]
  0099b	3d 6f 1c 00 00	 cmp	 eax, 7279		; 00001c6fH
  009a0	75 09		 jne	 SHORT $LN6@EnterEvent

; 326  : 		{
; 327  : 			invitationpos = i;

  009a2	0f bf 45 f4	 movsx	 eax, WORD PTR _i$231444[ebp]
  009a6	89 45 f8	 mov	 DWORD PTR _invitationpos$[ebp], eax

; 328  : 			break;

  009a9	eb 02		 jmp	 SHORT $LN7@EnterEvent
$LN6@EnterEvent:

; 329  : 		}
; 330  : 	}

  009ab	eb a5		 jmp	 SHORT $LN8@EnterEvent
$LN7@EnterEvent:

; 331  : 	if(invitationpos == -1)

  009ad	83 7d f8 ff	 cmp	 DWORD PTR _invitationpos$[ebp], -1
  009b1	75 05		 jne	 SHORT $LN5@EnterEvent

; 332  : 		return;

  009b3	e9 1a 01 00 00	 jmp	 $LN12@EnterEvent
$LN5@EnterEvent:

; 333  : 
; 334  : 	//if(lpObj->VipType == 0)
; 335  : 	//{
; 336  : 	if(lpObj->Money < DGEnterMoney)

  009b8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009bb	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  009c1	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?DGEnterMoney@@3HA ; DGEnterMoney
  009c7	7d 1a		 jge	 SHORT $LN4@EnterEvent

; 337  : 	{
; 338  : 		GCServerMsgStringSend("You are short of money", lpObj->m_Index, 1);

  009c9	6a 01		 push	 1
  009cb	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009ce	8b 08		 mov	 ecx, DWORD PTR [eax]
  009d0	51		 push	 ecx
  009d1	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@FNALGCI@You?5are?5short?5of?5money?$AA@
  009d6	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  009db	83 c4 0c	 add	 esp, 12			; 0000000cH

; 339  : 		return;

  009de	e9 ef 00 00 00	 jmp	 $LN12@EnterEvent
$LN4@EnterEvent:

; 340  : 	}
; 341  : 	lpObj->Money -= DGEnterMoney;

  009e3	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009e6	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  009ec	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR ?DGEnterMoney@@3HA ; DGEnterMoney
  009f2	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  009f5	89 8a f0 00 00
	00		 mov	 DWORD PTR [edx+240], ecx

; 342  : 	GCMoneySend(lpObj->m_Index, lpObj->Money);

  009fb	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009fe	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  00a04	51		 push	 ecx
  00a05	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00a08	8b 02		 mov	 eax, DWORD PTR [edx]
  00a0a	50		 push	 eax
  00a0b	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  00a10	83 c4 08	 add	 esp, 8

; 343  : 	//}
; 344  : 
; 345  : 	if(this->m_DGData.btPlayState == DG_STATE_WAITING)

  00a13	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00a16	0f b6 48 4a	 movzx	 ecx, BYTE PTR [eax+74]
  00a1a	83 f9 02	 cmp	 ecx, 2
  00a1d	75 19		 jne	 SHORT $LN3@EnterEvent

; 346  : 	{
; 347  : 		if(this->m_DGData.PartyNumber != lpObj->PartyNumber)

  00a1f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00a22	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00a25	8b 90 14 02 00
	00		 mov	 edx, DWORD PTR [eax+532]
  00a2b	3b 91 2c 04 00
	00		 cmp	 edx, DWORD PTR [ecx+1068]
  00a31	74 05		 je	 SHORT $LN3@EnterEvent

; 348  : 		{
; 349  : 			return;

  00a33	e9 9a 00 00 00	 jmp	 $LN12@EnterEvent
$LN3@EnterEvent:

; 350  : 		}
; 351  : 	}
; 352  : 	if(this->AddPlayer(lpObj) == true)

  00a38	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a3b	50		 push	 eax
  00a3c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a3f	e8 00 00 00 00	 call	 ?AddPlayer@CDoppelGanger@@QAE_NPAUOBJECTSTRUCT@@@Z ; CDoppelGanger::AddPlayer
  00a44	0f b6 c8	 movzx	 ecx, al
  00a47	83 f9 01	 cmp	 ecx, 1
  00a4a	0f 85 82 00 00
	00		 jne	 $LN12@EnterEvent

; 353  : 	{		
; 354  : 		gObjInventoryDeleteItem(lpObj->m_Index, invitationpos);

  00a50	8b 45 f8	 mov	 eax, DWORD PTR _invitationpos$[ebp]
  00a53	50		 push	 eax
  00a54	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00a57	8b 11		 mov	 edx, DWORD PTR [ecx]
  00a59	52		 push	 edx
  00a5a	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  00a5f	83 c4 08	 add	 esp, 8

; 355  : 		GCInventoryItemDeleteSend(lpObj->m_Index, invitationpos, 1);

  00a62	6a 01		 push	 1
  00a64	0f b6 45 f8	 movzx	 eax, BYTE PTR _invitationpos$[ebp]
  00a68	50		 push	 eax
  00a69	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00a6c	8b 11		 mov	 edx, DWORD PTR [ecx]
  00a6e	52		 push	 edx
  00a6f	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00a74	83 c4 0c	 add	 esp, 12			; 0000000cH

; 356  : 
; 357  : 		int iGate = this->SetMapNumber();

  00a77	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a7a	e8 00 00 00 00	 call	 ?SetMapNumber@CDoppelGanger@@QAEHXZ ; CDoppelGanger::SetMapNumber
  00a7f	89 45 f0	 mov	 DWORD PTR _iGate$231455[ebp], eax

; 358  : 
; 359  : 		gObjMoveGate(lpObj->m_Index, iGate);

  00a82	8b 45 f0	 mov	 eax, DWORD PTR _iGate$231455[ebp]
  00a85	50		 push	 eax
  00a86	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00a89	8b 11		 mov	 edx, DWORD PTR [ecx]
  00a8b	52		 push	 edx
  00a8c	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  00a91	83 c4 08	 add	 esp, 8

; 360  : 
; 361  : 		this->SetMapAttr(true, lpObj);

  00a94	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a97	50		 push	 eax
  00a98	6a 01		 push	 1
  00a9a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a9d	e8 00 00 00 00	 call	 ?SetMapAttr@CDoppelGanger@@QAEX_NPAUOBJECTSTRUCT@@@Z ; CDoppelGanger::SetMapAttr

; 362  : 
; 363  : 		lpObj->TargetShopNumber = 0;

  00aa2	33 c0		 xor	 eax, eax
  00aa4	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00aa7	66 89 81 5a 04
	00 00		 mov	 WORD PTR [ecx+1114], ax

; 364  : 
; 365  : 		LogAddTD("[DoppelGanger] [%s][%s] Entered to DoppelGanger (%d)", lpObj->AccountID, lpObj->Name, this->m_DGData.PlayerCount);

  00aae	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00ab1	0f b6 48 44	 movzx	 ecx, BYTE PTR [eax+68]
  00ab5	51		 push	 ecx
  00ab6	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00ab9	83 c2 77	 add	 edx, 119		; 00000077H
  00abc	52		 push	 edx
  00abd	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ac0	83 c0 6c	 add	 eax, 108		; 0000006cH
  00ac3	50		 push	 eax
  00ac4	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@JEEBAHNK@?$FLDoppelGanger?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Entered?5@
  00ac9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00acf	83 c4 10	 add	 esp, 16			; 00000010H
$LN12@EnterEvent:

; 366  : 	}
; 367  : }

  00ad2	5f		 pop	 edi
  00ad3	5e		 pop	 esi
  00ad4	5b		 pop	 ebx
  00ad5	8b e5		 mov	 esp, ebp
  00ad7	5d		 pop	 ebp
  00ad8	c2 04 00	 ret	 4
?EnterEvent@CDoppelGanger@@QAEXPAUOBJECTSTRUCT@@@Z ENDP	; CDoppelGanger::EnterEvent
_TEXT	ENDS
PUBLIC	??_C@_0DP@GOLHLEJH@?$FLDoppelGanger?$FN?5?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Add?5to?5e@ ; `string'
;	COMDAT ??_C@_0DP@GOLHLEJH@?$FLDoppelGanger?$FN?5?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Add?5to?5e@
CONST	SEGMENT
??_C@_0DP@GOLHLEJH@?$FLDoppelGanger?$FN?5?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Add?5to?5e@ DB '['
	DB	'DoppelGanger] (%s)(%s) Add to event, current player count: %d'
	DB	00H						; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_i$231461 = -8						; size = 4
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?AddPlayer@CDoppelGanger@@QAE_NPAUOBJECTSTRUCT@@@Z PROC	; CDoppelGanger::AddPlayer
; _this$ = ecx

; 370  : {

  00ae0	55		 push	 ebp
  00ae1	8b ec		 mov	 ebp, esp
  00ae3	83 ec 48	 sub	 esp, 72			; 00000048H
  00ae6	53		 push	 ebx
  00ae7	56		 push	 esi
  00ae8	57		 push	 edi
  00ae9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 371  : 	for(int i=0;i<5;++i)

  00aec	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$231461[ebp], 0
  00af3	eb 09		 jmp	 SHORT $LN5@AddPlayer
$LN4@AddPlayer:
  00af5	8b 45 f8	 mov	 eax, DWORD PTR _i$231461[ebp]
  00af8	83 c0 01	 add	 eax, 1
  00afb	89 45 f8	 mov	 DWORD PTR _i$231461[ebp], eax
$LN5@AddPlayer:
  00afe	83 7d f8 05	 cmp	 DWORD PTR _i$231461[ebp], 5
  00b02	7d 7a		 jge	 SHORT $LN3@AddPlayer

; 372  : 	{
; 373  : 		if(this->m_DGData.PlayerIndex[i] == -1)

  00b04	8b 45 f8	 mov	 eax, DWORD PTR _i$231461[ebp]
  00b07	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00b0a	83 7c 81 54 ff	 cmp	 DWORD PTR [ecx+eax*4+84], -1
  00b0f	75 68		 jne	 SHORT $LN2@AddPlayer

; 374  : 		{
; 375  : 			this->m_DGData.PlayerIndex[i] = lpObj->m_Index;

  00b11	8b 45 f8	 mov	 eax, DWORD PTR _i$231461[ebp]
  00b14	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00b17	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00b1a	8b 12		 mov	 edx, DWORD PTR [edx]
  00b1c	89 54 81 54	 mov	 DWORD PTR [ecx+eax*4+84], edx

; 376  : 			lpObj->m_btDoubleGoerRoom = 1;

  00b20	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b23	c6 80 b9 21 00
	00 01		 mov	 BYTE PTR [eax+8633], 1

; 377  : 			if(i == 0) // first player, set party number, that other teammates can enter to event

  00b2a	83 7d f8 00	 cmp	 DWORD PTR _i$231461[ebp], 0
  00b2e	75 12		 jne	 SHORT $LN1@AddPlayer

; 378  : 			{
; 379  : 				this->m_DGData.PartyNumber = lpObj->PartyNumber;

  00b30	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00b33	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00b36	8b 91 2c 04 00
	00		 mov	 edx, DWORD PTR [ecx+1068]
  00b3c	89 90 14 02 00
	00		 mov	 DWORD PTR [eax+532], edx
$LN1@AddPlayer:

; 380  : 			}
; 381  : 			++this->m_DGData.PlayerCount;

  00b42	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00b45	8a 48 44	 mov	 cl, BYTE PTR [eax+68]
  00b48	80 c1 01	 add	 cl, 1
  00b4b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00b4e	88 4a 44	 mov	 BYTE PTR [edx+68], cl

; 382  : 			LogAddTD("[DoppelGanger] (%s)(%s) Add to event, current player count: %d", lpObj->AccountID, lpObj->Name, this->m_DGData.PlayerCount);

  00b51	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00b54	0f b6 48 44	 movzx	 ecx, BYTE PTR [eax+68]
  00b58	51		 push	 ecx
  00b59	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00b5c	83 c2 77	 add	 edx, 119		; 00000077H
  00b5f	52		 push	 edx
  00b60	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b63	83 c0 6c	 add	 eax, 108		; 0000006cH
  00b66	50		 push	 eax
  00b67	68 00 00 00 00	 push	 OFFSET ??_C@_0DP@GOLHLEJH@?$FLDoppelGanger?$FN?5?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Add?5to?5e@
  00b6c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00b72	83 c4 10	 add	 esp, 16			; 00000010H

; 383  : 			return true;

  00b75	b0 01		 mov	 al, 1
  00b77	eb 07		 jmp	 SHORT $LN6@AddPlayer
$LN2@AddPlayer:

; 384  : 		}
; 385  : 	}

  00b79	e9 77 ff ff ff	 jmp	 $LN4@AddPlayer
$LN3@AddPlayer:

; 386  : 	return false;

  00b7e	32 c0		 xor	 al, al
$LN6@AddPlayer:

; 387  : }

  00b80	5f		 pop	 edi
  00b81	5e		 pop	 esi
  00b82	5b		 pop	 ebx
  00b83	8b e5		 mov	 esp, ebp
  00b85	5d		 pop	 ebp
  00b86	c2 04 00	 ret	 4
?AddPlayer@CDoppelGanger@@QAE_NPAUOBJECTSTRUCT@@@Z ENDP	; CDoppelGanger::AddPlayer
_TEXT	ENDS
PUBLIC	?GetEventTime@CDoppelGanger@@QAEDPAUOBJECTSTRUCT@@@Z ; CDoppelGanger::GetEventTime
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?GetEventTime@CDoppelGanger@@QAEDPAUOBJECTSTRUCT@@@Z PROC ; CDoppelGanger::GetEventTime
; _this$ = ecx

; 390  : {

  00b90	55		 push	 ebp
  00b91	8b ec		 mov	 ebp, esp
  00b93	83 ec 44	 sub	 esp, 68			; 00000044H
  00b96	53		 push	 ebx
  00b97	56		 push	 esi
  00b98	57		 push	 edi
  00b99	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 391  : 	if(lpObj->PartyNumber == this->m_DGData.PartyNumber && this->m_DGData.btPlayState == DG_STATE_WAITING)

  00b9c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b9f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00ba2	8b 90 2c 04 00
	00		 mov	 edx, DWORD PTR [eax+1068]
  00ba8	3b 91 14 02 00
	00		 cmp	 edx, DWORD PTR [ecx+532]
  00bae	75 12		 jne	 SHORT $LN3@GetEventTi
  00bb0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00bb3	0f b6 48 4a	 movzx	 ecx, BYTE PTR [eax+74]
  00bb7	83 f9 02	 cmp	 ecx, 2
  00bba	75 06		 jne	 SHORT $LN3@GetEventTi

; 392  : 	{
; 393  : 		return 0;

  00bbc	32 c0		 xor	 al, al
  00bbe	eb 1b		 jmp	 SHORT $LN4@GetEventTi
  00bc0	eb 10		 jmp	 SHORT $LN2@GetEventTi
$LN3@GetEventTi:

; 394  : 	}
; 395  : 	else if(this->m_DGData.btPlayState == DG_STATE_OPEN)

  00bc2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00bc5	0f b6 48 4a	 movzx	 ecx, BYTE PTR [eax+74]
  00bc9	83 f9 01	 cmp	 ecx, 1
  00bcc	75 04		 jne	 SHORT $LN2@GetEventTi

; 396  : 	{
; 397  : 		return 0;

  00bce	32 c0		 xor	 al, al
  00bd0	eb 09		 jmp	 SHORT $LN4@GetEventTi
$LN2@GetEventTi:

; 398  : 	}
; 399  : 	return this->m_DGData.eDuration;

  00bd2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00bd5	8a 80 08 02 00
	00		 mov	 al, BYTE PTR [eax+520]
$LN4@GetEventTi:

; 400  : }

  00bdb	5f		 pop	 edi
  00bdc	5e		 pop	 esi
  00bdd	5b		 pop	 ebx
  00bde	8b e5		 mov	 esp, ebp
  00be0	5d		 pop	 ebp
  00be1	c2 04 00	 ret	 4
?GetEventTime@CDoppelGanger@@QAEDPAUOBJECTSTRUCT@@@Z ENDP ; CDoppelGanger::GetEventTime
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pBodyMsg$ = -280					; size = 2
_pMsg$ = -276						; size = 7
_lOfs$ = -268						; size = 4
_cTEMP_BUF$ = -264					; size = 256
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_Block$ = 8						; size = 1
_lpObj$ = 12						; size = 4
?SetMapAttr@CDoppelGanger@@QAEX_NPAUOBJECTSTRUCT@@@Z PROC ; CDoppelGanger::SetMapAttr
; _this$ = ecx

; 403  : {

  00bf0	55		 push	 ebp
  00bf1	8b ec		 mov	 ebp, esp
  00bf3	81 ec 58 01 00
	00		 sub	 esp, 344		; 00000158H
  00bf9	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00bfe	33 c5		 xor	 eax, ebp
  00c00	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00c03	53		 push	 ebx
  00c04	56		 push	 esi
  00c05	57		 push	 edi
  00c06	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 404  : 	char cTEMP_BUF[256];
; 405  : 	int lOfs = 0;

  00c09	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _lOfs$[ebp], 0

; 406  : 	PMSG_SETMAPATTR_COUNT pMsg;
; 407  : 	PMSG_SETMAPATTR pBodyMsg;
; 408  : 	lOfs += sizeof(pMsg);

  00c13	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  00c19	83 c0 07	 add	 eax, 7
  00c1c	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _lOfs$[ebp], eax

; 409  : 
; 410  : 	pMsg.btType = 0;

  00c22	c6 85 ef fe ff
	ff 00		 mov	 BYTE PTR _pMsg$[ebp+3], 0

; 411  : 	pMsg.btCount = 1;

  00c29	c6 85 f2 fe ff
	ff 01		 mov	 BYTE PTR _pMsg$[ebp+6], 1

; 412  : 	pMsg.btMapAttr = 4;

  00c30	c6 85 f0 fe ff
	ff 04		 mov	 BYTE PTR _pMsg$[ebp+4], 4

; 413  : 	pMsg.btMapSetType = (Block == true) ? 4 : 1;

  00c37	0f b6 45 08	 movzx	 eax, BYTE PTR _Block$[ebp]
  00c3b	83 e8 01	 sub	 eax, 1
  00c3e	f7 d8		 neg	 eax
  00c40	1b c0		 sbb	 eax, eax
  00c42	83 e0 fd	 and	 eax, -3			; fffffffdH
  00c45	83 c0 04	 add	 eax, 4
  00c48	88 85 f1 fe ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+5], al

; 414  : 
; 415  : 	pBodyMsg.btX = g_DGEntrance[this->m_DGData.MapNumber-65].iStartX;

  00c4e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00c51	8b 88 10 02 00
	00		 mov	 ecx, DWORD PTR [eax+528]
  00c57	83 e9 41	 sub	 ecx, 65			; 00000041H
  00c5a	c1 e1 04	 shl	 ecx, 4
  00c5d	8a 91 00 00 00
	00		 mov	 dl, BYTE PTR _g_DGEntrance[ecx]
  00c63	88 95 e8 fe ff
	ff		 mov	 BYTE PTR _pBodyMsg$[ebp], dl

; 416  : 	pBodyMsg.btY = g_DGEntrance[this->m_DGData.MapNumber-65].iStartY;

  00c69	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00c6c	8b 88 10 02 00
	00		 mov	 ecx, DWORD PTR [eax+528]
  00c72	83 e9 41	 sub	 ecx, 65			; 00000041H
  00c75	c1 e1 04	 shl	 ecx, 4
  00c78	8a 91 04 00 00
	00		 mov	 dl, BYTE PTR _g_DGEntrance[ecx+4]
  00c7e	88 95 e9 fe ff
	ff		 mov	 BYTE PTR _pBodyMsg$[ebp+1], dl

; 417  : 	memcpy(&cTEMP_BUF[lOfs], &pBodyMsg, sizeof(pBodyMsg));

  00c84	6a 02		 push	 2
  00c86	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _pBodyMsg$[ebp]
  00c8c	50		 push	 eax
  00c8d	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _lOfs$[ebp]
  00c93	8d 94 0d f8 fe
	ff ff		 lea	 edx, DWORD PTR _cTEMP_BUF$[ebp+ecx]
  00c9a	52		 push	 edx
  00c9b	e8 00 00 00 00	 call	 _memcpy
  00ca0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 418  : 	lOfs += sizeof(pBodyMsg);

  00ca3	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  00ca9	83 c0 02	 add	 eax, 2
  00cac	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _lOfs$[ebp], eax

; 419  : 	pBodyMsg.btX   = g_DGEntrance[this->m_DGData.MapNumber-65].iEndX;

  00cb2	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00cb5	8b 88 10 02 00
	00		 mov	 ecx, DWORD PTR [eax+528]
  00cbb	83 e9 41	 sub	 ecx, 65			; 00000041H
  00cbe	c1 e1 04	 shl	 ecx, 4
  00cc1	8a 91 08 00 00
	00		 mov	 dl, BYTE PTR _g_DGEntrance[ecx+8]
  00cc7	88 95 e8 fe ff
	ff		 mov	 BYTE PTR _pBodyMsg$[ebp], dl

; 420  : 	pBodyMsg.btY   = g_DGEntrance[this->m_DGData.MapNumber-65].iEndY;

  00ccd	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00cd0	8b 88 10 02 00
	00		 mov	 ecx, DWORD PTR [eax+528]
  00cd6	83 e9 41	 sub	 ecx, 65			; 00000041H
  00cd9	c1 e1 04	 shl	 ecx, 4
  00cdc	8a 91 0c 00 00
	00		 mov	 dl, BYTE PTR _g_DGEntrance[ecx+12]
  00ce2	88 95 e9 fe ff
	ff		 mov	 BYTE PTR _pBodyMsg$[ebp+1], dl

; 421  : 	memcpy(&cTEMP_BUF[lOfs], &pBodyMsg, sizeof(pBodyMsg));

  00ce8	6a 02		 push	 2
  00cea	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _pBodyMsg$[ebp]
  00cf0	50		 push	 eax
  00cf1	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _lOfs$[ebp]
  00cf7	8d 94 0d f8 fe
	ff ff		 lea	 edx, DWORD PTR _cTEMP_BUF$[ebp+ecx]
  00cfe	52		 push	 edx
  00cff	e8 00 00 00 00	 call	 _memcpy
  00d04	83 c4 0c	 add	 esp, 12			; 0000000cH

; 422  : 	lOfs += sizeof(pBodyMsg);

  00d07	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  00d0d	83 c0 02	 add	 eax, 2
  00d10	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _lOfs$[ebp], eax

; 423  : 
; 424  : 	pMsg.h.c = 0xC1;

  00d16	c6 85 ec fe ff
	ff c1		 mov	 BYTE PTR _pMsg$[ebp], 193 ; 000000c1H

; 425  : 	pMsg.h.size = lOfs;

  00d1d	8a 85 f4 fe ff
	ff		 mov	 al, BYTE PTR _lOfs$[ebp]
  00d23	88 85 ed fe ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+1], al

; 426  : 	pMsg.h.headcode = 0x46;

  00d29	c6 85 ee fe ff
	ff 46		 mov	 BYTE PTR _pMsg$[ebp+2], 70 ; 00000046H

; 427  : 	memcpy(&cTEMP_BUF, &pMsg, sizeof(pMsg));

  00d30	6a 07		 push	 7
  00d32	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  00d38	50		 push	 eax
  00d39	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _cTEMP_BUF$[ebp]
  00d3f	51		 push	 ecx
  00d40	e8 00 00 00 00	 call	 _memcpy
  00d45	83 c4 0c	 add	 esp, 12			; 0000000cH

; 428  : 
; 429  : 	if(Block)

  00d48	0f b6 45 08	 movzx	 eax, BYTE PTR _Block$[ebp]
  00d4c	85 c0		 test	 eax, eax
  00d4e	74 1e		 je	 SHORT $LN2@SetMapAttr

; 430  : 	{
; 431  : 		DataSend(lpObj->m_Index, (LPBYTE)&cTEMP_BUF, lOfs);

  00d50	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  00d56	50		 push	 eax
  00d57	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _cTEMP_BUF$[ebp]
  00d5d	51		 push	 ecx
  00d5e	8b 55 0c	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00d61	8b 02		 mov	 eax, DWORD PTR [edx]
  00d63	50		 push	 eax
  00d64	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00d69	83 c4 0c	 add	 esp, 12			; 0000000cH

; 432  : 	}
; 433  : 	else

  00d6c	eb 16		 jmp	 SHORT $LN3@SetMapAttr
$LN2@SetMapAttr:

; 434  : 	{
; 435  : 		this->SendDoppelGangerPlayer((LPBYTE)&cTEMP_BUF, lOfs);

  00d6e	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  00d74	50		 push	 eax
  00d75	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _cTEMP_BUF$[ebp]
  00d7b	51		 push	 ecx
  00d7c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00d7f	e8 00 00 00 00	 call	 ?SendDoppelGangerPlayer@CDoppelGanger@@QAEXPAEH@Z ; CDoppelGanger::SendDoppelGangerPlayer
$LN3@SetMapAttr:

; 436  : 	}
; 437  : }

  00d84	5f		 pop	 edi
  00d85	5e		 pop	 esi
  00d86	5b		 pop	 ebx
  00d87	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00d8a	33 cd		 xor	 ecx, ebp
  00d8c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00d91	8b e5		 mov	 esp, ebp
  00d93	5d		 pop	 ebp
  00d94	c2 08 00	 ret	 8
?SetMapAttr@CDoppelGanger@@QAEX_NPAUOBJECTSTRUCT@@@Z ENDP ; CDoppelGanger::SetMapAttr
_TEXT	ENDS
EXTRN	?gObjIsConnectedGP@@YAHH@Z:PROC			; gObjIsConnectedGP
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_i$231493 = -8						; size = 4
_this$ = -4						; size = 4
_lpMsg$ = 8						; size = 4
_iSize$ = 12						; size = 4
?SendDoppelGangerPlayer@CDoppelGanger@@QAEXPAEH@Z PROC	; CDoppelGanger::SendDoppelGangerPlayer
; _this$ = ecx

; 440  : {

  00da0	55		 push	 ebp
  00da1	8b ec		 mov	 ebp, esp
  00da3	83 ec 48	 sub	 esp, 72			; 00000048H
  00da6	53		 push	 ebx
  00da7	56		 push	 esi
  00da8	57		 push	 edi
  00da9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 441  : 	for(int i=0;i<5;++i)

  00dac	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$231493[ebp], 0
  00db3	eb 09		 jmp	 SHORT $LN4@SendDoppel
$LN3@SendDoppel:
  00db5	8b 45 f8	 mov	 eax, DWORD PTR _i$231493[ebp]
  00db8	83 c0 01	 add	 eax, 1
  00dbb	89 45 f8	 mov	 DWORD PTR _i$231493[ebp], eax
$LN4@SendDoppel:
  00dbe	83 7d f8 05	 cmp	 DWORD PTR _i$231493[ebp], 5
  00dc2	7d 69		 jge	 SHORT $LN5@SendDoppel

; 442  : 	{
; 443  : 		if(this->m_DGData.PlayerIndex[i] != -1 && gObjIsConnectedGP(this->m_DGData.PlayerIndex[i]) && gObj[this->m_DGData.PlayerIndex[i]].MapNumber == this->m_DGData.MapNumber)

  00dc4	8b 45 f8	 mov	 eax, DWORD PTR _i$231493[ebp]
  00dc7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00dca	83 7c 81 54 ff	 cmp	 DWORD PTR [ecx+eax*4+84], -1
  00dcf	74 5a		 je	 SHORT $LN1@SendDoppel
  00dd1	8b 45 f8	 mov	 eax, DWORD PTR _i$231493[ebp]
  00dd4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00dd7	8b 54 81 54	 mov	 edx, DWORD PTR [ecx+eax*4+84]
  00ddb	52		 push	 edx
  00ddc	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  00de1	83 c4 04	 add	 esp, 4
  00de4	85 c0		 test	 eax, eax
  00de6	74 43		 je	 SHORT $LN1@SendDoppel
  00de8	8b 45 f8	 mov	 eax, DWORD PTR _i$231493[ebp]
  00deb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00dee	8b 54 81 54	 mov	 edx, DWORD PTR [ecx+eax*4+84]
  00df2	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  00df8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00dfd	0f b6 8c 10 49
	01 00 00	 movzx	 ecx, BYTE PTR [eax+edx+329]
  00e05	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00e08	3b 8a 10 02 00
	00		 cmp	 ecx, DWORD PTR [edx+528]
  00e0e	75 1b		 jne	 SHORT $LN1@SendDoppel

; 444  : 		{
; 445  : 			DataSend(this->m_DGData.PlayerIndex[i], lpMsg, iSize);

  00e10	8b 45 0c	 mov	 eax, DWORD PTR _iSize$[ebp]
  00e13	50		 push	 eax
  00e14	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00e17	51		 push	 ecx
  00e18	8b 55 f8	 mov	 edx, DWORD PTR _i$231493[ebp]
  00e1b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00e1e	8b 4c 90 54	 mov	 ecx, DWORD PTR [eax+edx*4+84]
  00e22	51		 push	 ecx
  00e23	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00e28	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@SendDoppel:

; 446  : 		}
; 447  : 	}

  00e2b	eb 88		 jmp	 SHORT $LN3@SendDoppel
$LN5@SendDoppel:

; 448  : }

  00e2d	5f		 pop	 edi
  00e2e	5e		 pop	 esi
  00e2f	5b		 pop	 ebx
  00e30	8b e5		 mov	 esp, ebp
  00e32	5d		 pop	 ebp
  00e33	c2 08 00	 ret	 8
?SendDoppelGangerPlayer@CDoppelGanger@@QAEXPAEH@Z ENDP	; CDoppelGanger::SendDoppelGangerPlayer
_TEXT	ENDS
EXTRN	?PHeadSetB@@YAXPAEEH@Z:PROC			; PHeadSetB
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pMsg$ = -8						; size = 4
_this$ = -4						; size = 4
_Type$ = 8						; size = 4
?SendHalfTimeInfo@CDoppelGanger@@QAEXH@Z PROC		; CDoppelGanger::SendHalfTimeInfo
; _this$ = ecx

; 451  : {

  00e40	55		 push	 ebp
  00e41	8b ec		 mov	 ebp, esp
  00e43	83 ec 48	 sub	 esp, 72			; 00000048H
  00e46	53		 push	 ebx
  00e47	56		 push	 esi
  00e48	57		 push	 edi
  00e49	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 452  : 	PMSG_SET_DEVILSQUARE pMsg;
; 453  : 
; 454  : 	PHeadSetB((LPBYTE)&pMsg, 0x92, sizeof(pMsg));

  00e4c	6a 04		 push	 4
  00e4e	68 92 00 00 00	 push	 146			; 00000092H
  00e53	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00e56	50		 push	 eax
  00e57	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00e5c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 455  : 	pMsg.Type = Type;

  00e5f	8a 45 08	 mov	 al, BYTE PTR _Type$[ebp]
  00e62	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 456  : 
; 457  : 	this->SendDoppelGangerPlayer((LPBYTE)&pMsg, pMsg.h.size);

  00e65	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00e69	50		 push	 eax
  00e6a	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00e6d	51		 push	 ecx
  00e6e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00e71	e8 00 00 00 00	 call	 ?SendDoppelGangerPlayer@CDoppelGanger@@QAEXPAEH@Z ; CDoppelGanger::SendDoppelGangerPlayer

; 458  : 	this->m_DGData.HalfTimeInfoSent = true;

  00e76	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00e79	c6 80 1c 02 00
	00 01		 mov	 BYTE PTR [eax+540], 1

; 459  : }

  00e80	5f		 pop	 edi
  00e81	5e		 pop	 esi
  00e82	5b		 pop	 ebx
  00e83	8b e5		 mov	 esp, ebp
  00e85	5d		 pop	 ebp
  00e86	c2 04 00	 ret	 4
?SendHalfTimeInfo@CDoppelGanger@@QAEXH@Z ENDP		; CDoppelGanger::SendHalfTimeInfo
_TEXT	ENDS
EXTRN	?PHeadSubSetB@@YAXPAEEEH@Z:PROC			; PHeadSubSetB
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_pMsg$ = -12						; size = 5
_this$ = -4						; size = 4
?SetEventInterface@CDoppelGanger@@QAEXXZ PROC		; CDoppelGanger::SetEventInterface
; _this$ = ecx

; 462  : {

  00e90	55		 push	 ebp
  00e91	8b ec		 mov	 ebp, esp
  00e93	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00e96	53		 push	 ebx
  00e97	56		 push	 esi
  00e98	57		 push	 edi
  00e99	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 463  : 	PMSG_DGOER_TIMER_INIT pMsg;
; 464  : 
; 465  : 	PHeadSubSetB((LPBYTE)&pMsg, 0xBF, 0x10, sizeof(pMsg));

  00e9c	6a 05		 push	 5
  00e9e	6a 10		 push	 16			; 00000010H
  00ea0	68 bf 00 00 00	 push	 191			; 000000bfH
  00ea5	8d 45 f4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00ea8	50		 push	 eax
  00ea9	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  00eae	83 c4 10	 add	 esp, 16			; 00000010H

; 466  : 	pMsg.Timer = 2;

  00eb1	c6 45 f8 02	 mov	 BYTE PTR _pMsg$[ebp+4], 2

; 467  : 
; 468  : 	this->SendDoppelGangerPlayer((LPBYTE)&pMsg, pMsg.h.size);

  00eb5	0f b6 45 f5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00eb9	50		 push	 eax
  00eba	8d 4d f4	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00ebd	51		 push	 ecx
  00ebe	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00ec1	e8 00 00 00 00	 call	 ?SendDoppelGangerPlayer@CDoppelGanger@@QAEXPAEH@Z ; CDoppelGanger::SendDoppelGangerPlayer

; 469  : }

  00ec6	5f		 pop	 edi
  00ec7	5e		 pop	 esi
  00ec8	5b		 pop	 ebx
  00ec9	8b e5		 mov	 esp, ebp
  00ecb	5d		 pop	 ebp
  00ecc	c3		 ret	 0
?SetEventInterface@CDoppelGanger@@QAEXXZ ENDP		; CDoppelGanger::SetEventInterface
; Function compile flags: /Odtp /ZI
_pMsg$ = -12						; size = 6
_this$ = -4						; size = 4
?SetMonsterCountOnInterface@CDoppelGanger@@QAEXXZ PROC	; CDoppelGanger::SetMonsterCountOnInterface
; _this$ = ecx

; 472  : {

  00ed0	55		 push	 ebp
  00ed1	8b ec		 mov	 ebp, esp
  00ed3	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00ed6	53		 push	 ebx
  00ed7	56		 push	 esi
  00ed8	57		 push	 edi
  00ed9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 473  : 	PMSG_DGOER_MONSTER_COUNT pMsg;
; 474  : 
; 475  : 	PHeadSubSetB((LPBYTE)&pMsg, 0xBF, 0x14, sizeof(pMsg));

  00edc	6a 06		 push	 6
  00ede	6a 14		 push	 20			; 00000014H
  00ee0	68 bf 00 00 00	 push	 191			; 000000bfH
  00ee5	8d 45 f4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00ee8	50		 push	 eax
  00ee9	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  00eee	83 c4 10	 add	 esp, 16			; 00000010H

; 476  : 	pMsg.Killed = this->m_DGData.MonsterPassed;

  00ef1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00ef4	8a 48 47	 mov	 cl, BYTE PTR [eax+71]
  00ef7	88 4d f9	 mov	 BYTE PTR _pMsg$[ebp+5], cl

; 477  : 	pMsg.Total = GOER_MAX_PASS_PORTAL;

  00efa	c6 45 f8 03	 mov	 BYTE PTR _pMsg$[ebp+4], 3

; 478  : 
; 479  : 	this->SendDoppelGangerPlayer((LPBYTE)&pMsg, pMsg.h.size);

  00efe	0f b6 45 f5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00f02	50		 push	 eax
  00f03	8d 4d f4	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00f06	51		 push	 ecx
  00f07	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00f0a	e8 00 00 00 00	 call	 ?SendDoppelGangerPlayer@CDoppelGanger@@QAEXPAEH@Z ; CDoppelGanger::SendDoppelGangerPlayer

; 480  : }

  00f0f	5f		 pop	 edi
  00f10	5e		 pop	 esi
  00f11	5b		 pop	 ebx
  00f12	8b e5		 mov	 esp, ebp
  00f14	5d		 pop	 ebp
  00f15	c3		 ret	 0
?SetMonsterCountOnInterface@CDoppelGanger@@QAEXXZ ENDP	; CDoppelGanger::SetMonsterCountOnInterface
_TEXT	ENDS
PUBLIC	?CalcPos@CDoppelGanger@@QAEHH_N@Z		; CDoppelGanger::CalcPos
PUBLIC	__$ArrayPad$
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_i$231525 = -288					; size = 4
_lOfs$ = -284						; size = 4
_cBUFF$ = -280						; size = 256
_Time$ = -24						; size = 4
_pPlayer$ = -20						; size = 4
_pMsg$ = -16						; size = 8
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?SendPlayerPos@CDoppelGanger@@QAEXXZ PROC		; CDoppelGanger::SendPlayerPos
; _this$ = ecx

; 483  : {

  00f20	55		 push	 ebp
  00f21	8b ec		 mov	 ebp, esp
  00f23	81 ec 60 01 00
	00		 sub	 esp, 352		; 00000160H
  00f29	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00f2e	33 c5		 xor	 eax, ebp
  00f30	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00f33	53		 push	 ebx
  00f34	56		 push	 esi
  00f35	57		 push	 edi
  00f36	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 484  : 	PMSG_DGOER_UPDATE_BAR pMsg;
; 485  : 	PLAYER_BAR_INFO pPlayer;
; 486  : 
; 487  : 	int Time = this->m_DGData.eDuration / 1000;

  00f39	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00f3c	8b 80 08 02 00
	00		 mov	 eax, DWORD PTR [eax+520]
  00f42	99		 cdq
  00f43	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  00f48	f7 f9		 idiv	 ecx
  00f4a	89 45 e8	 mov	 DWORD PTR _Time$[ebp], eax

; 488  : 	char cBUFF[256];
; 489  : 	int lOfs = 8;

  00f4d	c7 85 e4 fe ff
	ff 08 00 00 00	 mov	 DWORD PTR _lOfs$[ebp], 8

; 490  : 
; 491  : 	for(int i=0;i<5;++i)

  00f57	c7 85 e0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$231525[ebp], 0
  00f61	eb 0f		 jmp	 SHORT $LN4@SendPlayer
$LN3@SendPlayer:
  00f63	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _i$231525[ebp]
  00f69	83 c0 01	 add	 eax, 1
  00f6c	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _i$231525[ebp], eax
$LN4@SendPlayer:
  00f72	83 bd e0 fe ff
	ff 05		 cmp	 DWORD PTR _i$231525[ebp], 5
  00f79	0f 8d a1 00 00
	00		 jge	 $LN2@SendPlayer

; 492  : 	{
; 493  : 		memset(&pPlayer, 0x00, sizeof(pPlayer));

  00f7f	6a 04		 push	 4
  00f81	6a 00		 push	 0
  00f83	8d 45 ec	 lea	 eax, DWORD PTR _pPlayer$[ebp]
  00f86	50		 push	 eax
  00f87	e8 00 00 00 00	 call	 _memset
  00f8c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 494  : 		if(gObjIsConnectedGP(this->m_DGData.PlayerIndex[i]) )

  00f8f	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _i$231525[ebp]
  00f95	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00f98	8b 54 81 54	 mov	 edx, DWORD PTR [ecx+eax*4+84]
  00f9c	52		 push	 edx
  00f9d	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  00fa2	83 c4 04	 add	 esp, 4
  00fa5	85 c0		 test	 eax, eax
  00fa7	74 47		 je	 SHORT $LN1@SendPlayer

; 495  : 		{
; 496  : 			pPlayer.UserH = HIBYTE(this->m_DGData.PlayerIndex[i]);

  00fa9	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _i$231525[ebp]
  00faf	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00fb2	8b 54 81 54	 mov	 edx, DWORD PTR [ecx+eax*4+84]
  00fb6	c1 ea 08	 shr	 edx, 8
  00fb9	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00fbf	88 55 ed	 mov	 BYTE PTR _pPlayer$[ebp+1], dl

; 497  : 			pPlayer.UserL = LOBYTE(this->m_DGData.PlayerIndex[i]);

  00fc2	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _i$231525[ebp]
  00fc8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00fcb	8b 54 81 54	 mov	 edx, DWORD PTR [ecx+eax*4+84]
  00fcf	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00fd5	88 55 ec	 mov	 BYTE PTR _pPlayer$[ebp], dl

; 498  : 			pPlayer.Visible = 1; // visible on bar

  00fd8	c6 45 ee 01	 mov	 BYTE PTR _pPlayer$[ebp+2], 1

; 499  : 			pPlayer.Pos = this->CalcPos(i, false);

  00fdc	6a 00		 push	 0
  00fde	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _i$231525[ebp]
  00fe4	50		 push	 eax
  00fe5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00fe8	e8 00 00 00 00	 call	 ?CalcPos@CDoppelGanger@@QAEHH_N@Z ; CDoppelGanger::CalcPos
  00fed	88 45 ef	 mov	 BYTE PTR _pPlayer$[ebp+3], al
$LN1@SendPlayer:

; 500  : 		}
; 501  : 		memcpy(&cBUFF[lOfs], &pPlayer, sizeof(pPlayer));

  00ff0	6a 04		 push	 4
  00ff2	8d 45 ec	 lea	 eax, DWORD PTR _pPlayer$[ebp]
  00ff5	50		 push	 eax
  00ff6	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _lOfs$[ebp]
  00ffc	8d 94 0d e8 fe
	ff ff		 lea	 edx, DWORD PTR _cBUFF$[ebp+ecx]
  01003	52		 push	 edx
  01004	e8 00 00 00 00	 call	 _memcpy
  01009	83 c4 0c	 add	 esp, 12			; 0000000cH

; 502  : 		lOfs += sizeof(pPlayer);

  0100c	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  01012	83 c0 04	 add	 eax, 4
  01015	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _lOfs$[ebp], eax

; 503  : 	}

  0101b	e9 43 ff ff ff	 jmp	 $LN3@SendPlayer
$LN2@SendPlayer:

; 504  : 
; 505  : 	pMsg.UserCount = this->m_DGData.PlayerCount;

  01020	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  01023	8a 48 44	 mov	 cl, BYTE PTR [eax+68]
  01026	88 4d f6	 mov	 BYTE PTR _pMsg$[ebp+6], cl

; 506  : 	pMsg.Unk = 0;

  01029	c6 45 f7 00	 mov	 BYTE PTR _pMsg$[ebp+7], 0

; 507  : 	pMsg.TimerH = HIBYTE(Time);

  0102d	8b 45 e8	 mov	 eax, DWORD PTR _Time$[ebp]
  01030	c1 e8 08	 shr	 eax, 8
  01033	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  01038	88 45 f5	 mov	 BYTE PTR _pMsg$[ebp+5], al

; 508  : 	pMsg.TimerL = LOBYTE(Time);

  0103b	8b 45 e8	 mov	 eax, DWORD PTR _Time$[ebp]
  0103e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  01043	88 45 f4	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 509  : 
; 510  : 	PHeadSubSetB((LPBYTE)&pMsg, 0xBF, 0x12, lOfs);

  01046	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  0104c	50		 push	 eax
  0104d	6a 12		 push	 18			; 00000012H
  0104f	68 bf 00 00 00	 push	 191			; 000000bfH
  01054	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  01057	51		 push	 ecx
  01058	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  0105d	83 c4 10	 add	 esp, 16			; 00000010H

; 511  : 	memcpy(&cBUFF, &pMsg, sizeof(pMsg));

  01060	6a 08		 push	 8
  01062	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  01065	50		 push	 eax
  01066	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _cBUFF$[ebp]
  0106c	51		 push	 ecx
  0106d	e8 00 00 00 00	 call	 _memcpy
  01072	83 c4 0c	 add	 esp, 12			; 0000000cH

; 512  : 
; 513  : 	this->SendDoppelGangerPlayer((LPBYTE)&cBUFF, lOfs);

  01075	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  0107b	50		 push	 eax
  0107c	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _cBUFF$[ebp]
  01082	51		 push	 ecx
  01083	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01086	e8 00 00 00 00	 call	 ?SendDoppelGangerPlayer@CDoppelGanger@@QAEXPAEH@Z ; CDoppelGanger::SendDoppelGangerPlayer

; 514  : }

  0108b	5f		 pop	 edi
  0108c	5e		 pop	 esi
  0108d	5b		 pop	 ebx
  0108e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01091	33 cd		 xor	 ecx, ebp
  01093	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01098	8b e5		 mov	 esp, ebp
  0109a	5d		 pop	 ebp
  0109b	c3		 ret	 0
?SendPlayerPos@CDoppelGanger@@QAEXXZ ENDP		; CDoppelGanger::SendPlayerPos
_TEXT	ENDS
PUBLIC	?IsDGMonster@CDoppelGanger@@QAE_NPAUOBJECTSTRUCT@@@Z ; CDoppelGanger::IsDGMonster
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_i$231547 = -24						; size = 4
_temp$ = -20						; size = 4
_nearest$ = -16						; size = 4
_pMsg$ = -12						; size = 5
_this$ = -4						; size = 4
?SendMonsterPos@CDoppelGanger@@QAEXXZ PROC		; CDoppelGanger::SendMonsterPos
; _this$ = ecx

; 517  : {

  010a0	55		 push	 ebp
  010a1	8b ec		 mov	 ebp, esp
  010a3	83 ec 58	 sub	 esp, 88			; 00000058H
  010a6	53		 push	 ebx
  010a7	56		 push	 esi
  010a8	57		 push	 edi
  010a9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 518  : 	PMSG_DGOER_TRIANG_POS pMsg;
; 519  : 
; 520  : 	int nearest = 0, temp = -1;

  010ac	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _nearest$[ebp], 0
  010b3	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR _temp$[ebp], -1

; 521  : 
; 522  : 	PHeadSubSetB((LPBYTE)&pMsg, 0xBF, 0x0F, sizeof(pMsg));

  010ba	6a 05		 push	 5
  010bc	6a 0f		 push	 15			; 0000000fH
  010be	68 bf 00 00 00	 push	 191			; 000000bfH
  010c3	8d 45 f4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  010c6	50		 push	 eax
  010c7	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  010cc	83 c4 10	 add	 esp, 16			; 00000010H

; 523  : 
; 524  : 	for(int i=0;i<OBJ_MAXMONSTER;++i)

  010cf	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$231547[ebp], 0
  010d6	eb 09		 jmp	 SHORT $LN6@SendMonste
$LN5@SendMonste:
  010d8	8b 45 e8	 mov	 eax, DWORD PTR _i$231547[ebp]
  010db	83 c0 01	 add	 eax, 1
  010de	89 45 e8	 mov	 DWORD PTR _i$231547[ebp], eax
$LN6@SendMonste:
  010e1	81 7d e8 c8 32
	00 00		 cmp	 DWORD PTR _i$231547[ebp], 13000 ; 000032c8H
  010e8	0f 8d 94 00 00
	00		 jge	 $LN4@SendMonste

; 525  : 	{
; 526  : 		if(this->IsDGMonster(&gObj[i]) && this->m_DGData.MapNumber == gObj[i].MapNumber && gObj[i].Live == true && gObj[i].Connected == PLAYER_PLAYING)

  010ee	8b 45 e8	 mov	 eax, DWORD PTR _i$231547[ebp]
  010f1	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  010f7	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  010fd	50		 push	 eax
  010fe	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01101	e8 00 00 00 00	 call	 ?IsDGMonster@CDoppelGanger@@QAE_NPAUOBJECTSTRUCT@@@Z ; CDoppelGanger::IsDGMonster
  01106	0f b6 c8	 movzx	 ecx, al
  01109	85 c9		 test	 ecx, ecx
  0110b	74 62		 je	 SHORT $LN3@SendMonste
  0110d	8b 45 e8	 mov	 eax, DWORD PTR _i$231547[ebp]
  01110	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01116	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0111c	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  01124	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01127	39 90 10 02 00
	00		 cmp	 DWORD PTR [eax+528], edx
  0112d	75 40		 jne	 SHORT $LN3@SendMonste
  0112f	8b 45 e8	 mov	 eax, DWORD PTR _i$231547[ebp]
  01132	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01138	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0113e	0f b6 54 01 6a	 movzx	 edx, BYTE PTR [ecx+eax+106]
  01143	83 fa 01	 cmp	 edx, 1
  01146	75 27		 jne	 SHORT $LN3@SendMonste
  01148	8b 45 e8	 mov	 eax, DWORD PTR _i$231547[ebp]
  0114b	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01151	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01157	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  0115c	75 11		 jne	 SHORT $LN3@SendMonste

; 527  : 		{
; 528  : 			temp = this->CalcPos(i, true);

  0115e	6a 01		 push	 1
  01160	8b 45 e8	 mov	 eax, DWORD PTR _i$231547[ebp]
  01163	50		 push	 eax
  01164	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01167	e8 00 00 00 00	 call	 ?CalcPos@CDoppelGanger@@QAEHH_N@Z ; CDoppelGanger::CalcPos
  0116c	89 45 ec	 mov	 DWORD PTR _temp$[ebp], eax
$LN3@SendMonste:

; 529  : 		}
; 530  : 		if(temp > nearest)

  0116f	8b 45 ec	 mov	 eax, DWORD PTR _temp$[ebp]
  01172	3b 45 f0	 cmp	 eax, DWORD PTR _nearest$[ebp]
  01175	7e 06		 jle	 SHORT $LN2@SendMonste

; 531  : 		{
; 532  : 			nearest = temp;

  01177	8b 45 ec	 mov	 eax, DWORD PTR _temp$[ebp]
  0117a	89 45 f0	 mov	 DWORD PTR _nearest$[ebp], eax
$LN2@SendMonste:

; 533  : 		}
; 534  : 	}

  0117d	e9 56 ff ff ff	 jmp	 $LN5@SendMonste
$LN4@SendMonste:

; 535  : 	if(nearest == -1)

  01182	83 7d f0 ff	 cmp	 DWORD PTR _nearest$[ebp], -1
  01186	75 07		 jne	 SHORT $LN1@SendMonste

; 536  : 		nearest = 0;

  01188	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _nearest$[ebp], 0
$LN1@SendMonste:

; 537  : 
; 538  : 	pMsg.Pos = nearest;

  0118f	8a 45 f0	 mov	 al, BYTE PTR _nearest$[ebp]
  01192	88 45 f8	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 539  : 	this->SendDoppelGangerPlayer((LPBYTE)&pMsg, pMsg.h.size);

  01195	0f b6 45 f5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  01199	50		 push	 eax
  0119a	8d 4d f4	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0119d	51		 push	 ecx
  0119e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  011a1	e8 00 00 00 00	 call	 ?SendDoppelGangerPlayer@CDoppelGanger@@QAEXPAEH@Z ; CDoppelGanger::SendDoppelGangerPlayer

; 540  : }

  011a6	5f		 pop	 edi
  011a7	5e		 pop	 esi
  011a8	5b		 pop	 ebx
  011a9	8b e5		 mov	 esp, ebp
  011ab	5d		 pop	 ebp
  011ac	c3		 ret	 0
?SendMonsterPos@CDoppelGanger@@QAEXXZ ENDP		; CDoppelGanger::SendMonsterPos
; Function compile flags: /Odtp /ZI
_pMsg$ = -12						; size = 6
_this$ = -4						; size = 4
?SendIceWalkerPos@CDoppelGanger@@QAEXXZ PROC		; CDoppelGanger::SendIceWalkerPos
; _this$ = ecx

; 543  : {

  011b0	55		 push	 ebp
  011b1	8b ec		 mov	 ebp, esp
  011b3	83 ec 4c	 sub	 esp, 76			; 0000004cH
  011b6	53		 push	 ebx
  011b7	56		 push	 esi
  011b8	57		 push	 edi
  011b9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 544  : 	PMSG_DGOER_RTRIANG_POS pMsg;
; 545  : 
; 546  : 	PHeadSubSetB((LPBYTE)&pMsg, 0xBF, 0x11, sizeof(pMsg));

  011bc	6a 06		 push	 6
  011be	6a 11		 push	 17			; 00000011H
  011c0	68 bf 00 00 00	 push	 191			; 000000bfH
  011c5	8d 45 f4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  011c8	50		 push	 eax
  011c9	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  011ce	83 c4 10	 add	 esp, 16			; 00000010H

; 547  : 
; 548  : 	pMsg.Unk = (gObj[this->m_DGData.IceWalkerIndex].Live==true) ? 0 : 1;

  011d1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  011d4	0f bf 48 52	 movsx	 ecx, WORD PTR [eax+82]
  011d8	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  011de	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  011e4	0f b6 44 0a 6a	 movzx	 eax, BYTE PTR [edx+ecx+106]
  011e9	83 e8 01	 sub	 eax, 1
  011ec	f7 d8		 neg	 eax
  011ee	1b c0		 sbb	 eax, eax
  011f0	f7 d8		 neg	 eax
  011f2	88 45 f8	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 549  : 	pMsg.Pos = this->CalcPos(this->m_DGData.IceWalkerIndex, true);

  011f5	6a 01		 push	 1
  011f7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  011fa	0f bf 48 52	 movsx	 ecx, WORD PTR [eax+82]
  011fe	51		 push	 ecx
  011ff	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01202	e8 00 00 00 00	 call	 ?CalcPos@CDoppelGanger@@QAEHH_N@Z ; CDoppelGanger::CalcPos
  01207	88 45 f9	 mov	 BYTE PTR _pMsg$[ebp+5], al

; 550  : 
; 551  : 	this->SendDoppelGangerPlayer((LPBYTE)&pMsg, pMsg.h.size);

  0120a	0f b6 45 f5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0120e	50		 push	 eax
  0120f	8d 4d f4	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  01212	51		 push	 ecx
  01213	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01216	e8 00 00 00 00	 call	 ?SendDoppelGangerPlayer@CDoppelGanger@@QAEXPAEH@Z ; CDoppelGanger::SendDoppelGangerPlayer

; 552  : }

  0121b	5f		 pop	 edi
  0121c	5e		 pop	 esi
  0121d	5b		 pop	 ebx
  0121e	8b e5		 mov	 esp, ebp
  01220	5d		 pop	 ebp
  01221	c3		 ret	 0
?SendIceWalkerPos@CDoppelGanger@@QAEXXZ ENDP		; CDoppelGanger::SendIceWalkerPos
_TEXT	ENDS
EXTRN	_rand:PROC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetMapNumber@CDoppelGanger@@QAEHXZ PROC		; CDoppelGanger::SetMapNumber
; _this$ = ecx

; 556  : {

  01230	55		 push	 ebp
  01231	8b ec		 mov	 ebp, esp
  01233	83 ec 44	 sub	 esp, 68			; 00000044H
  01236	53		 push	 ebx
  01237	56		 push	 esi
  01238	57		 push	 edi
  01239	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 557  : 	if(this->m_DGData.MapNumber != -1)

  0123c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0123f	83 b8 10 02 00
	00 ff		 cmp	 DWORD PTR [eax+528], -1
  01246	74 12		 je	 SHORT $LN2@SetMapNumb

; 558  : 	{
; 559  : 		return (264+this->m_DGData.MapNumber);

  01248	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0124b	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [eax+528]
  01251	05 08 01 00 00	 add	 eax, 264		; 00000108H
  01256	eb 2d		 jmp	 SHORT $LN3@SetMapNumb

; 560  : 	}
; 561  : 	else

  01258	eb 2b		 jmp	 SHORT $LN3@SetMapNumb
$LN2@SetMapNumb:

; 562  : 	{
; 563  : 		this->m_DGData.MapNumber = 65 + (rand()%4);

  0125a	e8 00 00 00 00	 call	 _rand
  0125f	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  01264	79 05		 jns	 SHORT $LN5@SetMapNumb
  01266	48		 dec	 eax
  01267	83 c8 fc	 or	 eax, -4			; fffffffcH
  0126a	40		 inc	 eax
$LN5@SetMapNumb:
  0126b	83 c0 41	 add	 eax, 65			; 00000041H
  0126e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01271	89 81 10 02 00
	00		 mov	 DWORD PTR [ecx+528], eax

; 564  : 		return (264+this->m_DGData.MapNumber);

  01277	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0127a	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [eax+528]
  01280	05 08 01 00 00	 add	 eax, 264		; 00000108H
$LN3@SetMapNumb:

; 565  : 	}
; 566  : }

  01285	5f		 pop	 edi
  01286	5e		 pop	 esi
  01287	5b		 pop	 ebx
  01288	8b e5		 mov	 esp, ebp
  0128a	5d		 pop	 ebp
  0128b	c3		 ret	 0
?SetMapNumber@CDoppelGanger@@QAEHXZ ENDP		; CDoppelGanger::SetMapNumber
_TEXT	ENDS
PUBLIC	??_C@_0DA@HKJFDGCO@?$FLDoppelGanger?$FN?5Spawn?5Illusion?3?5?$CI@ ; `string'
EXTRN	?gObjSetMonster@@YAHHH@Z:PROC			; gObjSetMonster
EXTRN	?gObjAddMonster@@YAFH@Z:PROC			; gObjAddMonster
;	COMDAT ??_C@_0DA@HKJFDGCO@?$FLDoppelGanger?$FN?5Spawn?5Illusion?3?5?$CI@
CONST	SEGMENT
??_C@_0DA@HKJFDGCO@?$FLDoppelGanger?$FN?5Spawn?5Illusion?3?5?$CI@ DB '[Do'
	DB	'ppelGanger] Spawn Illusion: (%d) Index: (%d)', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_i$231570 = -8						; size = 4
_this$ = -4						; size = 4
?CreateMonster@CDoppelGanger@@QAEXXZ PROC		; CDoppelGanger::CreateMonster
; _this$ = ecx

; 569  : {

  01290	55		 push	 ebp
  01291	8b ec		 mov	 ebp, esp
  01293	83 ec 48	 sub	 esp, 72			; 00000048H
  01296	53		 push	 ebx
  01297	56		 push	 esi
  01298	57		 push	 edi
  01299	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 570  : 	if(this->m_DGData.MonsterCount < (40 * this->m_DGData.PlayerCount))

  0129c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0129f	0f b6 48 46	 movzx	 ecx, BYTE PTR [eax+70]
  012a3	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  012a6	0f b6 42 44	 movzx	 eax, BYTE PTR [edx+68]
  012aa	6b c0 28	 imul	 eax, 40			; 00000028H
  012ad	3b c8		 cmp	 ecx, eax
  012af	0f 8d 49 01 00
	00		 jge	 $LN7@CreateMons

; 571  : 	{
; 572  : 		for(int i=0;i<200;++i)

  012b5	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$231570[ebp], 0
  012bc	eb 09		 jmp	 SHORT $LN5@CreateMons
$LN4@CreateMons:
  012be	8b 45 f8	 mov	 eax, DWORD PTR _i$231570[ebp]
  012c1	83 c0 01	 add	 eax, 1
  012c4	89 45 f8	 mov	 DWORD PTR _i$231570[ebp], eax
$LN5@CreateMons:
  012c7	81 7d f8 c8 00
	00 00		 cmp	 DWORD PTR _i$231570[ebp], 200 ; 000000c8H
  012ce	0f 8d 2a 01 00
	00		 jge	 $LN7@CreateMons

; 573  : 		{
; 574  : 			if(this->m_DGData.MonsterIndex[i] == -1)

  012d4	8b 45 f8	 mov	 eax, DWORD PTR _i$231570[ebp]
  012d7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  012da	0f bf 54 41 68	 movsx	 edx, WORD PTR [ecx+eax*2+104]
  012df	83 fa ff	 cmp	 edx, -1
  012e2	0f 85 11 01 00
	00		 jne	 $LN2@CreateMons

; 575  : 			{
; 576  : 				this->m_DGData.MonsterIndex[i] = gObjAddMonster(this->m_DGData.MapNumber);

  012e8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  012eb	8b 88 10 02 00
	00		 mov	 ecx, DWORD PTR [eax+528]
  012f1	51		 push	 ecx
  012f2	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  012f7	83 c4 04	 add	 esp, 4
  012fa	8b 55 f8	 mov	 edx, DWORD PTR _i$231570[ebp]
  012fd	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01300	66 89 44 51 68	 mov	 WORD PTR [ecx+edx*2+104], ax

; 577  : 				if(this->m_DGData.MonsterIndex[i] >= 0)

  01305	8b 45 f8	 mov	 eax, DWORD PTR _i$231570[ebp]
  01308	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0130b	0f bf 54 41 68	 movsx	 edx, WORD PTR [ecx+eax*2+104]
  01310	85 d2		 test	 edx, edx
  01312	0f 8c e1 00 00
	00		 jl	 $LN2@CreateMons

; 578  : 				{
; 579  : 					gObj[this->m_DGData.MonsterIndex[i]].MapNumber = this->m_DGData.MapNumber;

  01318	8b 45 f8	 mov	 eax, DWORD PTR _i$231570[ebp]
  0131b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0131e	0f bf 54 41 68	 movsx	 edx, WORD PTR [ecx+eax*2+104]
  01323	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  01329	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0132e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01331	8a 89 10 02 00
	00		 mov	 cl, BYTE PTR [ecx+528]
  01337	88 8c 10 49 01
	00 00		 mov	 BYTE PTR [eax+edx+329], cl

; 580  : 					gObj[this->m_DGData.MonsterIndex[i]].X = this->MPOSX[this->m_DGData.MapNumber-65];

  0133e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01341	8b 88 10 02 00
	00		 mov	 ecx, DWORD PTR [eax+528]
  01347	8b 55 f8	 mov	 edx, DWORD PTR _i$231570[ebp]
  0134a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0134d	0f bf 54 50 68	 movsx	 edx, WORD PTR [eax+edx*2+104]
  01352	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  01358	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0135d	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  01360	66 8b 8c 8e 20
	ff ff ff	 mov	 cx, WORD PTR [esi+ecx*4-224]
  01368	66 89 8c 10 44
	01 00 00	 mov	 WORD PTR [eax+edx+324], cx

; 581  : 					gObj[this->m_DGData.MonsterIndex[i]].Y = this->MPOSY[this->m_DGData.MapNumber-65];

  01370	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01373	8b 88 10 02 00
	00		 mov	 ecx, DWORD PTR [eax+528]
  01379	8b 55 f8	 mov	 edx, DWORD PTR _i$231570[ebp]
  0137c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0137f	0f bf 54 50 68	 movsx	 edx, WORD PTR [eax+edx*2+104]
  01384	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  0138a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0138f	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  01392	66 8b 8c 8e 30
	ff ff ff	 mov	 cx, WORD PTR [esi+ecx*4-208]
  0139a	66 89 8c 10 46
	01 00 00	 mov	 WORD PTR [eax+edx+326], cx

; 582  : 
; 583  : 					gObjSetMonster(this->m_DGData.MonsterIndex[i], (rand()%6+533));

  013a2	e8 00 00 00 00	 call	 _rand
  013a7	99		 cdq
  013a8	b9 06 00 00 00	 mov	 ecx, 6
  013ad	f7 f9		 idiv	 ecx
  013af	81 c2 15 02 00
	00		 add	 edx, 533		; 00000215H
  013b5	52		 push	 edx
  013b6	8b 55 f8	 mov	 edx, DWORD PTR _i$231570[ebp]
  013b9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  013bc	0f bf 4c 50 68	 movsx	 ecx, WORD PTR [eax+edx*2+104]
  013c1	51		 push	 ecx
  013c2	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster
  013c7	83 c4 08	 add	 esp, 8

; 584  : 					++this->m_DGData.MonsterCount;

  013ca	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  013cd	8a 48 46	 mov	 cl, BYTE PTR [eax+70]
  013d0	80 c1 01	 add	 cl, 1
  013d3	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  013d6	88 4a 46	 mov	 BYTE PTR [edx+70], cl

; 585  : 					LogAddTD("[DoppelGanger] Spawn Illusion: (%d) Index: (%d)", i, this->m_DGData.MonsterIndex[i]);

  013d9	8b 45 f8	 mov	 eax, DWORD PTR _i$231570[ebp]
  013dc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  013df	0f bf 54 41 68	 movsx	 edx, WORD PTR [ecx+eax*2+104]
  013e4	52		 push	 edx
  013e5	8b 45 f8	 mov	 eax, DWORD PTR _i$231570[ebp]
  013e8	50		 push	 eax
  013e9	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@HKJFDGCO@?$FLDoppelGanger?$FN?5Spawn?5Illusion?3?5?$CI@
  013ee	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  013f4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 586  : 					return;

  013f7	eb 05		 jmp	 SHORT $LN7@CreateMons
$LN2@CreateMons:

; 587  : 				}
; 588  : 			}
; 589  : 		}

  013f9	e9 c0 fe ff ff	 jmp	 $LN4@CreateMons
$LN7@CreateMons:

; 590  : 	}
; 591  : }

  013fe	5f		 pop	 edi
  013ff	5e		 pop	 esi
  01400	5b		 pop	 ebx
  01401	8b e5		 mov	 esp, ebp
  01403	5d		 pop	 ebp
  01404	c3		 ret	 0
?CreateMonster@CDoppelGanger@@QAEXXZ ENDP		; CDoppelGanger::CreateMonster
_TEXT	ENDS
PUBLIC	?MoveProc@CDoppelGanger@@QAEXPAUOBJECTSTRUCT@@@Z ; CDoppelGanger::MoveProc
EXTRN	?FindPathToMoveMonster@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@HHHH@Z:PROC ; TMonsterAIUtil::FindPathToMoveMonster
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?MoveProc@CDoppelGanger@@QAEXPAUOBJECTSTRUCT@@@Z PROC	; CDoppelGanger::MoveProc
; _this$ = ecx

; 594  : {

  01410	55		 push	 ebp
  01411	8b ec		 mov	 ebp, esp
  01413	83 ec 44	 sub	 esp, 68			; 00000044H
  01416	53		 push	 ebx
  01417	56		 push	 esi
  01418	57		 push	 edi
  01419	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 595  : 	if(this->IsDGMonster(lpObj) == true)

  0141c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0141f	50		 push	 eax
  01420	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01423	e8 00 00 00 00	 call	 ?IsDGMonster@CDoppelGanger@@QAE_NPAUOBJECTSTRUCT@@@Z ; CDoppelGanger::IsDGMonster
  01428	0f b6 c8	 movzx	 ecx, al
  0142b	83 f9 01	 cmp	 ecx, 1
  0142e	75 76		 jne	 SHORT $LN2@MoveProc

; 596  : 	{
; 597  : 		lpObj->MTX = this->POSX[this->m_DGData.MapNumber-65];

  01430	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01433	8b 88 10 02 00
	00		 mov	 ecx, DWORD PTR [eax+528]
  01439	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0143c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0143f	66 8b 8c 88 00
	ff ff ff	 mov	 cx, WORD PTR [eax+ecx*4-256]
  01447	66 89 8a 80 01
	00 00		 mov	 WORD PTR [edx+384], cx

; 598  : 		lpObj->MTY = this->POSY[this->m_DGData.MapNumber-65];

  0144e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01451	8b 88 10 02 00
	00		 mov	 ecx, DWORD PTR [eax+528]
  01457	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0145a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0145d	66 8b 8c 88 10
	ff ff ff	 mov	 cx, WORD PTR [eax+ecx*4-240]
  01465	66 89 8a 82 01
	00 00		 mov	 WORD PTR [edx+386], cx

; 599  : 
; 600  : 		DG_UTIL.FindPathToMoveMonster(lpObj, this->POSX[this->m_DGData.MapNumber-65], this->POSY[this->m_DGData.MapNumber-65], 40, 2);

  0146c	6a 02		 push	 2
  0146e	6a 28		 push	 40			; 00000028H
  01470	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01473	8b 88 10 02 00
	00		 mov	 ecx, DWORD PTR [eax+528]
  01479	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0147c	8b 84 8a 10 ff
	ff ff		 mov	 eax, DWORD PTR [edx+ecx*4-240]
  01483	50		 push	 eax
  01484	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01487	8b 91 10 02 00
	00		 mov	 edx, DWORD PTR [ecx+528]
  0148d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01490	8b 8c 90 00 ff
	ff ff		 mov	 ecx, DWORD PTR [eax+edx*4-256]
  01497	51		 push	 ecx
  01498	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0149b	52		 push	 edx
  0149c	b9 00 00 00 00	 mov	 ecx, OFFSET _DG_UTIL
  014a1	e8 00 00 00 00	 call	 ?FindPathToMoveMonster@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@HHHH@Z ; TMonsterAIUtil::FindPathToMoveMonster
$LN2@MoveProc:

; 601  : 	}
; 602  : }

  014a6	5f		 pop	 edi
  014a7	5e		 pop	 esi
  014a8	5b		 pop	 ebx
  014a9	8b e5		 mov	 esp, ebp
  014ab	5d		 pop	 ebp
  014ac	c2 04 00	 ret	 4
?MoveProc@CDoppelGanger@@QAEXPAUOBJECTSTRUCT@@@Z ENDP	; CDoppelGanger::MoveProc
; Function compile flags: /Odtp /ZI
_n$231594 = -12					; size = 4
_i$231586 = -8						; size = 4
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?IsDGMonster@CDoppelGanger@@QAE_NPAUOBJECTSTRUCT@@@Z PROC ; CDoppelGanger::IsDGMonster
; _this$ = ecx

; 605  : {

  014b0	55		 push	 ebp
  014b1	8b ec		 mov	 ebp, esp
  014b3	83 ec 4c	 sub	 esp, 76			; 0000004cH
  014b6	53		 push	 ebx
  014b7	56		 push	 esi
  014b8	57		 push	 edi
  014b9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 606  : 	for(int i=0;i<200;++i)

  014bc	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$231586[ebp], 0
  014c3	eb 09		 jmp	 SHORT $LN11@IsDGMonste
$LN10@IsDGMonste:
  014c5	8b 45 f8	 mov	 eax, DWORD PTR _i$231586[ebp]
  014c8	83 c0 01	 add	 eax, 1
  014cb	89 45 f8	 mov	 DWORD PTR _i$231586[ebp], eax
$LN11@IsDGMonste:
  014ce	81 7d f8 c8 00
	00 00		 cmp	 DWORD PTR _i$231586[ebp], 200 ; 000000c8H
  014d5	7d 18		 jge	 SHORT $LN9@IsDGMonste

; 607  : 	{
; 608  : 		if(this->m_DGData.MonsterIndex[i] == lpObj->m_Index)

  014d7	8b 45 f8	 mov	 eax, DWORD PTR _i$231586[ebp]
  014da	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  014dd	0f bf 54 41 68	 movsx	 edx, WORD PTR [ecx+eax*2+104]
  014e2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  014e5	3b 10		 cmp	 edx, DWORD PTR [eax]
  014e7	75 04		 jne	 SHORT $LN8@IsDGMonste

; 609  : 		{
; 610  : 			return true;

  014e9	b0 01		 mov	 al, 1
  014eb	eb 6d		 jmp	 SHORT $LN12@IsDGMonste
$LN8@IsDGMonste:

; 611  : 		}
; 612  : 	}

  014ed	eb d6		 jmp	 SHORT $LN10@IsDGMonste
$LN9@IsDGMonste:

; 613  : 	if(this->m_DGData.ButcherIndex == lpObj->m_Index) return true;

  014ef	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  014f2	0f bf 48 4e	 movsx	 ecx, WORD PTR [eax+78]
  014f6	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  014f9	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  014fb	75 04		 jne	 SHORT $LN7@IsDGMonste
  014fd	b0 01		 mov	 al, 1
  014ff	eb 59		 jmp	 SHORT $LN12@IsDGMonste
$LN7@IsDGMonste:

; 614  : 	if(this->m_DGData.AngryButcherIndex == lpObj->m_Index) return true;

  01501	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01504	0f bf 48 50	 movsx	 ecx, WORD PTR [eax+80]
  01508	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0150b	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  0150d	75 04		 jne	 SHORT $LN6@IsDGMonste
  0150f	b0 01		 mov	 al, 1
  01511	eb 47		 jmp	 SHORT $LN12@IsDGMonste
$LN6@IsDGMonste:

; 615  : 	if(this->m_DGData.IceWalkerIndex == lpObj->m_Index) return true;

  01513	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01516	0f bf 48 52	 movsx	 ecx, WORD PTR [eax+82]
  0151a	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0151d	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  0151f	75 04		 jne	 SHORT $LN5@IsDGMonste
  01521	b0 01		 mov	 al, 1
  01523	eb 35		 jmp	 SHORT $LN12@IsDGMonste
$LN5@IsDGMonste:

; 616  : 	for(int n=0;n<3;++n)

  01525	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _n$231594[ebp], 0
  0152c	eb 09		 jmp	 SHORT $LN4@IsDGMonste
$LN3@IsDGMonste:
  0152e	8b 45 f4	 mov	 eax, DWORD PTR _n$231594[ebp]
  01531	83 c0 01	 add	 eax, 1
  01534	89 45 f4	 mov	 DWORD PTR _n$231594[ebp], eax
$LN4@IsDGMonste:
  01537	83 7d f4 03	 cmp	 DWORD PTR _n$231594[ebp], 3
  0153b	7d 1b		 jge	 SHORT $LN2@IsDGMonste

; 617  : 	{
; 618  : 		if(this->m_DGData.SilverBoxIndex[n] == lpObj->m_Index)

  0153d	8b 45 f4	 mov	 eax, DWORD PTR _n$231594[ebp]
  01540	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01543	0f bf 94 41 02
	02 00 00	 movsx	 edx, WORD PTR [ecx+eax*2+514]
  0154b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0154e	3b 10		 cmp	 edx, DWORD PTR [eax]
  01550	75 04		 jne	 SHORT $LN1@IsDGMonste

; 619  : 		{
; 620  : 			return true;

  01552	b0 01		 mov	 al, 1
  01554	eb 04		 jmp	 SHORT $LN12@IsDGMonste
$LN1@IsDGMonste:

; 621  : 		}
; 622  : 	}

  01556	eb d6		 jmp	 SHORT $LN3@IsDGMonste
$LN2@IsDGMonste:

; 623  : 	return false;

  01558	32 c0		 xor	 al, al
$LN12@IsDGMonste:

; 624  : }

  0155a	5f		 pop	 edi
  0155b	5e		 pop	 esi
  0155c	5b		 pop	 ebx
  0155d	8b e5		 mov	 esp, ebp
  0155f	5d		 pop	 ebp
  01560	c2 04 00	 ret	 4
?IsDGMonster@CDoppelGanger@@QAE_NPAUOBJECTSTRUCT@@@Z ENDP ; CDoppelGanger::IsDGMonster
_TEXT	ENDS
PUBLIC	?RegenProc@CDoppelGanger@@QAEXPAUOBJECTSTRUCT@@@Z ; CDoppelGanger::RegenProc
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_i$231607 = -8						; size = 4
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?RegenProc@CDoppelGanger@@QAEXPAUOBJECTSTRUCT@@@Z PROC	; CDoppelGanger::RegenProc
; _this$ = ecx

; 627  : {

  01570	55		 push	 ebp
  01571	8b ec		 mov	 ebp, esp
  01573	83 ec 48	 sub	 esp, 72			; 00000048H
  01576	53		 push	 ebx
  01577	56		 push	 esi
  01578	57		 push	 edi
  01579	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 628  : 	if(this->IsDGMonster(lpObj) == true)

  0157c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0157f	50		 push	 eax
  01580	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01583	e8 00 00 00 00	 call	 ?IsDGMonster@CDoppelGanger@@QAE_NPAUOBJECTSTRUCT@@@Z ; CDoppelGanger::IsDGMonster
  01588	0f b6 c8	 movzx	 ecx, al
  0158b	83 f9 01	 cmp	 ecx, 1
  0158e	75 74		 jne	 SHORT $LN8@RegenProc

; 629  : 	{
; 630  : 		lpObj->RegenMapX = this->MPOSX[this->m_DGData.MapNumber-65];

  01590	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01593	8b 88 10 02 00
	00		 mov	 ecx, DWORD PTR [eax+528]
  01599	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0159c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0159f	8a 8c 88 20 ff
	ff ff		 mov	 cl, BYTE PTR [eax+ecx*4-224]
  015a6	88 8a a5 03 00
	00		 mov	 BYTE PTR [edx+933], cl

; 631  : 		lpObj->RegenMapY = this->MPOSY[this->m_DGData.MapNumber-65];

  015ac	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  015af	8b 88 10 02 00
	00		 mov	 ecx, DWORD PTR [eax+528]
  015b5	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  015b8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  015bb	8a 8c 88 30 ff
	ff ff		 mov	 cl, BYTE PTR [eax+ecx*4-208]
  015c2	88 8a a6 03 00
	00		 mov	 BYTE PTR [edx+934], cl

; 632  : 		lpObj->X = this->MPOSX[this->m_DGData.MapNumber-65];

  015c8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  015cb	8b 88 10 02 00
	00		 mov	 ecx, DWORD PTR [eax+528]
  015d1	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  015d4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  015d7	66 8b 8c 88 20
	ff ff ff	 mov	 cx, WORD PTR [eax+ecx*4-224]
  015df	66 89 8a 44 01
	00 00		 mov	 WORD PTR [edx+324], cx

; 633  : 		lpObj->Y = this->MPOSY[this->m_DGData.MapNumber-65];

  015e6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  015e9	8b 88 10 02 00
	00		 mov	 ecx, DWORD PTR [eax+528]
  015ef	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  015f2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  015f5	66 8b 8c 88 30
	ff ff ff	 mov	 cx, WORD PTR [eax+ecx*4-208]
  015fd	66 89 8a 46 01
	00 00		 mov	 WORD PTR [edx+326], cx
$LN8@RegenProc:

; 634  : 	}
; 635  : 	if(this->m_DGData.ButcherIndex == lpObj->m_Index) gObjDel(lpObj->m_Index);

  01604	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01607	0f bf 48 4e	 movsx	 ecx, WORD PTR [eax+78]
  0160b	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0160e	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  01610	75 0e		 jne	 SHORT $LN7@RegenProc
  01612	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01615	8b 08		 mov	 ecx, DWORD PTR [eax]
  01617	51		 push	 ecx
  01618	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  0161d	83 c4 04	 add	 esp, 4
$LN7@RegenProc:

; 636  : 	if(this->m_DGData.AngryButcherIndex == lpObj->m_Index) gObjDel(lpObj->m_Index);

  01620	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01623	0f bf 48 50	 movsx	 ecx, WORD PTR [eax+80]
  01627	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0162a	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  0162c	75 0e		 jne	 SHORT $LN6@RegenProc
  0162e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01631	8b 08		 mov	 ecx, DWORD PTR [eax]
  01633	51		 push	 ecx
  01634	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  01639	83 c4 04	 add	 esp, 4
$LN6@RegenProc:

; 637  : 	if(this->m_DGData.IceWalkerIndex == lpObj->m_Index) gObjDel(lpObj->m_Index);

  0163c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0163f	0f bf 48 52	 movsx	 ecx, WORD PTR [eax+82]
  01643	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01646	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  01648	75 0e		 jne	 SHORT $LN5@RegenProc
  0164a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0164d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0164f	51		 push	 ecx
  01650	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  01655	83 c4 04	 add	 esp, 4
$LN5@RegenProc:

; 638  : 	for(int i=0;i<2;++i)

  01658	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$231607[ebp], 0
  0165f	eb 09		 jmp	 SHORT $LN4@RegenProc
$LN3@RegenProc:
  01661	8b 45 f8	 mov	 eax, DWORD PTR _i$231607[ebp]
  01664	83 c0 01	 add	 eax, 1
  01667	89 45 f8	 mov	 DWORD PTR _i$231607[ebp], eax
$LN4@RegenProc:
  0166a	83 7d f8 02	 cmp	 DWORD PTR _i$231607[ebp], 2
  0166e	7d 36		 jge	 SHORT $LN9@RegenProc

; 639  : 	{
; 640  : 		if(this->m_DGData.SilverBoxIndex[i] == lpObj->m_Index)

  01670	8b 45 f8	 mov	 eax, DWORD PTR _i$231607[ebp]
  01673	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01676	0f bf 94 41 02
	02 00 00	 movsx	 edx, WORD PTR [ecx+eax*2+514]
  0167e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01681	3b 10		 cmp	 edx, DWORD PTR [eax]
  01683	75 1f		 jne	 SHORT $LN1@RegenProc

; 641  : 		{
; 642  : 			this->m_DGData.SilverBoxIndex[i] = -1;

  01685	83 c8 ff	 or	 eax, -1
  01688	8b 4d f8	 mov	 ecx, DWORD PTR _i$231607[ebp]
  0168b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0168e	66 89 84 4a 02
	02 00 00	 mov	 WORD PTR [edx+ecx*2+514], ax

; 643  : 			gObjDel(lpObj->m_Index);

  01696	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01699	8b 08		 mov	 ecx, DWORD PTR [eax]
  0169b	51		 push	 ecx
  0169c	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  016a1	83 c4 04	 add	 esp, 4
$LN1@RegenProc:

; 644  : 		}
; 645  : 	}

  016a4	eb bb		 jmp	 SHORT $LN3@RegenProc
$LN9@RegenProc:

; 646  : }

  016a6	5f		 pop	 edi
  016a7	5e		 pop	 esi
  016a8	5b		 pop	 ebx
  016a9	8b e5		 mov	 esp, ebp
  016ab	5d		 pop	 ebp
  016ac	c2 04 00	 ret	 4
?RegenProc@CDoppelGanger@@QAEXPAUOBJECTSTRUCT@@@Z ENDP	; CDoppelGanger::RegenProc
_TEXT	ENDS
PUBLIC	__real@4010666666666666
PUBLIC	__real@4036000000000000
PUBLIC	__real@400999999999999a
EXTRN	__fltused:DWORD
EXTRN	__ftol2_sse:PROC
;	COMDAT __real@4010666666666666
CONST	SEGMENT
__real@4010666666666666 DQ 04010666666666666r	; 4.1
CONST	ENDS
;	COMDAT __real@4036000000000000
CONST	SEGMENT
__real@4036000000000000 DQ 04036000000000000r	; 22
CONST	ENDS
;	COMDAT __real@400999999999999a
CONST	SEGMENT
__real@400999999999999a DQ 0400999999999999ar	; 3.2
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv382 = -72						; size = 4
tv369 = -72						; size = 4
tv343 = -72						; size = 4
tv330 = -72						; size = 4
tv313 = -72						; size = 4
tv279 = -72						; size = 4
_this$ = -4						; size = 4
_player$ = 8						; size = 4
_MonsterCalc$ = 12					; size = 1
?CalcPos@CDoppelGanger@@QAEHH_N@Z PROC			; CDoppelGanger::CalcPos
; _this$ = ecx

; 649  : {

  016b0	55		 push	 ebp
  016b1	8b ec		 mov	 ebp, esp
  016b3	83 ec 48	 sub	 esp, 72			; 00000048H
  016b6	53		 push	 ebx
  016b7	56		 push	 esi
  016b8	57		 push	 edi
  016b9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 650  : 	if(MonsterCalc == false)

  016bc	0f b6 45 0c	 movzx	 eax, BYTE PTR _MonsterCalc$[ebp]
  016c0	85 c0		 test	 eax, eax
  016c2	0f 85 e7 01 00
	00		 jne	 $LN32@CalcPos

; 651  : 	{
; 652  : 		if(this->m_DGData.MapNumber == 65)

  016c8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  016cb	83 b8 10 02 00
	00 41		 cmp	 DWORD PTR [eax+528], 65	; 00000041H
  016d2	75 6f		 jne	 SHORT $LN31@CalcPos

; 653  : 		{
; 654  : 			if(gObj[this->m_DGData.PlayerIndex[player]].Y>31)

  016d4	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  016d7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  016da	8b 54 81 54	 mov	 edx, DWORD PTR [ecx+eax*4+84]
  016de	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  016e4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  016e9	0f bf 8c 10 46
	01 00 00	 movsx	 ecx, WORD PTR [eax+edx+326]
  016f1	83 f9 1f	 cmp	 ecx, 31			; 0000001fH
  016f4	7e 3e		 jle	 SHORT $LN30@CalcPos

; 655  : 			{
; 656  : 				return 22-((gObj[this->m_DGData.PlayerIndex[player]].Y-31)/3.2);

  016f6	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  016f9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  016fc	8b 54 81 54	 mov	 edx, DWORD PTR [ecx+eax*4+84]
  01700	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  01706	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0170b	0f bf 8c 10 46
	01 00 00	 movsx	 ecx, WORD PTR [eax+edx+326]
  01713	83 e9 1f	 sub	 ecx, 31			; 0000001fH
  01716	89 4d b8	 mov	 DWORD PTR tv279[ebp], ecx
  01719	db 45 b8	 fild	 DWORD PTR tv279[ebp]
  0171c	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@400999999999999a
  01722	dc 2d 00 00 00
	00		 fsubr	 QWORD PTR __real@4036000000000000
  01728	e8 00 00 00 00	 call	 __ftol2_sse
  0172d	e9 28 03 00 00	 jmp	 $LN33@CalcPos

; 657  : 			}
; 658  : 			else

  01732	eb 0a		 jmp	 SHORT $LN29@CalcPos
$LN30@CalcPos:

; 659  : 			{
; 660  : 				return 22;

  01734	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  01739	e9 1c 03 00 00	 jmp	 $LN33@CalcPos
$LN29@CalcPos:

; 661  : 			}

  0173e	e9 67 01 00 00	 jmp	 $LN17@CalcPos
$LN31@CalcPos:

; 662  : 		}
; 663  : 		else if(this->m_DGData.MapNumber == 66)

  01743	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01746	83 b8 10 02 00
	00 42		 cmp	 DWORD PTR [eax+528], 66	; 00000042H
  0174d	75 6d		 jne	 SHORT $LN27@CalcPos

; 664  : 		{
; 665  : 			if(gObj[this->m_DGData.PlayerIndex[player]].Y>69)

  0174f	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01752	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01755	8b 54 81 54	 mov	 edx, DWORD PTR [ecx+eax*4+84]
  01759	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  0175f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01764	0f bf 8c 10 46
	01 00 00	 movsx	 ecx, WORD PTR [eax+edx+326]
  0176c	83 f9 45	 cmp	 ecx, 69			; 00000045H
  0176f	7e 3c		 jle	 SHORT $LN26@CalcPos

; 666  : 			{
; 667  : 				return 22-(((gObj[this->m_DGData.PlayerIndex[player]].Y -70)*2)/10);

  01771	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01774	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01777	8b 54 81 54	 mov	 edx, DWORD PTR [ecx+eax*4+84]
  0177b	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  01781	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01786	0f bf 8c 10 46
	01 00 00	 movsx	 ecx, WORD PTR [eax+edx+326]
  0178e	8d 84 09 74 ff
	ff ff		 lea	 eax, DWORD PTR [ecx+ecx-140]
  01795	99		 cdq
  01796	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  0179b	f7 f9		 idiv	 ecx
  0179d	ba 16 00 00 00	 mov	 edx, 22			; 00000016H
  017a2	2b d0		 sub	 edx, eax
  017a4	8b c2		 mov	 eax, edx
  017a6	e9 af 02 00 00	 jmp	 $LN33@CalcPos

; 668  : 			}
; 669  : 			else

  017ab	eb 0a		 jmp	 SHORT $LN25@CalcPos
$LN26@CalcPos:

; 670  : 			{
; 671  : 				return 22;

  017ad	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  017b2	e9 a3 02 00 00	 jmp	 $LN33@CalcPos
$LN25@CalcPos:

; 672  : 			}

  017b7	e9 ee 00 00 00	 jmp	 $LN17@CalcPos
$LN27@CalcPos:

; 673  : 		}
; 674  : 		else if(this->m_DGData.MapNumber == 67)

  017bc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  017bf	83 b8 10 02 00
	00 43		 cmp	 DWORD PTR [eax+528], 67	; 00000043H
  017c6	75 6c		 jne	 SHORT $LN23@CalcPos

; 675  : 		{
; 676  : 			if(gObj[this->m_DGData.PlayerIndex[player]].Y>61)

  017c8	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  017cb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  017ce	8b 54 81 54	 mov	 edx, DWORD PTR [ecx+eax*4+84]
  017d2	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  017d8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  017dd	0f bf 8c 10 46
	01 00 00	 movsx	 ecx, WORD PTR [eax+edx+326]
  017e5	83 f9 3d	 cmp	 ecx, 61			; 0000003dH
  017e8	7e 3e		 jle	 SHORT $LN22@CalcPos

; 677  : 			{
; 678  : 				return 22-((gObj[this->m_DGData.PlayerIndex[player]].Y-61)/4.1);

  017ea	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  017ed	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  017f0	8b 54 81 54	 mov	 edx, DWORD PTR [ecx+eax*4+84]
  017f4	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  017fa	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  017ff	0f bf 8c 10 46
	01 00 00	 movsx	 ecx, WORD PTR [eax+edx+326]
  01807	83 e9 3d	 sub	 ecx, 61			; 0000003dH
  0180a	89 4d b8	 mov	 DWORD PTR tv313[ebp], ecx
  0180d	db 45 b8	 fild	 DWORD PTR tv313[ebp]
  01810	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@4010666666666666
  01816	dc 2d 00 00 00
	00		 fsubr	 QWORD PTR __real@4036000000000000
  0181c	e8 00 00 00 00	 call	 __ftol2_sse
  01821	e9 34 02 00 00	 jmp	 $LN33@CalcPos

; 679  : 			}
; 680  : 			else

  01826	eb 0a		 jmp	 SHORT $LN21@CalcPos
$LN22@CalcPos:

; 681  : 			{
; 682  : 				return 22;

  01828	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  0182d	e9 28 02 00 00	 jmp	 $LN33@CalcPos
$LN21@CalcPos:

; 683  : 			}

  01832	eb 76		 jmp	 SHORT $LN17@CalcPos
$LN23@CalcPos:

; 684  : 		}
; 685  : 		else if(this->m_DGData.MapNumber == 68)

  01834	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01837	83 b8 10 02 00
	00 44		 cmp	 DWORD PTR [eax+528], 68	; 00000044H
  0183e	75 6a		 jne	 SHORT $LN17@CalcPos

; 686  : 		{
; 687  : 			//for(int n=1;n<23;n++)
; 688  : 			//{	
; 689  : 			//	if(gObj[this->m_DGData.PlayerIndex[player]].MapNumber == 68 && gObj[this->m_DGData.PlayerIndex[player]].Y > 24+((n-1)*4) && gObj[this->m_DGData.PlayerIndex[player]].Y <= 27+((n-1)*4))
; 690  : 			//	{
; 691  : 			//		return n;
; 692  : 			//	}
; 693  : 			//}
; 694  : 			if(gObj[this->m_DGData.PlayerIndex[player]].Y>18)

  01840	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01843	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01846	8b 54 81 54	 mov	 edx, DWORD PTR [ecx+eax*4+84]
  0184a	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  01850	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01855	0f bf 8c 10 46
	01 00 00	 movsx	 ecx, WORD PTR [eax+edx+326]
  0185d	83 f9 12	 cmp	 ecx, 18			; 00000012H
  01860	7e 3e		 jle	 SHORT $LN18@CalcPos

; 695  : 			{
; 696  : 				return 22-((gObj[this->m_DGData.PlayerIndex[player]].Y-18)/4.1);

  01862	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01865	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01868	8b 54 81 54	 mov	 edx, DWORD PTR [ecx+eax*4+84]
  0186c	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  01872	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01877	0f bf 8c 10 46
	01 00 00	 movsx	 ecx, WORD PTR [eax+edx+326]
  0187f	83 e9 12	 sub	 ecx, 18			; 00000012H
  01882	89 4d b8	 mov	 DWORD PTR tv330[ebp], ecx
  01885	db 45 b8	 fild	 DWORD PTR tv330[ebp]
  01888	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@4010666666666666
  0188e	dc 2d 00 00 00
	00		 fsubr	 QWORD PTR __real@4036000000000000
  01894	e8 00 00 00 00	 call	 __ftol2_sse
  01899	e9 bc 01 00 00	 jmp	 $LN33@CalcPos

; 697  : 			}
; 698  : 			else

  0189e	eb 0a		 jmp	 SHORT $LN17@CalcPos
$LN18@CalcPos:

; 699  : 			{
; 700  : 				return 22;

  018a0	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  018a5	e9 b0 01 00 00	 jmp	 $LN33@CalcPos
$LN17@CalcPos:

; 701  : 			}
; 702  : 		}
; 703  : 
; 704  : 	}
; 705  : 	else

  018aa	e9 a6 01 00 00	 jmp	 $LN1@CalcPos
$LN32@CalcPos:

; 706  : 	{
; 707  : 		if(this->m_DGData.MapNumber == 65)

  018af	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  018b2	83 b8 10 02 00
	00 41		 cmp	 DWORD PTR [eax+528], 65	; 00000041H
  018b9	75 63		 jne	 SHORT $LN15@CalcPos

; 708  : 		{
; 709  : 			if(gObj[player].Y>31)

  018bb	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  018be	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  018c4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  018ca	0f bf 94 01 46
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+326]
  018d2	83 fa 1f	 cmp	 edx, 31			; 0000001fH
  018d5	7e 38		 jle	 SHORT $LN14@CalcPos

; 710  : 			{
; 711  : 				return 22-((gObj[player].Y-31)/3.2);

  018d7	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  018da	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  018e0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  018e6	0f bf 94 01 46
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+326]
  018ee	83 ea 1f	 sub	 edx, 31			; 0000001fH
  018f1	89 55 b8	 mov	 DWORD PTR tv343[ebp], edx
  018f4	db 45 b8	 fild	 DWORD PTR tv343[ebp]
  018f7	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@400999999999999a
  018fd	dc 2d 00 00 00
	00		 fsubr	 QWORD PTR __real@4036000000000000
  01903	e8 00 00 00 00	 call	 __ftol2_sse
  01908	e9 4d 01 00 00	 jmp	 $LN33@CalcPos

; 712  : 			}
; 713  : 			else

  0190d	eb 0a		 jmp	 SHORT $LN13@CalcPos
$LN14@CalcPos:

; 714  : 			{
; 715  : 				return 22;

  0190f	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  01914	e9 41 01 00 00	 jmp	 $LN33@CalcPos
$LN13@CalcPos:

; 716  : 			}

  01919	e9 37 01 00 00	 jmp	 $LN1@CalcPos
$LN15@CalcPos:

; 717  : 		}
; 718  : 		else if(this->m_DGData.MapNumber == 66)

  0191e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01921	83 b8 10 02 00
	00 42		 cmp	 DWORD PTR [eax+528], 66	; 00000042H
  01928	75 61		 jne	 SHORT $LN11@CalcPos

; 719  : 		{
; 720  : 			if(gObj[player].Y>69)

  0192a	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0192d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01933	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01939	0f bf 94 01 46
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+326]
  01941	83 fa 45	 cmp	 edx, 69			; 00000045H
  01944	7e 36		 jle	 SHORT $LN10@CalcPos

; 721  : 			{
; 722  : 				return 22-(((gObj[player].Y -70)*2)/10);

  01946	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01949	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0194f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01955	0f bf 94 01 46
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+326]
  0195d	8d 84 12 74 ff
	ff ff		 lea	 eax, DWORD PTR [edx+edx-140]
  01964	99		 cdq
  01965	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  0196a	f7 f9		 idiv	 ecx
  0196c	ba 16 00 00 00	 mov	 edx, 22			; 00000016H
  01971	2b d0		 sub	 edx, eax
  01973	8b c2		 mov	 eax, edx
  01975	e9 e0 00 00 00	 jmp	 $LN33@CalcPos

; 723  : 			}
; 724  : 			else

  0197a	eb 0a		 jmp	 SHORT $LN9@CalcPos
$LN10@CalcPos:

; 725  : 			{
; 726  : 				return 22;

  0197c	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  01981	e9 d4 00 00 00	 jmp	 $LN33@CalcPos
$LN9@CalcPos:

; 727  : 			}

  01986	e9 ca 00 00 00	 jmp	 $LN1@CalcPos
$LN11@CalcPos:

; 728  : 		}
; 729  : 		else if(this->m_DGData.MapNumber == 67)

  0198b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0198e	83 b8 10 02 00
	00 43		 cmp	 DWORD PTR [eax+528], 67	; 00000043H
  01995	75 5a		 jne	 SHORT $LN7@CalcPos

; 730  : 		{
; 731  : 			if(gObj[player].Y>61)

  01997	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0199a	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  019a0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  019a6	0f bf 94 01 46
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+326]
  019ae	83 fa 3d	 cmp	 edx, 61			; 0000003dH
  019b1	7e 35		 jle	 SHORT $LN6@CalcPos

; 732  : 			{
; 733  : 				return 22-((gObj[player].Y-61)/4.1);

  019b3	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  019b6	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  019bc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  019c2	0f bf 94 01 46
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+326]
  019ca	83 ea 3d	 sub	 edx, 61			; 0000003dH
  019cd	89 55 b8	 mov	 DWORD PTR tv369[ebp], edx
  019d0	db 45 b8	 fild	 DWORD PTR tv369[ebp]
  019d3	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@4010666666666666
  019d9	dc 2d 00 00 00
	00		 fsubr	 QWORD PTR __real@4036000000000000
  019df	e8 00 00 00 00	 call	 __ftol2_sse
  019e4	eb 74		 jmp	 SHORT $LN33@CalcPos

; 734  : 			}
; 735  : 			else

  019e6	eb 07		 jmp	 SHORT $LN5@CalcPos
$LN6@CalcPos:

; 736  : 			{
; 737  : 				return 22;

  019e8	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  019ed	eb 6b		 jmp	 SHORT $LN33@CalcPos
$LN5@CalcPos:

; 738  : 			}

  019ef	eb 64		 jmp	 SHORT $LN1@CalcPos
$LN7@CalcPos:

; 739  : 		}
; 740  : 		else if(this->m_DGData.MapNumber == 68)

  019f1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  019f4	83 b8 10 02 00
	00 44		 cmp	 DWORD PTR [eax+528], 68	; 00000044H
  019fb	75 58		 jne	 SHORT $LN1@CalcPos

; 741  : 		{
; 742  : 			//for(int n=1;n<23;n++)
; 743  : 			//{	
; 744  : 			//	if(gObj[player].MapNumber == 68 && gObj[player].Y > 24+((n-1)*4) && gObj[player].Y <= 27+((n-1)*4))
; 745  : 			//	{
; 746  : 			//		return n;
; 747  : 			//	}
; 748  : 			//}
; 749  : 			if(gObj[player].Y>18)

  019fd	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01a00	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01a06	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01a0c	0f bf 94 01 46
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+326]
  01a14	83 fa 12	 cmp	 edx, 18			; 00000012H
  01a17	7e 35		 jle	 SHORT $LN2@CalcPos

; 750  : 			{
; 751  : 				return 22-((gObj[player].Y-18)/4.1);

  01a19	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01a1c	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01a22	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01a28	0f bf 94 01 46
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+326]
  01a30	83 ea 12	 sub	 edx, 18			; 00000012H
  01a33	89 55 b8	 mov	 DWORD PTR tv382[ebp], edx
  01a36	db 45 b8	 fild	 DWORD PTR tv382[ebp]
  01a39	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@4010666666666666
  01a3f	dc 2d 00 00 00
	00		 fsubr	 QWORD PTR __real@4036000000000000
  01a45	e8 00 00 00 00	 call	 __ftol2_sse
  01a4a	eb 0e		 jmp	 SHORT $LN33@CalcPos

; 752  : 			}
; 753  : 			else

  01a4c	eb 07		 jmp	 SHORT $LN1@CalcPos
$LN2@CalcPos:

; 754  : 			{
; 755  : 				return 22;

  01a4e	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  01a53	eb 05		 jmp	 SHORT $LN33@CalcPos
$LN1@CalcPos:

; 756  : 			}
; 757  : 		}
; 758  : 	}
; 759  : 	return 22;

  01a55	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
$LN33@CalcPos:

; 760  : }

  01a5a	5f		 pop	 edi
  01a5b	5e		 pop	 esi
  01a5c	5b		 pop	 ebx
  01a5d	8b e5		 mov	 esp, ebp
  01a5f	5d		 pop	 ebp
  01a60	c2 08 00	 ret	 8
?CalcPos@CDoppelGanger@@QAEHH_N@Z ENDP			; CDoppelGanger::CalcPos
_TEXT	ENDS
PUBLIC	??_C@_0DA@OOOKDDFK@?$FLDoppelGanger?$FN?5Increase?5Monster?5@ ; `string'
;	COMDAT ??_C@_0DA@OOOKDDFK@?$FLDoppelGanger?$FN?5Increase?5Monster?5@
CONST	SEGMENT
??_C@_0DA@OOOKDDFK@?$FLDoppelGanger?$FN?5Increase?5Monster?5@ DB '[Doppel'
	DB	'Ganger] Increase Monster Passed: (%d/%d)', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_i$231652 = -8						; size = 4
_this$ = -4						; size = 4
?CheckPosition@CDoppelGanger@@QAEXXZ PROC		; CDoppelGanger::CheckPosition
; _this$ = ecx

; 763  : {

  01a70	55		 push	 ebp
  01a71	8b ec		 mov	 ebp, esp
  01a73	83 ec 48	 sub	 esp, 72			; 00000048H
  01a76	53		 push	 ebx
  01a77	56		 push	 esi
  01a78	57		 push	 edi
  01a79	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 764  : 	for(int i=0;i<200;++i)

  01a7c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$231652[ebp], 0
  01a83	eb 09		 jmp	 SHORT $LN5@CheckPosit
$LN4@CheckPosit:
  01a85	8b 45 f8	 mov	 eax, DWORD PTR _i$231652[ebp]
  01a88	83 c0 01	 add	 eax, 1
  01a8b	89 45 f8	 mov	 DWORD PTR _i$231652[ebp], eax
$LN5@CheckPosit:
  01a8e	81 7d f8 c8 00
	00 00		 cmp	 DWORD PTR _i$231652[ebp], 200 ; 000000c8H
  01a95	0f 8d 67 01 00
	00		 jge	 $LN6@CheckPosit

; 765  : 	{
; 766  : 		if(gObj[this->m_DGData.MonsterIndex[i]].X > g_DGPortal[this->m_DGData.MapNumber-65].StartX - 3 &&
; 767  : 			gObj[this->m_DGData.MonsterIndex[i]].X < g_DGPortal[this->m_DGData.MapNumber-65].StartX +3 )

  01a9b	8b 45 f8	 mov	 eax, DWORD PTR _i$231652[ebp]
  01a9e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01aa1	0f bf 54 41 68	 movsx	 edx, WORD PTR [ecx+eax*2+104]
  01aa6	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  01aac	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01ab1	0f bf 8c 10 44
	01 00 00	 movsx	 ecx, WORD PTR [eax+edx+324]
  01ab9	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01abc	8b 82 10 02 00
	00		 mov	 eax, DWORD PTR [edx+528]
  01ac2	0f b6 14 45 7e
	ff ff ff	 movzx	 edx, BYTE PTR _g_DGPortal[eax*2-130]
  01aca	83 ea 03	 sub	 edx, 3
  01acd	3b ca		 cmp	 ecx, edx
  01acf	0f 8e 28 01 00
	00		 jle	 $LN2@CheckPosit
  01ad5	8b 45 f8	 mov	 eax, DWORD PTR _i$231652[ebp]
  01ad8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01adb	0f bf 54 41 68	 movsx	 edx, WORD PTR [ecx+eax*2+104]
  01ae0	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  01ae6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01aeb	0f bf 8c 10 44
	01 00 00	 movsx	 ecx, WORD PTR [eax+edx+324]
  01af3	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01af6	8b 82 10 02 00
	00		 mov	 eax, DWORD PTR [edx+528]
  01afc	0f b6 14 45 7e
	ff ff ff	 movzx	 edx, BYTE PTR _g_DGPortal[eax*2-130]
  01b04	83 c2 03	 add	 edx, 3
  01b07	3b ca		 cmp	 ecx, edx
  01b09	0f 8d ee 00 00
	00		 jge	 $LN2@CheckPosit

; 768  : 		{
; 769  : 			if(gObj[this->m_DGData.MonsterIndex[i]].Y > g_DGPortal[this->m_DGData.MapNumber-65].StartY - 5 &&
; 770  : 				gObj[this->m_DGData.MonsterIndex[i]].Y < g_DGPortal[this->m_DGData.MapNumber-65].StartY +5 )

  01b0f	8b 45 f8	 mov	 eax, DWORD PTR _i$231652[ebp]
  01b12	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01b15	0f bf 54 41 68	 movsx	 edx, WORD PTR [ecx+eax*2+104]
  01b1a	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  01b20	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01b25	0f bf 8c 10 46
	01 00 00	 movsx	 ecx, WORD PTR [eax+edx+326]
  01b2d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01b30	8b 82 10 02 00
	00		 mov	 eax, DWORD PTR [edx+528]
  01b36	0f b6 14 45 7f
	ff ff ff	 movzx	 edx, BYTE PTR _g_DGPortal[eax*2-129]
  01b3e	83 ea 05	 sub	 edx, 5
  01b41	3b ca		 cmp	 ecx, edx
  01b43	0f 8e b4 00 00
	00		 jle	 $LN2@CheckPosit
  01b49	8b 45 f8	 mov	 eax, DWORD PTR _i$231652[ebp]
  01b4c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01b4f	0f bf 54 41 68	 movsx	 edx, WORD PTR [ecx+eax*2+104]
  01b54	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  01b5a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01b5f	0f bf 8c 10 46
	01 00 00	 movsx	 ecx, WORD PTR [eax+edx+326]
  01b67	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01b6a	8b 82 10 02 00
	00		 mov	 eax, DWORD PTR [edx+528]
  01b70	0f b6 14 45 7f
	ff ff ff	 movzx	 edx, BYTE PTR _g_DGPortal[eax*2-129]
  01b78	83 c2 05	 add	 edx, 5
  01b7b	3b ca		 cmp	 ecx, edx
  01b7d	7d 7e		 jge	 SHORT $LN2@CheckPosit

; 771  : 			{
; 772  : 				gObj[this->m_DGData.MonsterIndex[i]].m_ViewSkillState[105] = 1;

  01b7f	8b 45 f8	 mov	 eax, DWORD PTR _i$231652[ebp]
  01b82	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01b85	0f bf 54 41 68	 movsx	 edx, WORD PTR [ecx+eax*2+104]
  01b8a	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  01b90	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01b95	c6 84 10 23 22
	00 00 01	 mov	 BYTE PTR [eax+edx+8739], 1

; 773  : 				//BuffEffectC.EnableBuff(this->m_DGData.MonsterIndex[i], 105, -1, 0, 0, 0);
; 774  : 				gObjDel(this->m_DGData.MonsterIndex[i]);

  01b9d	8b 45 f8	 mov	 eax, DWORD PTR _i$231652[ebp]
  01ba0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01ba3	0f bf 54 41 68	 movsx	 edx, WORD PTR [ecx+eax*2+104]
  01ba8	52		 push	 edx
  01ba9	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  01bae	83 c4 04	 add	 esp, 4

; 775  : 				this->m_DGData.MonsterIndex[i] = -1;

  01bb1	83 c8 ff	 or	 eax, -1
  01bb4	8b 4d f8	 mov	 ecx, DWORD PTR _i$231652[ebp]
  01bb7	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01bba	66 89 44 4a 68	 mov	 WORD PTR [edx+ecx*2+104], ax

; 776  : 				--this->m_DGData.MonsterCount;

  01bbf	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01bc2	8a 48 46	 mov	 cl, BYTE PTR [eax+70]
  01bc5	80 e9 01	 sub	 cl, 1
  01bc8	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01bcb	88 4a 46	 mov	 BYTE PTR [edx+70], cl

; 777  : 				++this->m_DGData.MonsterPassed;

  01bce	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01bd1	8a 48 47	 mov	 cl, BYTE PTR [eax+71]
  01bd4	80 c1 01	 add	 cl, 1
  01bd7	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01bda	88 4a 47	 mov	 BYTE PTR [edx+71], cl

; 778  : 				this->SetMonsterCountOnInterface();

  01bdd	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01be0	e8 00 00 00 00	 call	 ?SetMonsterCountOnInterface@CDoppelGanger@@QAEXXZ ; CDoppelGanger::SetMonsterCountOnInterface

; 779  : 				LogAddTD("[DoppelGanger] Increase Monster Passed: (%d/%d)", this->m_DGData.MonsterPassed, GOER_MAX_PASS_PORTAL);

  01be5	6a 03		 push	 3
  01be7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01bea	0f b6 48 47	 movzx	 ecx, BYTE PTR [eax+71]
  01bee	51		 push	 ecx
  01bef	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@OOOKDDFK@?$FLDoppelGanger?$FN?5Increase?5Monster?5@
  01bf4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01bfa	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@CheckPosit:

; 780  : 			}
; 781  : 		}
; 782  : 	}

  01bfd	e9 83 fe ff ff	 jmp	 $LN4@CheckPosit
$LN6@CheckPosit:

; 783  : }

  01c02	5f		 pop	 edi
  01c03	5e		 pop	 esi
  01c04	5b		 pop	 ebx
  01c05	8b e5		 mov	 esp, ebp
  01c07	5d		 pop	 ebp
  01c08	c3		 ret	 0
?CheckPosition@CDoppelGanger@@QAEXXZ ENDP		; CDoppelGanger::CheckPosition
; Function compile flags: /Odtp /ZI
_pResult$ = -12					; size = 5
_this$ = -4						; size = 4
_Result$ = 8						; size = 1
_SendForAll$ = 12					; size = 1
_aIndex$ = 16						; size = 4
?SendResultMessage@CDoppelGanger@@QAEXE_NH@Z PROC	; CDoppelGanger::SendResultMessage
; _this$ = ecx

; 786  : {

  01c10	55		 push	 ebp
  01c11	8b ec		 mov	 ebp, esp
  01c13	83 ec 4c	 sub	 esp, 76			; 0000004cH
  01c16	53		 push	 ebx
  01c17	56		 push	 esi
  01c18	57		 push	 edi
  01c19	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 787  : 	PMSG_DGOER_END pResult;
; 788  : 
; 789  : 	PHeadSubSetB((LPBYTE)&pResult, 0xBF, 0x13, sizeof(pResult));

  01c1c	6a 05		 push	 5
  01c1e	6a 13		 push	 19			; 00000013H
  01c20	68 bf 00 00 00	 push	 191			; 000000bfH
  01c25	8d 45 f4	 lea	 eax, DWORD PTR _pResult$[ebp]
  01c28	50		 push	 eax
  01c29	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  01c2e	83 c4 10	 add	 esp, 16			; 00000010H

; 790  : 
; 791  : 	pResult.Status = Result;

  01c31	8a 45 08	 mov	 al, BYTE PTR _Result$[ebp]
  01c34	88 45 f8	 mov	 BYTE PTR _pResult$[ebp+4], al

; 792  : 
; 793  : 	if(SendForAll)

  01c37	0f b6 45 0c	 movzx	 eax, BYTE PTR _SendForAll$[ebp]
  01c3b	85 c0		 test	 eax, eax
  01c3d	74 13		 je	 SHORT $LN2@SendResult

; 794  : 	{
; 795  : 		this->SendDoppelGangerPlayer((LPBYTE)&pResult, pResult.h.size);

  01c3f	0f b6 45 f5	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  01c43	50		 push	 eax
  01c44	8d 4d f4	 lea	 ecx, DWORD PTR _pResult$[ebp]
  01c47	51		 push	 ecx
  01c48	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01c4b	e8 00 00 00 00	 call	 ?SendDoppelGangerPlayer@CDoppelGanger@@QAEXPAEH@Z ; CDoppelGanger::SendDoppelGangerPlayer

; 796  : 	}
; 797  : 	else

  01c50	eb 15		 jmp	 SHORT $LN3@SendResult
$LN2@SendResult:

; 798  : 	{
; 799  : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  01c52	0f b6 45 f5	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  01c56	50		 push	 eax
  01c57	8d 4d f4	 lea	 ecx, DWORD PTR _pResult$[ebp]
  01c5a	51		 push	 ecx
  01c5b	8b 55 10	 mov	 edx, DWORD PTR _aIndex$[ebp]
  01c5e	52		 push	 edx
  01c5f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  01c64	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@SendResult:

; 800  : 	}
; 801  : }

  01c67	5f		 pop	 edi
  01c68	5e		 pop	 esi
  01c69	5b		 pop	 ebx
  01c6a	8b e5		 mov	 esp, ebp
  01c6c	5d		 pop	 ebp
  01c6d	c2 0c 00	 ret	 12			; 0000000cH
?SendResultMessage@CDoppelGanger@@QAEXE_NH@Z ENDP	; CDoppelGanger::SendResultMessage
; Function compile flags: /Odtp /ZI
_i$231682 = -12					; size = 4
_i$231674 = -8						; size = 4
_this$ = -4						; size = 4
?DeleteMonster@CDoppelGanger@@QAEXXZ PROC		; CDoppelGanger::DeleteMonster
; _this$ = ecx

; 804  : {

  01c70	55		 push	 ebp
  01c71	8b ec		 mov	 ebp, esp
  01c73	83 ec 4c	 sub	 esp, 76			; 0000004cH
  01c76	53		 push	 ebx
  01c77	56		 push	 esi
  01c78	57		 push	 edi
  01c79	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 805  : 	for(int i=0;i<200;++i)

  01c7c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$231674[ebp], 0
  01c83	eb 09		 jmp	 SHORT $LN12@DeleteMons
$LN11@DeleteMons:
  01c85	8b 45 f8	 mov	 eax, DWORD PTR _i$231674[ebp]
  01c88	83 c0 01	 add	 eax, 1
  01c8b	89 45 f8	 mov	 DWORD PTR _i$231674[ebp], eax
$LN12@DeleteMons:
  01c8e	81 7d f8 c8 00
	00 00		 cmp	 DWORD PTR _i$231674[ebp], 200 ; 000000c8H
  01c95	7d 43		 jge	 SHORT $LN10@DeleteMons

; 806  : 	{
; 807  : 		if(this->m_DGData.MonsterIndex[i] != -1)

  01c97	8b 45 f8	 mov	 eax, DWORD PTR _i$231674[ebp]
  01c9a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01c9d	0f bf 54 41 68	 movsx	 edx, WORD PTR [ecx+eax*2+104]
  01ca2	83 fa ff	 cmp	 edx, -1
  01ca5	74 31		 je	 SHORT $LN9@DeleteMons

; 808  : 		{
; 809  : 			gObjDel(this->m_DGData.MonsterIndex[i]);

  01ca7	8b 45 f8	 mov	 eax, DWORD PTR _i$231674[ebp]
  01caa	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01cad	0f bf 54 41 68	 movsx	 edx, WORD PTR [ecx+eax*2+104]
  01cb2	52		 push	 edx
  01cb3	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  01cb8	83 c4 04	 add	 esp, 4

; 810  : 			this->m_DGData.MonsterIndex[i] = -1;

  01cbb	83 c8 ff	 or	 eax, -1
  01cbe	8b 4d f8	 mov	 ecx, DWORD PTR _i$231674[ebp]
  01cc1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01cc4	66 89 44 4a 68	 mov	 WORD PTR [edx+ecx*2+104], ax

; 811  : 			--this->m_DGData.MonsterCount;

  01cc9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01ccc	8a 48 46	 mov	 cl, BYTE PTR [eax+70]
  01ccf	80 e9 01	 sub	 cl, 1
  01cd2	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01cd5	88 4a 46	 mov	 BYTE PTR [edx+70], cl
$LN9@DeleteMons:

; 812  : 		}
; 813  : 	}

  01cd8	eb ab		 jmp	 SHORT $LN11@DeleteMons
$LN10@DeleteMons:

; 814  : 	if(this->m_DGData.ButcherIndex >= 0)

  01cda	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01cdd	0f bf 48 4e	 movsx	 ecx, WORD PTR [eax+78]
  01ce1	85 c9		 test	 ecx, ecx
  01ce3	7c 10		 jl	 SHORT $LN8@DeleteMons

; 815  : 		gObjDel(this->m_DGData.ButcherIndex);

  01ce5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01ce8	0f bf 48 4e	 movsx	 ecx, WORD PTR [eax+78]
  01cec	51		 push	 ecx
  01ced	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  01cf2	83 c4 04	 add	 esp, 4
$LN8@DeleteMons:

; 816  : 	if(this->m_DGData.AngryButcherIndex >= 0)

  01cf5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01cf8	0f bf 48 50	 movsx	 ecx, WORD PTR [eax+80]
  01cfc	85 c9		 test	 ecx, ecx
  01cfe	7c 10		 jl	 SHORT $LN7@DeleteMons

; 817  : 		gObjDel(this->m_DGData.AngryButcherIndex);

  01d00	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01d03	0f bf 48 50	 movsx	 ecx, WORD PTR [eax+80]
  01d07	51		 push	 ecx
  01d08	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  01d0d	83 c4 04	 add	 esp, 4
$LN7@DeleteMons:

; 818  : 	if(this->m_DGData.IceWalkerIndex >= 0)

  01d10	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01d13	0f bf 48 52	 movsx	 ecx, WORD PTR [eax+82]
  01d17	85 c9		 test	 ecx, ecx
  01d19	7c 10		 jl	 SHORT $LN6@DeleteMons

; 819  : 		gObjDel(this->m_DGData.IceWalkerIndex);

  01d1b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01d1e	0f bf 48 52	 movsx	 ecx, WORD PTR [eax+82]
  01d22	51		 push	 ecx
  01d23	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  01d28	83 c4 04	 add	 esp, 4
$LN6@DeleteMons:

; 820  : 
; 821  : 	this->m_DGData.SilverBoxIndex[0] = -1;

  01d2b	83 c8 ff	 or	 eax, -1
  01d2e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01d31	66 89 81 02 02
	00 00		 mov	 WORD PTR [ecx+514], ax

; 822  : 	this->m_DGData.SilverBoxIndex[1] = -1;

  01d38	83 c8 ff	 or	 eax, -1
  01d3b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01d3e	66 89 81 04 02
	00 00		 mov	 WORD PTR [ecx+516], ax

; 823  : 	this->m_DGData.SilverBoxIndex[2] = -1;

  01d45	83 c8 ff	 or	 eax, -1
  01d48	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01d4b	66 89 81 06 02
	00 00		 mov	 WORD PTR [ecx+518], ax

; 824  : 
; 825  : 	for(int i=0;i<OBJ_MAXMONSTER;++i)

  01d52	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$231682[ebp], 0
  01d59	eb 09		 jmp	 SHORT $LN5@DeleteMons
$LN4@DeleteMons:
  01d5b	8b 45 f4	 mov	 eax, DWORD PTR _i$231682[ebp]
  01d5e	83 c0 01	 add	 eax, 1
  01d61	89 45 f4	 mov	 DWORD PTR _i$231682[ebp], eax
$LN5@DeleteMons:
  01d64	81 7d f4 c8 32
	00 00		 cmp	 DWORD PTR _i$231682[ebp], 13000 ; 000032c8H
  01d6b	7d 4c		 jge	 SHORT $LN13@DeleteMons

; 826  : 	{
; 827  : 		if(gObj[i].Class == 541 || gObj[i].Class == 532)

  01d6d	8b 45 f4	 mov	 eax, DWORD PTR _i$231682[ebp]
  01d70	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01d76	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01d7c	0f b7 94 01 b8
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+184]
  01d84	81 fa 1d 02 00
	00		 cmp	 edx, 541		; 0000021dH
  01d8a	74 1f		 je	 SHORT $LN1@DeleteMons
  01d8c	8b 45 f4	 mov	 eax, DWORD PTR _i$231682[ebp]
  01d8f	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01d95	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01d9b	0f b7 94 01 b8
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+184]
  01da3	81 fa 14 02 00
	00		 cmp	 edx, 532		; 00000214H
  01da9	75 0c		 jne	 SHORT $LN2@DeleteMons
$LN1@DeleteMons:

; 828  : 			gObjDel(i);

  01dab	8b 45 f4	 mov	 eax, DWORD PTR _i$231682[ebp]
  01dae	50		 push	 eax
  01daf	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  01db4	83 c4 04	 add	 esp, 4
$LN2@DeleteMons:

; 829  : 	}

  01db7	eb a2		 jmp	 SHORT $LN4@DeleteMons
$LN13@DeleteMons:

; 830  : }

  01db9	5f		 pop	 edi
  01dba	5e		 pop	 esi
  01dbb	5b		 pop	 ebx
  01dbc	8b e5		 mov	 esp, ebp
  01dbe	5d		 pop	 ebp
  01dbf	c3		 ret	 0
?DeleteMonster@CDoppelGanger@@QAEXXZ ENDP		; CDoppelGanger::DeleteMonster
_TEXT	ENDS
PUBLIC	??_C@_0CN@JCFIIPPC@?$FLDoppelGanger?$FN?5Current?5Phaze?3?5Bu@ ; `string'
;	COMDAT ??_C@_0CN@JCFIIPPC@?$FLDoppelGanger?$FN?5Current?5Phaze?3?5Bu@
CONST	SEGMENT
??_C@_0CN@JCFIIPPC@?$FLDoppelGanger?$FN?5Current?5Phaze?3?5Bu@ DB '[Doppe'
	DB	'lGanger] Current Phaze: Butcher Attack', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CreateButcher@CDoppelGanger@@QAEXXZ PROC		; CDoppelGanger::CreateButcher
; _this$ = ecx

; 833  : {

  01dc0	55		 push	 ebp
  01dc1	8b ec		 mov	 ebp, esp
  01dc3	83 ec 44	 sub	 esp, 68			; 00000044H
  01dc6	53		 push	 ebx
  01dc7	56		 push	 esi
  01dc8	57		 push	 edi
  01dc9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 834  : 	if(this->m_DGData.ButcherIndex >= 0) gObjDel(this->m_DGData.ButcherIndex);

  01dcc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01dcf	0f bf 48 4e	 movsx	 ecx, WORD PTR [eax+78]
  01dd3	85 c9		 test	 ecx, ecx
  01dd5	7c 10		 jl	 SHORT $LN2@CreateButc
  01dd7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01dda	0f bf 48 4e	 movsx	 ecx, WORD PTR [eax+78]
  01dde	51		 push	 ecx
  01ddf	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  01de4	83 c4 04	 add	 esp, 4
$LN2@CreateButc:

; 835  : 	this->m_DGData.ButcherIndex = gObjAddMonster(this->m_DGData.MapNumber);

  01de7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01dea	8b 88 10 02 00
	00		 mov	 ecx, DWORD PTR [eax+528]
  01df0	51		 push	 ecx
  01df1	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  01df6	83 c4 04	 add	 esp, 4
  01df9	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01dfc	66 89 42 4e	 mov	 WORD PTR [edx+78], ax

; 836  : 	if(this->m_DGData.ButcherIndex >= 0)

  01e00	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01e03	0f bf 48 4e	 movsx	 ecx, WORD PTR [eax+78]
  01e07	85 c9		 test	 ecx, ecx
  01e09	0f 8c d8 00 00
	00		 jl	 $LN3@CreateButc

; 837  : 	{
; 838  : 		gObj[this->m_DGData.ButcherIndex].MapNumber = this->m_DGData.MapNumber;

  01e0f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01e12	0f bf 48 4e	 movsx	 ecx, WORD PTR [eax+78]
  01e16	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  01e1c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01e22	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01e25	8a 80 10 02 00
	00		 mov	 al, BYTE PTR [eax+528]
  01e2b	88 84 0a 49 01
	00 00		 mov	 BYTE PTR [edx+ecx+329], al

; 839  : 		gObj[this->m_DGData.ButcherIndex].X = this->MPOSX[this->m_DGData.MapNumber-65];

  01e32	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01e35	8b 88 10 02 00
	00		 mov	 ecx, DWORD PTR [eax+528]
  01e3b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01e3e	0f bf 42 4e	 movsx	 eax, WORD PTR [edx+78]
  01e42	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01e48	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01e4e	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  01e51	66 8b 8c 8e 20
	ff ff ff	 mov	 cx, WORD PTR [esi+ecx*4-224]
  01e59	66 89 8c 02 44
	01 00 00	 mov	 WORD PTR [edx+eax+324], cx

; 840  : 		gObj[this->m_DGData.ButcherIndex].Y = this->MPOSY[this->m_DGData.MapNumber-65];

  01e61	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01e64	8b 88 10 02 00
	00		 mov	 ecx, DWORD PTR [eax+528]
  01e6a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01e6d	0f bf 42 4e	 movsx	 eax, WORD PTR [edx+78]
  01e71	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01e77	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01e7d	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  01e80	66 8b 8c 8e 30
	ff ff ff	 mov	 cx, WORD PTR [esi+ecx*4-208]
  01e88	66 89 8c 02 46
	01 00 00	 mov	 WORD PTR [edx+eax+326], cx

; 841  : 		gObj[this->m_DGData.ButcherIndex].m_MoveRange = 30;

  01e90	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01e93	0f bf 48 4e	 movsx	 ecx, WORD PTR [eax+78]
  01e97	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  01e9d	ba 1e 00 00 00	 mov	 edx, 30			; 0000001eH
  01ea2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01ea7	66 89 94 08 ae
	04 00 00	 mov	 WORD PTR [eax+ecx+1198], dx

; 842  : 		++this->m_DGData.PhazesPassed;

  01eaf	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01eb2	8a 88 23 02 00
	00		 mov	 cl, BYTE PTR [eax+547]
  01eb8	80 c1 01	 add	 cl, 1
  01ebb	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01ebe	88 8a 23 02 00
	00		 mov	 BYTE PTR [edx+547], cl

; 843  : 		gObjSetMonster(this->m_DGData.ButcherIndex, 530);

  01ec4	68 12 02 00 00	 push	 530			; 00000212H
  01ec9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01ecc	0f bf 48 4e	 movsx	 ecx, WORD PTR [eax+78]
  01ed0	51		 push	 ecx
  01ed1	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster
  01ed6	83 c4 08	 add	 esp, 8

; 844  : 
; 845  : 		LogAddTD("[DoppelGanger] Current Phaze: Butcher Attack");

  01ed9	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@JCFIIPPC@?$FLDoppelGanger?$FN?5Current?5Phaze?3?5Bu@
  01ede	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01ee4	83 c4 04	 add	 esp, 4
$LN3@CreateButc:

; 846  : 	}
; 847  : }

  01ee7	5f		 pop	 edi
  01ee8	5e		 pop	 esi
  01ee9	5b		 pop	 ebx
  01eea	8b e5		 mov	 esp, ebp
  01eec	5d		 pop	 ebp
  01eed	c3		 ret	 0
?CreateButcher@CDoppelGanger@@QAEXXZ ENDP		; CDoppelGanger::CreateButcher
_TEXT	ENDS
PUBLIC	??_C@_0DD@NJFAEIED@?$FLDoppelGanger?$FN?5Current?5Phaze?3?5An@ ; `string'
;	COMDAT ??_C@_0DD@NJFAEIED@?$FLDoppelGanger?$FN?5Current?5Phaze?3?5An@
CONST	SEGMENT
??_C@_0DD@NJFAEIED@?$FLDoppelGanger?$FN?5Current?5Phaze?3?5An@ DB '[Doppe'
	DB	'lGanger] Current Phaze: Angry Butcher Attack', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CreateAngryButcher@CDoppelGanger@@QAEXXZ PROC		; CDoppelGanger::CreateAngryButcher
; _this$ = ecx

; 850  : {

  01ef0	55		 push	 ebp
  01ef1	8b ec		 mov	 ebp, esp
  01ef3	83 ec 44	 sub	 esp, 68			; 00000044H
  01ef6	53		 push	 ebx
  01ef7	56		 push	 esi
  01ef8	57		 push	 edi
  01ef9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 851  : 	if(this->m_DGData.AngryButcherIndex >= 0) gObjDel(this->m_DGData.AngryButcherIndex);

  01efc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01eff	0f bf 48 50	 movsx	 ecx, WORD PTR [eax+80]
  01f03	85 c9		 test	 ecx, ecx
  01f05	7c 10		 jl	 SHORT $LN2@CreateAngr
  01f07	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01f0a	0f bf 48 50	 movsx	 ecx, WORD PTR [eax+80]
  01f0e	51		 push	 ecx
  01f0f	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  01f14	83 c4 04	 add	 esp, 4
$LN2@CreateAngr:

; 852  : 	this->m_DGData.AngryButcherIndex = gObjAddMonster(this->m_DGData.MapNumber);

  01f17	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01f1a	8b 88 10 02 00
	00		 mov	 ecx, DWORD PTR [eax+528]
  01f20	51		 push	 ecx
  01f21	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  01f26	83 c4 04	 add	 esp, 4
  01f29	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01f2c	66 89 42 50	 mov	 WORD PTR [edx+80], ax

; 853  : 	if(this->m_DGData.AngryButcherIndex >= 0)

  01f30	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01f33	0f bf 48 50	 movsx	 ecx, WORD PTR [eax+80]
  01f37	85 c9		 test	 ecx, ecx
  01f39	0f 8c d8 00 00
	00		 jl	 $LN3@CreateAngr

; 854  : 	{
; 855  : 		gObj[this->m_DGData.AngryButcherIndex].MapNumber = this->m_DGData.MapNumber;

  01f3f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01f42	0f bf 48 50	 movsx	 ecx, WORD PTR [eax+80]
  01f46	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  01f4c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01f52	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01f55	8a 80 10 02 00
	00		 mov	 al, BYTE PTR [eax+528]
  01f5b	88 84 0a 49 01
	00 00		 mov	 BYTE PTR [edx+ecx+329], al

; 856  : 		gObj[this->m_DGData.AngryButcherIndex].X = this->MPOSX[this->m_DGData.MapNumber-65];

  01f62	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01f65	8b 88 10 02 00
	00		 mov	 ecx, DWORD PTR [eax+528]
  01f6b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01f6e	0f bf 42 50	 movsx	 eax, WORD PTR [edx+80]
  01f72	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01f78	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01f7e	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  01f81	66 8b 8c 8e 20
	ff ff ff	 mov	 cx, WORD PTR [esi+ecx*4-224]
  01f89	66 89 8c 02 44
	01 00 00	 mov	 WORD PTR [edx+eax+324], cx

; 857  : 		gObj[this->m_DGData.AngryButcherIndex].Y = this->MPOSY[this->m_DGData.MapNumber-65];

  01f91	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01f94	8b 88 10 02 00
	00		 mov	 ecx, DWORD PTR [eax+528]
  01f9a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01f9d	0f bf 42 50	 movsx	 eax, WORD PTR [edx+80]
  01fa1	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01fa7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01fad	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  01fb0	66 8b 8c 8e 30
	ff ff ff	 mov	 cx, WORD PTR [esi+ecx*4-208]
  01fb8	66 89 8c 02 46
	01 00 00	 mov	 WORD PTR [edx+eax+326], cx

; 858  : 		gObj[this->m_DGData.AngryButcherIndex].m_MoveRange = 30;

  01fc0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01fc3	0f bf 48 50	 movsx	 ecx, WORD PTR [eax+80]
  01fc7	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  01fcd	ba 1e 00 00 00	 mov	 edx, 30			; 0000001eH
  01fd2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01fd7	66 89 94 08 ae
	04 00 00	 mov	 WORD PTR [eax+ecx+1198], dx

; 859  : 		++this->m_DGData.PhazesPassed;

  01fdf	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01fe2	8a 88 23 02 00
	00		 mov	 cl, BYTE PTR [eax+547]
  01fe8	80 c1 01	 add	 cl, 1
  01feb	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01fee	88 8a 23 02 00
	00		 mov	 BYTE PTR [edx+547], cl

; 860  : 		gObjSetMonster(this->m_DGData.AngryButcherIndex, 529);

  01ff4	68 11 02 00 00	 push	 529			; 00000211H
  01ff9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01ffc	0f bf 48 50	 movsx	 ecx, WORD PTR [eax+80]
  02000	51		 push	 ecx
  02001	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster
  02006	83 c4 08	 add	 esp, 8

; 861  : 
; 862  : 		LogAddTD("[DoppelGanger] Current Phaze: Angry Butcher Attack");

  02009	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@NJFAEIED@?$FLDoppelGanger?$FN?5Current?5Phaze?3?5An@
  0200e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  02014	83 c4 04	 add	 esp, 4
$LN3@CreateAngr:

; 863  : 	}
; 864  : }

  02017	5f		 pop	 edi
  02018	5e		 pop	 esi
  02019	5b		 pop	 ebx
  0201a	8b e5		 mov	 esp, ebp
  0201c	5d		 pop	 ebp
  0201d	c3		 ret	 0
?CreateAngryButcher@CDoppelGanger@@QAEXXZ ENDP		; CDoppelGanger::CreateAngryButcher
_TEXT	ENDS
PUBLIC	??_C@_0BK@PNNNMAGF@ICE?5Walker?5has?5been?5Spawn?$AA@ ; `string'
PUBLIC	__$ArrayPad$
;	COMDAT ??_C@_0BK@PNNNMAGF@ICE?5Walker?5has?5been?5Spawn?$AA@
CONST	SEGMENT
??_C@_0BK@PNNNMAGF@ICE?5Walker?5has?5been?5Spawn?$AA@ DB 'ICE Walker has '
	DB	'been Spawn', 00H				; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_pNotice$231705 = -280					; size = 272
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?CreateIceWalker@CDoppelGanger@@QAEXXZ PROC		; CDoppelGanger::CreateIceWalker
; _this$ = ecx

; 867  : {

  02020	55		 push	 ebp
  02021	8b ec		 mov	 ebp, esp
  02023	81 ec 58 01 00
	00		 sub	 esp, 344		; 00000158H
  02029	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0202e	33 c5		 xor	 eax, ebp
  02030	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  02033	53		 push	 ebx
  02034	56		 push	 esi
  02035	57		 push	 edi
  02036	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 868  : 	if(this->m_DGData.IceWalkerIndex >= 0) gObjDel(this->m_DGData.IceWalkerIndex);

  02039	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0203c	0f bf 48 52	 movsx	 ecx, WORD PTR [eax+82]
  02040	85 c9		 test	 ecx, ecx
  02042	7c 10		 jl	 SHORT $LN2@CreateIceW
  02044	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  02047	0f bf 48 52	 movsx	 ecx, WORD PTR [eax+82]
  0204b	51		 push	 ecx
  0204c	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  02051	83 c4 04	 add	 esp, 4
$LN2@CreateIceW:

; 869  : 	this->m_DGData.IceWalkerIndex = gObjAddMonster(this->m_DGData.MapNumber);

  02054	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  02057	8b 88 10 02 00
	00		 mov	 ecx, DWORD PTR [eax+528]
  0205d	51		 push	 ecx
  0205e	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  02063	83 c4 04	 add	 esp, 4
  02066	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  02069	66 89 42 52	 mov	 WORD PTR [edx+82], ax

; 870  : 	if(this->m_DGData.IceWalkerIndex >= 0)

  0206d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  02070	0f bf 48 52	 movsx	 ecx, WORD PTR [eax+82]
  02074	85 c9		 test	 ecx, ecx
  02076	0f 8c 06 01 00
	00		 jl	 $LN3@CreateIceW

; 871  : 	{
; 872  : 		gObj[this->m_DGData.IceWalkerIndex].MapNumber = this->m_DGData.MapNumber;

  0207c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0207f	0f bf 48 52	 movsx	 ecx, WORD PTR [eax+82]
  02083	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  02089	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0208f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  02092	8a 80 10 02 00
	00		 mov	 al, BYTE PTR [eax+528]
  02098	88 84 0a 49 01
	00 00		 mov	 BYTE PTR [edx+ecx+329], al

; 873  : 		gObj[this->m_DGData.IceWalkerIndex].X = this->MPOSX[this->m_DGData.MapNumber-65];

  0209f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  020a2	8b 88 10 02 00
	00		 mov	 ecx, DWORD PTR [eax+528]
  020a8	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  020ab	0f bf 42 52	 movsx	 eax, WORD PTR [edx+82]
  020af	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  020b5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  020bb	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  020be	66 8b 8c 8e 20
	ff ff ff	 mov	 cx, WORD PTR [esi+ecx*4-224]
  020c6	66 89 8c 02 44
	01 00 00	 mov	 WORD PTR [edx+eax+324], cx

; 874  : 		gObj[this->m_DGData.IceWalkerIndex].Y = this->MPOSY[this->m_DGData.MapNumber-65];

  020ce	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  020d1	8b 88 10 02 00
	00		 mov	 ecx, DWORD PTR [eax+528]
  020d7	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  020da	0f bf 42 52	 movsx	 eax, WORD PTR [edx+82]
  020de	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  020e4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  020ea	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  020ed	66 8b 8c 8e 30
	ff ff ff	 mov	 cx, WORD PTR [esi+ecx*4-208]
  020f5	66 89 8c 02 46
	01 00 00	 mov	 WORD PTR [edx+eax+326], cx

; 875  : 		gObj[this->m_DGData.IceWalkerIndex].m_MoveRange = 30;

  020fd	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  02100	0f bf 48 52	 movsx	 ecx, WORD PTR [eax+82]
  02104	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0210a	ba 1e 00 00 00	 mov	 edx, 30			; 0000001eH
  0210f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02114	66 89 94 08 ae
	04 00 00	 mov	 WORD PTR [eax+ecx+1198], dx

; 876  : 		++this->m_DGData.PhazesPassed;

  0211c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0211f	8a 88 23 02 00
	00		 mov	 cl, BYTE PTR [eax+547]
  02125	80 c1 01	 add	 cl, 1
  02128	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0212b	88 8a 23 02 00
	00		 mov	 BYTE PTR [edx+547], cl

; 877  : 		this->m_DGData.IceWalkerPhazeTime = 90;

  02131	b8 5a 00 00 00	 mov	 eax, 90			; 0000005aH
  02136	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  02139	66 89 81 1e 02
	00 00		 mov	 WORD PTR [ecx+542], ax

; 878  : 		gObjSetMonster(this->m_DGData.IceWalkerIndex, 531);

  02140	68 13 02 00 00	 push	 531			; 00000213H
  02145	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  02148	0f bf 48 52	 movsx	 ecx, WORD PTR [eax+82]
  0214c	51		 push	 ecx
  0214d	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster
  02152	83 c4 08	 add	 esp, 8

; 879  : 
; 880  : 		PMSG_NOTICE pNotice;
; 881  : 		TNotice::MakeNoticeMsg(&pNotice, 0, "ICE Walker has been Spawn");

  02155	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@PNNNMAGF@ICE?5Walker?5has?5been?5Spawn?$AA@
  0215a	6a 00		 push	 0
  0215c	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$231705[ebp]
  02162	50		 push	 eax
  02163	e8 00 00 00 00	 call	 ?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z ; TNotice::MakeNoticeMsg
  02168	83 c4 0c	 add	 esp, 12			; 0000000cH

; 882  : 		this->SendDoppelGangerPlayer((LPBYTE)&pNotice, pNotice.h.size);

  0216b	0f b6 85 e9 fe
	ff ff		 movzx	 eax, BYTE PTR _pNotice$231705[ebp+1]
  02172	50		 push	 eax
  02173	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$231705[ebp]
  02179	51		 push	 ecx
  0217a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0217d	e8 00 00 00 00	 call	 ?SendDoppelGangerPlayer@CDoppelGanger@@QAEXPAEH@Z ; CDoppelGanger::SendDoppelGangerPlayer
$LN3@CreateIceW:

; 883  : 	}
; 884  : }

  02182	5f		 pop	 edi
  02183	5e		 pop	 esi
  02184	5b		 pop	 ebx
  02185	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  02188	33 cd		 xor	 ecx, ebp
  0218a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0218f	8b e5		 mov	 esp, ebp
  02191	5d		 pop	 ebp
  02192	c3		 ret	 0
?CreateIceWalker@CDoppelGanger@@QAEXXZ ENDP		; CDoppelGanger::CreateIceWalker
_TEXT	ENDS
PUBLIC	?CreateSilverChest@CDoppelGanger@@QAE_NPAUOBJECTSTRUCT@@@Z ; CDoppelGanger::CreateSilverChest
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_i$231713 = -8						; size = 4
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?CreateSilverChest@CDoppelGanger@@QAE_NPAUOBJECTSTRUCT@@@Z PROC ; CDoppelGanger::CreateSilverChest
; _this$ = ecx

; 887  : {

  021a0	55		 push	 ebp
  021a1	8b ec		 mov	 ebp, esp
  021a3	83 ec 48	 sub	 esp, 72			; 00000048H
  021a6	53		 push	 ebx
  021a7	56		 push	 esi
  021a8	57		 push	 edi
  021a9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 888  : 	if(this->IsDGMonster(lpObj))

  021ac	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  021af	50		 push	 eax
  021b0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  021b3	e8 00 00 00 00	 call	 ?IsDGMonster@CDoppelGanger@@QAE_NPAUOBJECTSTRUCT@@@Z ; CDoppelGanger::IsDGMonster
  021b8	0f b6 c8	 movzx	 ecx, al
  021bb	85 c9		 test	 ecx, ecx
  021bd	0f 84 f4 00 00
	00		 je	 $LN4@CreateSilv

; 889  : 	{
; 890  : 		for(int i=0;i<3;++i)

  021c3	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$231713[ebp], 0
  021ca	eb 09		 jmp	 SHORT $LN3@CreateSilv
$LN2@CreateSilv:
  021cc	8b 45 f8	 mov	 eax, DWORD PTR _i$231713[ebp]
  021cf	83 c0 01	 add	 eax, 1
  021d2	89 45 f8	 mov	 DWORD PTR _i$231713[ebp], eax
$LN3@CreateSilv:
  021d5	83 7d f8 03	 cmp	 DWORD PTR _i$231713[ebp], 3
  021d9	0f 8d d4 00 00
	00		 jge	 $LN1@CreateSilv

; 891  : 		{
; 892  : 			this->m_DGData.SilverBoxIndex[i] = gObjAddMonster(this->m_DGData.MapNumber);

  021df	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  021e2	8b 88 10 02 00
	00		 mov	 ecx, DWORD PTR [eax+528]
  021e8	51		 push	 ecx
  021e9	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  021ee	83 c4 04	 add	 esp, 4
  021f1	8b 55 f8	 mov	 edx, DWORD PTR _i$231713[ebp]
  021f4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  021f7	66 89 84 51 02
	02 00 00	 mov	 WORD PTR [ecx+edx*2+514], ax

; 893  : 			gObj[this->m_DGData.SilverBoxIndex[i]].MapNumber = lpObj->MapNumber;

  021ff	8b 45 f8	 mov	 eax, DWORD PTR _i$231713[ebp]
  02202	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02205	0f bf 94 41 02
	02 00 00	 movsx	 edx, WORD PTR [ecx+eax*2+514]
  0220d	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  02213	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02218	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0221b	8a 89 49 01 00
	00		 mov	 cl, BYTE PTR [ecx+329]
  02221	88 8c 10 49 01
	00 00		 mov	 BYTE PTR [eax+edx+329], cl

; 894  : 			gObj[this->m_DGData.SilverBoxIndex[i]].X = lpObj->X;

  02228	8b 45 f8	 mov	 eax, DWORD PTR _i$231713[ebp]
  0222b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0222e	0f bf 94 41 02
	02 00 00	 movsx	 edx, WORD PTR [ecx+eax*2+514]
  02236	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  0223c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02241	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  02244	66 8b 89 44 01
	00 00		 mov	 cx, WORD PTR [ecx+324]
  0224b	66 89 8c 10 44
	01 00 00	 mov	 WORD PTR [eax+edx+324], cx

; 895  : 			gObj[this->m_DGData.SilverBoxIndex[i]].Y = lpObj->Y+rand()%2;

  02253	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  02256	0f bf b0 46 01
	00 00		 movsx	 esi, WORD PTR [eax+326]
  0225d	e8 00 00 00 00	 call	 _rand
  02262	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  02267	79 05		 jns	 SHORT $LN7@CreateSilv
  02269	48		 dec	 eax
  0226a	83 c8 fe	 or	 eax, -2			; fffffffeH
  0226d	40		 inc	 eax
$LN7@CreateSilv:
  0226e	03 f0		 add	 esi, eax
  02270	8b 4d f8	 mov	 ecx, DWORD PTR _i$231713[ebp]
  02273	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  02276	0f bf 84 4a 02
	02 00 00	 movsx	 eax, WORD PTR [edx+ecx*2+514]
  0227e	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  02284	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0228a	66 89 b4 01 46
	01 00 00	 mov	 WORD PTR [ecx+eax+326], si

; 896  : 			gObjSetMonster(this->m_DGData.SilverBoxIndex[i], 541);

  02292	68 1d 02 00 00	 push	 541			; 0000021dH
  02297	8b 45 f8	 mov	 eax, DWORD PTR _i$231713[ebp]
  0229a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0229d	0f bf 94 41 02
	02 00 00	 movsx	 edx, WORD PTR [ecx+eax*2+514]
  022a5	52		 push	 edx
  022a6	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster
  022ab	83 c4 08	 add	 esp, 8

; 897  : 		}

  022ae	e9 19 ff ff ff	 jmp	 $LN2@CreateSilv
$LN1@CreateSilv:

; 898  : 		return true;

  022b3	b0 01		 mov	 al, 1
  022b5	eb 02		 jmp	 SHORT $LN5@CreateSilv
$LN4@CreateSilv:

; 899  : 	}
; 900  : 	return false;

  022b7	32 c0		 xor	 al, al
$LN5@CreateSilv:

; 901  : }

  022b9	5f		 pop	 edi
  022ba	5e		 pop	 esi
  022bb	5b		 pop	 ebx
  022bc	8b e5		 mov	 esp, ebp
  022be	5d		 pop	 ebp
  022bf	c2 04 00	 ret	 4
?CreateSilverChest@CDoppelGanger@@QAE_NPAUOBJECTSTRUCT@@@Z ENDP ; CDoppelGanger::CreateSilverChest
_TEXT	ENDS
PUBLIC	?DeadUserProc@CDoppelGanger@@QAEXPAUOBJECTSTRUCT@@@Z ; CDoppelGanger::DeadUserProc
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_i$231722 = -12						; size = 4
_index$ = -5						; size = 1
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?DeadUserProc@CDoppelGanger@@QAEXPAUOBJECTSTRUCT@@@Z PROC ; CDoppelGanger::DeadUserProc
; _this$ = ecx

; 904  : {

  022d0	55		 push	 ebp
  022d1	8b ec		 mov	 ebp, esp
  022d3	83 ec 4c	 sub	 esp, 76			; 0000004cH
  022d6	53		 push	 ebx
  022d7	56		 push	 esi
  022d8	57		 push	 edi
  022d9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 905  : 	unsigned char index = -1;

  022dc	c6 45 fb ff	 mov	 BYTE PTR _index$[ebp], 255 ; 000000ffH

; 906  : 
; 907  : 	for(int i=0;i<5;++i)

  022e0	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$231722[ebp], 0
  022e7	eb 09		 jmp	 SHORT $LN5@DeadUserPr
$LN4@DeadUserPr:
  022e9	8b 45 f4	 mov	 eax, DWORD PTR _i$231722[ebp]
  022ec	83 c0 01	 add	 eax, 1
  022ef	89 45 f4	 mov	 DWORD PTR _i$231722[ebp], eax
$LN5@DeadUserPr:
  022f2	83 7d f4 05	 cmp	 DWORD PTR _i$231722[ebp], 5
  022f6	7d 1b		 jge	 SHORT $LN3@DeadUserPr

; 908  : 	{
; 909  : 		if(this->m_DGData.PlayerIndex[i] == lpObj->m_Index)

  022f8	8b 45 f4	 mov	 eax, DWORD PTR _i$231722[ebp]
  022fb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  022fe	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  02301	8b 44 81 54	 mov	 eax, DWORD PTR [ecx+eax*4+84]
  02305	3b 02		 cmp	 eax, DWORD PTR [edx]
  02307	75 08		 jne	 SHORT $LN2@DeadUserPr

; 910  : 		{
; 911  : 			index = i;

  02309	8a 45 f4	 mov	 al, BYTE PTR _i$231722[ebp]
  0230c	88 45 fb	 mov	 BYTE PTR _index$[ebp], al

; 912  : 			break;

  0230f	eb 02		 jmp	 SHORT $LN3@DeadUserPr
$LN2@DeadUserPr:

; 913  : 		}
; 914  : 	}

  02311	eb d6		 jmp	 SHORT $LN4@DeadUserPr
$LN3@DeadUserPr:

; 915  : 	if(index == -1)

  02313	0f b6 45 fb	 movzx	 eax, BYTE PTR _index$[ebp]
  02317	83 f8 ff	 cmp	 eax, -1
  0231a	75 02		 jne	 SHORT $LN1@DeadUserPr

; 916  : 	{
; 917  : 		return;

  0231c	eb 30		 jmp	 SHORT $LN6@DeadUserPr
$LN1@DeadUserPr:

; 918  : 	}
; 919  : 
; 920  : 	this->m_DGData.PlayerIndex[index] = -1;

  0231e	0f b6 45 fb	 movzx	 eax, BYTE PTR _index$[ebp]
  02322	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02325	c7 44 81 54 ff
	ff ff ff	 mov	 DWORD PTR [ecx+eax*4+84], -1

; 921  : 	--this->m_DGData.PlayerCount;

  0232d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02330	8a 48 44	 mov	 cl, BYTE PTR [eax+68]
  02333	80 e9 01	 sub	 cl, 1
  02336	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  02339	88 4a 44	 mov	 BYTE PTR [edx+68], cl

; 922  : 
; 923  : 	this->SendResultMessage(DG_RESULT_DEAD_PLAYER, false, lpObj->m_Index);

  0233c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0233f	8b 08		 mov	 ecx, DWORD PTR [eax]
  02341	51		 push	 ecx
  02342	6a 00		 push	 0
  02344	6a 01		 push	 1
  02346	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02349	e8 00 00 00 00	 call	 ?SendResultMessage@CDoppelGanger@@QAEXE_NH@Z ; CDoppelGanger::SendResultMessage
$LN6@DeadUserPr:

; 924  : }

  0234e	5f		 pop	 edi
  0234f	5e		 pop	 esi
  02350	5b		 pop	 ebx
  02351	8b e5		 mov	 esp, ebp
  02353	5d		 pop	 ebp
  02354	c2 04 00	 ret	 4
?DeadUserProc@CDoppelGanger@@QAEXPAUOBJECTSTRUCT@@@Z ENDP ; CDoppelGanger::DeadUserProc
_TEXT	ENDS
PUBLIC	??_C@_0DH@CGFAOOPN@?$FLDoppelGanger?$FN?5Spawn?5Golden?5Larv@ ; `string'
PUBLIC	?CreateGoldenLarva@CDoppelGanger@@QAEXPAUOBJECTSTRUCT@@@Z ; CDoppelGanger::CreateGoldenLarva
;	COMDAT ??_C@_0DH@CGFAOOPN@?$FLDoppelGanger?$FN?5Spawn?5Golden?5Larv@
CONST	SEGMENT
??_C@_0DH@CGFAOOPN@?$FLDoppelGanger?$FN?5Spawn?5Golden?5Larv@ DB '[Doppel'
	DB	'Ganger] Spawn Golden Larva Trap (%d) (%d/%d/%d)', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_i$231733 = -12						; size = 4
_index$ = -8						; size = 4
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?CreateGoldenLarva@CDoppelGanger@@QAEXPAUOBJECTSTRUCT@@@Z PROC ; CDoppelGanger::CreateGoldenLarva
; _this$ = ecx

; 927  : {

  02360	55		 push	 ebp
  02361	8b ec		 mov	 ebp, esp
  02363	83 ec 4c	 sub	 esp, 76			; 0000004cH
  02366	53		 push	 ebx
  02367	56		 push	 esi
  02368	57		 push	 edi
  02369	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 928  : 	int index;
; 929  : 	for(int i=0;i<2;++i)

  0236c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$231733[ebp], 0
  02373	eb 09		 jmp	 SHORT $LN4@CreateGold
$LN3@CreateGold:
  02375	8b 45 f4	 mov	 eax, DWORD PTR _i$231733[ebp]
  02378	83 c0 01	 add	 eax, 1
  0237b	89 45 f4	 mov	 DWORD PTR _i$231733[ebp], eax
$LN4@CreateGold:
  0237e	83 7d f4 02	 cmp	 DWORD PTR _i$231733[ebp], 2
  02382	0f 8d f4 00 00
	00		 jge	 $LN5@CreateGold

; 930  : 	{
; 931  : 		index = gObjAddMonster(lpObj->MapNumber);

  02388	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0238b	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  02392	51		 push	 ecx
  02393	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  02398	83 c4 04	 add	 esp, 4
  0239b	0f bf d0	 movsx	 edx, ax
  0239e	89 55 f8	 mov	 DWORD PTR _index$[ebp], edx

; 932  : 		if(index >= 0)

  023a1	83 7d f8 00	 cmp	 DWORD PTR _index$[ebp], 0
  023a5	0f 8c cc 00 00
	00		 jl	 $LN1@CreateGold

; 933  : 		{
; 934  : 			gObj[index].MapNumber = lpObj->MapNumber;

  023ab	8b 45 f8	 mov	 eax, DWORD PTR _index$[ebp]
  023ae	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  023b4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  023ba	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  023bd	8a 92 49 01 00
	00		 mov	 dl, BYTE PTR [edx+329]
  023c3	88 94 01 49 01
	00 00		 mov	 BYTE PTR [ecx+eax+329], dl

; 935  : 			gObj[index].X = lpObj->X;

  023ca	8b 45 f8	 mov	 eax, DWORD PTR _index$[ebp]
  023cd	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  023d3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  023d9	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  023dc	66 8b 92 44 01
	00 00		 mov	 dx, WORD PTR [edx+324]
  023e3	66 89 94 01 44
	01 00 00	 mov	 WORD PTR [ecx+eax+324], dx

; 936  : 			gObj[index].Y = lpObj->Y;

  023eb	8b 45 f8	 mov	 eax, DWORD PTR _index$[ebp]
  023ee	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  023f4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  023fa	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  023fd	66 8b 92 46 01
	00 00		 mov	 dx, WORD PTR [edx+326]
  02404	66 89 94 01 46
	01 00 00	 mov	 WORD PTR [ecx+eax+326], dx

; 937  : 			gObjSetMonster(index, 532);

  0240c	68 14 02 00 00	 push	 532			; 00000214H
  02411	8b 45 f8	 mov	 eax, DWORD PTR _index$[ebp]
  02414	50		 push	 eax
  02415	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster
  0241a	83 c4 08	 add	 esp, 8

; 938  : 			LogAddTD("[DoppelGanger] Spawn Golden Larva Trap (%d) (%d/%d/%d)", index, gObj[index].MapNumber, gObj[index].X, gObj[index].Y);

  0241d	8b 45 f8	 mov	 eax, DWORD PTR _index$[ebp]
  02420	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  02426	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0242c	0f bf 94 01 46
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+326]
  02434	52		 push	 edx
  02435	8b 45 f8	 mov	 eax, DWORD PTR _index$[ebp]
  02438	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0243e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02444	0f bf 94 01 44
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+324]
  0244c	52		 push	 edx
  0244d	8b 45 f8	 mov	 eax, DWORD PTR _index$[ebp]
  02450	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  02456	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0245c	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  02464	52		 push	 edx
  02465	8b 45 f8	 mov	 eax, DWORD PTR _index$[ebp]
  02468	50		 push	 eax
  02469	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@CGFAOOPN@?$FLDoppelGanger?$FN?5Spawn?5Golden?5Larv@
  0246e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  02474	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@CreateGold:

; 939  : 		}
; 940  : 	}

  02477	e9 f9 fe ff ff	 jmp	 $LN3@CreateGold
$LN5@CreateGold:

; 941  : }

  0247c	5f		 pop	 edi
  0247d	5e		 pop	 esi
  0247e	5b		 pop	 ebx
  0247f	8b e5		 mov	 esp, ebp
  02481	5d		 pop	 ebp
  02482	c2 04 00	 ret	 4
?CreateGoldenLarva@CDoppelGanger@@QAEXPAUOBJECTSTRUCT@@@Z ENDP ; CDoppelGanger::CreateGoldenLarva
_TEXT	ENDS
PUBLIC	__real@00000000
PUBLIC	?SilverChestOpen@CDoppelGanger@@QAEXPAUOBJECTSTRUCT@@@Z ; CDoppelGanger::SilverChestOpen
EXTRN	?gObjLifeCheck@@YAXPAUOBJECTSTRUCT@@0HHHHGH@Z:PROC ; gObjLifeCheck
EXTRN	?DropSilverChestItem@CItemBagEx@@QAEHHEEE@Z:PROC ; CItemBagEx::DropSilverChestItem
EXTRN	?SilverChestItemBag@@3PAVCItemBagEx@@A:DWORD	; SilverChestItemBag
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_i$231745 = -8						; size = 4
_this$ = -4						; size = 4
_lpChest$ = 8						; size = 4
?SilverChestOpen@CDoppelGanger@@QAEXPAUOBJECTSTRUCT@@@Z PROC ; CDoppelGanger::SilverChestOpen
; _this$ = ecx

; 944  : {

  02490	55		 push	 ebp
  02491	8b ec		 mov	 ebp, esp
  02493	83 ec 48	 sub	 esp, 72			; 00000048H
  02496	53		 push	 ebx
  02497	56		 push	 esi
  02498	57		 push	 edi
  02499	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 945  : 	if(rand()%10000 < DGSilverChestOpenRate)

  0249c	e8 00 00 00 00	 call	 _rand
  024a1	99		 cdq
  024a2	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  024a7	f7 f9		 idiv	 ecx
  024a9	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?DGSilverChestOpenRate@@3HA ; DGSilverChestOpenRate
  024af	7d 34		 jge	 SHORT $LN6@SilverChes

; 946  : 	{
; 947  : 		SilverChestItemBag->DropSilverChestItem(lpChest->m_Index, lpChest->MapNumber, lpChest->X, lpChest->Y);

  024b1	8b 45 08	 mov	 eax, DWORD PTR _lpChest$[ebp]
  024b4	0f b6 88 46 01
	00 00		 movzx	 ecx, BYTE PTR [eax+326]
  024bb	51		 push	 ecx
  024bc	8b 55 08	 mov	 edx, DWORD PTR _lpChest$[ebp]
  024bf	0f b6 82 44 01
	00 00		 movzx	 eax, BYTE PTR [edx+324]
  024c6	50		 push	 eax
  024c7	8b 4d 08	 mov	 ecx, DWORD PTR _lpChest$[ebp]
  024ca	0f b6 91 49 01
	00 00		 movzx	 edx, BYTE PTR [ecx+329]
  024d1	52		 push	 edx
  024d2	8b 45 08	 mov	 eax, DWORD PTR _lpChest$[ebp]
  024d5	8b 08		 mov	 ecx, DWORD PTR [eax]
  024d7	51		 push	 ecx
  024d8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?SilverChestItemBag@@3PAVCItemBagEx@@A ; SilverChestItemBag
  024de	e8 00 00 00 00	 call	 ?DropSilverChestItem@CItemBagEx@@QAEHHEEE@Z ; CItemBagEx::DropSilverChestItem

; 948  : 	}
; 949  : 	else

  024e3	eb 0c		 jmp	 SHORT $LN5@SilverChes
$LN6@SilverChes:

; 950  : 	{
; 951  : 		this->CreateGoldenLarva(lpChest);

  024e5	8b 45 08	 mov	 eax, DWORD PTR _lpChest$[ebp]
  024e8	50		 push	 eax
  024e9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  024ec	e8 00 00 00 00	 call	 ?CreateGoldenLarva@CDoppelGanger@@QAEXPAUOBJECTSTRUCT@@@Z ; CDoppelGanger::CreateGoldenLarva
$LN5@SilverChes:

; 952  : 	}
; 953  : 	lpChest->Life = 0.0;

  024f1	8b 45 08	 mov	 eax, DWORD PTR _lpChest$[ebp]
  024f4	d9 ee		 fldz
  024f6	d9 98 fc 00 00
	00		 fstp	 DWORD PTR [eax+252]

; 954  : 	gObjLifeCheck(lpChest, lpChest, 1, 0, 0, 0, 0, 0);

  024fc	6a 00		 push	 0
  024fe	6a 00		 push	 0
  02500	6a 00		 push	 0
  02502	6a 00		 push	 0
  02504	6a 00		 push	 0
  02506	6a 01		 push	 1
  02508	8b 45 08	 mov	 eax, DWORD PTR _lpChest$[ebp]
  0250b	50		 push	 eax
  0250c	8b 4d 08	 mov	 ecx, DWORD PTR _lpChest$[ebp]
  0250f	51		 push	 ecx
  02510	e8 00 00 00 00	 call	 ?gObjLifeCheck@@YAXPAUOBJECTSTRUCT@@0HHHHGH@Z ; gObjLifeCheck
  02515	83 c4 20	 add	 esp, 32			; 00000020H

; 955  : 	for(int i=0;i<3;++i)

  02518	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$231745[ebp], 0
  0251f	eb 09		 jmp	 SHORT $LN4@SilverChes
$LN3@SilverChes:
  02521	8b 45 f8	 mov	 eax, DWORD PTR _i$231745[ebp]
  02524	83 c0 01	 add	 eax, 1
  02527	89 45 f8	 mov	 DWORD PTR _i$231745[ebp], eax
$LN4@SilverChes:
  0252a	83 7d f8 03	 cmp	 DWORD PTR _i$231745[ebp], 3
  0252e	7d 2e		 jge	 SHORT $LN2@SilverChes

; 956  : 	{
; 957  : 		if(this->m_DGData.SilverBoxIndex[i] != lpChest->m_Index)

  02530	8b 45 f8	 mov	 eax, DWORD PTR _i$231745[ebp]
  02533	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02536	0f bf 94 41 02
	02 00 00	 movsx	 edx, WORD PTR [ecx+eax*2+514]
  0253e	8b 45 08	 mov	 eax, DWORD PTR _lpChest$[ebp]
  02541	3b 10		 cmp	 edx, DWORD PTR [eax]
  02543	74 17		 je	 SHORT $LN1@SilverChes

; 958  : 		{
; 959  : 			gObjDel(this->m_DGData.SilverBoxIndex[i]);

  02545	8b 45 f8	 mov	 eax, DWORD PTR _i$231745[ebp]
  02548	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0254b	0f bf 94 41 02
	02 00 00	 movsx	 edx, WORD PTR [ecx+eax*2+514]
  02553	52		 push	 edx
  02554	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  02559	83 c4 04	 add	 esp, 4
$LN1@SilverChes:

; 960  : 		}
; 961  : 	}

  0255c	eb c3		 jmp	 SHORT $LN3@SilverChes
$LN2@SilverChes:

; 962  : }

  0255e	5f		 pop	 edi
  0255f	5e		 pop	 esi
  02560	5b		 pop	 ebx
  02561	8b e5		 mov	 esp, ebp
  02563	5d		 pop	 ebp
  02564	c2 04 00	 ret	 4
?SilverChestOpen@CDoppelGanger@@QAEXPAUOBJECTSTRUCT@@@Z ENDP ; CDoppelGanger::SilverChestOpen
; Function compile flags: /Odtp /ZI
_i$231754 = -12					; size = 4
_index$ = -8						; size = 4
_this$ = -4						; size = 4
?CreateFinalChest@CDoppelGanger@@QAEXXZ PROC		; CDoppelGanger::CreateFinalChest
; _this$ = ecx

; 965  : {

  02570	55		 push	 ebp
  02571	8b ec		 mov	 ebp, esp
  02573	83 ec 4c	 sub	 esp, 76			; 0000004cH
  02576	53		 push	 ebx
  02577	56		 push	 esi
  02578	57		 push	 edi
  02579	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 966  : 	int index = -1;

  0257c	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _index$[ebp], -1

; 967  : 	for(int i=0;i<5;++i)

  02583	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$231754[ebp], 0
  0258a	eb 09		 jmp	 SHORT $LN5@CreateFina
$LN4@CreateFina:
  0258c	8b 45 f4	 mov	 eax, DWORD PTR _i$231754[ebp]
  0258f	83 c0 01	 add	 eax, 1
  02592	89 45 f4	 mov	 DWORD PTR _i$231754[ebp], eax
$LN5@CreateFina:
  02595	83 7d f4 05	 cmp	 DWORD PTR _i$231754[ebp], 5
  02599	0f 8d d2 00 00
	00		 jge	 $LN6@CreateFina

; 968  : 	{
; 969  : 		if(this->m_DGData.PlayerIndex[i] != -1)

  0259f	8b 45 f4	 mov	 eax, DWORD PTR _i$231754[ebp]
  025a2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  025a5	83 7c 81 54 ff	 cmp	 DWORD PTR [ecx+eax*4+84], -1
  025aa	0f 84 bc 00 00
	00		 je	 $LN2@CreateFina

; 970  : 		{
; 971  : 			index = gObjAddMonster(this->m_DGData.MapNumber);

  025b0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  025b3	8b 88 10 02 00
	00		 mov	 ecx, DWORD PTR [eax+528]
  025b9	51		 push	 ecx
  025ba	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  025bf	83 c4 04	 add	 esp, 4
  025c2	0f bf d0	 movsx	 edx, ax
  025c5	89 55 f8	 mov	 DWORD PTR _index$[ebp], edx

; 972  : 			if(index >= 0)

  025c8	83 7d f8 00	 cmp	 DWORD PTR _index$[ebp], 0
  025cc	0f 8c 9a 00 00
	00		 jl	 $LN2@CreateFina

; 973  : 			{
; 974  : 				gObj[index].MapNumber = this->m_DGData.MapNumber;

  025d2	8b 45 f8	 mov	 eax, DWORD PTR _index$[ebp]
  025d5	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  025db	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  025e1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  025e4	8a 92 10 02 00
	00		 mov	 dl, BYTE PTR [edx+528]
  025ea	88 94 01 49 01
	00 00		 mov	 BYTE PTR [ecx+eax+329], dl

; 975  : 				gObj[index].X = gObj[this->m_DGData.PlayerIndex[i]].X;

  025f1	8b 45 f4	 mov	 eax, DWORD PTR _i$231754[ebp]
  025f4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  025f7	8b 54 81 54	 mov	 edx, DWORD PTR [ecx+eax*4+84]
  025fb	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  02601	8b 45 f8	 mov	 eax, DWORD PTR _index$[ebp]
  02604	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0260a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02610	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02616	66 8b 94 16 44
	01 00 00	 mov	 dx, WORD PTR [esi+edx+324]
  0261e	66 89 94 01 44
	01 00 00	 mov	 WORD PTR [ecx+eax+324], dx

; 976  : 				gObj[index].Y = gObj[this->m_DGData.PlayerIndex[i]].Y;

  02626	8b 45 f4	 mov	 eax, DWORD PTR _i$231754[ebp]
  02629	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0262c	8b 54 81 54	 mov	 edx, DWORD PTR [ecx+eax*4+84]
  02630	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  02636	8b 45 f8	 mov	 eax, DWORD PTR _index$[ebp]
  02639	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0263f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02645	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0264b	66 8b 94 16 46
	01 00 00	 mov	 dx, WORD PTR [esi+edx+326]
  02653	66 89 94 01 46
	01 00 00	 mov	 WORD PTR [ecx+eax+326], dx

; 977  : 				gObjSetMonster(index, 542);

  0265b	68 1e 02 00 00	 push	 542			; 0000021eH
  02660	8b 45 f8	 mov	 eax, DWORD PTR _index$[ebp]
  02663	50		 push	 eax
  02664	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster
  02669	83 c4 08	 add	 esp, 8
$LN2@CreateFina:

; 978  : 			}
; 979  : 		}
; 980  : 	}

  0266c	e9 1b ff ff ff	 jmp	 $LN4@CreateFina
$LN6@CreateFina:

; 981  : }

  02671	5f		 pop	 edi
  02672	5e		 pop	 esi
  02673	5b		 pop	 ebx
  02674	8b e5		 mov	 esp, ebp
  02676	5d		 pop	 ebp
  02677	c3		 ret	 0
?CreateFinalChest@CDoppelGanger@@QAEXXZ ENDP		; CDoppelGanger::CreateFinalChest
_TEXT	ENDS
PUBLIC	?FinalChestOpen@CDoppelGanger@@QAEXPAUOBJECTSTRUCT@@@Z ; CDoppelGanger::FinalChestOpen
EXTRN	?DropGoldenChestItem@CItemBagEx@@QAEHHEEE@Z:PROC ; CItemBagEx::DropGoldenChestItem
EXTRN	?GoldenChestItemBag@@3PAVCItemBagEx@@A:DWORD	; GoldenChestItemBag
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpChest$ = 8						; size = 4
?FinalChestOpen@CDoppelGanger@@QAEXPAUOBJECTSTRUCT@@@Z PROC ; CDoppelGanger::FinalChestOpen
; _this$ = ecx

; 984  : {

  02680	55		 push	 ebp
  02681	8b ec		 mov	 ebp, esp
  02683	83 ec 44	 sub	 esp, 68			; 00000044H
  02686	53		 push	 ebx
  02687	56		 push	 esi
  02688	57		 push	 edi
  02689	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 985  : 	GoldenChestItemBag->DropGoldenChestItem(lpChest->m_Index, lpChest->MapNumber, lpChest->X, lpChest->Y);

  0268c	8b 45 08	 mov	 eax, DWORD PTR _lpChest$[ebp]
  0268f	0f b6 88 46 01
	00 00		 movzx	 ecx, BYTE PTR [eax+326]
  02696	51		 push	 ecx
  02697	8b 55 08	 mov	 edx, DWORD PTR _lpChest$[ebp]
  0269a	0f b6 82 44 01
	00 00		 movzx	 eax, BYTE PTR [edx+324]
  026a1	50		 push	 eax
  026a2	8b 4d 08	 mov	 ecx, DWORD PTR _lpChest$[ebp]
  026a5	0f b6 91 49 01
	00 00		 movzx	 edx, BYTE PTR [ecx+329]
  026ac	52		 push	 edx
  026ad	8b 45 08	 mov	 eax, DWORD PTR _lpChest$[ebp]
  026b0	8b 08		 mov	 ecx, DWORD PTR [eax]
  026b2	51		 push	 ecx
  026b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?GoldenChestItemBag@@3PAVCItemBagEx@@A ; GoldenChestItemBag
  026b9	e8 00 00 00 00	 call	 ?DropGoldenChestItem@CItemBagEx@@QAEHHEEE@Z ; CItemBagEx::DropGoldenChestItem

; 986  : 	lpChest->Life = 0.0;

  026be	8b 45 08	 mov	 eax, DWORD PTR _lpChest$[ebp]
  026c1	d9 ee		 fldz
  026c3	d9 98 fc 00 00
	00		 fstp	 DWORD PTR [eax+252]

; 987  : 	gObjLifeCheck(lpChest, lpChest, 1, 0, 0, 0, 0, 0);

  026c9	6a 00		 push	 0
  026cb	6a 00		 push	 0
  026cd	6a 00		 push	 0
  026cf	6a 00		 push	 0
  026d1	6a 00		 push	 0
  026d3	6a 01		 push	 1
  026d5	8b 45 08	 mov	 eax, DWORD PTR _lpChest$[ebp]
  026d8	50		 push	 eax
  026d9	8b 4d 08	 mov	 ecx, DWORD PTR _lpChest$[ebp]
  026dc	51		 push	 ecx
  026dd	e8 00 00 00 00	 call	 ?gObjLifeCheck@@YAXPAUOBJECTSTRUCT@@0HHHHGH@Z ; gObjLifeCheck
  026e2	83 c4 20	 add	 esp, 32			; 00000020H

; 988  : }

  026e5	5f		 pop	 edi
  026e6	5e		 pop	 esi
  026e7	5b		 pop	 ebx
  026e8	8b e5		 mov	 esp, ebp
  026ea	5d		 pop	 ebp
  026eb	c2 04 00	 ret	 4
?FinalChestOpen@CDoppelGanger@@QAEXPAUOBJECTSTRUCT@@@Z ENDP ; CDoppelGanger::FinalChestOpen
; Function compile flags: /Odtp /ZI
_i$231767 = -8						; size = 4
_this$ = -4						; size = 4
?CheckUsers@CDoppelGanger@@QAEXXZ PROC			; CDoppelGanger::CheckUsers
; _this$ = ecx

; 991  : {

  026f0	55		 push	 ebp
  026f1	8b ec		 mov	 ebp, esp
  026f3	83 ec 48	 sub	 esp, 72			; 00000048H
  026f6	53		 push	 ebx
  026f7	56		 push	 esi
  026f8	57		 push	 edi
  026f9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 992  : 	for(int i=0;i<5;++i)

  026fc	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$231767[ebp], 0
  02703	eb 09		 jmp	 SHORT $LN6@CheckUsers
$LN5@CheckUsers:
  02705	8b 45 f8	 mov	 eax, DWORD PTR _i$231767[ebp]
  02708	83 c0 01	 add	 eax, 1
  0270b	89 45 f8	 mov	 DWORD PTR _i$231767[ebp], eax
$LN6@CheckUsers:
  0270e	83 7d f8 05	 cmp	 DWORD PTR _i$231767[ebp], 5
  02712	0f 8d 85 00 00
	00		 jge	 $LN7@CheckUsers

; 993  : 	{
; 994  : 		if(this->m_DGData.PlayerIndex[i] != -1)

  02718	8b 45 f8	 mov	 eax, DWORD PTR _i$231767[ebp]
  0271b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0271e	83 7c 81 54 ff	 cmp	 DWORD PTR [ecx+eax*4+84], -1
  02723	74 73		 je	 SHORT $LN3@CheckUsers

; 995  : 		{
; 996  : 			if(gObj[this->m_DGData.PlayerIndex[i]].MapNumber != this->m_DGData.MapNumber || !gObjIsConnectedGP(this->m_DGData.PlayerIndex[i]))

  02725	8b 45 f8	 mov	 eax, DWORD PTR _i$231767[ebp]
  02728	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0272b	8b 54 81 54	 mov	 edx, DWORD PTR [ecx+eax*4+84]
  0272f	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  02735	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0273a	0f b6 8c 10 49
	01 00 00	 movzx	 ecx, BYTE PTR [eax+edx+329]
  02742	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  02745	3b 8a 10 02 00
	00		 cmp	 ecx, DWORD PTR [edx+528]
  0274b	75 17		 jne	 SHORT $LN1@CheckUsers
  0274d	8b 45 f8	 mov	 eax, DWORD PTR _i$231767[ebp]
  02750	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02753	8b 54 81 54	 mov	 edx, DWORD PTR [ecx+eax*4+84]
  02757	52		 push	 edx
  02758	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  0275d	83 c4 04	 add	 esp, 4
  02760	85 c0		 test	 eax, eax
  02762	75 34		 jne	 SHORT $LN3@CheckUsers
$LN1@CheckUsers:

; 997  : 			{
; 998  : 				this->SendResultMessage(DG_RESULT_DEAD_PLAYER, false, this->m_DGData.PlayerIndex[i]);

  02764	8b 45 f8	 mov	 eax, DWORD PTR _i$231767[ebp]
  02767	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0276a	8b 54 81 54	 mov	 edx, DWORD PTR [ecx+eax*4+84]
  0276e	52		 push	 edx
  0276f	6a 00		 push	 0
  02771	6a 01		 push	 1
  02773	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02776	e8 00 00 00 00	 call	 ?SendResultMessage@CDoppelGanger@@QAEXE_NH@Z ; CDoppelGanger::SendResultMessage

; 999  : 				this->m_DGData.PlayerIndex[i] = -1;

  0277b	8b 45 f8	 mov	 eax, DWORD PTR _i$231767[ebp]
  0277e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02781	c7 44 81 54 ff
	ff ff ff	 mov	 DWORD PTR [ecx+eax*4+84], -1

; 1000 : 				--this->m_DGData.PlayerCount;

  02789	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0278c	8a 48 44	 mov	 cl, BYTE PTR [eax+68]
  0278f	80 e9 01	 sub	 cl, 1
  02792	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  02795	88 4a 44	 mov	 BYTE PTR [edx+68], cl
$LN3@CheckUsers:

; 1001 : 			}
; 1002 : 		}
; 1003 : 	}

  02798	e9 68 ff ff ff	 jmp	 $LN5@CheckUsers
$LN7@CheckUsers:

; 1004 : }

  0279d	5f		 pop	 edi
  0279e	5e		 pop	 esi
  0279f	5b		 pop	 ebx
  027a0	8b e5		 mov	 esp, ebp
  027a2	5d		 pop	 ebp
  027a3	c3		 ret	 0
?CheckUsers@CDoppelGanger@@QAEXXZ ENDP			; CDoppelGanger::CheckUsers
_TEXT	ENDS
PUBLIC	??_C@_0CH@FDGIGGED@?$FLDoppelGanger?$FN?5Loaded?5?$CFd?5Monster@ ; `string'
PUBLIC	?push_back@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAEXABUDG_MONSTER_STAT@@@Z ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::push_back
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	??_C@_0FE@LHJMLGEG@?$FLDoppelGanger?$FN?5Load?5Option?3?5Enab@ ; `string'
PUBLIC	??_C@_0BC@JAIHNJEB@?$CFs?5file?5not?5found?$AA@	; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	__$ArrayPad$
EXTRN	_strcmp:PROC
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	_fopen:PROC
_BSS	SEGMENT
_TokenString DB	064H DUP (?)
_TokenNumber DD	01H DUP (?)
_SMDFile DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0CH@FDGIGGED@?$FLDoppelGanger?$FN?5Loaded?5?$CFd?5Monster@
CONST	SEGMENT
??_C@_0CH@FDGIGGED@?$FLDoppelGanger?$FN?5Loaded?5?$CFd?5Monster@ DB '[Dop'
	DB	'pelGanger] Loaded %d Monster stats', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FE@LHJMLGEG@?$FLDoppelGanger?$FN?5Load?5Option?3?5Enab@
CONST	SEGMENT
??_C@_0FE@LHJMLGEG@?$FLDoppelGanger?$FN?5Load?5Option?3?5Enab@ DB '[Doppe'
	DB	'lGanger] Load Option: Enabled: %d, CoolDown: %d, AutoStat: %d'
	DB	', EnterMoney: %d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JAIHNJEB@?$CFs?5file?5not?5found?$AA@
CONST	SEGMENT
??_C@_0BC@JAIHNJEB@?$CFs?5file?5not?5found?$AA@ DB '%s file not found', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_Stat$ = -44						; size = 24
_type$ = -20						; size = 4
_n$ = -16						; size = 4
_Token$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_hFile$ = 8						; size = 4
?LoadConfigFile@CDoppelGanger@@QAE_NPAD@Z PROC		; CDoppelGanger::LoadConfigFile
; _this$ = ecx

; 1007 : {

  027b0	55		 push	 ebp
  027b1	8b ec		 mov	 ebp, esp
  027b3	83 ec 6c	 sub	 esp, 108		; 0000006cH
  027b6	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  027bb	33 c5		 xor	 eax, ebp
  027bd	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  027c0	53		 push	 ebx
  027c1	56		 push	 esi
  027c2	57		 push	 edi
  027c3	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1008 : 	SMDFile = fopen(hFile, "r");

  027c6	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  027cb	8b 45 08	 mov	 eax, DWORD PTR _hFile$[ebp]
  027ce	50		 push	 eax
  027cf	e8 00 00 00 00	 call	 _fopen
  027d4	83 c4 08	 add	 esp, 8
  027d7	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax

; 1009 : 
; 1010 : 	if(SMDFile == NULL)

  027dc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SMDFile, 0
  027e3	75 18		 jne	 SHORT $LN12@LoadConfig

; 1011 : 	{
; 1012 : 		MsgBox("%s file not found", hFile);

  027e5	8b 45 08	 mov	 eax, DWORD PTR _hFile$[ebp]
  027e8	50		 push	 eax
  027e9	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@JAIHNJEB@?$CFs?5file?5not?5found?$AA@
  027ee	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  027f3	83 c4 08	 add	 esp, 8

; 1013 : 		return false;

  027f6	32 c0		 xor	 al, al
  027f8	e9 ee 01 00 00	 jmp	 $LN13@LoadConfig
$LN12@LoadConfig:

; 1014 : 	}
; 1015 : 
; 1016 : 	int Token;
; 1017 : 	int n = 0;

  027fd	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
$LN15@LoadConfig:

; 1018 : 	int type;
; 1019 : 
; 1020 : 	DG_MONSTER_STAT Stat;
; 1021 : 
; 1022 : 	while(true)

  02804	b8 01 00 00 00	 mov	 eax, 1
  02809	85 c0		 test	 eax, eax
  0280b	0f 84 c6 01 00
	00		 je	 $LN10@LoadConfig

; 1023 : 	{
; 1024 : 		type = 0;

  02811	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _type$[ebp], 0

; 1025 : 
; 1026 : 		Token = GetToken();

  02818	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0281d	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 1027 : 
; 1028 : 		if(Token == END)

  02820	83 7d f4 02	 cmp	 DWORD PTR _Token$[ebp], 2
  02824	75 05		 jne	 SHORT $LN9@LoadConfig

; 1029 : 			break;

  02826	e9 ac 01 00 00	 jmp	 $LN10@LoadConfig
$LN9@LoadConfig:

; 1030 : 
; 1031 : 		if(Token == NAME)

  0282b	83 7d f4 00	 cmp	 DWORD PTR _Token$[ebp], 0
  0282f	75 02		 jne	 SHORT $LN8@LoadConfig

; 1032 : 			continue;

  02831	eb d1		 jmp	 SHORT $LN15@LoadConfig
$LN8@LoadConfig:

; 1033 : 
; 1034 : 		type = TokenNumber;

  02833	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  02839	e8 00 00 00 00	 call	 __ftol2_sse
  0283e	89 45 ec	 mov	 DWORD PTR _type$[ebp], eax

; 1035 : 
; 1036 : 		if(type == 1)

  02841	83 7d ec 01	 cmp	 DWORD PTR _type$[ebp], 1
  02845	0f 85 8d 00 00
	00		 jne	 $LN7@LoadConfig

; 1037 : 		{
; 1038 : 			Token = GetToken();

  0284b	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  02850	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 1039 : 			DGEnabled = TokenNumber;

  02853	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  02859	e8 00 00 00 00	 call	 __ftol2_sse
  0285e	a3 00 00 00 00	 mov	 DWORD PTR ?DGEnabled@@3HA, eax ; DGEnabled

; 1040 : 
; 1041 : 			Token = GetToken();

  02863	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  02868	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 1042 : 			DGCoolDown = TokenNumber;

  0286b	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  02871	e8 00 00 00 00	 call	 __ftol2_sse
  02876	a3 00 00 00 00	 mov	 DWORD PTR ?DGCoolDown@@3HA, eax ; DGCoolDown

; 1043 : 
; 1044 : 			Token = GetToken();

  0287b	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  02880	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 1045 : 			DGUseAutoStat = TokenNumber;

  02883	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  02889	e8 00 00 00 00	 call	 __ftol2_sse
  0288e	a3 00 00 00 00	 mov	 DWORD PTR ?DGUseAutoStat@@3HA, eax ; DGUseAutoStat

; 1046 : 
; 1047 : 			Token = GetToken();

  02893	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  02898	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 1048 : 			DGEnterMoney = TokenNumber;

  0289b	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  028a1	e8 00 00 00 00	 call	 __ftol2_sse
  028a6	a3 00 00 00 00	 mov	 DWORD PTR ?DGEnterMoney@@3HA, eax ; DGEnterMoney

; 1049 : 
; 1050 : 			LogAddTD("[DoppelGanger] Load Option: Enabled: %d, CoolDown: %d, AutoStat: %d, EnterMoney: %d", DGEnabled, DGCoolDown, DGUseAutoStat, DGEnterMoney);

  028ab	a1 00 00 00 00	 mov	 eax, DWORD PTR ?DGEnterMoney@@3HA ; DGEnterMoney
  028b0	50		 push	 eax
  028b1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?DGUseAutoStat@@3HA ; DGUseAutoStat
  028b7	51		 push	 ecx
  028b8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?DGCoolDown@@3HA ; DGCoolDown
  028be	52		 push	 edx
  028bf	a1 00 00 00 00	 mov	 eax, DWORD PTR ?DGEnabled@@3HA ; DGEnabled
  028c4	50		 push	 eax
  028c5	68 00 00 00 00	 push	 OFFSET ??_C@_0FE@LHJMLGEG@?$FLDoppelGanger?$FN?5Load?5Option?3?5Enab@
  028ca	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  028d0	83 c4 14	 add	 esp, 20			; 00000014H
  028d3	e9 fa 00 00 00	 jmp	 $LN3@LoadConfig
$LN7@LoadConfig:

; 1051 : 		}
; 1052 : 
; 1053 : 		else if(type == 2)

  028d8	83 7d ec 02	 cmp	 DWORD PTR _type$[ebp], 2
  028dc	0f 85 f0 00 00
	00		 jne	 $LN3@LoadConfig
$LN4@LoadConfig:

; 1054 : 		{
; 1055 : 			while(true)

  028e2	b8 01 00 00 00	 mov	 eax, 1
  028e7	85 c0		 test	 eax, eax
  028e9	0f 84 e3 00 00
	00		 je	 $LN3@LoadConfig

; 1056 : 			{
; 1057 : 				Token = GetToken();

  028ef	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  028f4	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 1058 : 
; 1059 : 				if(Token == END)

  028f7	83 7d f4 02	 cmp	 DWORD PTR _Token$[ebp], 2
  028fb	75 05		 jne	 SHORT $LN2@LoadConfig

; 1060 : 					break;

  028fd	e9 d0 00 00 00	 jmp	 $LN3@LoadConfig
$LN2@LoadConfig:

; 1061 : 
; 1062 : 				if(strcmp("end", TokenString)== 0)

  02902	68 00 00 00 00	 push	 OFFSET _TokenString
  02907	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  0290c	e8 00 00 00 00	 call	 _strcmp
  02911	83 c4 08	 add	 esp, 8
  02914	85 c0		 test	 eax, eax
  02916	75 05		 jne	 SHORT $LN1@LoadConfig

; 1063 : 					break;

  02918	e9 b5 00 00 00	 jmp	 $LN3@LoadConfig
$LN1@LoadConfig:

; 1064 : 
; 1065 : 				Stat.EventLevel = TokenNumber;

  0291d	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  02923	e8 00 00 00 00	 call	 __ftol2_sse
  02928	66 89 45 d4	 mov	 WORD PTR _Stat$[ebp], ax

; 1066 : 
; 1067 : 				Token = GetToken();

  0292c	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  02931	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 1068 : 				Stat.Class = TokenNumber;

  02934	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0293a	e8 00 00 00 00	 call	 __ftol2_sse
  0293f	66 89 45 d6	 mov	 WORD PTR _Stat$[ebp+2], ax

; 1069 : 
; 1070 : 				Token = GetToken();

  02943	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  02948	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 1071 : 				Stat.Level = TokenNumber;

  0294b	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  02951	e8 00 00 00 00	 call	 __ftol2_sse
  02956	66 89 45 d8	 mov	 WORD PTR _Stat$[ebp+4], ax

; 1072 : 
; 1073 : 				Token = GetToken();

  0295a	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0295f	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 1074 : 				Stat.HP = TokenNumber;

  02962	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  02968	e8 00 00 00 00	 call	 __ftol2_sse
  0296d	89 45 dc	 mov	 DWORD PTR _Stat$[ebp+8], eax

; 1075 : 
; 1076 : 				Token = GetToken();

  02970	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  02975	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 1077 : 				Stat.DmgMin = TokenNumber;

  02978	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0297e	e8 00 00 00 00	 call	 __ftol2_sse
  02983	89 45 e0	 mov	 DWORD PTR _Stat$[ebp+12], eax

; 1078 : 
; 1079 : 				Token = GetToken();

  02986	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0298b	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 1080 : 				Stat.DmgMax = TokenNumber;

  0298e	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  02994	e8 00 00 00 00	 call	 __ftol2_sse
  02999	89 45 e4	 mov	 DWORD PTR _Stat$[ebp+16], eax

; 1081 : 
; 1082 : 				Token = GetToken();

  0299c	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  029a1	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 1083 : 				Stat.Defense = TokenNumber;

  029a4	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  029aa	e8 00 00 00 00	 call	 __ftol2_sse
  029af	89 45 e8	 mov	 DWORD PTR _Stat$[ebp+20], eax

; 1084 : 
; 1085 : 				this->m_vtDGMobStat.push_back(Stat);

  029b2	8d 45 d4	 lea	 eax, DWORD PTR _Stat$[ebp]
  029b5	50		 push	 eax
  029b6	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  029b9	81 c1 24 02 00
	00		 add	 ecx, 548		; 00000224H
  029bf	e8 00 00 00 00	 call	 ?push_back@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAEXABUDG_MONSTER_STAT@@@Z ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::push_back

; 1086 : 				++n;

  029c4	8b 45 f0	 mov	 eax, DWORD PTR _n$[ebp]
  029c7	83 c0 01	 add	 eax, 1
  029ca	89 45 f0	 mov	 DWORD PTR _n$[ebp], eax

; 1087 : 			}

  029cd	e9 10 ff ff ff	 jmp	 $LN4@LoadConfig
$LN3@LoadConfig:

; 1088 : 		}
; 1089 : 	}

  029d2	e9 2d fe ff ff	 jmp	 $LN15@LoadConfig
$LN10@LoadConfig:

; 1090 : 	LogAddTD("[DoppelGanger] Loaded %d Monster stats",n);

  029d7	8b 45 f0	 mov	 eax, DWORD PTR _n$[ebp]
  029da	50		 push	 eax
  029db	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@FDGIGGED@?$FLDoppelGanger?$FN?5Loaded?5?$CFd?5Monster@
  029e0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  029e6	83 c4 08	 add	 esp, 8

; 1091 : 	return true;

  029e9	b0 01		 mov	 al, 1
$LN13@LoadConfig:

; 1092 : }

  029eb	5f		 pop	 edi
  029ec	5e		 pop	 esi
  029ed	5b		 pop	 ebx
  029ee	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  029f1	33 cd		 xor	 ecx, ebp
  029f3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  029f8	8b e5		 mov	 esp, ebp
  029fa	5d		 pop	 ebp
  029fb	c2 04 00	 ret	 4
?LoadConfigFile@CDoppelGanger@@QAE_NPAD@Z ENDP		; CDoppelGanger::LoadConfigFile
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_isalnum:PROC
EXTRN	_isalpha:PROC
EXTRN	_atof:PROC
EXTRN	_isdigit:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_isspace:PROC
EXTRN	_fgetc:PROC
_BSS	SEGMENT
_CurrentToken DD 01H DUP (?)
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\include\readscript.h
_BSS	ENDS
_TEXT	SEGMENT
tv90 = -180						; size = 4
_TempString$ = -112					; size = 100
_p$ = -12						; size = 4
_ch$ = -5						; size = 1
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken

; 24   : {

  02a00	55		 push	 ebp
  02a01	8b ec		 mov	 ebp, esp
  02a03	81 ec b4 00 00
	00		 sub	 esp, 180		; 000000b4H
  02a09	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  02a0e	33 c5		 xor	 eax, ebp
  02a10	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  02a13	53		 push	 ebx
  02a14	56		 push	 esi
  02a15	57		 push	 edi

; 25   : 	char ch;
; 26   : 	char* p;
; 27   : 	char TempString[100];
; 28   : 
; 29   : 	TokenString[0]=0;

  02a16	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _TokenString, 0
$LN31@GetToken:

; 30   : 
; 31   : 	do
; 32   : 	{
; 33   : 		if ((ch=fgetc(SMDFile)) == -1)

  02a1d	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  02a22	50		 push	 eax
  02a23	e8 00 00 00 00	 call	 _fgetc
  02a28	83 c4 04	 add	 esp, 4
  02a2b	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  02a2e	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  02a32	83 f9 ff	 cmp	 ecx, -1
  02a35	75 0c		 jne	 SHORT $LN28@GetToken

; 34   : 		{
; 35   : 			return END;	// End of FILE (EOF)

  02a37	b8 02 00 00 00	 mov	 eax, 2
  02a3c	e9 f7 02 00 00	 jmp	 $LN32@GetToken

; 36   : 		}
; 37   : 		else

  02a41	eb 5b		 jmp	 SHORT $LN22@GetToken
$LN28@GetToken:

; 38   : 		{	
; 39   : 			if (ch=='/')		// this is /

  02a43	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  02a47	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  02a4a	75 52		 jne	 SHORT $LN22@GetToken

; 40   : 			{
; 41   : 				if((ch=fgetc(SMDFile)) == '/')

  02a4c	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  02a51	50		 push	 eax
  02a52	e8 00 00 00 00	 call	 _fgetc
  02a57	83 c4 04	 add	 esp, 4
  02a5a	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  02a5d	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  02a61	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  02a64	75 38		 jne	 SHORT $LN22@GetToken
$LN24@GetToken:

; 42   : 				{
; 43   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  02a66	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  02a6a	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  02a6d	74 1c		 je	 SHORT $LN23@GetToken
  02a6f	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  02a73	83 f8 ff	 cmp	 eax, -1
  02a76	74 13		 je	 SHORT $LN23@GetToken

; 44   : 					{
; 45   : 						ch=fgetc(SMDFile);

  02a78	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  02a7d	50		 push	 eax
  02a7e	e8 00 00 00 00	 call	 _fgetc
  02a83	83 c4 04	 add	 esp, 4
  02a86	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al

; 46   : 					}

  02a89	eb db		 jmp	 SHORT $LN24@GetToken
$LN23@GetToken:

; 47   : 	
; 48   : 					if (ch == -1)

  02a8b	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  02a8f	83 f8 ff	 cmp	 eax, -1
  02a92	75 0a		 jne	 SHORT $LN22@GetToken

; 49   : 					{
; 50   : 						return END;	// End of FILE

  02a94	b8 02 00 00 00	 mov	 eax, 2
  02a99	e9 9a 02 00 00	 jmp	 $LN32@GetToken
$LN22@GetToken:

; 51   : 					}
; 52   : 				}
; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : 	while (isspace(ch) != 0);

  02a9e	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  02aa2	50		 push	 eax
  02aa3	e8 00 00 00 00	 call	 _isspace
  02aa8	83 c4 04	 add	 esp, 4
  02aab	85 c0		 test	 eax, eax
  02aad	0f 85 6a ff ff
	ff		 jne	 $LN31@GetToken

; 57   : 
; 58   : 	
; 59   : 	switch(ch)

  02ab3	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  02ab7	89 85 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], eax
  02abd	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR tv90[ebp]
  02ac3	83 e9 22	 sub	 ecx, 34			; 00000022H
  02ac6	89 8d 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], ecx
  02acc	83 bd 4c ff ff
	ff 5b		 cmp	 DWORD PTR tv90[ebp], 91	; 0000005bH
  02ad3	0f 87 a3 01 00
	00		 ja	 $LN6@GetToken
  02ad9	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR tv90[ebp]
  02adf	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN34@GetToken[edx]
  02ae6	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN35@GetToken[eax*4]
$LN19@GetToken:

; 60   : 	{
; 61   : 
; 62   : 	case 0x23:	// #
; 63   : 		return CurrentToken=COMMAND;

  02aed	c7 05 00 00 00
	00 23 00 00 00	 mov	 DWORD PTR _CurrentToken, 35 ; 00000023H
  02af7	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  02afc	e9 37 02 00 00	 jmp	 $LN32@GetToken

; 64   : 		break;

  02b01	e9 30 02 00 00	 jmp	 $LN20@GetToken
$LN18@GetToken:

; 65   : 	
; 66   : 	case 0x3B:	// ;
; 67   : 		return CurrentToken=SEMICOLON;

  02b06	c7 05 00 00 00
	00 3b 00 00 00	 mov	 DWORD PTR _CurrentToken, 59 ; 0000003bH
  02b10	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  02b15	e9 1e 02 00 00	 jmp	 $LN32@GetToken

; 68   : 		break;

  02b1a	e9 17 02 00 00	 jmp	 $LN20@GetToken
$LN17@GetToken:

; 69   : 	
; 70   : 	case 0x2C:	// ,
; 71   : 
; 72   : 		return CurrentToken=COMMA;

  02b1f	c7 05 00 00 00
	00 2c 00 00 00	 mov	 DWORD PTR _CurrentToken, 44 ; 0000002cH
  02b29	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  02b2e	e9 05 02 00 00	 jmp	 $LN32@GetToken

; 73   : 		break;

  02b33	e9 fe 01 00 00	 jmp	 $LN20@GetToken
$LN16@GetToken:

; 74   : 	
; 75   : 	case 0x7B:	// {
; 76   : 		return CurrentToken = LP;

  02b38	c7 05 00 00 00
	00 7b 00 00 00	 mov	 DWORD PTR _CurrentToken, 123 ; 0000007bH
  02b42	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  02b47	e9 ec 01 00 00	 jmp	 $LN32@GetToken

; 77   : 		break;

  02b4c	e9 e5 01 00 00	 jmp	 $LN20@GetToken
$LN15@GetToken:

; 78   : 
; 79   : 	case 0x7D:	// }
; 80   : 		return CurrentToken = RP;

  02b51	c7 05 00 00 00
	00 7d 00 00 00	 mov	 DWORD PTR _CurrentToken, 125 ; 0000007dH
  02b5b	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  02b60	e9 d3 01 00 00	 jmp	 $LN32@GetToken

; 81   : 		break;

  02b65	e9 cc 01 00 00	 jmp	 $LN20@GetToken
$LN14@GetToken:

; 82   : 	// Nice Index Table :)	by Deathway
; 83   : 	// Numbers Case
; 84   : 	case 0x2D:	//-
; 85   : 	case 0x2E:	//.
; 86   : 	case '0':	//0
; 87   : 	case '1':	//1
; 88   : 	case '2':	//2
; 89   : 	case '3':	//3
; 90   : 	case '4':	//4		
; 91   : 	case '5':	//5
; 92   : 	case '6':	//6
; 93   : 	case '7':	//7
; 94   : 	case '8':	//8
; 95   : 	case '9':	//9
; 96   : 		ungetc(ch, SMDFile);

  02b6a	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  02b6f	50		 push	 eax
  02b70	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  02b74	51		 push	 ecx
  02b75	e8 00 00 00 00	 call	 _ungetc
  02b7a	83 c4 08	 add	 esp, 8

; 97   : 		p = TempString;

  02b7d	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  02b80	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN13@GetToken:

; 98   : 		
; 99   : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  02b83	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  02b88	50		 push	 eax
  02b89	e8 00 00 00 00	 call	 _getc
  02b8e	83 c4 04	 add	 esp, 4
  02b91	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  02b94	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  02b98	83 f9 ff	 cmp	 ecx, -1
  02b9b	74 36		 je	 SHORT $LN12@GetToken
  02b9d	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  02ba1	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  02ba4	74 1a		 je	 SHORT $LN11@GetToken
  02ba6	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  02baa	50		 push	 eax
  02bab	e8 00 00 00 00	 call	 _isdigit
  02bb0	83 c4 04	 add	 esp, 4
  02bb3	85 c0		 test	 eax, eax
  02bb5	75 09		 jne	 SHORT $LN11@GetToken
  02bb7	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  02bbb	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  02bbe	75 13		 jne	 SHORT $LN12@GetToken
$LN11@GetToken:

; 100  : 		{
; 101  : 			*p = ch;	// Construct a String

  02bc0	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  02bc3	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  02bc6	88 08		 mov	 BYTE PTR [eax], cl

; 102  : 			p++;

  02bc8	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  02bcb	83 c0 01	 add	 eax, 1
  02bce	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 103  : 		}		

  02bd1	eb b0		 jmp	 SHORT $LN13@GetToken
$LN12@GetToken:

; 104  : 		*p = 0;

  02bd3	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  02bd6	c6 00 00	 mov	 BYTE PTR [eax], 0

; 105  : 		TokenNumber = atof( TempString);	// Select the first Byte as Main ID

  02bd9	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  02bdc	50		 push	 eax
  02bdd	e8 00 00 00 00	 call	 _atof
  02be2	83 c4 04	 add	 esp, 4
  02be5	d9 1d 00 00 00
	00		 fstp	 DWORD PTR _TokenNumber

; 106  : 		return CurrentToken  = NUMBER ;

  02beb	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CurrentToken, 1
  02bf5	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  02bfa	e9 39 01 00 00	 jmp	 $LN32@GetToken

; 107  : 		break;

  02bff	e9 32 01 00 00	 jmp	 $LN20@GetToken
$LN10@GetToken:

; 108  : 
; 109  : 	case '\"':	// "	String Case
; 110  : 		p=&TokenString[0];

  02c04	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString
$LN9@GetToken:

; 111  : 		
; 112  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  02c0b	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  02c10	50		 push	 eax
  02c11	e8 00 00 00 00	 call	 _getc
  02c16	83 c4 04	 add	 esp, 4
  02c19	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  02c1c	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  02c20	83 f9 ff	 cmp	 ecx, -1
  02c23	74 1c		 je	 SHORT $LN8@GetToken
  02c25	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  02c29	83 f8 22	 cmp	 eax, 34			; 00000022H
  02c2c	74 13		 je	 SHORT $LN8@GetToken

; 113  : 		{
; 114  : 			*p = ch;

  02c2e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  02c31	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  02c34	88 08		 mov	 BYTE PTR [eax], cl

; 115  : 			p++;

  02c36	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  02c39	83 c0 01	 add	 eax, 1
  02c3c	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 116  : 		}

  02c3f	eb ca		 jmp	 SHORT $LN9@GetToken
$LN8@GetToken:

; 117  : 		if (ch != 0x22 )

  02c41	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  02c45	83 f8 22	 cmp	 eax, 34			; 00000022H
  02c48	74 13		 je	 SHORT $LN7@GetToken

; 118  : 		{
; 119  : 			ungetc(ch, SMDFile);

  02c4a	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  02c4f	50		 push	 eax
  02c50	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  02c54	51		 push	 ecx
  02c55	e8 00 00 00 00	 call	 _ungetc
  02c5a	83 c4 08	 add	 esp, 8
$LN7@GetToken:

; 120  : 		}
; 121  : 		*p = 0;

  02c5d	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  02c60	c6 00 00	 mov	 BYTE PTR [eax], 0

; 122  : 		return CurrentToken = NAME;

  02c63	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0
  02c6d	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  02c72	e9 c1 00 00 00	 jmp	 $LN32@GetToken

; 123  : 		break;

  02c77	e9 ba 00 00 00	 jmp	 $LN20@GetToken
$LN6@GetToken:

; 124  : 
; 125  : 	default:	// Others
; 126  : 		if (isalpha(ch))

  02c7c	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  02c80	50		 push	 eax
  02c81	e8 00 00 00 00	 call	 _isalpha
  02c86	83 c4 04	 add	 esp, 4
  02c89	85 c0		 test	 eax, eax
  02c8b	0f 84 94 00 00
	00		 je	 $LN5@GetToken

; 127  : 		{
; 128  : 			p=&TokenString[0];

  02c91	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString

; 129  : 			*p=ch;

  02c98	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  02c9b	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  02c9e	88 08		 mov	 BYTE PTR [eax], cl

; 130  : 			p++;

  02ca0	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  02ca3	83 c0 01	 add	 eax, 1
  02ca6	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN4@GetToken:

; 131  : 
; 132  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  02ca9	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  02cae	50		 push	 eax
  02caf	e8 00 00 00 00	 call	 _getc
  02cb4	83 c4 04	 add	 esp, 4
  02cb7	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  02cba	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  02cbe	83 f9 ff	 cmp	 ecx, -1
  02cc1	74 36		 je	 SHORT $LN3@GetToken
  02cc3	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  02cc7	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  02cca	74 1a		 je	 SHORT $LN2@GetToken
  02ccc	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  02cd0	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  02cd3	74 11		 je	 SHORT $LN2@GetToken
  02cd5	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  02cd9	50		 push	 eax
  02cda	e8 00 00 00 00	 call	 _isalnum
  02cdf	83 c4 04	 add	 esp, 4
  02ce2	85 c0		 test	 eax, eax
  02ce4	74 13		 je	 SHORT $LN3@GetToken
$LN2@GetToken:

; 133  : 			{
; 134  : 				*p=ch;

  02ce6	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  02ce9	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  02cec	88 08		 mov	 BYTE PTR [eax], cl

; 135  : 				p++;

  02cee	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  02cf1	83 c0 01	 add	 eax, 1
  02cf4	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 136  : 				
; 137  : 			}

  02cf7	eb b0		 jmp	 SHORT $LN4@GetToken
$LN3@GetToken:

; 138  : 
; 139  : 			ungetc(ch, SMDFile);

  02cf9	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  02cfe	50		 push	 eax
  02cff	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  02d03	51		 push	 ecx
  02d04	e8 00 00 00 00	 call	 _ungetc
  02d09	83 c4 08	 add	 esp, 8

; 140  : 			*p=0;

  02d0c	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  02d0f	c6 00 00	 mov	 BYTE PTR [eax], 0

; 141  : 			CurrentToken=NAME;

  02d12	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0

; 142  : 			return CurrentToken;

  02d1c	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  02d21	eb 15		 jmp	 SHORT $LN32@GetToken

; 143  : 		}
; 144  : 		else

  02d23	eb 11		 jmp	 SHORT $LN1@GetToken
$LN5@GetToken:

; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'

  02d25	c7 05 00 00 00
	00 3c 00 00 00	 mov	 DWORD PTR _CurrentToken, 60 ; 0000003cH
  02d2f	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  02d34	eb 02		 jmp	 SHORT $LN32@GetToken
$LN1@GetToken:
$LN20@GetToken:

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;

  02d36	33 c0		 xor	 eax, eax
$LN32@GetToken:

; 153  : }

  02d38	5f		 pop	 edi
  02d39	5e		 pop	 esi
  02d3a	5b		 pop	 ebx
  02d3b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  02d3e	33 cd		 xor	 ecx, ebp
  02d40	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02d45	8b e5		 mov	 esp, ebp
  02d47	5d		 pop	 ebp
  02d48	c3		 ret	 0
  02d49	8d 49 00	 npad	 3
$LN35@GetToken:
  02d4c	00 00 00 00	 DD	 $LN10@GetToken
  02d50	00 00 00 00	 DD	 $LN19@GetToken
  02d54	00 00 00 00	 DD	 $LN17@GetToken
  02d58	00 00 00 00	 DD	 $LN14@GetToken
  02d5c	00 00 00 00	 DD	 $LN18@GetToken
  02d60	00 00 00 00	 DD	 $LN16@GetToken
  02d64	00 00 00 00	 DD	 $LN15@GetToken
  02d68	00 00 00 00	 DD	 $LN6@GetToken
$LN34@GetToken:
  02d6c	00		 DB	 0
  02d6d	01		 DB	 1
  02d6e	07		 DB	 7
  02d6f	07		 DB	 7
  02d70	07		 DB	 7
  02d71	07		 DB	 7
  02d72	07		 DB	 7
  02d73	07		 DB	 7
  02d74	07		 DB	 7
  02d75	07		 DB	 7
  02d76	02		 DB	 2
  02d77	03		 DB	 3
  02d78	03		 DB	 3
  02d79	07		 DB	 7
  02d7a	03		 DB	 3
  02d7b	03		 DB	 3
  02d7c	03		 DB	 3
  02d7d	03		 DB	 3
  02d7e	03		 DB	 3
  02d7f	03		 DB	 3
  02d80	03		 DB	 3
  02d81	03		 DB	 3
  02d82	03		 DB	 3
  02d83	03		 DB	 3
  02d84	07		 DB	 7
  02d85	04		 DB	 4
  02d86	07		 DB	 7
  02d87	07		 DB	 7
  02d88	07		 DB	 7
  02d89	07		 DB	 7
  02d8a	07		 DB	 7
  02d8b	07		 DB	 7
  02d8c	07		 DB	 7
  02d8d	07		 DB	 7
  02d8e	07		 DB	 7
  02d8f	07		 DB	 7
  02d90	07		 DB	 7
  02d91	07		 DB	 7
  02d92	07		 DB	 7
  02d93	07		 DB	 7
  02d94	07		 DB	 7
  02d95	07		 DB	 7
  02d96	07		 DB	 7
  02d97	07		 DB	 7
  02d98	07		 DB	 7
  02d99	07		 DB	 7
  02d9a	07		 DB	 7
  02d9b	07		 DB	 7
  02d9c	07		 DB	 7
  02d9d	07		 DB	 7
  02d9e	07		 DB	 7
  02d9f	07		 DB	 7
  02da0	07		 DB	 7
  02da1	07		 DB	 7
  02da2	07		 DB	 7
  02da3	07		 DB	 7
  02da4	07		 DB	 7
  02da5	07		 DB	 7
  02da6	07		 DB	 7
  02da7	07		 DB	 7
  02da8	07		 DB	 7
  02da9	07		 DB	 7
  02daa	07		 DB	 7
  02dab	07		 DB	 7
  02dac	07		 DB	 7
  02dad	07		 DB	 7
  02dae	07		 DB	 7
  02daf	07		 DB	 7
  02db0	07		 DB	 7
  02db1	07		 DB	 7
  02db2	07		 DB	 7
  02db3	07		 DB	 7
  02db4	07		 DB	 7
  02db5	07		 DB	 7
  02db6	07		 DB	 7
  02db7	07		 DB	 7
  02db8	07		 DB	 7
  02db9	07		 DB	 7
  02dba	07		 DB	 7
  02dbb	07		 DB	 7
  02dbc	07		 DB	 7
  02dbd	07		 DB	 7
  02dbe	07		 DB	 7
  02dbf	07		 DB	 7
  02dc0	07		 DB	 7
  02dc1	07		 DB	 7
  02dc2	07		 DB	 7
  02dc3	07		 DB	 7
  02dc4	07		 DB	 7
  02dc5	05		 DB	 5
  02dc6	07		 DB	 7
  02dc7	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
PUBLIC	??_C@_0CI@FOAGBNK@?$FLDoppelGanger?$FN?5ERROR?3?5EventLevel@ ; `string'
EXTRN	?LogAddC@@3P6AXEPADZZA:DWORD			; LogAddC
;	COMDAT ??_C@_0CI@FOAGBNK@?$FLDoppelGanger?$FN?5ERROR?3?5EventLevel@
; File d:\projects\exteam6.3\source\gameserver\gameserver\doublegoer.cpp
CONST	SEGMENT
??_C@_0CI@FOAGBNK@?$FLDoppelGanger?$FN?5ERROR?3?5EventLevel@ DB '[DoppelG'
	DB	'anger] ERROR: EventLevel == -1!', 00H	; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_i$231807 = -16						; size = 4
_level$ = -12						; size = 4
_temp$ = -8						; size = 4
_this$ = -4						; size = 4
?SetEventLevel@CDoppelGanger@@QAE_NXZ PROC		; CDoppelGanger::SetEventLevel
; _this$ = ecx

; 1095 : {

  02dd0	55		 push	 ebp
  02dd1	8b ec		 mov	 ebp, esp
  02dd3	83 ec 50	 sub	 esp, 80			; 00000050H
  02dd6	53		 push	 ebx
  02dd7	56		 push	 esi
  02dd8	57		 push	 edi
  02dd9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1096 : 	if(!DGUseAutoStat)

  02ddc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?DGUseAutoStat@@3HA, 0 ; DGUseAutoStat
  02de3	75 07		 jne	 SHORT $LN6@SetEventLe

; 1097 : 	{
; 1098 : 		return true;

  02de5	b0 01		 mov	 al, 1
  02de7	e9 9f 00 00 00	 jmp	 $LN7@SetEventLe
$LN6@SetEventLe:

; 1099 : 	}
; 1100 : 	int temp = -1;

  02dec	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _temp$[ebp], -1

; 1101 : 	int level;
; 1102 : 	for(int i=0;i<5;++i)

  02df3	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$231807[ebp], 0
  02dfa	eb 09		 jmp	 SHORT $LN5@SetEventLe
$LN4@SetEventLe:
  02dfc	8b 45 f0	 mov	 eax, DWORD PTR _i$231807[ebp]
  02dff	83 c0 01	 add	 eax, 1
  02e02	89 45 f0	 mov	 DWORD PTR _i$231807[ebp], eax
$LN5@SetEventLe:
  02e05	83 7d f0 05	 cmp	 DWORD PTR _i$231807[ebp], 5
  02e09	7d 4f		 jge	 SHORT $LN3@SetEventLe

; 1103 : 	{
; 1104 : 		if((level = (gObj[this->m_DGData.PlayerIndex[i]].Level + gObj[this->m_DGData.PlayerIndex[i]].MLevel)) > temp)

  02e0b	8b 45 f0	 mov	 eax, DWORD PTR _i$231807[ebp]
  02e0e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02e11	8b 54 81 54	 mov	 edx, DWORD PTR [ecx+eax*4+84]
  02e15	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  02e1b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02e20	0f bf 8c 10 be
	00 00 00	 movsx	 ecx, WORD PTR [eax+edx+190]
  02e28	8b 55 f0	 mov	 edx, DWORD PTR _i$231807[ebp]
  02e2b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02e2e	8b 54 90 54	 mov	 edx, DWORD PTR [eax+edx*4+84]
  02e32	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  02e38	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02e3d	0f bf 94 10 d0
	00 00 00	 movsx	 edx, WORD PTR [eax+edx+208]
  02e45	03 ca		 add	 ecx, edx
  02e47	89 4d f4	 mov	 DWORD PTR _level$[ebp], ecx
  02e4a	8b 45 f4	 mov	 eax, DWORD PTR _level$[ebp]
  02e4d	3b 45 f8	 cmp	 eax, DWORD PTR _temp$[ebp]
  02e50	7e 06		 jle	 SHORT $LN2@SetEventLe

; 1105 : 		{
; 1106 : 			temp = level;

  02e52	8b 45 f4	 mov	 eax, DWORD PTR _level$[ebp]
  02e55	89 45 f8	 mov	 DWORD PTR _temp$[ebp], eax
$LN2@SetEventLe:

; 1107 : 		}
; 1108 : 	}

  02e58	eb a2		 jmp	 SHORT $LN4@SetEventLe
$LN3@SetEventLe:

; 1109 : 	if(temp == -1)

  02e5a	83 7d f8 ff	 cmp	 DWORD PTR _temp$[ebp], -1
  02e5e	75 14		 jne	 SHORT $LN1@SetEventLe

; 1110 : 	{
; 1111 : 		LogAddC(2, "[DoppelGanger] ERROR: EventLevel == -1!");

  02e60	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@FOAGBNK@?$FLDoppelGanger?$FN?5ERROR?3?5EventLevel@
  02e65	6a 02		 push	 2
  02e67	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  02e6d	83 c4 08	 add	 esp, 8

; 1112 : 		return false;

  02e70	32 c0		 xor	 al, al
  02e72	eb 17		 jmp	 SHORT $LN7@SetEventLe
$LN1@SetEventLe:

; 1113 : 	}
; 1114 : 	this->m_DGData.EventLevel = temp/10;

  02e74	8b 45 f8	 mov	 eax, DWORD PTR _temp$[ebp]
  02e77	99		 cdq
  02e78	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  02e7d	f7 f9		 idiv	 ecx
  02e7f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  02e82	66 89 82 20 02
	00 00		 mov	 WORD PTR [edx+544], ax

; 1115 : 	return true;

  02e89	b0 01		 mov	 al, 1
$LN7@SetEventLe:

; 1116 : }

  02e8b	5f		 pop	 edi
  02e8c	5e		 pop	 esi
  02e8d	5b		 pop	 ebx
  02e8e	8b e5		 mov	 esp, ebp
  02e90	5d		 pop	 ebp
  02e91	c3		 ret	 0
?SetEventLevel@CDoppelGanger@@QAE_NXZ ENDP		; CDoppelGanger::SetEventLevel
_TEXT	ENDS
PUBLIC	__real@4059000000000000
PUBLIC	??C?$_Vector_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QBEPAUDG_MONSTER_STAT@@XZ ; std::_Vector_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::operator->
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::operator!=
PUBLIC	?end@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@2@XZ ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::end
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::operator++
PUBLIC	?begin@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@2@XZ ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::begin
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::_Vector_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >
PUBLIC	?SetMonsterStats@CDoppelGanger@@QAEXPAUOBJECTSTRUCT@@@Z ; CDoppelGanger::SetMonsterStats
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv290 = -88						; size = 4
tv282 = -88						; size = 4
tv274 = -88						; size = 4
tv265 = -88						; size = 4
tv258 = -88						; size = 4
tv68 = -88						; size = 4
$T232874 = -84						; size = 4
$T232875 = -80						; size = 4
_Iterator$ = -12					; size = 4
_partyinc$ = -8						; size = 2
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?SetMonsterStats@CDoppelGanger@@QAEXPAUOBJECTSTRUCT@@@Z PROC ; CDoppelGanger::SetMonsterStats
; _this$ = ecx

; 1119 : {

  02ea0	55		 push	 ebp
  02ea1	8b ec		 mov	 ebp, esp
  02ea3	83 ec 58	 sub	 esp, 88			; 00000058H
  02ea6	53		 push	 ebx
  02ea7	56		 push	 esi
  02ea8	57		 push	 edi
  02ea9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1120 : 	if(!DGUseAutoStat)

  02eac	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?DGUseAutoStat@@3HA, 0 ; DGUseAutoStat
  02eb3	75 05		 jne	 SHORT $LN12@SetMonster

; 1121 : 	{
; 1122 : 		return;

  02eb5	e9 26 02 00 00	 jmp	 $LN13@SetMonster
$LN12@SetMonster:

; 1123 : 	}
; 1124 : 
; 1125 : 	short partyinc = 0;

  02eba	33 c0		 xor	 eax, eax
  02ebc	66 89 45 f8	 mov	 WORD PTR _partyinc$[ebp], ax

; 1126 : 
; 1127 : 	switch ( this->m_DGData.PlayerCount )

  02ec0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02ec3	0f b6 48 44	 movzx	 ecx, BYTE PTR [eax+68]
  02ec7	89 4d a8	 mov	 DWORD PTR tv68[ebp], ecx
  02eca	8b 55 a8	 mov	 edx, DWORD PTR tv68[ebp]
  02ecd	83 ea 02	 sub	 edx, 2
  02ed0	89 55 a8	 mov	 DWORD PTR tv68[ebp], edx
  02ed3	83 7d a8 03	 cmp	 DWORD PTR tv68[ebp], 3
  02ed7	77 34		 ja	 SHORT $LN10@SetMonster
  02ed9	8b 45 a8	 mov	 eax, DWORD PTR tv68[ebp]
  02edc	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN15@SetMonster[eax*4]
$LN9@SetMonster:

; 1128 : 	{
; 1129 : 	case 2:
; 1130 : 		partyinc = 20;

  02ee3	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  02ee8	66 89 45 f8	 mov	 WORD PTR _partyinc$[ebp], ax

; 1131 : 		break;

  02eec	eb 1f		 jmp	 SHORT $LN10@SetMonster
$LN8@SetMonster:

; 1132 : 	case 3:
; 1133 : 		partyinc = 50;

  02eee	b8 32 00 00 00	 mov	 eax, 50			; 00000032H
  02ef3	66 89 45 f8	 mov	 WORD PTR _partyinc$[ebp], ax

; 1134 : 		break;

  02ef7	eb 14		 jmp	 SHORT $LN10@SetMonster
$LN7@SetMonster:

; 1135 : 	case 4:
; 1136 : 		partyinc = 100;

  02ef9	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  02efe	66 89 45 f8	 mov	 WORD PTR _partyinc$[ebp], ax

; 1137 : 		break;

  02f02	eb 09		 jmp	 SHORT $LN10@SetMonster
$LN6@SetMonster:

; 1138 : 	case 5:
; 1139 : 		partyinc = 170;

  02f04	b8 aa 00 00 00	 mov	 eax, 170		; 000000aaH
  02f09	66 89 45 f8	 mov	 WORD PTR _partyinc$[ebp], ax
$LN10@SetMonster:

; 1140 : 		break;
; 1141 : 	}
; 1142 : 
; 1143 : 
; 1144 : 	std::vector<DG_MONSTER_STAT>::iterator Iterator;

  02f0d	8d 4d f4	 lea	 ecx, DWORD PTR _Iterator$[ebp]
  02f10	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::_Vector_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >

; 1145 : 
; 1146 : 	for(Iterator = this->m_vtDGMobStat.begin(); Iterator != this->m_vtDGMobStat.end(); ++Iterator)

  02f15	8d 45 ac	 lea	 eax, DWORD PTR $T232874[ebp]
  02f18	50		 push	 eax
  02f19	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02f1c	81 c1 24 02 00
	00		 add	 ecx, 548		; 00000224H
  02f22	e8 00 00 00 00	 call	 ?begin@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@2@XZ ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::begin
  02f27	8b 08		 mov	 ecx, DWORD PTR [eax]
  02f29	89 4d f4	 mov	 DWORD PTR _Iterator$[ebp], ecx
  02f2c	eb 08		 jmp	 SHORT $LN5@SetMonster
$LN4@SetMonster:
  02f2e	8d 4d f4	 lea	 ecx, DWORD PTR _Iterator$[ebp]
  02f31	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::operator++
$LN5@SetMonster:
  02f36	8d 45 b0	 lea	 eax, DWORD PTR $T232875[ebp]
  02f39	50		 push	 eax
  02f3a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02f3d	81 c1 24 02 00
	00		 add	 ecx, 548		; 00000224H
  02f43	e8 00 00 00 00	 call	 ?end@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@2@XZ ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::end
  02f48	50		 push	 eax
  02f49	8d 4d f4	 lea	 ecx, DWORD PTR _Iterator$[ebp]
  02f4c	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::operator!=
  02f51	0f b6 c8	 movzx	 ecx, al
  02f54	85 c9		 test	 ecx, ecx
  02f56	0f 84 84 01 00
	00		 je	 $LN3@SetMonster

; 1147 : 	{
; 1148 : 		if(this->m_DGData.EventLevel == Iterator->EventLevel && lpObj->Class == Iterator->Class)

  02f5c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02f5f	0f bf b0 20 02
	00 00		 movsx	 esi, WORD PTR [eax+544]
  02f66	8d 4d f4	 lea	 ecx, DWORD PTR _Iterator$[ebp]
  02f69	e8 00 00 00 00	 call	 ??C?$_Vector_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QBEPAUDG_MONSTER_STAT@@XZ ; std::_Vector_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::operator->
  02f6e	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  02f71	3b f1		 cmp	 esi, ecx
  02f73	0f 85 62 01 00
	00		 jne	 $LN2@SetMonster
  02f79	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  02f7c	0f b7 b0 b8 00
	00 00		 movzx	 esi, WORD PTR [eax+184]
  02f83	8d 4d f4	 lea	 ecx, DWORD PTR _Iterator$[ebp]
  02f86	e8 00 00 00 00	 call	 ??C?$_Vector_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QBEPAUDG_MONSTER_STAT@@XZ ; std::_Vector_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::operator->
  02f8b	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  02f8f	3b f1		 cmp	 esi, ecx
  02f91	0f 85 44 01 00
	00		 jne	 $LN2@SetMonster

; 1149 : 		{
; 1150 : 			lpObj->Level = Iterator->Level;

  02f97	8d 4d f4	 lea	 ecx, DWORD PTR _Iterator$[ebp]
  02f9a	e8 00 00 00 00	 call	 ??C?$_Vector_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QBEPAUDG_MONSTER_STAT@@XZ ; std::_Vector_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::operator->
  02f9f	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  02fa2	66 8b 50 04	 mov	 dx, WORD PTR [eax+4]
  02fa6	66 89 91 be 00
	00 00		 mov	 WORD PTR [ecx+190], dx

; 1151 : 			lpObj->Life = Iterator->HP;

  02fad	8d 4d f4	 lea	 ecx, DWORD PTR _Iterator$[ebp]
  02fb0	e8 00 00 00 00	 call	 ??C?$_Vector_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QBEPAUDG_MONSTER_STAT@@XZ ; std::_Vector_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::operator->
  02fb5	db 40 08	 fild	 DWORD PTR [eax+8]
  02fb8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  02fbb	d9 98 fc 00 00
	00		 fstp	 DWORD PTR [eax+252]

; 1152 : 			lpObj->MaxLife = Iterator->HP;

  02fc1	8d 4d f4	 lea	 ecx, DWORD PTR _Iterator$[ebp]
  02fc4	e8 00 00 00 00	 call	 ??C?$_Vector_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QBEPAUDG_MONSTER_STAT@@XZ ; std::_Vector_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::operator->
  02fc9	db 40 08	 fild	 DWORD PTR [eax+8]
  02fcc	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  02fcf	d9 98 00 01 00
	00		 fstp	 DWORD PTR [eax+256]

; 1153 : 			lpObj->m_Defense = Iterator->Defense;

  02fd5	8d 4d f4	 lea	 ecx, DWORD PTR _Iterator$[ebp]
  02fd8	e8 00 00 00 00	 call	 ??C?$_Vector_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QBEPAUDG_MONSTER_STAT@@XZ ; std::_Vector_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::operator->
  02fdd	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  02fe0	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  02fe3	89 91 94 04 00
	00		 mov	 DWORD PTR [ecx+1172], edx

; 1154 : 			lpObj->m_AttackDamageMin = Iterator->DmgMin;

  02fe9	8d 4d f4	 lea	 ecx, DWORD PTR _Iterator$[ebp]
  02fec	e8 00 00 00 00	 call	 ??C?$_Vector_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QBEPAUDG_MONSTER_STAT@@XZ ; std::_Vector_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::operator->
  02ff1	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  02ff4	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  02ff7	89 91 60 04 00
	00		 mov	 DWORD PTR [ecx+1120], edx

; 1155 : 			lpObj->m_AttackDamageMax = Iterator->DmgMax;

  02ffd	8d 4d f4	 lea	 ecx, DWORD PTR _Iterator$[ebp]
  03000	e8 00 00 00 00	 call	 ??C?$_Vector_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QBEPAUDG_MONSTER_STAT@@XZ ; std::_Vector_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::operator->
  03005	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  03008	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  0300b	89 91 64 04 00
	00		 mov	 DWORD PTR [ecx+1124], edx

; 1156 : 			if(partyinc != 0)

  03011	0f bf 45 f8	 movsx	 eax, WORD PTR _partyinc$[ebp]
  03015	85 c0		 test	 eax, eax
  03017	0f 84 bc 00 00
	00		 je	 $LN1@SetMonster

; 1157 : 			{
; 1158 : 				lpObj->Life = ((lpObj->Life * partyinc)/100.0f);

  0301d	0f bf 45 f8	 movsx	 eax, WORD PTR _partyinc$[ebp]
  03021	89 45 a8	 mov	 DWORD PTR tv258[ebp], eax
  03024	db 45 a8	 fild	 DWORD PTR tv258[ebp]
  03027	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0302a	d8 89 fc 00 00
	00		 fmul	 DWORD PTR [ecx+252]
  03030	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@4059000000000000
  03036	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  03039	d9 9a fc 00 00
	00		 fstp	 DWORD PTR [edx+252]

; 1159 : 				lpObj->MaxLife = ((lpObj->MaxLife * partyinc)/100.0f);

  0303f	0f bf 45 f8	 movsx	 eax, WORD PTR _partyinc$[ebp]
  03043	89 45 a8	 mov	 DWORD PTR tv265[ebp], eax
  03046	db 45 a8	 fild	 DWORD PTR tv265[ebp]
  03049	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0304c	d8 89 00 01 00
	00		 fmul	 DWORD PTR [ecx+256]
  03052	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@4059000000000000
  03058	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0305b	d9 9a 00 01 00
	00		 fstp	 DWORD PTR [edx+256]

; 1160 : 				lpObj->m_Defense = ((lpObj->m_Defense * partyinc)/100.0f);

  03061	0f bf 45 f8	 movsx	 eax, WORD PTR _partyinc$[ebp]
  03065	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  03068	0f af 81 94 04
	00 00		 imul	 eax, DWORD PTR [ecx+1172]
  0306f	89 45 a8	 mov	 DWORD PTR tv274[ebp], eax
  03072	db 45 a8	 fild	 DWORD PTR tv274[ebp]
  03075	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@4059000000000000
  0307b	e8 00 00 00 00	 call	 __ftol2_sse
  03080	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  03083	89 82 94 04 00
	00		 mov	 DWORD PTR [edx+1172], eax

; 1161 : 				lpObj->m_AttackDamageMin = ((lpObj->m_AttackDamageMin * partyinc)/100.0f);

  03089	0f bf 45 f8	 movsx	 eax, WORD PTR _partyinc$[ebp]
  0308d	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  03090	0f af 81 60 04
	00 00		 imul	 eax, DWORD PTR [ecx+1120]
  03097	89 45 a8	 mov	 DWORD PTR tv282[ebp], eax
  0309a	db 45 a8	 fild	 DWORD PTR tv282[ebp]
  0309d	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@4059000000000000
  030a3	e8 00 00 00 00	 call	 __ftol2_sse
  030a8	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  030ab	89 82 60 04 00
	00		 mov	 DWORD PTR [edx+1120], eax

; 1162 : 				lpObj->m_AttackDamageMax = ((lpObj->m_AttackDamageMax * partyinc)/100.0f);

  030b1	0f bf 45 f8	 movsx	 eax, WORD PTR _partyinc$[ebp]
  030b5	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  030b8	0f af 81 64 04
	00 00		 imul	 eax, DWORD PTR [ecx+1124]
  030bf	89 45 a8	 mov	 DWORD PTR tv290[ebp], eax
  030c2	db 45 a8	 fild	 DWORD PTR tv290[ebp]
  030c5	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@4059000000000000
  030cb	e8 00 00 00 00	 call	 __ftol2_sse
  030d0	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  030d3	89 82 64 04 00
	00		 mov	 DWORD PTR [edx+1124], eax
$LN1@SetMonster:

; 1163 : 			}
; 1164 : 			break;

  030d9	eb 05		 jmp	 SHORT $LN3@SetMonster
$LN2@SetMonster:

; 1165 : 		}
; 1166 : 	}

  030db	e9 4e fe ff ff	 jmp	 $LN4@SetMonster
$LN3@SetMonster:
$LN13@SetMonster:

; 1167 : }

  030e0	5f		 pop	 edi
  030e1	5e		 pop	 esi
  030e2	5b		 pop	 ebx
  030e3	8b e5		 mov	 esp, ebp
  030e5	5d		 pop	 ebp
  030e6	c2 04 00	 ret	 4
  030e9	8d 49 00	 npad	 3
$LN15@SetMonster:
  030ec	00 00 00 00	 DD	 $LN9@SetMonster
  030f0	00 00 00 00	 DD	 $LN8@SetMonster
  030f4	00 00 00 00	 DD	 $LN7@SetMonster
  030f8	00 00 00 00	 DD	 $LN6@SetMonster
?SetMonsterStats@CDoppelGanger@@QAEXPAUOBJECTSTRUCT@@@Z ENDP ; CDoppelGanger::SetMonsterStats
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QAE@PAUDG_MONSTER_STAT@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::_Vector_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?begin@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@2@XZ PROC ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 782  : 		return (iterator(this->_Myfirst, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	52		 push	 edx
  00016	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00019	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QAE@PAUDG_MONSTER_STAT@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::_Vector_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >
  0001e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 783  : 		}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?begin@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@2@XZ ENDP ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::begin
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?end@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@2@XZ PROC ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 792  : 		return (iterator(this->_Mylast, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	52		 push	 edx
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QAE@PAUDG_MONSTER_STAT@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::_Vector_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >
  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 793  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?end@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@2@XZ ENDP ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::end
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UDG_MONSTER_STAT@@@std@@UDG_MONSTER_STAT@@ABU3@@std@@YAXAAV?$allocator@UDG_MONSTER_STAT@@@0@PAUDG_MONSTER_STAT@@ABU2@@Z ; std::_Cons_val<std::allocator<DG_MONSTER_STAT>,DG_MONSTER_STAT,DG_MONSTER_STAT const &>
PUBLIC	??$_Cons_val@V?$allocator@UDG_MONSTER_STAT@@@std@@UDG_MONSTER_STAT@@AAU3@@std@@YAXAAV?$allocator@UDG_MONSTER_STAT@@@0@PAUDG_MONSTER_STAT@@AAU2@@Z ; std::_Cons_val<std::allocator<DG_MONSTER_STAT>,DG_MONSTER_STAT,DG_MONSTER_STAT &>
PUBLIC	?_Orphan_range@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@IBEXPAUDG_MONSTER_STAT@@0@Z ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::_Orphan_range
PUBLIC	?_Reserve@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@IAEXI@Z ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::_Reserve
PUBLIC	?_Inside@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@IBE_NPBUDG_MONSTER_STAT@@@Z ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::_Inside
PUBLIC	??$addressof@$$CBUDG_MONSTER_STAT@@@std@@YAPBUDG_MONSTER_STAT@@ABU1@@Z ; std::addressof<DG_MONSTER_STAT const >
; Function compile flags: /Odtp /ZI
;	COMDAT ?push_back@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAEXABUDG_MONSTER_STAT@@@Z
_TEXT	SEGMENT
__Idx$232009 = -8					; size = 4
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAEXABUDG_MONSTER_STAT@@@Z PROC ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$addressof@$$CBUDG_MONSTER_STAT@@@std@@YAPBUDG_MONSTER_STAT@@ABU1@@Z ; std::addressof<DG_MONSTER_STAT const >
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Inside@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@IBE_NPBUDG_MONSTER_STAT@@@Z ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::_Inside
  00021	0f b6 c8	 movzx	 ecx, al
  00024	85 c9		 test	 ecx, ecx
  00026	74 7d		 je	 SHORT $LN4@push_back

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$addressof@$$CBUDG_MONSTER_STAT@@@std@@YAPBUDG_MONSTER_STAT@@ABU1@@Z ; std::addressof<DG_MONSTER_STAT const >
  00031	83 c4 04	 add	 esp, 4
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	2b 01		 sub	 eax, DWORD PTR [ecx]
  00039	99		 cdq
  0003a	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  0003f	f7 f9		 idiv	 ecx
  00041	89 45 f8	 mov	 DWORD PTR __Idx$232009[ebp], eax

; 980  : 			if (this->_Mylast == this->_Myend)

  00044	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0004d	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00050	75 0a		 jne	 SHORT $LN3@push_back

; 981  : 				_Reserve(1);

  00052	6a 01		 push	 1
  00054	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@IAEXI@Z ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::_Reserve
$LN3@push_back:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  0005c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00062	51		 push	 ecx
  00063	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00066	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00069	50		 push	 eax
  0006a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006d	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@IBEXPAUDG_MONSTER_STAT@@0@Z ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::_Orphan_range

; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  00072	8b 45 f8	 mov	 eax, DWORD PTR __Idx$232009[ebp]
  00075	6b c0 18	 imul	 eax, 24			; 00000018H
  00078	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	03 01		 add	 eax, DWORD PTR [ecx]
  0007d	50		 push	 eax
  0007e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00081	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00084	50		 push	 eax
  00085	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00088	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0008b	51		 push	 ecx
  0008c	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UDG_MONSTER_STAT@@@std@@UDG_MONSTER_STAT@@AAU3@@std@@YAXAAV?$allocator@UDG_MONSTER_STAT@@@0@PAUDG_MONSTER_STAT@@AAU2@@Z ; std::_Cons_val<std::allocator<DG_MONSTER_STAT>,DG_MONSTER_STAT,DG_MONSTER_STAT &>
  00091	83 c4 0c	 add	 esp, 12			; 0000000cH

; 986  : 			++this->_Mylast;

  00094	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00097	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0009a	83 c1 18	 add	 ecx, 24			; 00000018H
  0009d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000a0	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 987  : 			}
; 988  : 		else

  000a3	eb 57		 jmp	 SHORT $LN5@push_back
$LN4@push_back:

; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  000a5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ab	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000ae	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  000b1	75 0a		 jne	 SHORT $LN1@push_back

; 991  : 				_Reserve(1);

  000b3	6a 01		 push	 1
  000b5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b8	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@IAEXI@Z ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::_Reserve
$LN1@push_back:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  000bd	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000c3	51		 push	 ecx
  000c4	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c7	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000ca	50		 push	 eax
  000cb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ce	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@IBEXPAUDG_MONSTER_STAT@@0@Z ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::_Orphan_range

; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  000d3	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  000d6	50		 push	 eax
  000d7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000da	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000dd	52		 push	 edx
  000de	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000e1	83 c0 0c	 add	 eax, 12			; 0000000cH
  000e4	50		 push	 eax
  000e5	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UDG_MONSTER_STAT@@@std@@UDG_MONSTER_STAT@@ABU3@@std@@YAXAAV?$allocator@UDG_MONSTER_STAT@@@0@PAUDG_MONSTER_STAT@@ABU2@@Z ; std::_Cons_val<std::allocator<DG_MONSTER_STAT>,DG_MONSTER_STAT,DG_MONSTER_STAT const &>
  000ea	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  000ed	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000f0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000f3	83 c1 18	 add	 ecx, 24			; 00000018H
  000f6	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000f9	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN5@push_back:

; 997  : 			}
; 998  : 		}

  000fc	5f		 pop	 edi
  000fd	5e		 pop	 esi
  000fe	5b		 pop	 ebx
  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c2 04 00	 ret	 4
?push_back@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAEXABUDG_MONSTER_STAT@@@Z ENDP ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::push_back
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::_Vector_const_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::_Vector_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >, COMDAT
; _this$ = ecx

; 298  : 	_Vector_iterator()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::_Vector_const_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >

; 299  : 		{	// construct with null vector pointer
; 300  : 		}

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0?$_Vector_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::_Vector_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QBEAAUDG_MONSTER_STAT@@XZ ; std::_Vector_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::operator*
; Function compile flags: /Odtp /ZI
;	COMDAT ??C?$_Vector_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QBEPAUDG_MONSTER_STAT@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??C?$_Vector_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QBEPAUDG_MONSTER_STAT@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::operator->, COMDAT
; _this$ = ecx

; 326  : 		{	// return pointer to class object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 327  : 		return (&**this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QBEAAUDG_MONSTER_STAT@@XZ ; std::_Vector_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::operator*

; 328  : 		}

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??C?$_Vector_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QBEPAUDG_MONSTER_STAT@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::operator->
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::operator++
; Function compile flags: /Odtp /ZI
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::operator++, COMDAT
; _this$ = ecx

; 331  : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 332  : 		++*(_Mybase *)this;

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??E?$_Vector_const_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::operator++

; 333  : 		return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 334  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??E?$_Vector_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::operator==
; Function compile flags: /Odtp /ZI
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 208  : 		return (!(*this == _Right));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??8?$_Vector_const_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::operator==
  00018	0f b6 c0	 movzx	 eax, al
  0001b	f7 d8		 neg	 eax
  0001d	1b c0		 sbb	 eax, eax
  0001f	83 c0 01	 add	 eax, 1

; 209  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::operator!=
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Inside@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@IBE_NPBUDG_MONSTER_STAT@@@Z
_TEXT	SEGMENT
tv76 = -72						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@IBE_NPBUDG_MONSTER_STAT@@@Z PROC ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00012	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00015	73 13		 jae	 SHORT $LN3@Inside
  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	3b 45 08	 cmp	 eax, DWORD PTR __Ptr$[ebp]
  0001f	77 09		 ja	 SHORT $LN3@Inside
  00021	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  00028	eb 07		 jmp	 SHORT $LN4@Inside
$LN3@Inside:
  0002a	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN4@Inside:
  00031	8a 45 b8	 mov	 al, BYTE PTR tv76[ebp]

; 1287 : 		}

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?_Inside@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@IBE_NPBUDG_MONSTER_STAT@@@Z ENDP ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::_Inside
_TEXT	ENDS
PUBLIC	?reserve@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAEXI@Z ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::reserve
PUBLIC	?_Grow_to@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@IBEII@Z ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::_Grow_to
PUBLIC	?capacity@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QBEIXZ ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::capacity
PUBLIC	?_Xlen@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@IBEXXZ ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::_Xlen
PUBLIC	?max_size@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QBEIXZ ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::max_size
PUBLIC	?size@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QBEIXZ ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::size
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Reserve@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$ = -8						; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@IAEXI@Z PROC ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1291 : 		size_type _Size = size();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?size@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QBEIXZ ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::size
  00014	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax

; 1292 : 		if (max_size() - _Count < _Size)

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QBEIXZ ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::max_size
  0001f	2b 45 08	 sub	 eax, DWORD PTR __Count$[ebp]
  00022	3b 45 f8	 cmp	 eax, DWORD PTR __Size$[ebp]
  00025	73 0a		 jae	 SHORT $LN4@Reserve

; 1293 : 			_Xlen();

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@IBEXXZ ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::_Xlen
  0002f	eb 2d		 jmp	 SHORT $LN6@Reserve
$LN4@Reserve:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00031	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  00034	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]
  00037	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?capacity@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QBEIXZ ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::capacity
  00042	39 45 f8	 cmp	 DWORD PTR __Size$[ebp], eax
  00045	77 02		 ja	 SHORT $LN2@Reserve

; 1295 : 			;
; 1296 : 		else

  00047	eb 15		 jmp	 SHORT $LN6@Reserve
$LN2@Reserve:

; 1297 : 			reserve(_Grow_to(_Size));

  00049	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?_Grow_to@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@IBEII@Z ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::_Grow_to
  00055	50		 push	 eax
  00056	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ?reserve@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAEXI@Z ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::reserve
$LN6@Reserve:

; 1298 : 		}

  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?_Reserve@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@IAEXI@Z ENDP ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::_Reserve
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Orphan_range@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@IBEXPAUDG_MONSTER_STAT@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@IBEXPAUDG_MONSTER_STAT@@0@Z PROC ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1453 : 		{	// orphan iterators within specified (inclusive) range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1454 : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@IBEXPAUDG_MONSTER_STAT@@0@Z ENDP ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QAE@PAUDG_MONSTER_STAT@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::_Vector_const_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QAE@PAUDG_MONSTER_STAT@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QAE@PAUDG_MONSTER_STAT@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::_Vector_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QAE@PAUDG_MONSTER_STAT@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::_Vector_const_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >

; 305  : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QAE@PAUDG_MONSTER_STAT@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::_Vector_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QBEABUDG_MONSTER_STAT@@XZ ; std::_Vector_const_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::operator*
; Function compile flags: /Odtp /ZI
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QBEAAUDG_MONSTER_STAT@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QBEAAUDG_MONSTER_STAT@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::operator*, COMDAT
; _this$ = ecx

; 321  : 		{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 322  : 		return ((reference)**(_Mybase *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_Vector_const_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QBEABUDG_MONSTER_STAT@@XZ ; std::_Vector_const_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::operator*

; 323  : 		}

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QBEAAUDG_MONSTER_STAT@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::operator*
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::_Vector_const_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >, COMDAT
; _this$ = ecx

; 40   : 		{	// construct with null pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 41   : 		}

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0?$_Vector_const_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::_Vector_const_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_const_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::operator++, COMDAT
; _this$ = ecx

; 93   : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 94   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 95   : 		if (this->_Getcont() == 0
; 96   : 			|| this->_Ptr == 0
; 97   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 98   : 			{	// report error
; 99   : 			_DEBUG_ERROR("vector iterator not incrementable");
; 100  : 			_SCL_SECURE_OUT_OF_RANGE;
; 101  : 			}
; 102  : 
; 103  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 104  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 105  : 		_SCL_SECURE_VALIDATE_RANGE(
; 106  : 			this->_Ptr != 0
; 107  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 108  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 109  : 
; 110  : 		++this->_Ptr;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	83 c1 18	 add	 ecx, 24			; 00000018H
  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	89 0a		 mov	 DWORD PTR [edx], ecx

; 111  : 		return (*this);

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 112  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::operator++
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::_Compat
; Function compile flags: /Odtp /ZI
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		_Compat(_Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::_Compat

; 203  : 		return (this->_Ptr == _Right._Ptr);

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001e	8b 10		 mov	 edx, DWORD PTR [eax]
  00020	33 c0		 xor	 eax, eax
  00022	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00024	0f 94 c0	 sete	 al

; 204  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::operator==
_TEXT	ENDS
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Destroy@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@IAEXPAUDG_MONSTER_STAT@@0@Z ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::_Destroy
PUBLIC	?deallocate@?$allocator@UDG_MONSTER_STAT@@@std@@QAEXPAUDG_MONSTER_STAT@@I@Z ; std::allocator<DG_MONSTER_STAT>::deallocate
PUBLIC	??$_Umove@PAUDG_MONSTER_STAT@@@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@IAEPAUDG_MONSTER_STAT@@PAU2@00@Z ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::_Umove<DG_MONSTER_STAT *>
PUBLIC	?allocate@?$allocator@UDG_MONSTER_STAT@@@std@@QAEPAUDG_MONSTER_STAT@@I@Z ; std::allocator<DG_MONSTER_STAT>::allocate
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__CxxThrowException@8:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Size$232104 = -28					; size = 4
__Ptr$232097 = -24					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?reserve@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAEXI@Z PROC ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?reserve@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 747  : 		if (max_size() < _Count)

  0002f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?max_size@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QBEIXZ ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::max_size
  00037	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0003a	73 0d		 jae	 SHORT $LN5@reserve

; 748  : 			_Xlen();	// result too long

  0003c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@IBEXXZ ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::_Xlen
  00044	e9 f0 00 00 00	 jmp	 $LN7@reserve
$LN5@reserve:

; 749  : 		else if (capacity() < _Count)

  00049	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?capacity@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QBEIXZ ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::capacity
  00051	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  00054	0f 83 df 00 00
	00		 jae	 $LN7@reserve

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  0005a	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00064	e8 00 00 00 00	 call	 ?allocate@?$allocator@UDG_MONSTER_STAT@@@std@@QAEPAUDG_MONSTER_STAT@@I@Z ; std::allocator<DG_MONSTER_STAT>::allocate
  00069	89 45 e8	 mov	 DWORD PTR __Ptr$232097[ebp], eax

; 752  : 
; 753  : 			_TRY_BEGIN

  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00073	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$232097[ebp]
  00076	50		 push	 eax
  00077	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007d	52		 push	 edx
  0007e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 08		 mov	 ecx, DWORD PTR [eax]
  00083	51		 push	 ecx
  00084	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	e8 00 00 00 00	 call	 ??$_Umove@PAUDG_MONSTER_STAT@@@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@IAEPAUDG_MONSTER_STAT@@PAU2@00@Z ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::_Umove<DG_MONSTER_STAT *>
  0008c	eb 29		 jmp	 SHORT $LN8@reserve
__catch$?reserve@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  0008e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00091	50		 push	 eax
  00092	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$232097[ebp]
  00095	51		 push	 ecx
  00096	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0009c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UDG_MONSTER_STAT@@@std@@QAEXPAUDG_MONSTER_STAT@@I@Z ; std::allocator<DG_MONSTER_STAT>::deallocate

; 757  : 			_RERAISE;

  000a1	6a 00		 push	 0
  000a3	6a 00		 push	 0
  000a5	e8 00 00 00 00	 call	 __CxxThrowException@8

; 758  : 			_CATCH_END

  000aa	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000b1	b8 00 00 00 00	 mov	 eax, __tryend$?reserve@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAEXI@Z$1
  000b6	c3		 ret	 0
$LN8@reserve:
  000b7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?reserve@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAEXI@Z$1:

; 759  : 
; 760  : 			size_type _Size = size();

  000be	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	e8 00 00 00 00	 call	 ?size@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QBEIXZ ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::size
  000c6	89 45 e4	 mov	 DWORD PTR __Size$232104[ebp], eax

; 761  : 			if (this->_Myfirst != 0)

  000c9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000cc	83 38 00	 cmp	 DWORD PTR [eax], 0
  000cf	74 3a		 je	 SHORT $LN1@reserve

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);

  000d1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d7	51		 push	 ecx
  000d8	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000db	8b 02		 mov	 eax, DWORD PTR [edx]
  000dd	50		 push	 eax
  000de	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@IAEXPAUDG_MONSTER_STAT@@0@Z ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::_Destroy

; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  000e6	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000ef	2b 01		 sub	 eax, DWORD PTR [ecx]
  000f1	99		 cdq
  000f2	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  000f7	f7 f9		 idiv	 ecx
  000f9	50		 push	 eax
  000fa	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000fd	8b 02		 mov	 eax, DWORD PTR [edx]
  000ff	50		 push	 eax
  00100	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00103	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00106	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UDG_MONSTER_STAT@@@std@@QAEXPAUDG_MONSTER_STAT@@I@Z ; std::allocator<DG_MONSTER_STAT>::deallocate
$LN1@reserve:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();

  0010b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0010e	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 769  : 			this->_Myend = _Ptr + _Count;

  00113	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00116	6b c0 18	 imul	 eax, 24			; 00000018H
  00119	03 45 e8	 add	 eax, DWORD PTR __Ptr$232097[ebp]
  0011c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0011f	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 770  : 			this->_Mylast = _Ptr + _Size;

  00122	8b 45 e4	 mov	 eax, DWORD PTR __Size$232104[ebp]
  00125	6b c0 18	 imul	 eax, 24			; 00000018H
  00128	03 45 e8	 add	 eax, DWORD PTR __Ptr$232097[ebp]
  0012b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0012e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 771  : 			this->_Myfirst = _Ptr;

  00131	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00134	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$232097[ebp]
  00137	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@reserve:

; 772  : 			}
; 773  : 		}

  00139	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0013c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00143	59		 pop	 ecx
  00144	5f		 pop	 edi
  00145	5e		 pop	 esi
  00146	5b		 pop	 ebx
  00147	8b e5		 mov	 esp, ebp
  00149	5d		 pop	 ebp
  0014a	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAEXI@Z ENDP ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::reserve
; Function compile flags: /Odtp /ZI
;	COMDAT ?capacity@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?capacity@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QBEIXZ PROC ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::capacity, COMDAT
; _this$ = ecx

; 776  : 		{	// return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	99		 cdq
  00018	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  0001d	f7 f9		 idiv	 ecx

; 778  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?capacity@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QBEIXZ ENDP ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::capacity
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?size@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QBEIXZ PROC ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::size, COMDAT
; _this$ = ecx

; 878  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	99		 cdq
  00018	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  0001d	f7 f9		 idiv	 ecx

; 880  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?size@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QBEIXZ ENDP ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UDG_MONSTER_STAT@@@std@@QBEIXZ ; std::allocator<DG_MONSTER_STAT>::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?max_size@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QBEIXZ PROC ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::max_size, COMDAT
; _this$ = ecx

; 883  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		return (this->_Alval.max_size());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00012	e8 00 00 00 00	 call	 ?max_size@?$allocator@UDG_MONSTER_STAT@@@std@@QBEIXZ ; std::allocator<DG_MONSTER_STAT>::max_size

; 885  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?max_size@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QBEIXZ ENDP ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@YAXPAUDG_MONSTER_STAT@@0AAV?$allocator@UDG_MONSTER_STAT@@@0@@Z ; std::_Destroy_range<std::allocator<DG_MONSTER_STAT> >
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Destroy@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@IAEXPAUDG_MONSTER_STAT@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@IAEXPAUDG_MONSTER_STAT@@0@Z PROC ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::_Destroy, COMDAT
; _this$ = ecx

; 1269 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@YAXPAUDG_MONSTER_STAT@@0AAV?$allocator@UDG_MONSTER_STAT@@@0@@Z ; std::_Destroy_range<std::allocator<DG_MONSTER_STAT> >
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1271 : 		}

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
?_Destroy@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@IAEXPAUDG_MONSTER_STAT@@0@Z ENDP ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::_Destroy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Grow_to@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -76						; size = 4
__Capacity$ = -8					; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@IBEII@Z PROC ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1275 : 		size_type _Capacity = capacity();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?capacity@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QBEIXZ ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::capacity
  00014	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QBEIXZ ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::max_size
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  00022	d1 e9		 shr	 ecx, 1
  00024	2b c1		 sub	 eax, ecx
  00026	3b 45 f8	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  00029	73 09		 jae	 SHORT $LN4@Grow_to
  0002b	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  00032	eb 0b		 jmp	 SHORT $LN5@Grow_to
$LN4@Grow_to:
  00034	8b 55 f8	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00037	d1 ea		 shr	 edx, 1
  00039	03 55 f8	 add	 edx, DWORD PTR __Capacity$[ebp]
  0003c	89 55 b4	 mov	 DWORD PTR tv73[ebp], edx
$LN5@Grow_to:
  0003f	8b 45 b4	 mov	 eax, DWORD PTR tv73[ebp]
  00042	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1279 : 		if (_Capacity < _Count)

  00045	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00048	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0004b	73 06		 jae	 SHORT $LN1@Grow_to

; 1280 : 			_Capacity = _Count;

  0004d	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00050	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax
$LN1@Grow_to:

; 1281 : 		return (_Capacity);

  00053	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]

; 1282 : 		}

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
?_Grow_to@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@IBEII@Z ENDP ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::_Grow_to
_TEXT	ENDS
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ?_Xlen@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@IBEXXZ PROC ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::_Xlen, COMDAT
; _this$ = ecx

; 1426 : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00011	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen:

; 1428 : 		}

  00016	5f		 pop	 edi
  00017	5e		 pop	 esi
  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Xlen@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@IBEXXZ ENDP ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::_Xlen
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?deallocate@?$allocator@UDG_MONSTER_STAT@@@std@@QAEXPAUDG_MONSTER_STAT@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UDG_MONSTER_STAT@@@std@@QAEXPAUDG_MONSTER_STAT@@I@Z PROC ; std::allocator<DG_MONSTER_STAT>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 182  : 		::operator delete(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4

; 183  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?deallocate@?$allocator@UDG_MONSTER_STAT@@@std@@QAEXPAUDG_MONSTER_STAT@@I@Z ENDP ; std::allocator<DG_MONSTER_STAT>::deallocate
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QAE@PAUDG_MONSTER_STAT@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QAE@PAUDG_MONSTER_STAT@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::_Vector_const_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 47   : 		}

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QAE@PAUDG_MONSTER_STAT@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::_Vector_const_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QBEABUDG_MONSTER_STAT@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_const_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QBEABUDG_MONSTER_STAT@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::operator*, COMDAT
; _this$ = ecx

; 63   : 		{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
$LN2@operator:

; 64   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 65   : 		if (this->_Getcont() == 0
; 66   : 			|| this->_Ptr == 0
; 67   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 68   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 69   : 			{	// report error
; 70   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 71   : 			_SCL_SECURE_OUT_OF_RANGE;
; 72   : 			}
; 73   : 
; 74   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 75   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 76   : 		_SCL_SECURE_VALIDATE_RANGE(
; 77   : 			this->_Ptr != 0
; 78   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 79   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 80   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 81   : 
; 82   : 		__analysis_assume(this->_Ptr != 0);

  0000c	33 c0		 xor	 eax, eax
  0000e	75 fc		 jne	 SHORT $LN2@operator

; 83   : 
; 84   : 		return (*this->_Ptr);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 00		 mov	 eax, DWORD PTR [eax]

; 85   : 		}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QBEABUDG_MONSTER_STAT@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::operator*
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::_Compat, COMDAT
; _this$ = ecx

; 252  : 		{	// test for compatible iterator pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 253  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> > >::_Compat
_TEXT	ENDS
PUBLIC	??$_Allocate@UDG_MONSTER_STAT@@@std@@YAPAUDG_MONSTER_STAT@@IPAU1@@Z ; std::_Allocate<DG_MONSTER_STAT>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@UDG_MONSTER_STAT@@@std@@QAEPAUDG_MONSTER_STAT@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UDG_MONSTER_STAT@@@std@@QAEPAUDG_MONSTER_STAT@@I@Z PROC ; std::allocator<DG_MONSTER_STAT>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 187  : 		return (_Allocate(_Count, (pointer)0));

  0000c	6a 00		 push	 0
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Allocate@UDG_MONSTER_STAT@@@std@@YAPAUDG_MONSTER_STAT@@IPAU1@@Z ; std::_Allocate<DG_MONSTER_STAT>
  00017	83 c4 08	 add	 esp, 8

; 188  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?allocate@?$allocator@UDG_MONSTER_STAT@@@std@@QAEPAUDG_MONSTER_STAT@@I@Z ENDP ; std::allocator<DG_MONSTER_STAT>::allocate
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UDG_MONSTER_STAT@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -76						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@UDG_MONSTER_STAT@@@std@@QBEIXZ PROC ; std::allocator<DG_MONSTER_STAT>::max_size, COMDAT
; _this$ = ecx

; 217  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  0000c	c7 45 f8 aa aa
	aa 0a		 mov	 DWORD PTR __Count$[ebp], 178956970 ; 0aaaaaaaH

; 219  : 		return (0 < _Count ? _Count : 1);

  00013	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00017	76 08		 jbe	 SHORT $LN3@max_size
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0001c	89 45 b4	 mov	 DWORD PTR tv65[ebp], eax
  0001f	eb 07		 jmp	 SHORT $LN4@max_size
$LN3@max_size:
  00021	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$LN4@max_size:
  00028	8b 45 b4	 mov	 eax, DWORD PTR tv65[ebp]

; 220  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?max_size@?$allocator@UDG_MONSTER_STAT@@@std@@QBEIXZ ENDP ; std::allocator<DG_MONSTER_STAT>::max_size
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$addressof@$$CBUDG_MONSTER_STAT@@@std@@YAPBUDG_MONSTER_STAT@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUDG_MONSTER_STAT@@@std@@YAPBUDG_MONSTER_STAT@@ABU1@@Z PROC ; std::addressof<DG_MONSTER_STAT const >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 111  : 	return ((_Ty *) &(char&)_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@$$CBUDG_MONSTER_STAT@@@std@@YAPBUDG_MONSTER_STAT@@ABU1@@Z ENDP ; std::addressof<DG_MONSTER_STAT const >
_TEXT	ENDS
PUBLIC	??$construct@AAUDG_MONSTER_STAT@@@?$allocator@UDG_MONSTER_STAT@@@std@@QAEXPAUDG_MONSTER_STAT@@AAU2@@Z ; std::allocator<DG_MONSTER_STAT>::construct<DG_MONSTER_STAT &>
PUBLIC	??$forward@AAUDG_MONSTER_STAT@@@std@@YAAAUDG_MONSTER_STAT@@AAU1@@Z ; std::forward<DG_MONSTER_STAT &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UDG_MONSTER_STAT@@@std@@UDG_MONSTER_STAT@@AAU3@@std@@YAXAAV?$allocator@UDG_MONSTER_STAT@@@0@PAUDG_MONSTER_STAT@@AAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UDG_MONSTER_STAT@@@std@@UDG_MONSTER_STAT@@AAU3@@std@@YAXAAV?$allocator@UDG_MONSTER_STAT@@@0@PAUDG_MONSTER_STAT@@AAU2@@Z PROC ; std::_Cons_val<std::allocator<DG_MONSTER_STAT>,DG_MONSTER_STAT,DG_MONSTER_STAT &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@AAUDG_MONSTER_STAT@@@std@@YAAAUDG_MONSTER_STAT@@AAU1@@Z ; std::forward<DG_MONSTER_STAT &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ??$construct@AAUDG_MONSTER_STAT@@@?$allocator@UDG_MONSTER_STAT@@@std@@QAEXPAUDG_MONSTER_STAT@@AAU2@@Z ; std::allocator<DG_MONSTER_STAT>::construct<DG_MONSTER_STAT &>

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UDG_MONSTER_STAT@@@std@@UDG_MONSTER_STAT@@AAU3@@std@@YAXAAV?$allocator@UDG_MONSTER_STAT@@@0@PAUDG_MONSTER_STAT@@AAU2@@Z ENDP ; std::_Cons_val<std::allocator<DG_MONSTER_STAT>,DG_MONSTER_STAT,DG_MONSTER_STAT &>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UDG_MONSTER_STAT@@@std@@QAEXPAUDG_MONSTER_STAT@@ABU3@@Z ; std::allocator<DG_MONSTER_STAT>::construct
PUBLIC	??$forward@ABUDG_MONSTER_STAT@@@std@@YAABUDG_MONSTER_STAT@@ABU1@@Z ; std::forward<DG_MONSTER_STAT const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UDG_MONSTER_STAT@@@std@@UDG_MONSTER_STAT@@ABU3@@std@@YAXAAV?$allocator@UDG_MONSTER_STAT@@@0@PAUDG_MONSTER_STAT@@ABU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UDG_MONSTER_STAT@@@std@@UDG_MONSTER_STAT@@ABU3@@std@@YAXAAV?$allocator@UDG_MONSTER_STAT@@@0@PAUDG_MONSTER_STAT@@ABU2@@Z PROC ; std::_Cons_val<std::allocator<DG_MONSTER_STAT>,DG_MONSTER_STAT,DG_MONSTER_STAT const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@ABUDG_MONSTER_STAT@@@std@@YAABUDG_MONSTER_STAT@@ABU1@@Z ; std::forward<DG_MONSTER_STAT const &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@UDG_MONSTER_STAT@@@std@@QAEXPAUDG_MONSTER_STAT@@ABU3@@Z ; std::allocator<DG_MONSTER_STAT>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UDG_MONSTER_STAT@@@std@@UDG_MONSTER_STAT@@ABU3@@std@@YAXAAV?$allocator@UDG_MONSTER_STAT@@@0@PAUDG_MONSTER_STAT@@ABU2@@Z ENDP ; std::_Cons_val<std::allocator<DG_MONSTER_STAT>,DG_MONSTER_STAT,DG_MONSTER_STAT const &>
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAUDG_MONSTER_STAT@@PAU1@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@YAPAUDG_MONSTER_STAT@@PAU1@00AAV?$allocator@UDG_MONSTER_STAT@@@0@@Z ; std::_Uninitialized_move<DG_MONSTER_STAT *,DG_MONSTER_STAT *,std::allocator<DG_MONSTER_STAT> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??$_Umove@PAUDG_MONSTER_STAT@@@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@IAEPAUDG_MONSTER_STAT@@PAU2@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAUDG_MONSTER_STAT@@@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@IAEPAUDG_MONSTER_STAT@@PAU2@00@Z PROC ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::_Umove<DG_MONSTER_STAT *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUDG_MONSTER_STAT@@PAU1@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@YAPAUDG_MONSTER_STAT@@PAU1@00AAV?$allocator@UDG_MONSTER_STAT@@@0@@Z ; std::_Uninitialized_move<DG_MONSTER_STAT *,DG_MONSTER_STAT *,std::allocator<DG_MONSTER_STAT> >
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 1326 : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUDG_MONSTER_STAT@@@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@IAEPAUDG_MONSTER_STAT@@PAU2@00@Z ENDP ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::_Umove<DG_MONSTER_STAT *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@YAXPAUDG_MONSTER_STAT@@0AAV?$allocator@UDG_MONSTER_STAT@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<DG_MONSTER_STAT> >
PUBLIC	??$_Ptr_cat@UDG_MONSTER_STAT@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUDG_MONSTER_STAT@@0@Z ; std::_Ptr_cat<DG_MONSTER_STAT,DG_MONSTER_STAT>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@YAXPAUDG_MONSTER_STAT@@0AAV?$allocator@UDG_MONSTER_STAT@@@0@@Z
_TEXT	SEGMENT
$T232967 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@YAXPAUDG_MONSTER_STAT@@0AAV?$allocator@UDG_MONSTER_STAT@@@0@@Z PROC ; std::_Destroy_range<std::allocator<DG_MONSTER_STAT> >, COMDAT

; 87   : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UDG_MONSTER_STAT@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUDG_MONSTER_STAT@@0@Z ; std::_Ptr_cat<DG_MONSTER_STAT,DG_MONSTER_STAT>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T232967[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T232967[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@YAXPAUDG_MONSTER_STAT@@0AAV?$allocator@UDG_MONSTER_STAT@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<DG_MONSTER_STAT> >
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 89   : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Destroy_range@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@YAXPAUDG_MONSTER_STAT@@0AAV?$allocator@UDG_MONSTER_STAT@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<DG_MONSTER_STAT> >
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Allocate@UDG_MONSTER_STAT@@@std@@YAPAUDG_MONSTER_STAT@@IPAU1@@Z
_TEXT	SEGMENT
$T232970 = -80						; size = 12
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UDG_MONSTER_STAT@@@std@@YAPAUDG_MONSTER_STAT@@IPAU1@@Z PROC ; std::_Allocate<DG_MONSTER_STAT>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 31   : 	void *_Ptr = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 32   : 
; 33   : 	if (_Count <= 0)

  00010	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	77 09		 ja	 SHORT $LN4@Allocate

; 34   : 		_Count = 0;

  00016	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __Count$[ebp], 0

; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0001d	eb 39		 jmp	 SHORT $LN3@Allocate
$LN4@Allocate:

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0001f	81 7d 08 aa aa
	aa 0a		 cmp	 DWORD PTR __Count$[ebp], 178956970 ; 0aaaaaaaH
  00026	77 18		 ja	 SHORT $LN1@Allocate
  00028	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002b	6b c0 18	 imul	 eax, 24			; 00000018H
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 fc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0003a	83 7d fc 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  0003e	75 18		 jne	 SHORT $LN3@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00040	6a 00		 push	 0
  00042	8d 4d b0	 lea	 ecx, DWORD PTR $T232970[ebp]
  00045	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0004a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0004f	8d 45 b0	 lea	 eax, DWORD PTR $T232970[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Allocate:

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00058	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 40   : 	}

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
??$_Allocate@UDG_MONSTER_STAT@@@std@@YAPAUDG_MONSTER_STAT@@IPAU1@@Z ENDP ; std::_Allocate<DG_MONSTER_STAT>
_TEXT	ENDS
PUBLIC	??$_Construct@UDG_MONSTER_STAT@@ABU1@@std@@YAXPAUDG_MONSTER_STAT@@ABU1@@Z ; std::_Construct<DG_MONSTER_STAT,DG_MONSTER_STAT const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ?construct@?$allocator@UDG_MONSTER_STAT@@@std@@QAEXPAUDG_MONSTER_STAT@@ABU3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UDG_MONSTER_STAT@@@std@@QAEXPAUDG_MONSTER_STAT@@ABU3@@Z PROC ; std::allocator<DG_MONSTER_STAT>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 197  : 		_Construct(_Ptr, _Val);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ??$_Construct@UDG_MONSTER_STAT@@ABU1@@std@@YAXPAUDG_MONSTER_STAT@@ABU1@@Z ; std::_Construct<DG_MONSTER_STAT,DG_MONSTER_STAT const &>
  00019	83 c4 08	 add	 esp, 8

; 198  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
?construct@?$allocator@UDG_MONSTER_STAT@@@std@@QAEXPAUDG_MONSTER_STAT@@ABU3@@Z ENDP ; std::allocator<DG_MONSTER_STAT>::construct
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@AAUDG_MONSTER_STAT@@@std@@YAAAUDG_MONSTER_STAT@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUDG_MONSTER_STAT@@@std@@YAAAUDG_MONSTER_STAT@@AAU1@@Z PROC ; std::forward<DG_MONSTER_STAT &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAUDG_MONSTER_STAT@@@std@@YAAAUDG_MONSTER_STAT@@AAU1@@Z ENDP ; std::forward<DG_MONSTER_STAT &>
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??2@YAPAXIPAX@Z					; operator new
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$construct@AAUDG_MONSTER_STAT@@@?$allocator@UDG_MONSTER_STAT@@@std@@QAEXPAUDG_MONSTER_STAT@@AAU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@AAUDG_MONSTER_STAT@@@?$allocator@UDG_MONSTER_STAT@@@std@@QAEXPAUDG_MONSTER_STAT@@AAU2@@Z$0
__ehfuncinfo$??$construct@AAUDG_MONSTER_STAT@@@?$allocator@UDG_MONSTER_STAT@@@std@@QAEXPAUDG_MONSTER_STAT@@AAU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@AAUDG_MONSTER_STAT@@@?$allocator@UDG_MONSTER_STAT@@@std@@QAEXPAUDG_MONSTER_STAT@@AAU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$construct@AAUDG_MONSTER_STAT@@@?$allocator@UDG_MONSTER_STAT@@@std@@QAEXPAUDG_MONSTER_STAT@@AAU2@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T232977 = -88						; size = 4
$T232978 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAUDG_MONSTER_STAT@@@?$allocator@UDG_MONSTER_STAT@@@std@@QAEXPAUDG_MONSTER_STAT@@AAU2@@Z PROC ; std::allocator<DG_MONSTER_STAT>::construct<DG_MONSTER_STAT &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@AAUDG_MONSTER_STAT@@@?$allocator@UDG_MONSTER_STAT@@@std@@QAEXPAUDG_MONSTER_STAT@@AAU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 18		 push	 24			; 00000018H
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T232978[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T232978[ebp], 0
  00047	74 39		 je	 SHORT $LN3@construct
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@AAUDG_MONSTER_STAT@@@std@@YAAAUDG_MONSTER_STAT@@AAU1@@Z ; std::forward<DG_MONSTER_STAT &>
  00052	83 c4 04	 add	 esp, 4
  00055	8b 55 ac	 mov	 edx, DWORD PTR $T232978[ebp]
  00058	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005a	89 0a		 mov	 DWORD PTR [edx], ecx
  0005c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005f	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00062	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00065	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00068	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0006b	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  0006e	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00071	89 4a 10	 mov	 DWORD PTR [edx+16], ecx
  00074	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00077	89 42 14	 mov	 DWORD PTR [edx+20], eax
  0007a	8b 4d ac	 mov	 ecx, DWORD PTR $T232978[ebp]
  0007d	89 4d a4	 mov	 DWORD PTR tv74[ebp], ecx
  00080	eb 07		 jmp	 SHORT $LN4@construct
$LN3@construct:
  00082	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct:
  00089	8b 55 a4	 mov	 edx, DWORD PTR tv74[ebp]
  0008c	89 55 a8	 mov	 DWORD PTR $T232977[ebp], edx
  0008f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 209  : 		}

  00096	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00099	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a0	59		 pop	 ecx
  000a1	5f		 pop	 edi
  000a2	5e		 pop	 esi
  000a3	5b		 pop	 ebx
  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@AAUDG_MONSTER_STAT@@@?$allocator@UDG_MONSTER_STAT@@@std@@QAEXPAUDG_MONSTER_STAT@@AAU2@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T232978[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@AAUDG_MONSTER_STAT@@@?$allocator@UDG_MONSTER_STAT@@@std@@QAEXPAUDG_MONSTER_STAT@@AAU2@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@AAUDG_MONSTER_STAT@@@?$allocator@UDG_MONSTER_STAT@@@std@@QAEXPAUDG_MONSTER_STAT@@AAU2@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@AAUDG_MONSTER_STAT@@@?$allocator@UDG_MONSTER_STAT@@@std@@QAEXPAUDG_MONSTER_STAT@@AAU2@@Z ENDP ; std::allocator<DG_MONSTER_STAT>::construct<DG_MONSTER_STAT &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 81   :         {return (_Where); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 83   :         {return; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@ABUDG_MONSTER_STAT@@@std@@YAABUDG_MONSTER_STAT@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUDG_MONSTER_STAT@@@std@@YAABUDG_MONSTER_STAT@@ABU1@@Z PROC ; std::forward<DG_MONSTER_STAT const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@ABUDG_MONSTER_STAT@@@std@@YAABUDG_MONSTER_STAT@@ABU1@@Z ENDP ; std::forward<DG_MONSTER_STAT const &>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUDG_MONSTER_STAT@@PAU1@V?$allocator@UDG_MONSTER_STAT@@@std@@U1@@std@@YAPAUDG_MONSTER_STAT@@PAU1@00AAV?$allocator@UDG_MONSTER_STAT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<DG_MONSTER_STAT *,DG_MONSTER_STAT *,std::allocator<DG_MONSTER_STAT>,DG_MONSTER_STAT>
PUBLIC	??$_Val_type@PAUDG_MONSTER_STAT@@@std@@YAPAUDG_MONSTER_STAT@@PAU1@@Z ; std::_Val_type<DG_MONSTER_STAT *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_move@PAUDG_MONSTER_STAT@@PAU1@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@YAPAUDG_MONSTER_STAT@@PAU1@00AAV?$allocator@UDG_MONSTER_STAT@@@0@@Z
_TEXT	SEGMENT
$T232996 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUDG_MONSTER_STAT@@PAU1@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@YAPAUDG_MONSTER_STAT@@PAU1@00AAV?$allocator@UDG_MONSTER_STAT@@@0@@Z PROC ; std::_Uninitialized_move<DG_MONSTER_STAT *,DG_MONSTER_STAT *,std::allocator<DG_MONSTER_STAT> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UDG_MONSTER_STAT@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUDG_MONSTER_STAT@@0@Z ; std::_Ptr_cat<DG_MONSTER_STAT,DG_MONSTER_STAT>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T232996[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T232996[ebp]
  00020	52		 push	 edx
  00021	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??$_Val_type@PAUDG_MONSTER_STAT@@@std@@YAPAUDG_MONSTER_STAT@@PAU1@@Z ; std::_Val_type<DG_MONSTER_STAT *>
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00031	51		 push	 ecx
  00032	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00035	52		 push	 edx
  00036	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUDG_MONSTER_STAT@@PAU1@V?$allocator@UDG_MONSTER_STAT@@@std@@U1@@std@@YAPAUDG_MONSTER_STAT@@PAU1@00AAV?$allocator@UDG_MONSTER_STAT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<DG_MONSTER_STAT *,DG_MONSTER_STAT *,std::allocator<DG_MONSTER_STAT>,DG_MONSTER_STAT>
  00043	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
??$_Uninitialized_move@PAUDG_MONSTER_STAT@@PAU1@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@YAPAUDG_MONSTER_STAT@@PAU1@00AAV?$allocator@UDG_MONSTER_STAT@@@0@@Z ENDP ; std::_Uninitialized_move<DG_MONSTER_STAT *,DG_MONSTER_STAT *,std::allocator<DG_MONSTER_STAT> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@UDG_MONSTER_STAT@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUDG_MONSTER_STAT@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UDG_MONSTER_STAT@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUDG_MONSTER_STAT@@0@Z PROC ; std::_Ptr_cat<DG_MONSTER_STAT,DG_MONSTER_STAT>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00009	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Ptr_cat@UDG_MONSTER_STAT@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUDG_MONSTER_STAT@@0@Z ENDP ; std::_Ptr_cat<DG_MONSTER_STAT,DG_MONSTER_STAT>
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@UDG_MONSTER_STAT@@@std@@UDG_MONSTER_STAT@@@std@@YAXAAV?$allocator@UDG_MONSTER_STAT@@@0@PAUDG_MONSTER_STAT@@@Z ; std::_Dest_val<std::allocator<DG_MONSTER_STAT>,DG_MONSTER_STAT>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@YAXPAUDG_MONSTER_STAT@@0AAV?$allocator@UDG_MONSTER_STAT@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@YAXPAUDG_MONSTER_STAT@@0AAV?$allocator@UDG_MONSTER_STAT@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<DG_MONSTER_STAT> >, COMDAT

; 95   : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 96   : 	for (; _First != _Last; ++_First)

  00009	eb 09		 jmp	 SHORT $LN3@Destroy_ra
$LN2@Destroy_ra:
  0000b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000e	83 c0 18	 add	 eax, 24			; 00000018H
  00011	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra:
  00014	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00017	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0001a	74 12		 je	 SHORT $LN4@Destroy_ra

; 97   : 		_Dest_val(_Al, _First);

  0001c	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@UDG_MONSTER_STAT@@@std@@UDG_MONSTER_STAT@@@std@@YAXAAV?$allocator@UDG_MONSTER_STAT@@@0@PAUDG_MONSTER_STAT@@@Z ; std::_Dest_val<std::allocator<DG_MONSTER_STAT>,DG_MONSTER_STAT>
  00029	83 c4 08	 add	 esp, 8
  0002c	eb dd		 jmp	 SHORT $LN2@Destroy_ra
$LN4@Destroy_ra:

; 98   : 	}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$_Destroy_range@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@YAXPAUDG_MONSTER_STAT@@0AAV?$allocator@UDG_MONSTER_STAT@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<DG_MONSTER_STAT> >
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Construct@UDG_MONSTER_STAT@@ABU1@@std@@YAXPAUDG_MONSTER_STAT@@ABU1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@UDG_MONSTER_STAT@@ABU1@@std@@YAXPAUDG_MONSTER_STAT@@ABU1@@Z$0
__ehfuncinfo$??$_Construct@UDG_MONSTER_STAT@@ABU1@@std@@YAXPAUDG_MONSTER_STAT@@ABU1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@UDG_MONSTER_STAT@@ABU1@@std@@YAXPAUDG_MONSTER_STAT@@ABU1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Construct@UDG_MONSTER_STAT@@ABU1@@std@@YAXPAUDG_MONSTER_STAT@@ABU1@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T233003 = -88						; size = 4
$T233004 = -84						; size = 4
__Vptr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UDG_MONSTER_STAT@@ABU1@@std@@YAXPAUDG_MONSTER_STAT@@ABU1@@Z PROC ; std::_Construct<DG_MONSTER_STAT,DG_MONSTER_STAT const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Construct@UDG_MONSTER_STAT@@ABU1@@std@@YAXPAUDG_MONSTER_STAT@@ABU1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 47   : 	void _FARQ *_Vptr = _Ptr;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002b	89 45 f0	 mov	 DWORD PTR __Vptr$[ebp], eax

; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  0002e	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00031	50		 push	 eax
  00032	6a 18		 push	 24			; 00000018H
  00034	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00039	83 c4 08	 add	 esp, 8
  0003c	89 45 ac	 mov	 DWORD PTR $T233004[ebp], eax
  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00046	83 7d ac 00	 cmp	 DWORD PTR $T233004[ebp], 0
  0004a	74 39		 je	 SHORT $LN3@Construct
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ??$forward@ABUDG_MONSTER_STAT@@@std@@YAABUDG_MONSTER_STAT@@ABU1@@Z ; std::forward<DG_MONSTER_STAT const &>
  00055	83 c4 04	 add	 esp, 4
  00058	8b 55 ac	 mov	 edx, DWORD PTR $T233004[ebp]
  0005b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005d	89 0a		 mov	 DWORD PTR [edx], ecx
  0005f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00062	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00065	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00068	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  0006b	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0006e	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  00071	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00074	89 4a 10	 mov	 DWORD PTR [edx+16], ecx
  00077	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0007a	89 42 14	 mov	 DWORD PTR [edx+20], eax
  0007d	8b 4d ac	 mov	 ecx, DWORD PTR $T233004[ebp]
  00080	89 4d a4	 mov	 DWORD PTR tv74[ebp], ecx
  00083	eb 07		 jmp	 SHORT $LN4@Construct
$LN3@Construct:
  00085	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@Construct:
  0008c	8b 55 a4	 mov	 edx, DWORD PTR tv74[ebp]
  0008f	89 55 a8	 mov	 DWORD PTR $T233003[ebp], edx
  00092	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 49   : 	}

  00099	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a3	59		 pop	 ecx
  000a4	5f		 pop	 edi
  000a5	5e		 pop	 esi
  000a6	5b		 pop	 ebx
  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@UDG_MONSTER_STAT@@ABU1@@std@@YAXPAUDG_MONSTER_STAT@@ABU1@@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T233004[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Construct@UDG_MONSTER_STAT@@ABU1@@std@@YAXPAUDG_MONSTER_STAT@@ABU1@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Construct@UDG_MONSTER_STAT@@ABU1@@std@@YAXPAUDG_MONSTER_STAT@@ABU1@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Construct@UDG_MONSTER_STAT@@ABU1@@std@@YAXPAUDG_MONSTER_STAT@@ABU1@@Z ENDP ; std::_Construct<DG_MONSTER_STAT,DG_MONSTER_STAT const &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAUDG_MONSTER_STAT@@@std@@YAPAUDG_MONSTER_STAT@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUDG_MONSTER_STAT@@@std@@YAPAUDG_MONSTER_STAT@@PAU1@@Z PROC ; std::_Val_type<DG_MONSTER_STAT *>, COMDAT

; 789  : 	{	// return value type from arbitrary argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 790  : 	return (0);

  00009	33 c0		 xor	 eax, eax

; 791  : 	}

  0000b	5f		 pop	 edi
  0000c	5e		 pop	 esi
  0000d	5b		 pop	 ebx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Val_type@PAUDG_MONSTER_STAT@@@std@@YAPAUDG_MONSTER_STAT@@PAU1@@Z ENDP ; std::_Val_type<DG_MONSTER_STAT *>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UDG_MONSTER_STAT@@@std@@UDG_MONSTER_STAT@@U3@@std@@YAXAAV?$allocator@UDG_MONSTER_STAT@@@0@PAUDG_MONSTER_STAT@@$$QAU2@@Z ; std::_Cons_val<std::allocator<DG_MONSTER_STAT>,DG_MONSTER_STAT,DG_MONSTER_STAT>
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_move@PAUDG_MONSTER_STAT@@PAU1@V?$allocator@UDG_MONSTER_STAT@@@std@@U1@@std@@YAPAUDG_MONSTER_STAT@@PAU1@00AAV?$allocator@UDG_MONSTER_STAT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_move@PAUDG_MONSTER_STAT@@PAU1@V?$allocator@UDG_MONSTER_STAT@@@std@@U1@@std@@YAPAUDG_MONSTER_STAT@@PAU1@00AAV?$allocator@UDG_MONSTER_STAT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_move@PAUDG_MONSTER_STAT@@PAU1@V?$allocator@UDG_MONSTER_STAT@@@std@@U1@@std@@YAPAUDG_MONSTER_STAT@@PAU1@00AAV?$allocator@UDG_MONSTER_STAT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_move@PAUDG_MONSTER_STAT@@PAU1@V?$allocator@UDG_MONSTER_STAT@@@std@@U1@@std@@YAPAUDG_MONSTER_STAT@@PAU1@00AAV?$allocator@UDG_MONSTER_STAT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_move@PAUDG_MONSTER_STAT@@PAU1@V?$allocator@UDG_MONSTER_STAT@@@std@@U1@@std@@YAPAUDG_MONSTER_STAT@@PAU1@00AAV?$allocator@UDG_MONSTER_STAT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_move@PAUDG_MONSTER_STAT@@PAU1@V?$allocator@UDG_MONSTER_STAT@@@std@@U1@@std@@YAPAUDG_MONSTER_STAT@@PAU1@00AAV?$allocator@UDG_MONSTER_STAT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_move@PAUDG_MONSTER_STAT@@PAU1@V?$allocator@UDG_MONSTER_STAT@@@std@@U1@@std@@YAPAUDG_MONSTER_STAT@@PAU1@00AAV?$allocator@UDG_MONSTER_STAT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_move@PAUDG_MONSTER_STAT@@PAU1@V?$allocator@UDG_MONSTER_STAT@@@std@@U1@@std@@YAPAUDG_MONSTER_STAT@@PAU1@00AAV?$allocator@UDG_MONSTER_STAT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Uninit_move@PAUDG_MONSTER_STAT@@PAU1@V?$allocator@UDG_MONSTER_STAT@@@std@@U1@@std@@YAPAUDG_MONSTER_STAT@@PAU1@00AAV?$allocator@UDG_MONSTER_STAT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUDG_MONSTER_STAT@@PAU1@V?$allocator@UDG_MONSTER_STAT@@@std@@U1@@std@@YAPAUDG_MONSTER_STAT@@PAU1@00AAV?$allocator@UDG_MONSTER_STAT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<DG_MONSTER_STAT *,DG_MONSTER_STAT *,std::allocator<DG_MONSTER_STAT>,DG_MONSTER_STAT>, COMDAT

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_move@PAUDG_MONSTER_STAT@@PAU1@V?$allocator@UDG_MONSTER_STAT@@@std@@U1@@std@@YAPAUDG_MONSTER_STAT@@PAU1@00AAV?$allocator@UDG_MONSTER_STAT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 44	 sub	 esp, 68			; 00000044H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;

  0002c	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0002f	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 428  : 
; 429  : 	_TRY_BEGIN

  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00039	eb 12		 jmp	 SHORT $LN6@Uninit_mov
$LN5@Uninit_mov:

; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  0003b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0003e	83 c0 18	 add	 eax, 24			; 00000018H
  00041	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00044	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00047	83 c1 18	 add	 ecx, 24			; 00000018H
  0004a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN6@Uninit_mov:
  0004d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00050	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00053	74 16		 je	 SHORT $LN4@Uninit_mov

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

  00055	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00058	50		 push	 eax
  00059	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0005c	51		 push	 ecx
  0005d	8b 55 14	 mov	 edx, DWORD PTR __Al$[ebp]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UDG_MONSTER_STAT@@@std@@UDG_MONSTER_STAT@@U3@@std@@YAXAAV?$allocator@UDG_MONSTER_STAT@@@0@PAUDG_MONSTER_STAT@@$$QAU2@@Z ; std::_Cons_val<std::allocator<DG_MONSTER_STAT>,DG_MONSTER_STAT,DG_MONSTER_STAT>
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
  00069	eb d0		 jmp	 SHORT $LN5@Uninit_mov
$LN4@Uninit_mov:
  0006b	eb 3b		 jmp	 SHORT $LN10@Uninit_mov
__catch$??$_Uninit_move@PAUDG_MONSTER_STAT@@PAU1@V?$allocator@UDG_MONSTER_STAT@@@std@@U1@@std@@YAPAUDG_MONSTER_STAT@@PAU1@00AAV?$allocator@UDG_MONSTER_STAT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 432  : 	_CATCH_ALL

  0006d	eb 09		 jmp	 SHORT $LN3@Uninit_mov
$LN2@Uninit_mov:

; 433  : 	for (; _Next != _Dest; ++_Next)

  0006f	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00072	83 c0 18	 add	 eax, 24			; 00000018H
  00075	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax
$LN3@Uninit_mov:
  00078	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  0007b	3b 45 10	 cmp	 eax, DWORD PTR __Dest$[ebp]
  0007e	74 12		 je	 SHORT $LN1@Uninit_mov

; 434  : 		_Dest_val(_Al, _Next);

  00080	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00083	50		 push	 eax
  00084	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@UDG_MONSTER_STAT@@@std@@UDG_MONSTER_STAT@@@std@@YAXAAV?$allocator@UDG_MONSTER_STAT@@@0@PAUDG_MONSTER_STAT@@@Z ; std::_Dest_val<std::allocator<DG_MONSTER_STAT>,DG_MONSTER_STAT>
  0008d	83 c4 08	 add	 esp, 8
  00090	eb dd		 jmp	 SHORT $LN2@Uninit_mov
$LN1@Uninit_mov:

; 435  : 	_RERAISE;

  00092	6a 00		 push	 0
  00094	6a 00		 push	 0
  00096	e8 00 00 00 00	 call	 __CxxThrowException@8

; 436  : 	_CATCH_END

  0009b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000a2	b8 00 00 00 00	 mov	 eax, __tryend$??$_Uninit_move@PAUDG_MONSTER_STAT@@PAU1@V?$allocator@UDG_MONSTER_STAT@@@std@@U1@@std@@YAPAUDG_MONSTER_STAT@@PAU1@00AAV?$allocator@UDG_MONSTER_STAT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1
  000a7	c3		 ret	 0
$LN10@Uninit_mov:
  000a8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_move@PAUDG_MONSTER_STAT@@PAU1@V?$allocator@UDG_MONSTER_STAT@@@std@@U1@@std@@YAPAUDG_MONSTER_STAT@@PAU1@00AAV?$allocator@UDG_MONSTER_STAT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1:

; 437  : 	return (_Dest);

  000af	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_mov:

; 438  : 	}

  000b2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000b5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000bc	59		 pop	 ecx
  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_move@PAUDG_MONSTER_STAT@@PAU1@V?$allocator@UDG_MONSTER_STAT@@@std@@U1@@std@@YAPAUDG_MONSTER_STAT@@PAU1@00AAV?$allocator@UDG_MONSTER_STAT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninit_move@PAUDG_MONSTER_STAT@@PAU1@V?$allocator@UDG_MONSTER_STAT@@@std@@U1@@std@@YAPAUDG_MONSTER_STAT@@PAU1@00AAV?$allocator@UDG_MONSTER_STAT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninit_move@PAUDG_MONSTER_STAT@@PAU1@V?$allocator@UDG_MONSTER_STAT@@@std@@U1@@std@@YAPAUDG_MONSTER_STAT@@PAU1@00AAV?$allocator@UDG_MONSTER_STAT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<DG_MONSTER_STAT *,DG_MONSTER_STAT *,std::allocator<DG_MONSTER_STAT>,DG_MONSTER_STAT>
PUBLIC	?destroy@?$allocator@UDG_MONSTER_STAT@@@std@@QAEXPAUDG_MONSTER_STAT@@@Z ; std::allocator<DG_MONSTER_STAT>::destroy
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Dest_val@V?$allocator@UDG_MONSTER_STAT@@@std@@UDG_MONSTER_STAT@@@std@@YAXAAV?$allocator@UDG_MONSTER_STAT@@@0@PAUDG_MONSTER_STAT@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@UDG_MONSTER_STAT@@@std@@UDG_MONSTER_STAT@@@std@@YAXAAV?$allocator@UDG_MONSTER_STAT@@@0@PAUDG_MONSTER_STAT@@@Z PROC ; std::_Dest_val<std::allocator<DG_MONSTER_STAT>,DG_MONSTER_STAT>, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 287  : 	_Alval.destroy(_Pdest);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  00010	e8 00 00 00 00	 call	 ?destroy@?$allocator@UDG_MONSTER_STAT@@@std@@QAEXPAUDG_MONSTER_STAT@@@Z ; std::allocator<DG_MONSTER_STAT>::destroy

; 288  : 	}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Dest_val@V?$allocator@UDG_MONSTER_STAT@@@std@@UDG_MONSTER_STAT@@@std@@YAXAAV?$allocator@UDG_MONSTER_STAT@@@0@PAUDG_MONSTER_STAT@@@Z ENDP ; std::_Dest_val<std::allocator<DG_MONSTER_STAT>,DG_MONSTER_STAT>
_TEXT	ENDS
PUBLIC	??$_Destroy@UDG_MONSTER_STAT@@@std@@YAXPAUDG_MONSTER_STAT@@@Z ; std::_Destroy<DG_MONSTER_STAT>
; Function compile flags: /Odtp /ZI
;	COMDAT ?destroy@?$allocator@UDG_MONSTER_STAT@@@std@@QAEXPAUDG_MONSTER_STAT@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UDG_MONSTER_STAT@@@std@@QAEXPAUDG_MONSTER_STAT@@@Z PROC ; std::allocator<DG_MONSTER_STAT>::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 213  : 		_Destroy(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Destroy@UDG_MONSTER_STAT@@@std@@YAXPAUDG_MONSTER_STAT@@@Z ; std::_Destroy<DG_MONSTER_STAT>
  00015	83 c4 04	 add	 esp, 4

; 214  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?destroy@?$allocator@UDG_MONSTER_STAT@@@std@@QAEXPAUDG_MONSTER_STAT@@@Z ENDP ; std::allocator<DG_MONSTER_STAT>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UDG_MONSTER_STAT@@@std@@QAEXPAUDG_MONSTER_STAT@@$$QAU3@@Z ; std::allocator<DG_MONSTER_STAT>::construct
PUBLIC	??$forward@UDG_MONSTER_STAT@@@std@@YA$$QAUDG_MONSTER_STAT@@AAU1@@Z ; std::forward<DG_MONSTER_STAT>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UDG_MONSTER_STAT@@@std@@UDG_MONSTER_STAT@@U3@@std@@YAXAAV?$allocator@UDG_MONSTER_STAT@@@0@PAUDG_MONSTER_STAT@@$$QAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UDG_MONSTER_STAT@@@std@@UDG_MONSTER_STAT@@U3@@std@@YAXAAV?$allocator@UDG_MONSTER_STAT@@@0@PAUDG_MONSTER_STAT@@$$QAU2@@Z PROC ; std::_Cons_val<std::allocator<DG_MONSTER_STAT>,DG_MONSTER_STAT,DG_MONSTER_STAT>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@UDG_MONSTER_STAT@@@std@@YA$$QAUDG_MONSTER_STAT@@AAU1@@Z ; std::forward<DG_MONSTER_STAT>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@UDG_MONSTER_STAT@@@std@@QAEXPAUDG_MONSTER_STAT@@$$QAU3@@Z ; std::allocator<DG_MONSTER_STAT>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UDG_MONSTER_STAT@@@std@@UDG_MONSTER_STAT@@U3@@std@@YAXAAV?$allocator@UDG_MONSTER_STAT@@@0@PAUDG_MONSTER_STAT@@$$QAU2@@Z ENDP ; std::_Cons_val<std::allocator<DG_MONSTER_STAT>,DG_MONSTER_STAT,DG_MONSTER_STAT>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Destroy@UDG_MONSTER_STAT@@@std@@YAXPAUDG_MONSTER_STAT@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UDG_MONSTER_STAT@@@std@@YAXPAUDG_MONSTER_STAT@@@Z PROC ; std::_Destroy<DG_MONSTER_STAT>, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Destroy@UDG_MONSTER_STAT@@@std@@YAXPAUDG_MONSTER_STAT@@@Z ENDP ; std::_Destroy<DG_MONSTER_STAT>
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@UDG_MONSTER_STAT@@@std@@QAEXPAUDG_MONSTER_STAT@@$$QAU3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@UDG_MONSTER_STAT@@@std@@QAEXPAUDG_MONSTER_STAT@@$$QAU3@@Z$0
__ehfuncinfo$?construct@?$allocator@UDG_MONSTER_STAT@@@std@@QAEXPAUDG_MONSTER_STAT@@$$QAU3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@UDG_MONSTER_STAT@@@std@@QAEXPAUDG_MONSTER_STAT@@$$QAU3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@UDG_MONSTER_STAT@@@std@@QAEXPAUDG_MONSTER_STAT@@$$QAU3@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T233041 = -88						; size = 4
$T233042 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UDG_MONSTER_STAT@@@std@@QAEXPAUDG_MONSTER_STAT@@$$QAU3@@Z PROC ; std::allocator<DG_MONSTER_STAT>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?construct@?$allocator@UDG_MONSTER_STAT@@@std@@QAEXPAUDG_MONSTER_STAT@@$$QAU3@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 18		 push	 24			; 00000018H
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T233042[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T233042[ebp], 0
  00047	74 39		 je	 SHORT $LN3@construct@2
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@UDG_MONSTER_STAT@@@std@@YA$$QAUDG_MONSTER_STAT@@AAU1@@Z ; std::forward<DG_MONSTER_STAT>
  00052	83 c4 04	 add	 esp, 4
  00055	8b 55 ac	 mov	 edx, DWORD PTR $T233042[ebp]
  00058	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005a	89 0a		 mov	 DWORD PTR [edx], ecx
  0005c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005f	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00062	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00065	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00068	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0006b	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  0006e	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00071	89 4a 10	 mov	 DWORD PTR [edx+16], ecx
  00074	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00077	89 42 14	 mov	 DWORD PTR [edx+20], eax
  0007a	8b 4d ac	 mov	 ecx, DWORD PTR $T233042[ebp]
  0007d	89 4d a4	 mov	 DWORD PTR tv74[ebp], ecx
  00080	eb 07		 jmp	 SHORT $LN4@construct@2
$LN3@construct@2:
  00082	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct@2:
  00089	8b 55 a4	 mov	 edx, DWORD PTR tv74[ebp]
  0008c	89 55 a8	 mov	 DWORD PTR $T233041[ebp], edx
  0008f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 203  : 		}

  00096	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00099	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a0	59		 pop	 ecx
  000a1	5f		 pop	 edi
  000a2	5e		 pop	 esi
  000a3	5b		 pop	 ebx
  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@UDG_MONSTER_STAT@@@std@@QAEXPAUDG_MONSTER_STAT@@$$QAU3@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T233042[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$?construct@?$allocator@UDG_MONSTER_STAT@@@std@@QAEXPAUDG_MONSTER_STAT@@$$QAU3@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?construct@?$allocator@UDG_MONSTER_STAT@@@std@@QAEXPAUDG_MONSTER_STAT@@$$QAU3@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@UDG_MONSTER_STAT@@@std@@QAEXPAUDG_MONSTER_STAT@@$$QAU3@@Z ENDP ; std::allocator<DG_MONSTER_STAT>::construct
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@UDG_MONSTER_STAT@@@std@@YA$$QAUDG_MONSTER_STAT@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UDG_MONSTER_STAT@@@std@@YA$$QAUDG_MONSTER_STAT@@AAU1@@Z PROC ; std::forward<DG_MONSTER_STAT>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@UDG_MONSTER_STAT@@@std@@YA$$QAUDG_MONSTER_STAT@@AAU1@@Z ENDP ; std::forward<DG_MONSTER_STAT>
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File d:\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
; Function compile flags: /Odtp /ZI
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ ; std::bad_alloc::~bad_alloc
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 37   : 		{	// orphan all iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 38   : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 48   : 		{	// adopt this iterator by parent

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 49   : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??0CDoppelGanger@@QAE@XZ			; CDoppelGanger::CDoppelGanger
EXTRN	_atexit:PROC
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\doublegoer.cpp
;	COMDAT ??__Eg_DoppelGanger@@YAXXZ
text$yc	SEGMENT
??__Eg_DoppelGanger@@YAXXZ PROC				; `dynamic initializer for 'g_DoppelGanger'', COMDAT

; 19   : CDoppelGanger g_DoppelGanger;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_DoppelGanger@@3VCDoppelGanger@@A ; g_DoppelGanger
  0000e	e8 00 00 00 00	 call	 ??0CDoppelGanger@@QAE@XZ
  00013	68 00 00 00 00	 push	 OFFSET ??__Fg_DoppelGanger@@YAXXZ ; `dynamic atexit destructor for 'g_DoppelGanger''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??__Eg_DoppelGanger@@YAXXZ ENDP				; `dynamic initializer for 'g_DoppelGanger''
text$yc	ENDS
PUBLIC	??0?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAE@XZ ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >
; Function compile flags: /Odtp /ZI
;	COMDAT ??0CDoppelGanger@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CDoppelGanger@@QAE@XZ PROC				; CDoppelGanger::CDoppelGanger, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	81 c1 24 02 00
	00		 add	 ecx, 548		; 00000224H
  00015	e8 00 00 00 00	 call	 ??0?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAE@XZ ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??0CDoppelGanger@@QAE@XZ ENDP				; CDoppelGanger::CDoppelGanger
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAE@V?$allocator@UDG_MONSTER_STAT@@@1@@Z ; std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >
PUBLIC	??0?$allocator@UDG_MONSTER_STAT@@@std@@QAE@XZ	; std::allocator<DG_MONSTER_STAT>::allocator<DG_MONSTER_STAT>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T233075 = -72						; size = 4
_this$ = -4						; size = 4
??0?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAE@XZ PROC ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	51		 push	 ecx
  0000d	8b cc		 mov	 ecx, esp
  0000f	89 65 b8	 mov	 DWORD PTR $T233075[ebp], esp
  00012	e8 00 00 00 00	 call	 ??0?$allocator@UDG_MONSTER_STAT@@@std@@QAE@XZ ; std::allocator<DG_MONSTER_STAT>::allocator<DG_MONSTER_STAT>
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAE@V?$allocator@UDG_MONSTER_STAT@@@1@@Z ; std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >

; 508  : 		}

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAE@XZ ENDP ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >
_TEXT	ENDS
PUBLIC	??0?$allocator@UDG_MONSTER_STAT@@@std@@QAE@ABV01@@Z ; std::allocator<DG_MONSTER_STAT>::allocator<DG_MONSTER_STAT>
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAE@V?$allocator@UDG_MONSTER_STAT@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAE@V?$allocator@UDG_MONSTER_STAT@@@1@@Z PROC ; std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00016	e8 00 00 00 00	 call	 ??0?$allocator@UDG_MONSTER_STAT@@@std@@QAE@ABV01@@Z ; std::allocator<DG_MONSTER_STAT>::allocator<DG_MONSTER_STAT>

; 427  : 		_Myfirst = 0;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 428  : 		_Mylast = 0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 429  : 		_Myend = 0;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 430  : 		}

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
??0?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAE@V?$allocator@UDG_MONSTER_STAT@@@1@@Z ENDP ; std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UDG_MONSTER_STAT@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@UDG_MONSTER_STAT@@@std@@QAE@XZ PROC	; std::allocator<DG_MONSTER_STAT>::allocator<DG_MONSTER_STAT>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@UDG_MONSTER_STAT@@@std@@QAE@XZ ENDP	; std::allocator<DG_MONSTER_STAT>::allocator<DG_MONSTER_STAT>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0?$allocator@UDG_MONSTER_STAT@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@UDG_MONSTER_STAT@@@std@@QAE@ABV01@@Z PROC ; std::allocator<DG_MONSTER_STAT>::allocator<DG_MONSTER_STAT>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$allocator@UDG_MONSTER_STAT@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<DG_MONSTER_STAT>::allocator<DG_MONSTER_STAT>
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\doublegoer.cpp
_TEXT	ENDS
;	COMDAT ??__EstTickRate@@YAXXZ
text$yc	SEGMENT
??__EstTickRate@@YAXXZ PROC				; `dynamic initializer for 'stTickRate'', COMDAT

; 29   : int			stTickRate		= GetTickCount();

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0000f	a3 00 00 00 00	 mov	 DWORD PTR ?stTickRate@@3HA, eax ; stTickRate
  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??__EstTickRate@@YAXXZ ENDP				; `dynamic initializer for 'stTickRate''
; Function compile flags: /Odtp /ZI
text$yc	ENDS
;	COMDAT ??__EEventTimeTick@@YAXXZ
text$yc	SEGMENT
??__EEventTimeTick@@YAXXZ PROC				; `dynamic initializer for 'EventTimeTick'', COMDAT

; 30   : int			EventTimeTick	= GetTickCount();

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0000f	a3 00 00 00 00	 mov	 DWORD PTR ?EventTimeTick@@3HA, eax ; EventTimeTick
  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??__EEventTimeTick@@YAXXZ ENDP				; `dynamic initializer for 'EventTimeTick''
text$yc	ENDS
EXTRN	??0TMonsterAIUtil@@QAE@XZ:PROC			; TMonsterAIUtil::TMonsterAIUtil
; Function compile flags: /Odtp /ZI
;	COMDAT ??__EDG_UTIL@@YAXXZ
text$yc	SEGMENT
??__EDG_UTIL@@YAXXZ PROC				; `dynamic initializer for 'DG_UTIL'', COMDAT

; 33   : static		TMonsterAIUtil DG_UTIL;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET _DG_UTIL
  0000e	e8 00 00 00 00	 call	 ??0TMonsterAIUtil@@QAE@XZ ; TMonsterAIUtil::TMonsterAIUtil
  00013	68 00 00 00 00	 push	 OFFSET ??__FDG_UTIL@@YAXXZ ; `dynamic atexit destructor for 'DG_UTIL''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??__EDG_UTIL@@YAXXZ ENDP				; `dynamic initializer for 'DG_UTIL''
text$yc	ENDS
PUBLIC	??1CDoppelGanger@@QAE@XZ			; CDoppelGanger::~CDoppelGanger
; Function compile flags: /Odtp /ZI
;	COMDAT ??__Fg_DoppelGanger@@YAXXZ
text$yd	SEGMENT
??__Fg_DoppelGanger@@YAXXZ PROC				; `dynamic atexit destructor for 'g_DoppelGanger'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_DoppelGanger@@3VCDoppelGanger@@A ; g_DoppelGanger
  0000e	e8 00 00 00 00	 call	 ??1CDoppelGanger@@QAE@XZ
  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__Fg_DoppelGanger@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_DoppelGanger''
text$yd	ENDS
PUBLIC	??1?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAE@XZ ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::~vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >
; Function compile flags: /Odtp /ZI
;	COMDAT ??1CDoppelGanger@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CDoppelGanger@@QAE@XZ PROC				; CDoppelGanger::~CDoppelGanger, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	81 c1 24 02 00
	00		 add	 ecx, 548		; 00000224H
  00015	e8 00 00 00 00	 call	 ??1?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAE@XZ ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::~vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >
  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??1CDoppelGanger@@QAE@XZ ENDP				; CDoppelGanger::~CDoppelGanger
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAE@XZ ; std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::~_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >
PUBLIC	?_Tidy@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@IAEXXZ ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::_Tidy
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$??1?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??1?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAE@XZ PROC ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::~vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >, COMDAT
; _this$ = ecx

; 704  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 705  : 		_Tidy();

  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@IAEXXZ ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::_Tidy

; 706  : 		}

  0003a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??1?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAE@XZ ; std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::~_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >
  00049	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAE@XZ ; std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::~_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >
__ehhandler$??1?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAE@XZ ENDP ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::~vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Tidy@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@IAEXXZ PROC ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1302 : 		if (this->_Myfirst != 0)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00012	74 42		 je	 SHORT $LN1@Tidy

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00022	51		 push	 ecx
  00023	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00026	8b 02		 mov	 eax, DWORD PTR [edx]
  00028	50		 push	 eax
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@IAEXPAUDG_MONSTER_STAT@@0@Z ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::_Destroy

; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0003a	2b 01		 sub	 eax, DWORD PTR [ecx]
  0003c	99		 cdq
  0003d	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00042	f7 f9		 idiv	 ecx
  00044	50		 push	 eax
  00045	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00048	8b 02		 mov	 eax, DWORD PTR [edx]
  0004a	50		 push	 eax
  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00051	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UDG_MONSTER_STAT@@@std@@QAEXPAUDG_MONSTER_STAT@@I@Z ; std::allocator<DG_MONSTER_STAT>::deallocate
$LN1@Tidy:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00056	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00059	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1310 : 		this->_Mylast = 0;

  0005f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00062	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1311 : 		this->_Myend = 0;

  00069	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 1312 : 		}

  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	5b		 pop	 ebx
  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
?_Tidy@?$vector@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@IAEXXZ ENDP ; std::vector<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::_Tidy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::~_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >, COMDAT
; _this$ = ecx

; 433  : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 434  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_Vector_val@UDG_MONSTER_STAT@@V?$allocator@UDG_MONSTER_STAT@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >::~_Vector_val<DG_MONSTER_STAT,std::allocator<DG_MONSTER_STAT> >
_TEXT	ENDS
EXTRN	??1TMonsterAIUtil@@UAE@XZ:PROC			; TMonsterAIUtil::~TMonsterAIUtil
; Function compile flags: /Odtp /ZI
;	COMDAT ??__FDG_UTIL@@YAXXZ
text$yd	SEGMENT
??__FDG_UTIL@@YAXXZ PROC				; `dynamic atexit destructor for 'DG_UTIL'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET _DG_UTIL
  0000e	e8 00 00 00 00	 call	 ??1TMonsterAIUtil@@UAE@XZ ; TMonsterAIUtil::~TMonsterAIUtil
  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__FDG_UTIL@@YAXXZ ENDP				; `dynamic atexit destructor for 'DG_UTIL''
text$yd	ENDS
PUBLIC	?EventTimeTick@@3HA				; EventTimeTick
PUBLIC	?stTickRate@@3HA				; stTickRate
PUBLIC	?g_DoppelGanger@@3VCDoppelGanger@@A		; g_DoppelGanger
_BSS	SEGMENT
_DG_UTIL DD	01H DUP (?)
?EventTimeTick@@3HA DD 01H DUP (?)			; EventTimeTick
?stTickRate@@3HA DD 01H DUP (?)				; stTickRate
?g_DoppelGanger@@3VCDoppelGanger@@A DB 0234H DUP (?)	; g_DoppelGanger
_BSS	ENDS
CRT$XCU	SEGMENT
_g_DoppelGanger$initializer$ DD FLAT:??__Eg_DoppelGanger@@YAXXZ
_stTickRate$initializer$ DD FLAT:??__EstTickRate@@YAXXZ
_EventTimeTick$initializer$ DD FLAT:??__EEventTimeTick@@YAXXZ
_DG_UTIL$initializer$ DD FLAT:??__EDG_UTIL@@YAXXZ
CRT$XCU	ENDS
END
