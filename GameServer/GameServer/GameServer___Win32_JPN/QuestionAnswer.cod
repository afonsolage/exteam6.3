; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	D:\Projects\ExTeam6.3\Source\GameServer\GameServer\QuestionAnswer.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
_DATA	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Odtp /ZI
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@vector:
  00009	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000c	83 e8 01	 sub	 eax, 1
  0000f	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00012	78 11		 js	 SHORT $LN3@vector
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00017	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  0001d	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00020	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00023	eb e4		 jmp	 SHORT $LN2@vector
$LN3@vector:
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??1?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAE@XZ ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::~vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >
PUBLIC	??1?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAE@XZ ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::~vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >
PUBLIC	?Init@CQuestionAnswer@@QAEXXZ			; CQuestionAnswer::Init
PUBLIC	??0?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAE@XZ ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >
PUBLIC	??0?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAE@XZ ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >
PUBLIC	??0CQuestionAnswer@@QAE@XZ			; CQuestionAnswer::CQuestionAnswer
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
xdata$x	SEGMENT
__unwindtable$??0CQuestionAnswer@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CQuestionAnswer@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CQuestionAnswer@@QAE@XZ$1
__ehfuncinfo$??0CQuestionAnswer@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0CQuestionAnswer@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\questionanswer.cpp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CQuestionAnswer@@QAE@XZ PROC				; CQuestionAnswer::CQuestionAnswer
; _this$ = ecx

; 15   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CQuestionAnswer@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	83 c1 18	 add	 ecx, 24			; 00000018H
  00031	e8 00 00 00 00	 call	 ??0?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAE@XZ ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >
  00036	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	83 c1 28	 add	 ecx, 40			; 00000028H
  00043	e8 00 00 00 00	 call	 ??0?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAE@XZ ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >
  00048	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 16   : 	this->Init();

  0004c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ?Init@CQuestionAnswer@@QAEXXZ ; CQuestionAnswer::Init

; 17   : }

  00054	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0005b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00061	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00068	59		 pop	 ecx
  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi
  0006b	5b		 pop	 ebx
  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0CQuestionAnswer@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 18	 add	 ecx, 24			; 00000018H
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAE@XZ ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::~vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >
__unwindfunclet$??0CQuestionAnswer@@QAE@XZ$1:
  0000b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 28	 add	 ecx, 40			; 00000028H
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAE@XZ ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::~vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >
__ehhandler$??0CQuestionAnswer@@QAE@XZ:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CQuestionAnswer@@QAE@XZ
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CQuestionAnswer@@QAE@XZ ENDP				; CQuestionAnswer::CQuestionAnswer
PUBLIC	??1CQuestionAnswer@@QAE@XZ			; CQuestionAnswer::~CQuestionAnswer
xdata$x	SEGMENT
__unwindtable$??1CQuestionAnswer@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CQuestionAnswer@@QAE@XZ$0
__ehfuncinfo$??1CQuestionAnswer@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CQuestionAnswer@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CQuestionAnswer@@QAE@XZ PROC				; CQuestionAnswer::~CQuestionAnswer
; _this$ = ecx

; 20   : {

  00070	55		 push	 ebp
  00071	8b ec		 mov	 ebp, esp
  00073	6a ff		 push	 -1
  00075	68 00 00 00 00	 push	 __ehhandler$??1CQuestionAnswer@@QAE@XZ
  0007a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00080	50		 push	 eax
  00081	83 ec 44	 sub	 esp, 68			; 00000044H
  00084	53		 push	 ebx
  00085	56		 push	 esi
  00086	57		 push	 edi
  00087	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0008c	33 c5		 xor	 eax, ebp
  0008e	50		 push	 eax
  0008f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00092	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00098	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0009b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 21   : }

  000a2	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	83 c1 28	 add	 ecx, 40			; 00000028H
  000a8	e8 00 00 00 00	 call	 ??1?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAE@XZ ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::~vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >
  000ad	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000b4	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000b7	83 c1 18	 add	 ecx, 24			; 00000018H
  000ba	e8 00 00 00 00	 call	 ??1?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAE@XZ ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::~vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >
  000bf	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c9	59		 pop	 ecx
  000ca	5f		 pop	 edi
  000cb	5e		 pop	 esi
  000cc	5b		 pop	 ebx
  000cd	8b e5		 mov	 esp, ebp
  000cf	5d		 pop	 ebp
  000d0	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??1CQuestionAnswer@@QAE@XZ$0:
  00031	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	83 c1 18	 add	 ecx, 24			; 00000018H
  00037	e9 00 00 00 00	 jmp	 ??1?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAE@XZ ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::~vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >
__ehhandler$??1CQuestionAnswer@@QAE@XZ:
  0003c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00040	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00043	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00046	33 c8		 xor	 ecx, eax
  00048	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CQuestionAnswer@@QAE@XZ
  00052	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CQuestionAnswer@@QAE@XZ ENDP				; CQuestionAnswer::~CQuestionAnswer
PUBLIC	?clear@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAEXXZ ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::clear
PUBLIC	?clear@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAEXXZ ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::clear
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Init@CQuestionAnswer@@QAEXXZ PROC			; CQuestionAnswer::Init
; _this$ = ecx

; 24   : {

  000e0	55		 push	 ebp
  000e1	8b ec		 mov	 ebp, esp
  000e3	83 ec 44	 sub	 esp, 68			; 00000044H
  000e6	53		 push	 ebx
  000e7	56		 push	 esi
  000e8	57		 push	 edi
  000e9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 25   : 	this->m_Enable = false;

  000ec	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ef	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 26   : 	this->m_NumData = -1;

  000f5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000f8	c7 40 04 ff ff
	ff ff		 mov	 DWORD PTR [eax+4], -1

; 27   : 
; 28   : 	this->m_RewardWCoinC = 0;

  000ff	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00102	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 29   : 	this->m_RewardWCoinP = 0;

  00109	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0010c	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 30   : 	this->m_RewardGoblin = 0;

  00113	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00116	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 31   : 	this->m_RewardCredit = 0;

  0011d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00120	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 32   : 
; 33   : 	this->m_Data.clear();

  00127	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0012a	83 c1 18	 add	 ecx, 24			; 00000018H
  0012d	e8 00 00 00 00	 call	 ?clear@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAEXXZ ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::clear

; 34   : 	this->m_Time.clear();

  00132	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00135	83 c1 28	 add	 ecx, 40			; 00000028H
  00138	e8 00 00 00 00	 call	 ?clear@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAEXXZ ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::clear

; 35   : }

  0013d	5f		 pop	 edi
  0013e	5e		 pop	 esi
  0013f	5b		 pop	 ebx
  00140	8b e5		 mov	 esp, ebp
  00142	5d		 pop	 ebp
  00143	c3		 ret	 0
?Init@CQuestionAnswer@@QAEXXZ ENDP			; CQuestionAnswer::Init
_TEXT	ENDS
PUBLIC	?Read@CQuestionAnswer@@QAEXPAD@Z		; CQuestionAnswer::Read
PUBLIC	??_C@_0CB@PHGCNEAE@ExData?2Events?2QuestionAnswer?4dat@ ; `string'
PUBLIC	?Load@CQuestionAnswer@@QAEXXZ			; CQuestionAnswer::Load
EXTRN	?GetNewPath@CDirPath@@QAEPADPAD@Z:PROC		; CDirPath::GetNewPath
EXTRN	?gDirPath@@3VCDirPath@@A:BYTE			; gDirPath
EXTRN	?CheckUser@CExLicense@@QAE_NH@Z:PROC		; CExLicense::CheckUser
EXTRN	?g_ExLicense@@3VCExLicense@@A:BYTE		; g_ExLicense
;	COMDAT ??_C@_0CB@PHGCNEAE@ExData?2Events?2QuestionAnswer?4dat@
CONST	SEGMENT
??_C@_0CB@PHGCNEAE@ExData?2Events?2QuestionAnswer?4dat@ DB 'ExData\Events'
	DB	'\QuestionAnswer.dat', 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Load@CQuestionAnswer@@QAEXXZ PROC			; CQuestionAnswer::Load
; _this$ = ecx

; 38   : {

  00150	55		 push	 ebp
  00151	8b ec		 mov	 ebp, esp
  00153	83 ec 44	 sub	 esp, 68			; 00000044H
  00156	53		 push	 ebx
  00157	56		 push	 esi
  00158	57		 push	 edi
  00159	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 39   : 	this->Init();

  0015c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0015f	e8 00 00 00 00	 call	 ?Init@CQuestionAnswer@@QAEXXZ ; CQuestionAnswer::Init

; 40   : 
; 41   : 	if(!g_ExLicense.CheckUser(eExUB::Local)  &&
; 42   : 	   !g_ExLicense.CheckUser(eExUB::eternalmu) &&
; 43   : 	   !g_ExLicense.CheckUser(eExUB::Artem) &&
; 44   : 	   !g_ExLicense.CheckUser(eExUB::Artem2))

  00164	6a 00		 push	 0
  00166	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  0016b	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00170	0f b6 c0	 movzx	 eax, al
  00173	85 c0		 test	 eax, eax
  00175	75 3b		 jne	 SHORT $LN1@Load
  00177	6a 4f		 push	 79			; 0000004fH
  00179	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  0017e	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00183	0f b6 c0	 movzx	 eax, al
  00186	85 c0		 test	 eax, eax
  00188	75 28		 jne	 SHORT $LN1@Load
  0018a	6a 30		 push	 48			; 00000030H
  0018c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  00191	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  00196	0f b6 c0	 movzx	 eax, al
  00199	85 c0		 test	 eax, eax
  0019b	75 15		 jne	 SHORT $LN1@Load
  0019d	6a 31		 push	 49			; 00000031H
  0019f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  001a4	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  001a9	0f b6 c0	 movzx	 eax, al
  001ac	85 c0		 test	 eax, eax
  001ae	75 02		 jne	 SHORT $LN1@Load

; 45   : 	{
; 46   : 		return;

  001b0	eb 18		 jmp	 SHORT $LN2@Load
$LN1@Load:

; 47   : 	}
; 48   : 
; 49   : 	this->Read(gDirPath.GetNewPath("ExData\\Events\\QuestionAnswer.dat"));

  001b2	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@PHGCNEAE@ExData?2Events?2QuestionAnswer?4dat@
  001b7	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  001bc	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  001c1	50		 push	 eax
  001c2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001c5	e8 00 00 00 00	 call	 ?Read@CQuestionAnswer@@QAEXPAD@Z ; CQuestionAnswer::Read
$LN2@Load:

; 50   : }

  001ca	5f		 pop	 edi
  001cb	5e		 pop	 esi
  001cc	5b		 pop	 ebx
  001cd	8b e5		 mov	 esp, ebp
  001cf	5d		 pop	 ebp
  001d0	c3		 ret	 0
?Load@CQuestionAnswer@@QAEXXZ ENDP			; CQuestionAnswer::Load
_TEXT	ENDS
PUBLIC	??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@	; `string'
PUBLIC	?push_back@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAEXABUQUESTIONANSWER_DATA@@@Z ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::push_back
PUBLIC	?push_back@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAEXABUQUESTIONANSWER_TIME@@@Z ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::push_back
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	__$ArrayPad$
EXTRN	_fclose:PROC
EXTRN	_memcpy:PROC
EXTRN	_strcmp:PROC
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	?Get@CMsg@@QAEPADH@Z:PROC			; CMsg::Get
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
EXTRN	_fopen:PROC
EXTRN	__ftol2_sse:PROC
_BSS	SEGMENT
_TokenString DB	064H DUP (?)
_TokenNumber DD	01H DUP (?)
_SMDFile DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@
CONST	SEGMENT
??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@ DB '%s file load!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_List$229056 = -152					; size = 128
_List$229043 = -24					; size = 8
_iType$ = -16						; size = 4
_Token$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
?Read@CQuestionAnswer@@QAEXPAD@Z PROC			; CQuestionAnswer::Read
; _this$ = ecx

; 53   : {

  001e0	55		 push	 ebp
  001e1	8b ec		 mov	 ebp, esp
  001e3	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  001e9	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  001ee	33 c5		 xor	 eax, ebp
  001f0	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  001f3	53		 push	 ebx
  001f4	56		 push	 esi
  001f5	57		 push	 edi
  001f6	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 54   : 	SMDFile = fopen(filename, "r");

  001f9	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  001fe	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00201	50		 push	 eax
  00202	e8 00 00 00 00	 call	 _fopen
  00207	83 c4 08	 add	 esp, 8
  0020a	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax

; 55   : 
; 56   : 	if(SMDFile == NULL)

  0020f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SMDFile, 0
  00216	75 22		 jne	 SHORT $LN19@Read

; 57   : 	{
; 58   : 		LogAdd(lMsg.Get(MSGGET(1, 198)), filename);

  00218	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0021b	50		 push	 eax
  0021c	68 c6 01 00 00	 push	 454			; 000001c6H
  00221	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00226	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0022b	50		 push	 eax
  0022c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00232	83 c4 08	 add	 esp, 8

; 59   : 		return;

  00235	e9 10 02 00 00	 jmp	 $LN20@Read
$LN19@Read:

; 60   : 	}
; 61   : 
; 62   : 	SMDToken Token;
; 63   : 
; 64   : 	int iType = -1;

  0023a	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _iType$[ebp], -1
$LN18@Read:

; 65   : 
; 66   : 	while(true)

  00241	b8 01 00 00 00	 mov	 eax, 1
  00246	85 c0		 test	 eax, eax
  00248	0f 84 dc 01 00
	00		 je	 $LN17@Read

; 67   : 	{
; 68   : 		Token = GetToken();

  0024e	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00253	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 69   : 
; 70   :         if(Token == END)

  00256	83 7d f4 02	 cmp	 DWORD PTR _Token$[ebp], 2
  0025a	75 05		 jne	 SHORT $LN16@Read

; 71   : 		{
; 72   :             break;

  0025c	e9 c9 01 00 00	 jmp	 $LN17@Read
$LN16@Read:

; 73   : 		}
; 74   : 
; 75   : 		iType = (int)TokenNumber;

  00261	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00267	e8 00 00 00 00	 call	 __ftol2_sse
  0026c	89 45 f0	 mov	 DWORD PTR _iType$[ebp], eax

; 76   : 
; 77   : 		if(iType < 0 || iType > 3)

  0026f	83 7d f0 00	 cmp	 DWORD PTR _iType$[ebp], 0
  00273	7c 06		 jl	 SHORT $LN14@Read
  00275	83 7d f0 03	 cmp	 DWORD PTR _iType$[ebp], 3
  00279	7e 05		 jle	 SHORT $LN15@Read
$LN14@Read:

; 78   : 		{
; 79   : 			break;

  0027b	e9 aa 01 00 00	 jmp	 $LN17@Read
$LN15@Read:

; 80   : 		}
; 81   : 
; 82   : 		while(true)

  00280	b8 01 00 00 00	 mov	 eax, 1
  00285	85 c0		 test	 eax, eax
  00287	0f 84 98 01 00
	00		 je	 $LN12@Read

; 83   : 		{
; 84   : 			if(iType == 0)

  0028d	83 7d f0 00	 cmp	 DWORD PTR _iType$[ebp], 0
  00291	75 38		 jne	 SHORT $LN11@Read

; 85   : 			{
; 86   : 				Token = GetToken();

  00293	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00298	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 87   : 
; 88   : 				if(!strcmp("end", TokenString))

  0029b	68 00 00 00 00	 push	 OFFSET _TokenString
  002a0	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  002a5	e8 00 00 00 00	 call	 _strcmp
  002aa	83 c4 08	 add	 esp, 8
  002ad	85 c0		 test	 eax, eax
  002af	75 05		 jne	 SHORT $LN10@Read

; 89   : 				{
; 90   : 					break;

  002b1	e9 6f 01 00 00	 jmp	 $LN12@Read
$LN10@Read:

; 91   : 				}
; 92   : 
; 93   : 				this->m_Enable = (int)TokenNumber;

  002b6	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  002bc	e8 00 00 00 00	 call	 __ftol2_sse
  002c1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  002c4	89 01		 mov	 DWORD PTR [ecx], eax
  002c6	e9 55 01 00 00	 jmp	 $LN2@Read
$LN11@Read:

; 94   : 			}
; 95   : 			else if(iType == 1)

  002cb	83 7d f0 01	 cmp	 DWORD PTR _iType$[ebp], 1
  002cf	75 5b		 jne	 SHORT $LN8@Read

; 96   : 			{
; 97   : 				Token = GetToken();

  002d1	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  002d6	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 98   : 
; 99   : 				if(!strcmp("end", TokenString))

  002d9	68 00 00 00 00	 push	 OFFSET _TokenString
  002de	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  002e3	e8 00 00 00 00	 call	 _strcmp
  002e8	83 c4 08	 add	 esp, 8
  002eb	85 c0		 test	 eax, eax
  002ed	75 05		 jne	 SHORT $LN7@Read

; 100  : 				{
; 101  : 					break;

  002ef	e9 31 01 00 00	 jmp	 $LN12@Read
$LN7@Read:

; 102  : 				}
; 103  : 
; 104  : 				QUESTIONANSWER_TIME List;
; 105  : 
; 106  : 				List.Hour = (int)TokenNumber;

  002f4	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  002fa	e8 00 00 00 00	 call	 __ftol2_sse
  002ff	89 45 e8	 mov	 DWORD PTR _List$229043[ebp], eax

; 107  : 
; 108  : 				Token = GetToken();

  00302	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00307	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 109  : 				List.Min = (int)TokenNumber;

  0030a	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00310	e8 00 00 00 00	 call	 __ftol2_sse
  00315	89 45 ec	 mov	 DWORD PTR _List$229043[ebp+4], eax

; 110  : 
; 111  : 				this->m_Time.push_back(List);

  00318	8d 45 e8	 lea	 eax, DWORD PTR _List$229043[ebp]
  0031b	50		 push	 eax
  0031c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0031f	83 c1 28	 add	 ecx, 40			; 00000028H
  00322	e8 00 00 00 00	 call	 ?push_back@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAEXABUQUESTIONANSWER_TIME@@@Z ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::push_back
  00327	e9 f4 00 00 00	 jmp	 $LN2@Read
$LN8@Read:

; 112  : 			}
; 113  : 			else if(iType == 2)

  0032c	83 7d f0 02	 cmp	 DWORD PTR _iType$[ebp], 2
  00330	0f 85 81 00 00
	00		 jne	 $LN5@Read

; 114  : 			{
; 115  : 				Token = GetToken();

  00336	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0033b	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 116  : 
; 117  : 				if(!strcmp("end", TokenString))

  0033e	68 00 00 00 00	 push	 OFFSET _TokenString
  00343	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  00348	e8 00 00 00 00	 call	 _strcmp
  0034d	83 c4 08	 add	 esp, 8
  00350	85 c0		 test	 eax, eax
  00352	75 05		 jne	 SHORT $LN4@Read

; 118  : 				{
; 119  : 					break;

  00354	e9 cc 00 00 00	 jmp	 $LN12@Read
$LN4@Read:

; 120  : 				}
; 121  : 
; 122  : 				this->m_RewardWCoinC = (int)TokenNumber;

  00359	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0035f	e8 00 00 00 00	 call	 __ftol2_sse
  00364	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00367	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 123  : 
; 124  : 				Token = GetToken();

  0036a	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0036f	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 125  : 				this->m_RewardWCoinP = (int)TokenNumber;

  00372	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00378	e8 00 00 00 00	 call	 __ftol2_sse
  0037d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00380	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 126  : 
; 127  : 				Token = GetToken();

  00383	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00388	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 128  : 				this->m_RewardGoblin = (int)TokenNumber;

  0038b	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00391	e8 00 00 00 00	 call	 __ftol2_sse
  00396	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00399	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 129  : 
; 130  : 				Token = GetToken();

  0039c	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  003a1	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 131  : 				this->m_RewardCredit = (int)TokenNumber;

  003a4	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  003aa	e8 00 00 00 00	 call	 __ftol2_sse
  003af	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  003b2	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  003b5	eb 69		 jmp	 SHORT $LN2@Read
$LN5@Read:

; 132  : 			}
; 133  : 			else if(iType == 3)

  003b7	83 7d f0 03	 cmp	 DWORD PTR _iType$[ebp], 3
  003bb	75 63		 jne	 SHORT $LN2@Read

; 134  : 			{
; 135  : 				Token = GetToken();

  003bd	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  003c2	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 136  : 
; 137  : 				if(!strcmp("end", TokenString))

  003c5	68 00 00 00 00	 push	 OFFSET _TokenString
  003ca	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  003cf	e8 00 00 00 00	 call	 _strcmp
  003d4	83 c4 08	 add	 esp, 8
  003d7	85 c0		 test	 eax, eax
  003d9	75 02		 jne	 SHORT $LN1@Read

; 138  : 				{
; 139  : 					break;

  003db	eb 48		 jmp	 SHORT $LN12@Read
$LN1@Read:

; 140  : 				}
; 141  : 
; 142  : 				QUESTIONANSWER_DATA List;
; 143  : 
; 144  : 				memcpy(List.Question, TokenString, sizeof(List.Question));

  003dd	6a 40		 push	 64			; 00000040H
  003df	68 00 00 00 00	 push	 OFFSET _TokenString
  003e4	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _List$229056[ebp]
  003ea	50		 push	 eax
  003eb	e8 00 00 00 00	 call	 _memcpy
  003f0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 145  : 
; 146  : 				Token = GetToken();

  003f3	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  003f8	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 147  : 				memcpy(List.Answer, TokenString, sizeof(List.Answer));

  003fb	6a 40		 push	 64			; 00000040H
  003fd	68 00 00 00 00	 push	 OFFSET _TokenString
  00402	8d 45 a8	 lea	 eax, DWORD PTR _List$229056[ebp+64]
  00405	50		 push	 eax
  00406	e8 00 00 00 00	 call	 _memcpy
  0040b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 148  : 
; 149  : 				this->m_Data.push_back(List);

  0040e	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _List$229056[ebp]
  00414	50		 push	 eax
  00415	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00418	83 c1 18	 add	 ecx, 24			; 00000018H
  0041b	e8 00 00 00 00	 call	 ?push_back@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAEXABUQUESTIONANSWER_DATA@@@Z ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::push_back
$LN2@Read:

; 150  : 			}
; 151  : 		}

  00420	e9 5b fe ff ff	 jmp	 $LN15@Read
$LN12@Read:

; 152  : 	}

  00425	e9 17 fe ff ff	 jmp	 $LN18@Read
$LN17@Read:

; 153  : 
; 154  : 	fclose(SMDFile);

  0042a	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0042f	50		 push	 eax
  00430	e8 00 00 00 00	 call	 _fclose
  00435	83 c4 04	 add	 esp, 4

; 155  : 
; 156  : 	LogAdd("%s file load!", filename);

  00438	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0043b	50		 push	 eax
  0043c	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@
  00441	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00447	83 c4 08	 add	 esp, 8
$LN20@Read:

; 157  : }

  0044a	5f		 pop	 edi
  0044b	5e		 pop	 esi
  0044c	5b		 pop	 ebx
  0044d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00450	33 cd		 xor	 ecx, ebp
  00452	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00457	8b e5		 mov	 esp, ebp
  00459	5d		 pop	 ebp
  0045a	c2 04 00	 ret	 4
?Read@CQuestionAnswer@@QAEXPAD@Z ENDP			; CQuestionAnswer::Read
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_isalnum:PROC
EXTRN	_isalpha:PROC
EXTRN	_atof:PROC
EXTRN	_isdigit:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_isspace:PROC
EXTRN	_fgetc:PROC
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_CurrentToken DD 01H DUP (?)
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\include\readscript.h
_BSS	ENDS
_TEXT	SEGMENT
tv90 = -180						; size = 4
_TempString$ = -112					; size = 100
_p$ = -12						; size = 4
_ch$ = -5						; size = 1
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken

; 24   : {

  00460	55		 push	 ebp
  00461	8b ec		 mov	 ebp, esp
  00463	81 ec b4 00 00
	00		 sub	 esp, 180		; 000000b4H
  00469	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0046e	33 c5		 xor	 eax, ebp
  00470	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00473	53		 push	 ebx
  00474	56		 push	 esi
  00475	57		 push	 edi

; 25   : 	char ch;
; 26   : 	char* p;
; 27   : 	char TempString[100];
; 28   : 
; 29   : 	TokenString[0]=0;

  00476	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _TokenString, 0
$LN31@GetToken:

; 30   : 
; 31   : 	do
; 32   : 	{
; 33   : 		if ((ch=fgetc(SMDFile)) == -1)

  0047d	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00482	50		 push	 eax
  00483	e8 00 00 00 00	 call	 _fgetc
  00488	83 c4 04	 add	 esp, 4
  0048b	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0048e	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00492	83 f9 ff	 cmp	 ecx, -1
  00495	75 0c		 jne	 SHORT $LN28@GetToken

; 34   : 		{
; 35   : 			return END;	// End of FILE (EOF)

  00497	b8 02 00 00 00	 mov	 eax, 2
  0049c	e9 f7 02 00 00	 jmp	 $LN32@GetToken

; 36   : 		}
; 37   : 		else

  004a1	eb 5b		 jmp	 SHORT $LN22@GetToken
$LN28@GetToken:

; 38   : 		{	
; 39   : 			if (ch=='/')		// this is /

  004a3	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  004a7	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  004aa	75 52		 jne	 SHORT $LN22@GetToken

; 40   : 			{
; 41   : 				if((ch=fgetc(SMDFile)) == '/')

  004ac	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  004b1	50		 push	 eax
  004b2	e8 00 00 00 00	 call	 _fgetc
  004b7	83 c4 04	 add	 esp, 4
  004ba	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  004bd	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  004c1	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  004c4	75 38		 jne	 SHORT $LN22@GetToken
$LN24@GetToken:

; 42   : 				{
; 43   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  004c6	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  004ca	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  004cd	74 1c		 je	 SHORT $LN23@GetToken
  004cf	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  004d3	83 f8 ff	 cmp	 eax, -1
  004d6	74 13		 je	 SHORT $LN23@GetToken

; 44   : 					{
; 45   : 						ch=fgetc(SMDFile);

  004d8	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  004dd	50		 push	 eax
  004de	e8 00 00 00 00	 call	 _fgetc
  004e3	83 c4 04	 add	 esp, 4
  004e6	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al

; 46   : 					}

  004e9	eb db		 jmp	 SHORT $LN24@GetToken
$LN23@GetToken:

; 47   : 	
; 48   : 					if (ch == -1)

  004eb	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  004ef	83 f8 ff	 cmp	 eax, -1
  004f2	75 0a		 jne	 SHORT $LN22@GetToken

; 49   : 					{
; 50   : 						return END;	// End of FILE

  004f4	b8 02 00 00 00	 mov	 eax, 2
  004f9	e9 9a 02 00 00	 jmp	 $LN32@GetToken
$LN22@GetToken:

; 51   : 					}
; 52   : 				}
; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : 	while (isspace(ch) != 0);

  004fe	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00502	50		 push	 eax
  00503	e8 00 00 00 00	 call	 _isspace
  00508	83 c4 04	 add	 esp, 4
  0050b	85 c0		 test	 eax, eax
  0050d	0f 85 6a ff ff
	ff		 jne	 $LN31@GetToken

; 57   : 
; 58   : 	
; 59   : 	switch(ch)

  00513	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00517	89 85 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], eax
  0051d	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR tv90[ebp]
  00523	83 e9 22	 sub	 ecx, 34			; 00000022H
  00526	89 8d 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], ecx
  0052c	83 bd 4c ff ff
	ff 5b		 cmp	 DWORD PTR tv90[ebp], 91	; 0000005bH
  00533	0f 87 a3 01 00
	00		 ja	 $LN6@GetToken
  00539	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR tv90[ebp]
  0053f	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN34@GetToken[edx]
  00546	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN35@GetToken[eax*4]
$LN19@GetToken:

; 60   : 	{
; 61   : 
; 62   : 	case 0x23:	// #
; 63   : 		return CurrentToken=COMMAND;

  0054d	c7 05 00 00 00
	00 23 00 00 00	 mov	 DWORD PTR _CurrentToken, 35 ; 00000023H
  00557	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  0055c	e9 37 02 00 00	 jmp	 $LN32@GetToken

; 64   : 		break;

  00561	e9 30 02 00 00	 jmp	 $LN20@GetToken
$LN18@GetToken:

; 65   : 	
; 66   : 	case 0x3B:	// ;
; 67   : 		return CurrentToken=SEMICOLON;

  00566	c7 05 00 00 00
	00 3b 00 00 00	 mov	 DWORD PTR _CurrentToken, 59 ; 0000003bH
  00570	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00575	e9 1e 02 00 00	 jmp	 $LN32@GetToken

; 68   : 		break;

  0057a	e9 17 02 00 00	 jmp	 $LN20@GetToken
$LN17@GetToken:

; 69   : 	
; 70   : 	case 0x2C:	// ,
; 71   : 
; 72   : 		return CurrentToken=COMMA;

  0057f	c7 05 00 00 00
	00 2c 00 00 00	 mov	 DWORD PTR _CurrentToken, 44 ; 0000002cH
  00589	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  0058e	e9 05 02 00 00	 jmp	 $LN32@GetToken

; 73   : 		break;

  00593	e9 fe 01 00 00	 jmp	 $LN20@GetToken
$LN16@GetToken:

; 74   : 	
; 75   : 	case 0x7B:	// {
; 76   : 		return CurrentToken = LP;

  00598	c7 05 00 00 00
	00 7b 00 00 00	 mov	 DWORD PTR _CurrentToken, 123 ; 0000007bH
  005a2	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  005a7	e9 ec 01 00 00	 jmp	 $LN32@GetToken

; 77   : 		break;

  005ac	e9 e5 01 00 00	 jmp	 $LN20@GetToken
$LN15@GetToken:

; 78   : 
; 79   : 	case 0x7D:	// }
; 80   : 		return CurrentToken = RP;

  005b1	c7 05 00 00 00
	00 7d 00 00 00	 mov	 DWORD PTR _CurrentToken, 125 ; 0000007dH
  005bb	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  005c0	e9 d3 01 00 00	 jmp	 $LN32@GetToken

; 81   : 		break;

  005c5	e9 cc 01 00 00	 jmp	 $LN20@GetToken
$LN14@GetToken:

; 82   : 	// Nice Index Table :)	by Deathway
; 83   : 	// Numbers Case
; 84   : 	case 0x2D:	//-
; 85   : 	case 0x2E:	//.
; 86   : 	case '0':	//0
; 87   : 	case '1':	//1
; 88   : 	case '2':	//2
; 89   : 	case '3':	//3
; 90   : 	case '4':	//4		
; 91   : 	case '5':	//5
; 92   : 	case '6':	//6
; 93   : 	case '7':	//7
; 94   : 	case '8':	//8
; 95   : 	case '9':	//9
; 96   : 		ungetc(ch, SMDFile);

  005ca	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  005cf	50		 push	 eax
  005d0	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  005d4	51		 push	 ecx
  005d5	e8 00 00 00 00	 call	 _ungetc
  005da	83 c4 08	 add	 esp, 8

; 97   : 		p = TempString;

  005dd	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  005e0	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN13@GetToken:

; 98   : 		
; 99   : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  005e3	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  005e8	50		 push	 eax
  005e9	e8 00 00 00 00	 call	 _getc
  005ee	83 c4 04	 add	 esp, 4
  005f1	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  005f4	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  005f8	83 f9 ff	 cmp	 ecx, -1
  005fb	74 36		 je	 SHORT $LN12@GetToken
  005fd	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00601	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  00604	74 1a		 je	 SHORT $LN11@GetToken
  00606	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  0060a	50		 push	 eax
  0060b	e8 00 00 00 00	 call	 _isdigit
  00610	83 c4 04	 add	 esp, 4
  00613	85 c0		 test	 eax, eax
  00615	75 09		 jne	 SHORT $LN11@GetToken
  00617	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  0061b	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  0061e	75 13		 jne	 SHORT $LN12@GetToken
$LN11@GetToken:

; 100  : 		{
; 101  : 			*p = ch;	// Construct a String

  00620	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00623	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00626	88 08		 mov	 BYTE PTR [eax], cl

; 102  : 			p++;

  00628	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0062b	83 c0 01	 add	 eax, 1
  0062e	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 103  : 		}		

  00631	eb b0		 jmp	 SHORT $LN13@GetToken
$LN12@GetToken:

; 104  : 		*p = 0;

  00633	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00636	c6 00 00	 mov	 BYTE PTR [eax], 0

; 105  : 		TokenNumber = atof( TempString);	// Select the first Byte as Main ID

  00639	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  0063c	50		 push	 eax
  0063d	e8 00 00 00 00	 call	 _atof
  00642	83 c4 04	 add	 esp, 4
  00645	d9 1d 00 00 00
	00		 fstp	 DWORD PTR _TokenNumber

; 106  : 		return CurrentToken  = NUMBER ;

  0064b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CurrentToken, 1
  00655	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  0065a	e9 39 01 00 00	 jmp	 $LN32@GetToken

; 107  : 		break;

  0065f	e9 32 01 00 00	 jmp	 $LN20@GetToken
$LN10@GetToken:

; 108  : 
; 109  : 	case '\"':	// "	String Case
; 110  : 		p=&TokenString[0];

  00664	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString
$LN9@GetToken:

; 111  : 		
; 112  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  0066b	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00670	50		 push	 eax
  00671	e8 00 00 00 00	 call	 _getc
  00676	83 c4 04	 add	 esp, 4
  00679	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0067c	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00680	83 f9 ff	 cmp	 ecx, -1
  00683	74 1c		 je	 SHORT $LN8@GetToken
  00685	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00689	83 f8 22	 cmp	 eax, 34			; 00000022H
  0068c	74 13		 je	 SHORT $LN8@GetToken

; 113  : 		{
; 114  : 			*p = ch;

  0068e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00691	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00694	88 08		 mov	 BYTE PTR [eax], cl

; 115  : 			p++;

  00696	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00699	83 c0 01	 add	 eax, 1
  0069c	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 116  : 		}

  0069f	eb ca		 jmp	 SHORT $LN9@GetToken
$LN8@GetToken:

; 117  : 		if (ch != 0x22 )

  006a1	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  006a5	83 f8 22	 cmp	 eax, 34			; 00000022H
  006a8	74 13		 je	 SHORT $LN7@GetToken

; 118  : 		{
; 119  : 			ungetc(ch, SMDFile);

  006aa	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  006af	50		 push	 eax
  006b0	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  006b4	51		 push	 ecx
  006b5	e8 00 00 00 00	 call	 _ungetc
  006ba	83 c4 08	 add	 esp, 8
$LN7@GetToken:

; 120  : 		}
; 121  : 		*p = 0;

  006bd	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  006c0	c6 00 00	 mov	 BYTE PTR [eax], 0

; 122  : 		return CurrentToken = NAME;

  006c3	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0
  006cd	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  006d2	e9 c1 00 00 00	 jmp	 $LN32@GetToken

; 123  : 		break;

  006d7	e9 ba 00 00 00	 jmp	 $LN20@GetToken
$LN6@GetToken:

; 124  : 
; 125  : 	default:	// Others
; 126  : 		if (isalpha(ch))

  006dc	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  006e0	50		 push	 eax
  006e1	e8 00 00 00 00	 call	 _isalpha
  006e6	83 c4 04	 add	 esp, 4
  006e9	85 c0		 test	 eax, eax
  006eb	0f 84 94 00 00
	00		 je	 $LN5@GetToken

; 127  : 		{
; 128  : 			p=&TokenString[0];

  006f1	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString

; 129  : 			*p=ch;

  006f8	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  006fb	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  006fe	88 08		 mov	 BYTE PTR [eax], cl

; 130  : 			p++;

  00700	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00703	83 c0 01	 add	 eax, 1
  00706	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN4@GetToken:

; 131  : 
; 132  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  00709	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0070e	50		 push	 eax
  0070f	e8 00 00 00 00	 call	 _getc
  00714	83 c4 04	 add	 esp, 4
  00717	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0071a	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  0071e	83 f9 ff	 cmp	 ecx, -1
  00721	74 36		 je	 SHORT $LN3@GetToken
  00723	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00727	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  0072a	74 1a		 je	 SHORT $LN2@GetToken
  0072c	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00730	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  00733	74 11		 je	 SHORT $LN2@GetToken
  00735	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00739	50		 push	 eax
  0073a	e8 00 00 00 00	 call	 _isalnum
  0073f	83 c4 04	 add	 esp, 4
  00742	85 c0		 test	 eax, eax
  00744	74 13		 je	 SHORT $LN3@GetToken
$LN2@GetToken:

; 133  : 			{
; 134  : 				*p=ch;

  00746	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00749	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  0074c	88 08		 mov	 BYTE PTR [eax], cl

; 135  : 				p++;

  0074e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00751	83 c0 01	 add	 eax, 1
  00754	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 136  : 				
; 137  : 			}

  00757	eb b0		 jmp	 SHORT $LN4@GetToken
$LN3@GetToken:

; 138  : 
; 139  : 			ungetc(ch, SMDFile);

  00759	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0075e	50		 push	 eax
  0075f	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00763	51		 push	 ecx
  00764	e8 00 00 00 00	 call	 _ungetc
  00769	83 c4 08	 add	 esp, 8

; 140  : 			*p=0;

  0076c	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0076f	c6 00 00	 mov	 BYTE PTR [eax], 0

; 141  : 			CurrentToken=NAME;

  00772	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0

; 142  : 			return CurrentToken;

  0077c	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00781	eb 15		 jmp	 SHORT $LN32@GetToken

; 143  : 		}
; 144  : 		else

  00783	eb 11		 jmp	 SHORT $LN1@GetToken
$LN5@GetToken:

; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'

  00785	c7 05 00 00 00
	00 3c 00 00 00	 mov	 DWORD PTR _CurrentToken, 60 ; 0000003cH
  0078f	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00794	eb 02		 jmp	 SHORT $LN32@GetToken
$LN1@GetToken:
$LN20@GetToken:

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;

  00796	33 c0		 xor	 eax, eax
$LN32@GetToken:

; 153  : }

  00798	5f		 pop	 edi
  00799	5e		 pop	 esi
  0079a	5b		 pop	 ebx
  0079b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0079e	33 cd		 xor	 ecx, ebp
  007a0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007a5	8b e5		 mov	 esp, ebp
  007a7	5d		 pop	 ebp
  007a8	c3		 ret	 0
  007a9	8d 49 00	 npad	 3
$LN35@GetToken:
  007ac	00 00 00 00	 DD	 $LN10@GetToken
  007b0	00 00 00 00	 DD	 $LN19@GetToken
  007b4	00 00 00 00	 DD	 $LN17@GetToken
  007b8	00 00 00 00	 DD	 $LN14@GetToken
  007bc	00 00 00 00	 DD	 $LN18@GetToken
  007c0	00 00 00 00	 DD	 $LN16@GetToken
  007c4	00 00 00 00	 DD	 $LN15@GetToken
  007c8	00 00 00 00	 DD	 $LN6@GetToken
$LN34@GetToken:
  007cc	00		 DB	 0
  007cd	01		 DB	 1
  007ce	07		 DB	 7
  007cf	07		 DB	 7
  007d0	07		 DB	 7
  007d1	07		 DB	 7
  007d2	07		 DB	 7
  007d3	07		 DB	 7
  007d4	07		 DB	 7
  007d5	07		 DB	 7
  007d6	02		 DB	 2
  007d7	03		 DB	 3
  007d8	03		 DB	 3
  007d9	07		 DB	 7
  007da	03		 DB	 3
  007db	03		 DB	 3
  007dc	03		 DB	 3
  007dd	03		 DB	 3
  007de	03		 DB	 3
  007df	03		 DB	 3
  007e0	03		 DB	 3
  007e1	03		 DB	 3
  007e2	03		 DB	 3
  007e3	03		 DB	 3
  007e4	07		 DB	 7
  007e5	04		 DB	 4
  007e6	07		 DB	 7
  007e7	07		 DB	 7
  007e8	07		 DB	 7
  007e9	07		 DB	 7
  007ea	07		 DB	 7
  007eb	07		 DB	 7
  007ec	07		 DB	 7
  007ed	07		 DB	 7
  007ee	07		 DB	 7
  007ef	07		 DB	 7
  007f0	07		 DB	 7
  007f1	07		 DB	 7
  007f2	07		 DB	 7
  007f3	07		 DB	 7
  007f4	07		 DB	 7
  007f5	07		 DB	 7
  007f6	07		 DB	 7
  007f7	07		 DB	 7
  007f8	07		 DB	 7
  007f9	07		 DB	 7
  007fa	07		 DB	 7
  007fb	07		 DB	 7
  007fc	07		 DB	 7
  007fd	07		 DB	 7
  007fe	07		 DB	 7
  007ff	07		 DB	 7
  00800	07		 DB	 7
  00801	07		 DB	 7
  00802	07		 DB	 7
  00803	07		 DB	 7
  00804	07		 DB	 7
  00805	07		 DB	 7
  00806	07		 DB	 7
  00807	07		 DB	 7
  00808	07		 DB	 7
  00809	07		 DB	 7
  0080a	07		 DB	 7
  0080b	07		 DB	 7
  0080c	07		 DB	 7
  0080d	07		 DB	 7
  0080e	07		 DB	 7
  0080f	07		 DB	 7
  00810	07		 DB	 7
  00811	07		 DB	 7
  00812	07		 DB	 7
  00813	07		 DB	 7
  00814	07		 DB	 7
  00815	07		 DB	 7
  00816	07		 DB	 7
  00817	07		 DB	 7
  00818	07		 DB	 7
  00819	07		 DB	 7
  0081a	07		 DB	 7
  0081b	07		 DB	 7
  0081c	07		 DB	 7
  0081d	07		 DB	 7
  0081e	07		 DB	 7
  0081f	07		 DB	 7
  00820	07		 DB	 7
  00821	07		 DB	 7
  00822	07		 DB	 7
  00823	07		 DB	 7
  00824	07		 DB	 7
  00825	05		 DB	 5
  00826	07		 DB	 7
  00827	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
PUBLIC	?Search@CQuestionAnswer@@QAEXXZ			; CQuestionAnswer::Search
PUBLIC	??C?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QBEPAUQUESTIONANSWER_TIME@@XZ ; std::_Vector_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >::operator->
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >::operator!=
PUBLIC	?end@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@2@XZ ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::end
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >::operator++
PUBLIC	?begin@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@2@XZ ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::begin
PUBLIC	__$ArrayPad$
PUBLIC	?Run@CQuestionAnswer@@QAEXXZ			; CQuestionAnswer::Run
EXTRN	__imp__GetLocalTime@4:PROC
EXTRN	?GetSecond@CTimerEx@@QAEHXZ:PROC		; CTimerEx::GetSecond
EXTRN	?g_TimerEx@@3VCTimerEx@@A:DWORD			; g_TimerEx
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\questionanswer.cpp
_TEXT	SEGMENT
$T231002 = -100						; size = 4
$T231003 = -96						; size = 4
_it$229194 = -28					; size = 4
_systime$ = -24						; size = 16
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?Run@CQuestionAnswer@@QAEXXZ PROC			; CQuestionAnswer::Run
; _this$ = ecx

; 160  : {

  00830	55		 push	 ebp
  00831	8b ec		 mov	 ebp, esp
  00833	83 ec 64	 sub	 esp, 100		; 00000064H
  00836	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0083b	33 c5		 xor	 eax, ebp
  0083d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00840	53		 push	 ebx
  00841	56		 push	 esi
  00842	57		 push	 edi
  00843	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 161  : 	if(!this->m_Enable)

  00846	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00849	83 38 00	 cmp	 DWORD PTR [eax], 0
  0084c	75 05		 jne	 SHORT $LN6@Run

; 162  : 	{
; 163  : 		return;

  0084e	e9 85 00 00 00	 jmp	 $LN7@Run
$LN6@Run:

; 164  : 	}
; 165  : 
; 166  : #if(NEWTIMEREX)
; 167  : 	if(g_TimerEx.GetSecond() != 00)

  00853	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TimerEx@@3VCTimerEx@@A ; g_TimerEx
  00858	e8 00 00 00 00	 call	 ?GetSecond@CTimerEx@@QAEHXZ ; CTimerEx::GetSecond
  0085d	85 c0		 test	 eax, eax
  0085f	74 02		 je	 SHORT $LN5@Run

; 168  : #else
; 169  : 	if(time.wSecond != 00)
; 170  : #endif
; 171  : 	{
; 172  : 		return;

  00861	eb 75		 jmp	 SHORT $LN7@Run
$LN5@Run:

; 173  : 	}
; 174  : 
; 175  : 	SYSTEMTIME systime;
; 176  : 
; 177  : 	GetLocalTime(&systime);

  00863	8d 45 e8	 lea	 eax, DWORD PTR _systime$[ebp]
  00866	50		 push	 eax
  00867	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocalTime@4

; 178  : 
; 179  : 	for(std::vector<QUESTIONANSWER_TIME>::iterator it = this->m_Time.begin(); it != this->m_Time.end(); it++)

  0086d	8d 45 e4	 lea	 eax, DWORD PTR _it$229194[ebp]
  00870	50		 push	 eax
  00871	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00874	83 c1 28	 add	 ecx, 40			; 00000028H
  00877	e8 00 00 00 00	 call	 ?begin@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@2@XZ ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::begin
  0087c	eb 0e		 jmp	 SHORT $LN4@Run
$LN3@Run:
  0087e	6a 00		 push	 0
  00880	8d 45 9c	 lea	 eax, DWORD PTR $T231002[ebp]
  00883	50		 push	 eax
  00884	8d 4d e4	 lea	 ecx, DWORD PTR _it$229194[ebp]
  00887	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >::operator++
$LN4@Run:
  0088c	8d 45 a0	 lea	 eax, DWORD PTR $T231003[ebp]
  0088f	50		 push	 eax
  00890	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00893	83 c1 28	 add	 ecx, 40			; 00000028H
  00896	e8 00 00 00 00	 call	 ?end@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@2@XZ ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::end
  0089b	50		 push	 eax
  0089c	8d 4d e4	 lea	 ecx, DWORD PTR _it$229194[ebp]
  0089f	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >::operator!=
  008a4	0f b6 c8	 movzx	 ecx, al
  008a7	85 c9		 test	 ecx, ecx
  008a9	74 2d		 je	 SHORT $LN7@Run

; 180  : 	{
; 181  : 		if(it->Hour == systime.wHour && it->Min == systime.wMinute)

  008ab	8d 4d e4	 lea	 ecx, DWORD PTR _it$229194[ebp]
  008ae	e8 00 00 00 00	 call	 ??C?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QBEPAUQUESTIONANSWER_TIME@@XZ ; std::_Vector_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >::operator->
  008b3	0f b7 4d f0	 movzx	 ecx, WORD PTR _systime$[ebp+8]
  008b7	39 08		 cmp	 DWORD PTR [eax], ecx
  008b9	75 1b		 jne	 SHORT $LN1@Run
  008bb	8d 4d e4	 lea	 ecx, DWORD PTR _it$229194[ebp]
  008be	e8 00 00 00 00	 call	 ??C?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QBEPAUQUESTIONANSWER_TIME@@XZ ; std::_Vector_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >::operator->
  008c3	0f b7 4d f2	 movzx	 ecx, WORD PTR _systime$[ebp+10]
  008c7	39 48 04	 cmp	 DWORD PTR [eax+4], ecx
  008ca	75 0a		 jne	 SHORT $LN1@Run

; 182  : 		{
; 183  : 			this->Search();

  008cc	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  008cf	e8 00 00 00 00	 call	 ?Search@CQuestionAnswer@@QAEXXZ ; CQuestionAnswer::Search

; 184  : 
; 185  : 			return;

  008d4	eb 02		 jmp	 SHORT $LN7@Run
$LN1@Run:

; 186  : 		}
; 187  : 	}

  008d6	eb a6		 jmp	 SHORT $LN3@Run
$LN7@Run:

; 188  : }

  008d8	5f		 pop	 edi
  008d9	5e		 pop	 esi
  008da	5b		 pop	 ebx
  008db	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  008de	33 cd		 xor	 ecx, ebp
  008e0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  008e5	8b e5		 mov	 esp, ebp
  008e7	5d		 pop	 ebp
  008e8	c3		 ret	 0
?Run@CQuestionAnswer@@QAEXXZ ENDP			; CQuestionAnswer::Run
_TEXT	ENDS
PUBLIC	??A?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAEAAUQUESTIONANSWER_DATA@@I@Z ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::operator[]
PUBLIC	?size@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QBEIXZ ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::size
EXTRN	?AllSendServerMsg@@YAXPAD@Z:PROC		; AllSendServerMsg
EXTRN	_rand:PROC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_iDataSize$ = -8					; size = 4
_this$ = -4						; size = 4
?Search@CQuestionAnswer@@QAEXXZ PROC			; CQuestionAnswer::Search
; _this$ = ecx

; 191  : {

  008f0	55		 push	 ebp
  008f1	8b ec		 mov	 ebp, esp
  008f3	83 ec 48	 sub	 esp, 72			; 00000048H
  008f6	53		 push	 ebx
  008f7	56		 push	 esi
  008f8	57		 push	 edi
  008f9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 192  : 	int iDataSize = this->m_Data.size();

  008fc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  008ff	83 c1 18	 add	 ecx, 24			; 00000018H
  00902	e8 00 00 00 00	 call	 ?size@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QBEIXZ ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::size
  00907	89 45 f8	 mov	 DWORD PTR _iDataSize$[ebp], eax

; 193  : 
; 194  : 	if(iDataSize <= 0)

  0090a	83 7d f8 00	 cmp	 DWORD PTR _iDataSize$[ebp], 0
  0090e	7f 02		 jg	 SHORT $LN1@Search

; 195  : 	{
; 196  : 		return;

  00910	eb 2a		 jmp	 SHORT $LN2@Search
$LN1@Search:

; 197  : 	}
; 198  : 
; 199  : 	this->m_NumData = rand() % iDataSize;

  00912	e8 00 00 00 00	 call	 _rand
  00917	99		 cdq
  00918	f7 7d f8	 idiv	 DWORD PTR _iDataSize$[ebp]
  0091b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0091e	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 200  : 
; 201  : 	AllSendServerMsg(this->m_Data[this->m_NumData].Question);

  00921	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00924	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00927	51		 push	 ecx
  00928	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0092b	83 c1 18	 add	 ecx, 24			; 00000018H
  0092e	e8 00 00 00 00	 call	 ??A?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAEAAUQUESTIONANSWER_DATA@@I@Z ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::operator[]
  00933	50		 push	 eax
  00934	e8 00 00 00 00	 call	 ?AllSendServerMsg@@YAXPAD@Z ; AllSendServerMsg
  00939	83 c4 04	 add	 esp, 4
$LN2@Search:

; 202  : }

  0093c	5f		 pop	 edi
  0093d	5e		 pop	 esi
  0093e	5b		 pop	 ebx
  0093f	8b e5		 mov	 esp, ebp
  00941	5d		 pop	 ebp
  00942	c3		 ret	 0
?Search@CQuestionAnswer@@QAEXXZ ENDP			; CQuestionAnswer::Search
_TEXT	ENDS
PUBLIC	??_C@_0BE@PEGBOLMA@?$FL?$CFs?$FN?5Correct?5Answer?$AA@ ; `string'
PUBLIC	?Reward@CQuestionAnswer@@QAEXH@Z		; CQuestionAnswer::Reward
PUBLIC	__$ArrayPad$
PUBLIC	?Chat@CQuestionAnswer@@QAEXHPAD@Z		; CQuestionAnswer::Chat
EXTRN	_sprintf:PROC
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
;	COMDAT ??_C@_0BE@PEGBOLMA@?$FL?$CFs?$FN?5Correct?5Answer?$AA@
CONST	SEGMENT
??_C@_0BE@PEGBOLMA@?$FL?$CFs?$FN?5Correct?5Answer?$AA@ DB '[%s] Correct A'
	DB	'nswer', 00H					; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv70 = -208						; size = 4
_szText$229233 = -140					; size = 128
_lpObj$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_Msg$ = 12						; size = 4
?Chat@CQuestionAnswer@@QAEXHPAD@Z PROC			; CQuestionAnswer::Chat
; _this$ = ecx

; 205  : {

  00950	55		 push	 ebp
  00951	8b ec		 mov	 ebp, esp
  00953	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00959	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0095e	33 c5		 xor	 eax, ebp
  00960	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00963	53		 push	 ebx
  00964	56		 push	 esi
  00965	57		 push	 edi
  00966	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 206  : 	if(!this->m_Enable)

  00969	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0096c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0096f	75 05		 jne	 SHORT $LN4@Chat

; 207  : 	{
; 208  : 		return;

  00971	e9 b5 00 00 00	 jmp	 $LN5@Chat
$LN4@Chat:

; 209  : 	}
; 210  : 	
; 211  : 	if(this->m_NumData == -1)

  00976	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00979	83 78 04 ff	 cmp	 DWORD PTR [eax+4], -1
  0097d	75 05		 jne	 SHORT $LN3@Chat

; 212  : 	{
; 213  : 		return;

  0097f	e9 a7 00 00 00	 jmp	 $LN5@Chat
$LN3@Chat:

; 214  : 	}
; 215  : 
; 216  : 	if(!OBJMAX_RANGE(aIndex))

  00984	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  00988	7d 0c		 jge	 SHORT $LN7@Chat
  0098a	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv70[ebp], 0
  00994	eb 12		 jmp	 SHORT $LN8@Chat
$LN7@Chat:
  00996	33 c0		 xor	 eax, eax
  00998	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  0099f	0f 9e c0	 setle	 al
  009a2	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv70[ebp], eax
$LN8@Chat:
  009a8	83 bd 30 ff ff
	ff 00		 cmp	 DWORD PTR tv70[ebp], 0
  009af	75 02		 jne	 SHORT $LN2@Chat

; 217  : 	{
; 218  : 		return;

  009b1	eb 78		 jmp	 SHORT $LN5@Chat
$LN2@Chat:

; 219  : 	}
; 220  : 
; 221  : 	LPOBJ lpObj = &gObj[aIndex];

  009b3	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  009b6	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  009bc	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  009c2	89 45 f4	 mov	 DWORD PTR _lpObj$[ebp], eax

; 222  : 
; 223  : 	if(!strcmp(Msg, this->m_Data[this->m_NumData].Answer))

  009c5	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  009c8	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  009cb	51		 push	 ecx
  009cc	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  009cf	83 c1 18	 add	 ecx, 24			; 00000018H
  009d2	e8 00 00 00 00	 call	 ??A?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAEAAUQUESTIONANSWER_DATA@@I@Z ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::operator[]
  009d7	83 c0 40	 add	 eax, 64			; 00000040H
  009da	50		 push	 eax
  009db	8b 55 0c	 mov	 edx, DWORD PTR _Msg$[ebp]
  009de	52		 push	 edx
  009df	e8 00 00 00 00	 call	 _strcmp
  009e4	83 c4 08	 add	 esp, 8
  009e7	85 c0		 test	 eax, eax
  009e9	75 40		 jne	 SHORT $LN5@Chat

; 224  : 	{
; 225  : 		this->Reward(aIndex);

  009eb	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  009ee	50		 push	 eax
  009ef	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  009f2	e8 00 00 00 00	 call	 ?Reward@CQuestionAnswer@@QAEXH@Z ; CQuestionAnswer::Reward

; 226  : 
; 227  : 		char szText[128];
; 228  : 		sprintf(szText, "[%s] Correct Answer", lpObj->Name);

  009f7	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009fa	83 c0 77	 add	 eax, 119		; 00000077H
  009fd	50		 push	 eax
  009fe	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@PEGBOLMA@?$FL?$CFs?$FN?5Correct?5Answer?$AA@
  00a03	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _szText$229233[ebp]
  00a09	51		 push	 ecx
  00a0a	e8 00 00 00 00	 call	 _sprintf
  00a0f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 229  : 		AllSendServerMsg(szText);

  00a12	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _szText$229233[ebp]
  00a18	50		 push	 eax
  00a19	e8 00 00 00 00	 call	 ?AllSendServerMsg@@YAXPAD@Z ; AllSendServerMsg
  00a1e	83 c4 04	 add	 esp, 4

; 230  : 	
; 231  : 		this->m_NumData = -1;

  00a21	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00a24	c7 40 04 ff ff
	ff ff		 mov	 DWORD PTR [eax+4], -1
$LN5@Chat:

; 232  : 	}
; 233  : }

  00a2b	5f		 pop	 edi
  00a2c	5e		 pop	 esi
  00a2d	5b		 pop	 ebx
  00a2e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00a31	33 cd		 xor	 ecx, ebp
  00a33	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00a38	8b e5		 mov	 esp, ebp
  00a3a	5d		 pop	 ebp
  00a3b	c2 08 00	 ret	 8
?Chat@CQuestionAnswer@@QAEXHPAD@Z ENDP			; CQuestionAnswer::Chat
_TEXT	ENDS
PUBLIC	??_C@_0O@MBBCCDIM@?$FLCredit?$FN?3?5?$CL?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0O@ECFCHPMI@?$FLWCoinG?$FN?3?5?$CL?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0O@DECMEHPK@?$FLWCoinP?$FN?3?5?$CL?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0O@MGBIHBDC@?$FLWCoinC?$FN?3?5?$CL?$CFd?$AA@ ; `string'
EXTRN	?GDSaveUserInfo@GameShop@@QAEXH@Z:PROC		; GameShop::GDSaveUserInfo
EXTRN	?gGameShop@@3VGameShop@@A:BYTE			; gGameShop
EXTRN	?ExUserDataSend@@YAXH@Z:PROC			; ExUserDataSend
EXTRN	?MsgOutput@@YAXHPADZZ:PROC			; MsgOutput
;	COMDAT ??_C@_0O@MBBCCDIM@?$FLCredit?$FN?3?5?$CL?$CFd?$AA@
CONST	SEGMENT
??_C@_0O@MBBCCDIM@?$FLCredit?$FN?3?5?$CL?$CFd?$AA@ DB '[Credit]: +%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@ECFCHPMI@?$FLWCoinG?$FN?3?5?$CL?$CFd?$AA@
CONST	SEGMENT
??_C@_0O@ECFCHPMI@?$FLWCoinG?$FN?3?5?$CL?$CFd?$AA@ DB '[WCoinG]: +%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DECMEHPK@?$FLWCoinP?$FN?3?5?$CL?$CFd?$AA@
CONST	SEGMENT
??_C@_0O@DECMEHPK@?$FLWCoinP?$FN?3?5?$CL?$CFd?$AA@ DB '[WCoinP]: +%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MGBIHBDC@?$FLWCoinC?$FN?3?5?$CL?$CFd?$AA@
CONST	SEGMENT
??_C@_0O@MGBIHBDC@?$FLWCoinC?$FN?3?5?$CL?$CFd?$AA@ DB '[WCoinC]: +%d', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv67 = -80						; size = 4
_bWcoinSend$ = -9					; size = 1
_lpObj$ = -8						; size = 4
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?Reward@CQuestionAnswer@@QAEXH@Z PROC			; CQuestionAnswer::Reward
; _this$ = ecx

; 236  : {

  00a40	55		 push	 ebp
  00a41	8b ec		 mov	 ebp, esp
  00a43	83 ec 50	 sub	 esp, 80			; 00000050H
  00a46	53		 push	 ebx
  00a47	56		 push	 esi
  00a48	57		 push	 edi
  00a49	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 237  : 	if(!OBJMAX_RANGE(aIndex))

  00a4c	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  00a50	7d 09		 jge	 SHORT $LN9@Reward
  00a52	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00a59	eb 0f		 jmp	 SHORT $LN10@Reward
$LN9@Reward:
  00a5b	33 c0		 xor	 eax, eax
  00a5d	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 14999 ; 00003a97H
  00a64	0f 9e c0	 setle	 al
  00a67	89 45 b0	 mov	 DWORD PTR tv67[ebp], eax
$LN10@Reward:
  00a6a	83 7d b0 00	 cmp	 DWORD PTR tv67[ebp], 0
  00a6e	75 05		 jne	 SHORT $LN6@Reward

; 238  : 	{
; 239  : 		return;

  00a70	e9 10 01 00 00	 jmp	 $LN7@Reward
$LN6@Reward:

; 240  : 	}
; 241  : 
; 242  : 	LPOBJ lpObj = &gObj[aIndex];

  00a75	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00a78	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00a7e	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00a84	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 243  : 
; 244  : 	bool bWcoinSend = false;

  00a87	c6 45 f7 00	 mov	 BYTE PTR _bWcoinSend$[ebp], 0

; 245  : 
; 246  : 	if(this->m_RewardWCoinC > 0)

  00a8b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00a8e	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00a92	7e 34		 jle	 SHORT $LN5@Reward

; 247  : 	{
; 248  : 		lpObj->GameShop.WCoinC += this->m_RewardWCoinC;

  00a94	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00a97	db 40 08	 fild	 DWORD PTR [eax+8]
  00a9a	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00a9d	dc 81 00 23 00
	00		 fadd	 QWORD PTR [ecx+8960]
  00aa3	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00aa6	dd 9a 00 23 00
	00		 fstp	 QWORD PTR [edx+8960]

; 249  : 		MsgOutput(aIndex, "[WCoinC]: +%d", this->m_RewardWCoinC);

  00aac	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00aaf	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00ab2	51		 push	 ecx
  00ab3	68 00 00 00 00	 push	 OFFSET ??_C@_0O@MGBIHBDC@?$FLWCoinC?$FN?3?5?$CL?$CFd?$AA@
  00ab8	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00abb	52		 push	 edx
  00abc	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  00ac1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 250  : 		bWcoinSend = true;

  00ac4	c6 45 f7 01	 mov	 BYTE PTR _bWcoinSend$[ebp], 1
$LN5@Reward:

; 251  : 	}
; 252  : 
; 253  : 	if(this->m_RewardWCoinP > 0)

  00ac8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00acb	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00acf	7e 34		 jle	 SHORT $LN4@Reward

; 254  : 	{
; 255  : 		lpObj->GameShop.WCoinP += this->m_RewardWCoinP;

  00ad1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00ad4	db 40 0c	 fild	 DWORD PTR [eax+12]
  00ad7	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00ada	dc 81 f8 22 00
	00		 fadd	 QWORD PTR [ecx+8952]
  00ae0	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00ae3	dd 9a f8 22 00
	00		 fstp	 QWORD PTR [edx+8952]

; 256  : 		MsgOutput(aIndex, "[WCoinP]: +%d", this->m_RewardWCoinP);

  00ae9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00aec	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00aef	51		 push	 ecx
  00af0	68 00 00 00 00	 push	 OFFSET ??_C@_0O@DECMEHPK@?$FLWCoinP?$FN?3?5?$CL?$CFd?$AA@
  00af5	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00af8	52		 push	 edx
  00af9	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  00afe	83 c4 0c	 add	 esp, 12			; 0000000cH

; 257  : 		bWcoinSend = true;

  00b01	c6 45 f7 01	 mov	 BYTE PTR _bWcoinSend$[ebp], 1
$LN4@Reward:

; 258  : 	}
; 259  : 
; 260  : 	if(this->m_RewardGoblin > 0)

  00b05	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00b08	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00b0c	7e 34		 jle	 SHORT $LN3@Reward

; 261  : 	{
; 262  : 		lpObj->GameShop.GoblinPoint += this->m_RewardGoblin;

  00b0e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00b11	db 40 10	 fild	 DWORD PTR [eax+16]
  00b14	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00b17	dc 81 08 23 00
	00		 fadd	 QWORD PTR [ecx+8968]
  00b1d	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00b20	dd 9a 08 23 00
	00		 fstp	 QWORD PTR [edx+8968]

; 263  : 		MsgOutput(aIndex, "[WCoinG]: +%d", this->m_RewardGoblin);

  00b26	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00b29	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00b2c	51		 push	 ecx
  00b2d	68 00 00 00 00	 push	 OFFSET ??_C@_0O@ECFCHPMI@?$FLWCoinG?$FN?3?5?$CL?$CFd?$AA@
  00b32	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00b35	52		 push	 edx
  00b36	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  00b3b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 264  : 		bWcoinSend = true;

  00b3e	c6 45 f7 01	 mov	 BYTE PTR _bWcoinSend$[ebp], 1
$LN3@Reward:

; 265  : 	}
; 266  : 
; 267  : 	if(this->m_RewardCredit > 0)

  00b42	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00b45	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  00b49	7e 24		 jle	 SHORT $LN2@Reward

; 268  : 	{
; 269  : 		ExUserDataSend(aIndex);

  00b4b	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00b4e	50		 push	 eax
  00b4f	e8 00 00 00 00	 call	 ?ExUserDataSend@@YAXH@Z	; ExUserDataSend
  00b54	83 c4 04	 add	 esp, 4

; 270  : 		MsgOutput(aIndex, "[Credit]: +%d", this->m_RewardCredit);

  00b57	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00b5a	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00b5d	51		 push	 ecx
  00b5e	68 00 00 00 00	 push	 OFFSET ??_C@_0O@MBBCCDIM@?$FLCredit?$FN?3?5?$CL?$CFd?$AA@
  00b63	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00b66	52		 push	 edx
  00b67	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  00b6c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@Reward:

; 271  : 	}
; 272  : 
; 273  : 	if(bWcoinSend)

  00b6f	0f b6 45 f7	 movzx	 eax, BYTE PTR _bWcoinSend$[ebp]
  00b73	85 c0		 test	 eax, eax
  00b75	74 0e		 je	 SHORT $LN1@Reward

; 274  : 	{
; 275  : 		gGameShop.GDSaveUserInfo(aIndex);

  00b77	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00b7a	50		 push	 eax
  00b7b	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGameShop@@3VGameShop@@A ; gGameShop
  00b80	e8 00 00 00 00	 call	 ?GDSaveUserInfo@GameShop@@QAEXH@Z ; GameShop::GDSaveUserInfo
$LN1@Reward:
$LN7@Reward:

; 276  : 	}
; 277  : }

  00b85	5f		 pop	 edi
  00b86	5e		 pop	 esi
  00b87	5b		 pop	 ebx
  00b88	8b e5		 mov	 esp, ebp
  00b8a	5d		 pop	 ebp
  00b8b	c2 04 00	 ret	 4
?Reward@CQuestionAnswer@@QAEXH@Z ENDP			; CQuestionAnswer::Reward
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAE@V?$allocator@UQUESTIONANSWER_DATA@@@1@@Z ; std::_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >
PUBLIC	??0?$allocator@UQUESTIONANSWER_DATA@@@std@@QAE@XZ ; std::allocator<QUESTIONANSWER_DATA>::allocator<QUESTIONANSWER_DATA>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T231013 = -72						; size = 4
_this$ = -4						; size = 4
??0?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAE@XZ PROC ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	51		 push	 ecx
  0000d	8b cc		 mov	 ecx, esp
  0000f	89 65 b8	 mov	 DWORD PTR $T231013[ebp], esp
  00012	e8 00 00 00 00	 call	 ??0?$allocator@UQUESTIONANSWER_DATA@@@std@@QAE@XZ ; std::allocator<QUESTIONANSWER_DATA>::allocator<QUESTIONANSWER_DATA>
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAE@V?$allocator@UQUESTIONANSWER_DATA@@@1@@Z ; std::_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >

; 508  : 		}

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAE@XZ ENDP ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAE@XZ ; std::_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::~_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >
PUBLIC	?_Tidy@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@IAEXXZ ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??1?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAE@XZ PROC ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::~vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >, COMDAT
; _this$ = ecx

; 704  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 705  : 		_Tidy();

  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@IAEXXZ ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::_Tidy

; 706  : 		}

  0003a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??1?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAE@XZ ; std::_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::~_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >
  00049	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAE@XZ ; std::_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::~_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >
__ehhandler$??1?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAE@XZ ENDP ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::~vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >
; Function compile flags: /Odtp /ZI
;	COMDAT ?size@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QBEIXZ PROC ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::size, COMDAT
; _this$ = ecx

; 878  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	c1 f8 07	 sar	 eax, 7

; 880  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?size@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::size
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??A?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAEAAUQUESTIONANSWER_DATA@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAEAAUQUESTIONANSWER_DATA@@I@Z PROC ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::operator[], COMDAT
; _this$ = ecx

; 928  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 929  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 930  : 		if (size() <= _Pos)
; 931  : 			{	// report error
; 932  : 			_DEBUG_ERROR("vector subscript out of range");
; 933  : 			_SCL_SECURE_OUT_OF_RANGE;
; 934  : 			}
; 935  : 
; 936  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 937  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 938  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 939  : 
; 940  : 		return (*(this->_Myfirst + _Pos));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  0000f	c1 e0 07	 shl	 eax, 7
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	03 01		 add	 eax, DWORD PTR [ecx]

; 941  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??A?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAEAAUQUESTIONANSWER_DATA@@I@Z ENDP ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::operator[]
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UQUESTIONANSWER_DATA@@@std@@UQUESTIONANSWER_DATA@@ABU3@@std@@YAXAAV?$allocator@UQUESTIONANSWER_DATA@@@0@PAUQUESTIONANSWER_DATA@@ABU2@@Z ; std::_Cons_val<std::allocator<QUESTIONANSWER_DATA>,QUESTIONANSWER_DATA,QUESTIONANSWER_DATA const &>
PUBLIC	??$_Cons_val@V?$allocator@UQUESTIONANSWER_DATA@@@std@@UQUESTIONANSWER_DATA@@AAU3@@std@@YAXAAV?$allocator@UQUESTIONANSWER_DATA@@@0@PAUQUESTIONANSWER_DATA@@AAU2@@Z ; std::_Cons_val<std::allocator<QUESTIONANSWER_DATA>,QUESTIONANSWER_DATA,QUESTIONANSWER_DATA &>
PUBLIC	?_Orphan_range@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@IBEXPAUQUESTIONANSWER_DATA@@0@Z ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::_Orphan_range
PUBLIC	?_Reserve@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@IAEXI@Z ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::_Reserve
PUBLIC	?_Inside@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@IBE_NPBUQUESTIONANSWER_DATA@@@Z ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::_Inside
PUBLIC	??$addressof@$$CBUQUESTIONANSWER_DATA@@@std@@YAPBUQUESTIONANSWER_DATA@@ABU1@@Z ; std::addressof<QUESTIONANSWER_DATA const >
; Function compile flags: /Odtp /ZI
;	COMDAT ?push_back@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAEXABUQUESTIONANSWER_DATA@@@Z
_TEXT	SEGMENT
__Idx$229280 = -8					; size = 4
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAEXABUQUESTIONANSWER_DATA@@@Z PROC ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$addressof@$$CBUQUESTIONANSWER_DATA@@@std@@YAPBUQUESTIONANSWER_DATA@@ABU1@@Z ; std::addressof<QUESTIONANSWER_DATA const >
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Inside@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@IBE_NPBUQUESTIONANSWER_DATA@@@Z ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::_Inside
  00021	0f b6 c8	 movzx	 ecx, al
  00024	85 c9		 test	 ecx, ecx
  00026	74 7b		 je	 SHORT $LN4@push_back

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$addressof@$$CBUQUESTIONANSWER_DATA@@@std@@YAPBUQUESTIONANSWER_DATA@@ABU1@@Z ; std::addressof<QUESTIONANSWER_DATA const >
  00031	83 c4 04	 add	 esp, 4
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	2b 01		 sub	 eax, DWORD PTR [ecx]
  00039	c1 f8 07	 sar	 eax, 7
  0003c	89 45 f8	 mov	 DWORD PTR __Idx$229280[ebp], eax

; 980  : 			if (this->_Mylast == this->_Myend)

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00048	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0004b	75 0a		 jne	 SHORT $LN3@push_back

; 981  : 				_Reserve(1);

  0004d	6a 01		 push	 1
  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@IAEXI@Z ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::_Reserve
$LN3@push_back:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  00057	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005d	51		 push	 ecx
  0005e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00061	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00064	50		 push	 eax
  00065	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@IBEXPAUQUESTIONANSWER_DATA@@0@Z ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::_Orphan_range

; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  0006d	8b 45 f8	 mov	 eax, DWORD PTR __Idx$229280[ebp]
  00070	c1 e0 07	 shl	 eax, 7
  00073	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	03 01		 add	 eax, DWORD PTR [ecx]
  00078	50		 push	 eax
  00079	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0007c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0007f	50		 push	 eax
  00080	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00083	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00086	51		 push	 ecx
  00087	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UQUESTIONANSWER_DATA@@@std@@UQUESTIONANSWER_DATA@@AAU3@@std@@YAXAAV?$allocator@UQUESTIONANSWER_DATA@@@0@PAUQUESTIONANSWER_DATA@@AAU2@@Z ; std::_Cons_val<std::allocator<QUESTIONANSWER_DATA>,QUESTIONANSWER_DATA,QUESTIONANSWER_DATA &>
  0008c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 986  : 			++this->_Mylast;

  0008f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00092	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00095	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0009b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0009e	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 987  : 			}
; 988  : 		else

  000a1	eb 5a		 jmp	 SHORT $LN5@push_back
$LN4@push_back:

; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  000a3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a9	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000ac	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  000af	75 0a		 jne	 SHORT $LN1@push_back

; 991  : 				_Reserve(1);

  000b1	6a 01		 push	 1
  000b3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b6	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@IAEXI@Z ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::_Reserve
$LN1@push_back:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  000bb	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000be	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000c1	51		 push	 ecx
  000c2	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c5	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000c8	50		 push	 eax
  000c9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000cc	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@IBEXPAUQUESTIONANSWER_DATA@@0@Z ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::_Orphan_range

; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  000d1	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  000d4	50		 push	 eax
  000d5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d8	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000db	52		 push	 edx
  000dc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000df	83 c0 0c	 add	 eax, 12			; 0000000cH
  000e2	50		 push	 eax
  000e3	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UQUESTIONANSWER_DATA@@@std@@UQUESTIONANSWER_DATA@@ABU3@@std@@YAXAAV?$allocator@UQUESTIONANSWER_DATA@@@0@PAUQUESTIONANSWER_DATA@@ABU2@@Z ; std::_Cons_val<std::allocator<QUESTIONANSWER_DATA>,QUESTIONANSWER_DATA,QUESTIONANSWER_DATA const &>
  000e8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  000eb	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ee	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000f1	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  000f7	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000fa	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN5@push_back:

; 997  : 			}
; 998  : 		}

  000fd	5f		 pop	 edi
  000fe	5e		 pop	 esi
  000ff	5b		 pop	 ebx
  00100	8b e5		 mov	 esp, ebp
  00102	5d		 pop	 ebp
  00103	c2 04 00	 ret	 4
?push_back@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAEXABUQUESTIONANSWER_DATA@@@Z ENDP ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::push_back
_TEXT	ENDS
PUBLIC	?erase@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@2@0@Z ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::erase
PUBLIC	?begin@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@2@XZ ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::begin
PUBLIC	?end@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@2@XZ ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::end
; Function compile flags: /Odtp /ZI
;	COMDAT ?clear@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T231032 = -88						; size = 4
$T231033 = -84						; size = 4
$T231034 = -80						; size = 4
$T231035 = -76						; size = 4
$T231036 = -72						; size = 4
_this$ = -4						; size = 4
?clear@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAEXXZ PROC ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::clear, COMDAT
; _this$ = ecx

; 1217 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1218 : 		erase(begin(), end());

  0000c	8d 45 ac	 lea	 eax, DWORD PTR $T231033[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?end@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@2@XZ ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::end
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d a8	 mov	 DWORD PTR $T231032[ebp], ecx
  0001d	8d 55 b4	 lea	 edx, DWORD PTR $T231035[ebp]
  00020	52		 push	 edx
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?begin@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@2@XZ ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::begin
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 b0	 mov	 DWORD PTR $T231034[ebp], eax
  0002e	8b 4d a8	 mov	 ecx, DWORD PTR $T231032[ebp]
  00031	51		 push	 ecx
  00032	8b 55 b0	 mov	 edx, DWORD PTR $T231034[ebp]
  00035	52		 push	 edx
  00036	8d 45 b8	 lea	 eax, DWORD PTR $T231036[ebp]
  00039	50		 push	 eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?erase@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@2@0@Z ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::erase

; 1219 : 		}

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?clear@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAEXXZ ENDP ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::clear
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAE@V?$allocator@UQUESTIONANSWER_TIME@@@1@@Z ; std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >
PUBLIC	??0?$allocator@UQUESTIONANSWER_TIME@@@std@@QAE@XZ ; std::allocator<QUESTIONANSWER_TIME>::allocator<QUESTIONANSWER_TIME>
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T231039 = -72						; size = 4
_this$ = -4						; size = 4
??0?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAE@XZ PROC ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	51		 push	 ecx
  0000d	8b cc		 mov	 ecx, esp
  0000f	89 65 b8	 mov	 DWORD PTR $T231039[ebp], esp
  00012	e8 00 00 00 00	 call	 ??0?$allocator@UQUESTIONANSWER_TIME@@@std@@QAE@XZ ; std::allocator<QUESTIONANSWER_TIME>::allocator<QUESTIONANSWER_TIME>
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAE@V?$allocator@UQUESTIONANSWER_TIME@@@1@@Z ; std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >

; 508  : 		}

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAE@XZ ENDP ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAE@XZ ; std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::~_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >
PUBLIC	?_Tidy@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@IAEXXZ ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??1?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAE@XZ PROC ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::~vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >, COMDAT
; _this$ = ecx

; 704  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 705  : 		_Tidy();

  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@IAEXXZ ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::_Tidy

; 706  : 		}

  0003a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??1?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAE@XZ ; std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::~_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >
  00049	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAE@XZ ; std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::~_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >
__ehhandler$??1?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAE@XZ ENDP ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::~vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QAE@PAUQUESTIONANSWER_TIME@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >::_Vector_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ?begin@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@2@XZ PROC ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 782  : 		return (iterator(this->_Myfirst, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	52		 push	 edx
  00016	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00019	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QAE@PAUQUESTIONANSWER_TIME@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >::_Vector_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >
  0001e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 783  : 		}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?begin@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@2@XZ ENDP ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::begin
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?end@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@2@XZ PROC ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 792  : 		return (iterator(this->_Mylast, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	52		 push	 edx
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QAE@PAUQUESTIONANSWER_TIME@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >::_Vector_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >
  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 793  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?end@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@2@XZ ENDP ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::end
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UQUESTIONANSWER_TIME@@@std@@UQUESTIONANSWER_TIME@@ABU3@@std@@YAXAAV?$allocator@UQUESTIONANSWER_TIME@@@0@PAUQUESTIONANSWER_TIME@@ABU2@@Z ; std::_Cons_val<std::allocator<QUESTIONANSWER_TIME>,QUESTIONANSWER_TIME,QUESTIONANSWER_TIME const &>
PUBLIC	??$_Cons_val@V?$allocator@UQUESTIONANSWER_TIME@@@std@@UQUESTIONANSWER_TIME@@AAU3@@std@@YAXAAV?$allocator@UQUESTIONANSWER_TIME@@@0@PAUQUESTIONANSWER_TIME@@AAU2@@Z ; std::_Cons_val<std::allocator<QUESTIONANSWER_TIME>,QUESTIONANSWER_TIME,QUESTIONANSWER_TIME &>
PUBLIC	?_Orphan_range@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@IBEXPAUQUESTIONANSWER_TIME@@0@Z ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::_Orphan_range
PUBLIC	?_Reserve@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@IAEXI@Z ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::_Reserve
PUBLIC	?_Inside@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@IBE_NPBUQUESTIONANSWER_TIME@@@Z ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::_Inside
PUBLIC	??$addressof@$$CBUQUESTIONANSWER_TIME@@@std@@YAPBUQUESTIONANSWER_TIME@@ABU1@@Z ; std::addressof<QUESTIONANSWER_TIME const >
; Function compile flags: /Odtp /ZI
;	COMDAT ?push_back@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAEXABUQUESTIONANSWER_TIME@@@Z
_TEXT	SEGMENT
__Idx$229460 = -8					; size = 4
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAEXABUQUESTIONANSWER_TIME@@@Z PROC ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$addressof@$$CBUQUESTIONANSWER_TIME@@@std@@YAPBUQUESTIONANSWER_TIME@@ABU1@@Z ; std::addressof<QUESTIONANSWER_TIME const >
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Inside@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@IBE_NPBUQUESTIONANSWER_TIME@@@Z ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::_Inside
  00021	0f b6 c8	 movzx	 ecx, al
  00024	85 c9		 test	 ecx, ecx
  00026	74 78		 je	 SHORT $LN4@push_back@2

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$addressof@$$CBUQUESTIONANSWER_TIME@@@std@@YAPBUQUESTIONANSWER_TIME@@ABU1@@Z ; std::addressof<QUESTIONANSWER_TIME const >
  00031	83 c4 04	 add	 esp, 4
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	2b 01		 sub	 eax, DWORD PTR [ecx]
  00039	c1 f8 03	 sar	 eax, 3
  0003c	89 45 f8	 mov	 DWORD PTR __Idx$229460[ebp], eax

; 980  : 			if (this->_Mylast == this->_Myend)

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00048	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0004b	75 0a		 jne	 SHORT $LN3@push_back@2

; 981  : 				_Reserve(1);

  0004d	6a 01		 push	 1
  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@IAEXI@Z ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::_Reserve
$LN3@push_back@2:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  00057	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005d	51		 push	 ecx
  0005e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00061	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00064	50		 push	 eax
  00065	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@IBEXPAUQUESTIONANSWER_TIME@@0@Z ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::_Orphan_range

; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  0006d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00070	8b 08		 mov	 ecx, DWORD PTR [eax]
  00072	8b 55 f8	 mov	 edx, DWORD PTR __Idx$229460[ebp]
  00075	8d 04 d1	 lea	 eax, DWORD PTR [ecx+edx*8]
  00078	50		 push	 eax
  00079	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007f	52		 push	 edx
  00080	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00083	83 c0 0c	 add	 eax, 12			; 0000000cH
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UQUESTIONANSWER_TIME@@@std@@UQUESTIONANSWER_TIME@@AAU3@@std@@YAXAAV?$allocator@UQUESTIONANSWER_TIME@@@0@PAUQUESTIONANSWER_TIME@@AAU2@@Z ; std::_Cons_val<std::allocator<QUESTIONANSWER_TIME>,QUESTIONANSWER_TIME,QUESTIONANSWER_TIME &>
  0008c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 986  : 			++this->_Mylast;

  0008f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00092	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00095	83 c1 08	 add	 ecx, 8
  00098	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0009b	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 987  : 			}
; 988  : 		else

  0009e	eb 57		 jmp	 SHORT $LN5@push_back@2
$LN4@push_back@2:

; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  000a0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a9	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  000ac	75 0a		 jne	 SHORT $LN1@push_back@2

; 991  : 				_Reserve(1);

  000ae	6a 01		 push	 1
  000b0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b3	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@IAEXI@Z ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::_Reserve
$LN1@push_back@2:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);

  000b8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000bb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000be	51		 push	 ecx
  000bf	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c2	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000c5	50		 push	 eax
  000c6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c9	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@IBEXPAUQUESTIONANSWER_TIME@@0@Z ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::_Orphan_range

; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  000ce	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  000d1	50		 push	 eax
  000d2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d5	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000d8	52		 push	 edx
  000d9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000dc	83 c0 0c	 add	 eax, 12			; 0000000cH
  000df	50		 push	 eax
  000e0	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UQUESTIONANSWER_TIME@@@std@@UQUESTIONANSWER_TIME@@ABU3@@std@@YAXAAV?$allocator@UQUESTIONANSWER_TIME@@@0@PAUQUESTIONANSWER_TIME@@ABU2@@Z ; std::_Cons_val<std::allocator<QUESTIONANSWER_TIME>,QUESTIONANSWER_TIME,QUESTIONANSWER_TIME const &>
  000e5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  000e8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000eb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ee	83 c1 08	 add	 ecx, 8
  000f1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000f4	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN5@push_back@2:

; 997  : 			}
; 998  : 		}

  000f7	5f		 pop	 edi
  000f8	5e		 pop	 esi
  000f9	5b		 pop	 ebx
  000fa	8b e5		 mov	 esp, ebp
  000fc	5d		 pop	 ebp
  000fd	c2 04 00	 ret	 4
?push_back@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAEXABUQUESTIONANSWER_TIME@@@Z ENDP ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::push_back
_TEXT	ENDS
PUBLIC	?erase@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@2@0@Z ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::erase
; Function compile flags: /Odtp /ZI
;	COMDAT ?clear@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T231058 = -88						; size = 4
$T231059 = -84						; size = 4
$T231060 = -80						; size = 4
$T231061 = -76						; size = 4
$T231062 = -72						; size = 4
_this$ = -4						; size = 4
?clear@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAEXXZ PROC ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::clear, COMDAT
; _this$ = ecx

; 1217 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1218 : 		erase(begin(), end());

  0000c	8d 45 ac	 lea	 eax, DWORD PTR $T231059[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?end@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@2@XZ ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::end
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d a8	 mov	 DWORD PTR $T231058[ebp], ecx
  0001d	8d 55 b4	 lea	 edx, DWORD PTR $T231061[ebp]
  00020	52		 push	 edx
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?begin@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@2@XZ ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::begin
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 b0	 mov	 DWORD PTR $T231060[ebp], eax
  0002e	8b 4d a8	 mov	 ecx, DWORD PTR $T231058[ebp]
  00031	51		 push	 ecx
  00032	8b 55 b0	 mov	 edx, DWORD PTR $T231060[ebp]
  00035	52		 push	 edx
  00036	8d 45 b8	 lea	 eax, DWORD PTR $T231062[ebp]
  00039	50		 push	 eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?erase@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@2@0@Z ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::erase

; 1219 : 		}

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?clear@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAEXXZ ENDP ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::clear
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QBEAAUQUESTIONANSWER_TIME@@XZ ; std::_Vector_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >::operator*
; Function compile flags: /Odtp /ZI
;	COMDAT ??C?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QBEPAUQUESTIONANSWER_TIME@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??C?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QBEPAUQUESTIONANSWER_TIME@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >::operator->, COMDAT
; _this$ = ecx

; 326  : 		{	// return pointer to class object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 327  : 		return (&**this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QBEAAUQUESTIONANSWER_TIME@@XZ ; std::_Vector_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >::operator*

; 328  : 		}

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??C?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QBEPAUQUESTIONANSWER_TIME@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >::operator->
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >::operator++
; Function compile flags: /Odtp /ZI
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >::operator++, COMDAT
; _this$ = ecx

; 337  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 338  : 		_Myiter _Tmp = *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	89 4d f8	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 339  : 		++*this;

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >::operator++

; 340  : 		return (_Tmp);

  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Tmp$[ebp]
  00022	89 08		 mov	 DWORD PTR [eax], ecx
  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 341  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
??E?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >::operator==
; Function compile flags: /Odtp /ZI
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 208  : 		return (!(*this == _Right));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??8?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >::operator==
  00018	0f b6 c0	 movzx	 eax, al
  0001b	f7 d8		 neg	 eax
  0001d	1b c0		 sbb	 eax, eax
  0001f	83 c0 01	 add	 eax, 1

; 209  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >::operator!=
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@std@@QAE@PAUQUESTIONANSWER_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> > >::_Vector_iterator<std::_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ?begin@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@2@XZ PROC ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 782  : 		return (iterator(this->_Myfirst, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	52		 push	 edx
  00016	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00019	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@std@@QAE@PAUQUESTIONANSWER_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> > >::_Vector_iterator<std::_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> > >
  0001e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 783  : 		}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?begin@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@2@XZ ENDP ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::begin
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?end@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@2@XZ PROC ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 792  : 		return (iterator(this->_Mylast, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	52		 push	 edx
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@std@@QAE@PAUQUESTIONANSWER_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> > >::_Vector_iterator<std::_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> > >
  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 793  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?end@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@2@XZ ENDP ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::end
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@IAEXPAUQUESTIONANSWER_DATA@@0@Z ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::_Destroy
PUBLIC	??$_Move@PAUQUESTIONANSWER_DATA@@PAU1@@std@@YAPAUQUESTIONANSWER_DATA@@PAU1@00@Z ; std::_Move<QUESTIONANSWER_DATA *,QUESTIONANSWER_DATA *>
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> > >::operator!=
PUBLIC	?_Make_iter@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@2@@Z ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::_Make_iter
; Function compile flags: /Odtp /ZI
;	COMDAT ?erase@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T231075 = -84						; size = 4
__Ptr$229543 = -16					; size = 4
__Last$ = -12						; size = 4
__First$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@2@0@Z PROC ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::erase, COMDAT
; _this$ = ecx

; 1190 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1191 : 		iterator _First = _Make_iter(_First_arg);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __First_arg$[ebp]
  0000f	50		 push	 eax
  00010	8d 4d f8	 lea	 ecx, DWORD PTR __First$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@2@@Z ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::_Make_iter

; 1192 : 		iterator _Last = _Make_iter(_Last_arg);

  0001c	8b 45 10	 mov	 eax, DWORD PTR __Last_arg$[ebp]
  0001f	50		 push	 eax
  00020	8d 4d f4	 lea	 ecx, DWORD PTR __Last$[ebp]
  00023	51		 push	 ecx
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@2@@Z ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::_Make_iter

; 1193 : 
; 1194 : 		if (_First != _Last)

  0002c	8d 45 f4	 lea	 eax, DWORD PTR __Last$[ebp]
  0002f	50		 push	 eax
  00030	8d 4d f8	 lea	 ecx, DWORD PTR __First$[ebp]
  00033	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> > >::operator!=
  00038	0f b6 c8	 movzx	 ecx, al
  0003b	85 c9		 test	 ecx, ecx
  0003d	74 36		 je	 SHORT $LN1@erase

; 1195 : 			{	// worth doing, copy down over hole
; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 			if (_Last < _First || _VICONT(_First) != this
; 1198 : 				|| _VIPTR(_First) < this->_Myfirst
; 1199 : 				|| this->_Mylast < _VIPTR(_Last))
; 1200 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1201 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1202 : 				_VIPTR(_First));
; 1203 : 			_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1204 : 
; 1205 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1206 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1207 : 				_VIPTR(_First));

  0003f	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00042	50		 push	 eax
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00049	52		 push	 edx
  0004a	8b 45 f4	 mov	 eax, DWORD PTR __Last$[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ??$_Move@PAUQUESTIONANSWER_DATA@@PAU1@@std@@YAPAUQUESTIONANSWER_DATA@@PAU1@00@Z ; std::_Move<QUESTIONANSWER_DATA *,QUESTIONANSWER_DATA *>
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH
  00056	89 45 f0	 mov	 DWORD PTR __Ptr$229543[ebp], eax

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 			_Destroy(_Ptr, this->_Mylast);

  00059	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005f	51		 push	 ecx
  00060	8b 55 f0	 mov	 edx, DWORD PTR __Ptr$229543[ebp]
  00063	52		 push	 edx
  00064	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@IAEXPAUQUESTIONANSWER_DATA@@0@Z ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::_Destroy

; 1211 : 			this->_Mylast = _Ptr;

  0006c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006f	8b 4d f0	 mov	 ecx, DWORD PTR __Ptr$229543[ebp]
  00072	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@erase:

; 1212 : 			}
; 1213 : 		return (_Make_iter(_First));

  00075	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00078	89 45 ac	 mov	 DWORD PTR $T231075[ebp], eax
  0007b	8b 4d ac	 mov	 ecx, DWORD PTR $T231075[ebp]
  0007e	51		 push	 ecx
  0007f	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00082	52		 push	 edx
  00083	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@2@@Z ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::_Make_iter
  0008b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1214 : 		}

  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@2@0@Z ENDP ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::erase
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Inside@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@IBE_NPBUQUESTIONANSWER_DATA@@@Z
_TEXT	SEGMENT
tv76 = -72						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@IBE_NPBUQUESTIONANSWER_DATA@@@Z PROC ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00012	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00015	73 13		 jae	 SHORT $LN3@Inside
  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	3b 45 08	 cmp	 eax, DWORD PTR __Ptr$[ebp]
  0001f	77 09		 ja	 SHORT $LN3@Inside
  00021	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  00028	eb 07		 jmp	 SHORT $LN4@Inside
$LN3@Inside:
  0002a	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN4@Inside:
  00031	8a 45 b8	 mov	 al, BYTE PTR tv76[ebp]

; 1287 : 		}

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?_Inside@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@IBE_NPBUQUESTIONANSWER_DATA@@@Z ENDP ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::_Inside
_TEXT	ENDS
PUBLIC	?reserve@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAEXI@Z ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::reserve
PUBLIC	?_Grow_to@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@IBEII@Z ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::_Grow_to
PUBLIC	?capacity@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QBEIXZ ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::capacity
PUBLIC	?_Xlen@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@IBEXXZ ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::_Xlen
PUBLIC	?max_size@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QBEIXZ ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Reserve@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$ = -8						; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@IAEXI@Z PROC ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1291 : 		size_type _Size = size();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?size@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QBEIXZ ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::size
  00014	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax

; 1292 : 		if (max_size() - _Count < _Size)

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QBEIXZ ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::max_size
  0001f	2b 45 08	 sub	 eax, DWORD PTR __Count$[ebp]
  00022	3b 45 f8	 cmp	 eax, DWORD PTR __Size$[ebp]
  00025	73 0a		 jae	 SHORT $LN4@Reserve

; 1293 : 			_Xlen();

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@IBEXXZ ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::_Xlen
  0002f	eb 2d		 jmp	 SHORT $LN6@Reserve
$LN4@Reserve:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00031	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  00034	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]
  00037	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?capacity@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QBEIXZ ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::capacity
  00042	39 45 f8	 cmp	 DWORD PTR __Size$[ebp], eax
  00045	77 02		 ja	 SHORT $LN2@Reserve

; 1295 : 			;
; 1296 : 		else

  00047	eb 15		 jmp	 SHORT $LN6@Reserve
$LN2@Reserve:

; 1297 : 			reserve(_Grow_to(_Size));

  00049	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?_Grow_to@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@IBEII@Z ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::_Grow_to
  00055	50		 push	 eax
  00056	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ?reserve@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAEXI@Z ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::reserve
$LN6@Reserve:

; 1298 : 		}

  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?_Reserve@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@IAEXI@Z ENDP ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::_Reserve
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UQUESTIONANSWER_DATA@@@std@@QAEXPAUQUESTIONANSWER_DATA@@I@Z ; std::allocator<QUESTIONANSWER_DATA>::deallocate
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Tidy@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@IAEXXZ PROC ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1302 : 		if (this->_Myfirst != 0)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00012	74 3d		 je	 SHORT $LN1@Tidy

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00022	51		 push	 ecx
  00023	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00026	8b 02		 mov	 eax, DWORD PTR [edx]
  00028	50		 push	 eax
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@IAEXPAUQUESTIONANSWER_DATA@@0@Z ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::_Destroy

; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0003a	2b 11		 sub	 edx, DWORD PTR [ecx]
  0003c	c1 fa 07	 sar	 edx, 7
  0003f	52		 push	 edx
  00040	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b 08		 mov	 ecx, DWORD PTR [eax]
  00045	51		 push	 ecx
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0004c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UQUESTIONANSWER_DATA@@@std@@QAEXPAUQUESTIONANSWER_DATA@@I@Z ; std::allocator<QUESTIONANSWER_DATA>::deallocate
$LN1@Tidy:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00051	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00054	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1310 : 		this->_Mylast = 0;

  0005a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1311 : 		this->_Myend = 0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 1312 : 		}

  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
?_Tidy@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@IAEXXZ ENDP ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::_Tidy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Orphan_range@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@IBEXPAUQUESTIONANSWER_DATA@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@IBEXPAUQUESTIONANSWER_DATA@@0@Z PROC ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1453 : 		{	// orphan iterators within specified (inclusive) range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1454 : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@IBEXPAUQUESTIONANSWER_DATA@@0@Z ENDP ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??0?$allocator@UQUESTIONANSWER_DATA@@@std@@QAE@ABV01@@Z ; std::allocator<QUESTIONANSWER_DATA>::allocator<QUESTIONANSWER_DATA>
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAE@V?$allocator@UQUESTIONANSWER_DATA@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAE@V?$allocator@UQUESTIONANSWER_DATA@@@1@@Z PROC ; std::_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00016	e8 00 00 00 00	 call	 ??0?$allocator@UQUESTIONANSWER_DATA@@@std@@QAE@ABV01@@Z ; std::allocator<QUESTIONANSWER_DATA>::allocator<QUESTIONANSWER_DATA>

; 427  : 		_Myfirst = 0;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 428  : 		_Mylast = 0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 429  : 		_Myend = 0;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 430  : 		}

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
??0?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAE@V?$allocator@UQUESTIONANSWER_DATA@@@1@@Z ENDP ; std::_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::~_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >, COMDAT
; _this$ = ecx

; 433  : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 434  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::~_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UQUESTIONANSWER_DATA@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@UQUESTIONANSWER_DATA@@@std@@QAE@XZ PROC	; std::allocator<QUESTIONANSWER_DATA>::allocator<QUESTIONANSWER_DATA>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@UQUESTIONANSWER_DATA@@@std@@QAE@XZ ENDP	; std::allocator<QUESTIONANSWER_DATA>::allocator<QUESTIONANSWER_DATA>
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@IAEXPAUQUESTIONANSWER_TIME@@0@Z ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::_Destroy
PUBLIC	??$_Move@PAUQUESTIONANSWER_TIME@@PAU1@@std@@YAPAUQUESTIONANSWER_TIME@@PAU1@00@Z ; std::_Move<QUESTIONANSWER_TIME *,QUESTIONANSWER_TIME *>
PUBLIC	?_Make_iter@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@2@@Z ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::_Make_iter
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?erase@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T231094 = -84						; size = 4
__Ptr$229581 = -16					; size = 4
__Last$ = -12						; size = 4
__First$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@2@0@Z PROC ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::erase, COMDAT
; _this$ = ecx

; 1190 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1191 : 		iterator _First = _Make_iter(_First_arg);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __First_arg$[ebp]
  0000f	50		 push	 eax
  00010	8d 4d f8	 lea	 ecx, DWORD PTR __First$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@2@@Z ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::_Make_iter

; 1192 : 		iterator _Last = _Make_iter(_Last_arg);

  0001c	8b 45 10	 mov	 eax, DWORD PTR __Last_arg$[ebp]
  0001f	50		 push	 eax
  00020	8d 4d f4	 lea	 ecx, DWORD PTR __Last$[ebp]
  00023	51		 push	 ecx
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@2@@Z ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::_Make_iter

; 1193 : 
; 1194 : 		if (_First != _Last)

  0002c	8d 45 f4	 lea	 eax, DWORD PTR __Last$[ebp]
  0002f	50		 push	 eax
  00030	8d 4d f8	 lea	 ecx, DWORD PTR __First$[ebp]
  00033	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >::operator!=
  00038	0f b6 c8	 movzx	 ecx, al
  0003b	85 c9		 test	 ecx, ecx
  0003d	74 36		 je	 SHORT $LN1@erase@2

; 1195 : 			{	// worth doing, copy down over hole
; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 			if (_Last < _First || _VICONT(_First) != this
; 1198 : 				|| _VIPTR(_First) < this->_Myfirst
; 1199 : 				|| this->_Mylast < _VIPTR(_Last))
; 1200 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1201 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1202 : 				_VIPTR(_First));
; 1203 : 			_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1204 : 
; 1205 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1206 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1207 : 				_VIPTR(_First));

  0003f	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00042	50		 push	 eax
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00049	52		 push	 edx
  0004a	8b 45 f4	 mov	 eax, DWORD PTR __Last$[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ??$_Move@PAUQUESTIONANSWER_TIME@@PAU1@@std@@YAPAUQUESTIONANSWER_TIME@@PAU1@00@Z ; std::_Move<QUESTIONANSWER_TIME *,QUESTIONANSWER_TIME *>
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH
  00056	89 45 f0	 mov	 DWORD PTR __Ptr$229581[ebp], eax

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 			_Destroy(_Ptr, this->_Mylast);

  00059	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005f	51		 push	 ecx
  00060	8b 55 f0	 mov	 edx, DWORD PTR __Ptr$229581[ebp]
  00063	52		 push	 edx
  00064	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@IAEXPAUQUESTIONANSWER_TIME@@0@Z ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::_Destroy

; 1211 : 			this->_Mylast = _Ptr;

  0006c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006f	8b 4d f0	 mov	 ecx, DWORD PTR __Ptr$229581[ebp]
  00072	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@erase@2:

; 1212 : 			}
; 1213 : 		return (_Make_iter(_First));

  00075	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00078	89 45 ac	 mov	 DWORD PTR $T231094[ebp], eax
  0007b	8b 4d ac	 mov	 ecx, DWORD PTR $T231094[ebp]
  0007e	51		 push	 ecx
  0007f	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00082	52		 push	 edx
  00083	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@2@@Z ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::_Make_iter
  0008b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1214 : 		}

  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@2@0@Z ENDP ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::erase
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Inside@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@IBE_NPBUQUESTIONANSWER_TIME@@@Z
_TEXT	SEGMENT
tv76 = -72						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@IBE_NPBUQUESTIONANSWER_TIME@@@Z PROC ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00012	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00015	73 13		 jae	 SHORT $LN3@Inside@2
  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	3b 45 08	 cmp	 eax, DWORD PTR __Ptr$[ebp]
  0001f	77 09		 ja	 SHORT $LN3@Inside@2
  00021	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  00028	eb 07		 jmp	 SHORT $LN4@Inside@2
$LN3@Inside@2:
  0002a	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN4@Inside@2:
  00031	8a 45 b8	 mov	 al, BYTE PTR tv76[ebp]

; 1287 : 		}

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?_Inside@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@IBE_NPBUQUESTIONANSWER_TIME@@@Z ENDP ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::_Inside
_TEXT	ENDS
PUBLIC	?reserve@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAEXI@Z ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::reserve
PUBLIC	?_Grow_to@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@IBEII@Z ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::_Grow_to
PUBLIC	?capacity@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QBEIXZ ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::capacity
PUBLIC	?_Xlen@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@IBEXXZ ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::_Xlen
PUBLIC	?max_size@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QBEIXZ ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::max_size
PUBLIC	?size@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QBEIXZ ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::size
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Reserve@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$ = -8						; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@IAEXI@Z PROC ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1291 : 		size_type _Size = size();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?size@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QBEIXZ ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::size
  00014	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax

; 1292 : 		if (max_size() - _Count < _Size)

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QBEIXZ ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::max_size
  0001f	2b 45 08	 sub	 eax, DWORD PTR __Count$[ebp]
  00022	3b 45 f8	 cmp	 eax, DWORD PTR __Size$[ebp]
  00025	73 0a		 jae	 SHORT $LN4@Reserve@2

; 1293 : 			_Xlen();

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@IBEXXZ ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::_Xlen
  0002f	eb 2d		 jmp	 SHORT $LN6@Reserve@2
$LN4@Reserve@2:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00031	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  00034	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]
  00037	89 45 f8	 mov	 DWORD PTR __Size$[ebp], eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?capacity@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QBEIXZ ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::capacity
  00042	39 45 f8	 cmp	 DWORD PTR __Size$[ebp], eax
  00045	77 02		 ja	 SHORT $LN2@Reserve@2

; 1295 : 			;
; 1296 : 		else

  00047	eb 15		 jmp	 SHORT $LN6@Reserve@2
$LN2@Reserve@2:

; 1297 : 			reserve(_Grow_to(_Size));

  00049	8b 45 f8	 mov	 eax, DWORD PTR __Size$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?_Grow_to@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@IBEII@Z ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::_Grow_to
  00055	50		 push	 eax
  00056	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ?reserve@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAEXI@Z ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::reserve
$LN6@Reserve@2:

; 1298 : 		}

  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?_Reserve@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@IAEXI@Z ENDP ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::_Reserve
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UQUESTIONANSWER_TIME@@@std@@QAEXPAUQUESTIONANSWER_TIME@@I@Z ; std::allocator<QUESTIONANSWER_TIME>::deallocate
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Tidy@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@IAEXXZ PROC ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1302 : 		if (this->_Myfirst != 0)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00012	74 3d		 je	 SHORT $LN1@Tidy@2

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00022	51		 push	 ecx
  00023	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00026	8b 02		 mov	 eax, DWORD PTR [edx]
  00028	50		 push	 eax
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@IAEXPAUQUESTIONANSWER_TIME@@0@Z ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::_Destroy

; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0003a	2b 11		 sub	 edx, DWORD PTR [ecx]
  0003c	c1 fa 03	 sar	 edx, 3
  0003f	52		 push	 edx
  00040	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b 08		 mov	 ecx, DWORD PTR [eax]
  00045	51		 push	 ecx
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0004c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UQUESTIONANSWER_TIME@@@std@@QAEXPAUQUESTIONANSWER_TIME@@I@Z ; std::allocator<QUESTIONANSWER_TIME>::deallocate
$LN1@Tidy@2:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00051	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00054	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1310 : 		this->_Mylast = 0;

  0005a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1311 : 		this->_Myend = 0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 1312 : 		}

  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
?_Tidy@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@IAEXXZ ENDP ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::_Tidy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Orphan_range@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@IBEXPAUQUESTIONANSWER_TIME@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@IBEXPAUQUESTIONANSWER_TIME@@0@Z PROC ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1453 : 		{	// orphan iterators within specified (inclusive) range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1454 : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@IBEXPAUQUESTIONANSWER_TIME@@0@Z ENDP ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??0?$allocator@UQUESTIONANSWER_TIME@@@std@@QAE@ABV01@@Z ; std::allocator<QUESTIONANSWER_TIME>::allocator<QUESTIONANSWER_TIME>
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAE@V?$allocator@UQUESTIONANSWER_TIME@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAE@V?$allocator@UQUESTIONANSWER_TIME@@@1@@Z PROC ; std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00016	e8 00 00 00 00	 call	 ??0?$allocator@UQUESTIONANSWER_TIME@@@std@@QAE@ABV01@@Z ; std::allocator<QUESTIONANSWER_TIME>::allocator<QUESTIONANSWER_TIME>

; 427  : 		_Myfirst = 0;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 428  : 		_Mylast = 0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 429  : 		_Myend = 0;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 430  : 		}

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
??0?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAE@V?$allocator@UQUESTIONANSWER_TIME@@@1@@Z ENDP ; std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::~_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >, COMDAT
; _this$ = ecx

; 433  : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 434  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::~_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UQUESTIONANSWER_TIME@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@UQUESTIONANSWER_TIME@@@std@@QAE@XZ PROC	; std::allocator<QUESTIONANSWER_TIME>::allocator<QUESTIONANSWER_TIME>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@UQUESTIONANSWER_TIME@@@std@@QAE@XZ ENDP	; std::allocator<QUESTIONANSWER_TIME>::allocator<QUESTIONANSWER_TIME>
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QAE@PAUQUESTIONANSWER_TIME@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QAE@PAUQUESTIONANSWER_TIME@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QAE@PAUQUESTIONANSWER_TIME@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >::_Vector_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QAE@PAUQUESTIONANSWER_TIME@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >

; 305  : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QAE@PAUQUESTIONANSWER_TIME@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >::_Vector_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QBEABUQUESTIONANSWER_TIME@@XZ ; std::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >::operator*
; Function compile flags: /Odtp /ZI
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QBEAAUQUESTIONANSWER_TIME@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QBEAAUQUESTIONANSWER_TIME@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >::operator*, COMDAT
; _this$ = ecx

; 321  : 		{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 322  : 		return ((reference)**(_Mybase *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QBEABUQUESTIONANSWER_TIME@@XZ ; std::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >::operator*

; 323  : 		}

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QBEAAUQUESTIONANSWER_TIME@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >::operator++
; Function compile flags: /Odtp /ZI
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >::operator++, COMDAT
; _this$ = ecx

; 331  : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 332  : 		++*(_Mybase *)this;

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??E?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >::operator++

; 333  : 		return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 334  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??E?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >::operator++
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >::_Compat
; Function compile flags: /Odtp /ZI
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		_Compat(_Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >::_Compat

; 203  : 		return (this->_Ptr == _Right._Ptr);

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001e	8b 10		 mov	 edx, DWORD PTR [eax]
  00020	33 c0		 xor	 eax, eax
  00022	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00024	0f 94 c0	 sete	 al

; 204  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >::operator==
_TEXT	ENDS
PUBLIC	??$_Umove@PAUQUESTIONANSWER_DATA@@@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@IAEPAUQUESTIONANSWER_DATA@@PAU2@00@Z ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::_Umove<QUESTIONANSWER_DATA *>
PUBLIC	?allocate@?$allocator@UQUESTIONANSWER_DATA@@@std@@QAEPAUQUESTIONANSWER_DATA@@I@Z ; std::allocator<QUESTIONANSWER_DATA>::allocate
EXTRN	__CxxThrowException@8:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Size$229634 = -28					; size = 4
__Ptr$229627 = -24					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?reserve@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAEXI@Z PROC ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?reserve@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 747  : 		if (max_size() < _Count)

  0002f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?max_size@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QBEIXZ ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::max_size
  00037	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0003a	73 0d		 jae	 SHORT $LN5@reserve

; 748  : 			_Xlen();	// result too long

  0003c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@IBEXXZ ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::_Xlen
  00044	e9 eb 00 00 00	 jmp	 $LN7@reserve
$LN5@reserve:

; 749  : 		else if (capacity() < _Count)

  00049	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?capacity@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QBEIXZ ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::capacity
  00051	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  00054	0f 83 da 00 00
	00		 jae	 $LN7@reserve

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  0005a	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00064	e8 00 00 00 00	 call	 ?allocate@?$allocator@UQUESTIONANSWER_DATA@@@std@@QAEPAUQUESTIONANSWER_DATA@@I@Z ; std::allocator<QUESTIONANSWER_DATA>::allocate
  00069	89 45 e8	 mov	 DWORD PTR __Ptr$229627[ebp], eax

; 752  : 
; 753  : 			_TRY_BEGIN

  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00073	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$229627[ebp]
  00076	50		 push	 eax
  00077	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007d	52		 push	 edx
  0007e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 08		 mov	 ecx, DWORD PTR [eax]
  00083	51		 push	 ecx
  00084	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	e8 00 00 00 00	 call	 ??$_Umove@PAUQUESTIONANSWER_DATA@@@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@IAEPAUQUESTIONANSWER_DATA@@PAU2@00@Z ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::_Umove<QUESTIONANSWER_DATA *>
  0008c	eb 29		 jmp	 SHORT $LN8@reserve
__catch$?reserve@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  0008e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00091	50		 push	 eax
  00092	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$229627[ebp]
  00095	51		 push	 ecx
  00096	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0009c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UQUESTIONANSWER_DATA@@@std@@QAEXPAUQUESTIONANSWER_DATA@@I@Z ; std::allocator<QUESTIONANSWER_DATA>::deallocate

; 757  : 			_RERAISE;

  000a1	6a 00		 push	 0
  000a3	6a 00		 push	 0
  000a5	e8 00 00 00 00	 call	 __CxxThrowException@8

; 758  : 			_CATCH_END

  000aa	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000b1	b8 00 00 00 00	 mov	 eax, __tryend$?reserve@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAEXI@Z$1
  000b6	c3		 ret	 0
$LN8@reserve:
  000b7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?reserve@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAEXI@Z$1:

; 759  : 
; 760  : 			size_type _Size = size();

  000be	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	e8 00 00 00 00	 call	 ?size@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QBEIXZ ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::size
  000c6	89 45 e4	 mov	 DWORD PTR __Size$229634[ebp], eax

; 761  : 			if (this->_Myfirst != 0)

  000c9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000cc	83 38 00	 cmp	 DWORD PTR [eax], 0
  000cf	74 35		 je	 SHORT $LN1@reserve

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);

  000d1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d7	51		 push	 ecx
  000d8	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000db	8b 02		 mov	 eax, DWORD PTR [edx]
  000dd	50		 push	 eax
  000de	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@IAEXPAUQUESTIONANSWER_DATA@@0@Z ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::_Destroy

; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  000e6	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000ef	2b 11		 sub	 edx, DWORD PTR [ecx]
  000f1	c1 fa 07	 sar	 edx, 7
  000f4	52		 push	 edx
  000f5	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000f8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fa	51		 push	 ecx
  000fb	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000fe	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00101	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UQUESTIONANSWER_DATA@@@std@@QAEXPAUQUESTIONANSWER_DATA@@I@Z ; std::allocator<QUESTIONANSWER_DATA>::deallocate
$LN1@reserve:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();

  00106	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 769  : 			this->_Myend = _Ptr + _Count;

  0010e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00111	c1 e0 07	 shl	 eax, 7
  00114	03 45 e8	 add	 eax, DWORD PTR __Ptr$229627[ebp]
  00117	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0011a	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 770  : 			this->_Mylast = _Ptr + _Size;

  0011d	8b 45 e4	 mov	 eax, DWORD PTR __Size$229634[ebp]
  00120	c1 e0 07	 shl	 eax, 7
  00123	03 45 e8	 add	 eax, DWORD PTR __Ptr$229627[ebp]
  00126	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00129	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 771  : 			this->_Myfirst = _Ptr;

  0012c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0012f	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$229627[ebp]
  00132	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@reserve:

; 772  : 			}
; 773  : 		}

  00134	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00137	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0013e	59		 pop	 ecx
  0013f	5f		 pop	 edi
  00140	5e		 pop	 esi
  00141	5b		 pop	 ebx
  00142	8b e5		 mov	 esp, ebp
  00144	5d		 pop	 ebp
  00145	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QAEXI@Z ENDP ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::reserve
; Function compile flags: /Odtp /ZI
;	COMDAT ?capacity@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?capacity@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QBEIXZ PROC ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::capacity, COMDAT
; _this$ = ecx

; 776  : 		{	// return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	c1 f8 07	 sar	 eax, 7

; 778  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?capacity@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::capacity
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@2@@Z PROC ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::_Make_iter, COMDAT
; _this$ = ecx

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  : 		return (iterator(_Where._Ptr, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@std@@QAE@PAUQUESTIONANSWER_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> > >::_Vector_iterator<std::_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> > >
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 803  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
?_Make_iter@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@2@@Z ENDP ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UQUESTIONANSWER_DATA@@@std@@QBEIXZ ; std::allocator<QUESTIONANSWER_DATA>::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?max_size@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QBEIXZ PROC ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::max_size, COMDAT
; _this$ = ecx

; 883  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		return (this->_Alval.max_size());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00012	e8 00 00 00 00	 call	 ?max_size@?$allocator@UQUESTIONANSWER_DATA@@@std@@QBEIXZ ; std::allocator<QUESTIONANSWER_DATA>::max_size

; 885  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?max_size@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@YAXPAUQUESTIONANSWER_DATA@@0AAV?$allocator@UQUESTIONANSWER_DATA@@@0@@Z ; std::_Destroy_range<std::allocator<QUESTIONANSWER_DATA> >
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Destroy@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@IAEXPAUQUESTIONANSWER_DATA@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@IAEXPAUQUESTIONANSWER_DATA@@0@Z PROC ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::_Destroy, COMDAT
; _this$ = ecx

; 1269 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@YAXPAUQUESTIONANSWER_DATA@@0AAV?$allocator@UQUESTIONANSWER_DATA@@@0@@Z ; std::_Destroy_range<std::allocator<QUESTIONANSWER_DATA> >
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1271 : 		}

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
?_Destroy@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@IAEXPAUQUESTIONANSWER_DATA@@0@Z ENDP ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::_Destroy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Grow_to@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -76						; size = 4
__Capacity$ = -8					; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@IBEII@Z PROC ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1275 : 		size_type _Capacity = capacity();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?capacity@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QBEIXZ ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::capacity
  00014	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@QBEIXZ ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::max_size
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  00022	d1 e9		 shr	 ecx, 1
  00024	2b c1		 sub	 eax, ecx
  00026	3b 45 f8	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  00029	73 09		 jae	 SHORT $LN4@Grow_to
  0002b	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  00032	eb 0b		 jmp	 SHORT $LN5@Grow_to
$LN4@Grow_to:
  00034	8b 55 f8	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00037	d1 ea		 shr	 edx, 1
  00039	03 55 f8	 add	 edx, DWORD PTR __Capacity$[ebp]
  0003c	89 55 b4	 mov	 DWORD PTR tv73[ebp], edx
$LN5@Grow_to:
  0003f	8b 45 b4	 mov	 eax, DWORD PTR tv73[ebp]
  00042	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1279 : 		if (_Capacity < _Count)

  00045	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00048	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0004b	73 06		 jae	 SHORT $LN1@Grow_to

; 1280 : 			_Capacity = _Count;

  0004d	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00050	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax
$LN1@Grow_to:

; 1281 : 		return (_Capacity);

  00053	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]

; 1282 : 		}

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
?_Grow_to@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@IBEII@Z ENDP ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::_Grow_to
_TEXT	ENDS
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ?_Xlen@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@IBEXXZ PROC ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::_Xlen, COMDAT
; _this$ = ecx

; 1426 : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00011	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen:

; 1428 : 		}

  00016	5f		 pop	 edi
  00017	5e		 pop	 esi
  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Xlen@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@IBEXXZ ENDP ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::_Xlen
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UQUESTIONANSWER_DATA@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@UQUESTIONANSWER_DATA@@@std@@QAE@ABV01@@Z PROC ; std::allocator<QUESTIONANSWER_DATA>::allocator<QUESTIONANSWER_DATA>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$allocator@UQUESTIONANSWER_DATA@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<QUESTIONANSWER_DATA>::allocator<QUESTIONANSWER_DATA>
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp /ZI
;	COMDAT ?deallocate@?$allocator@UQUESTIONANSWER_DATA@@@std@@QAEXPAUQUESTIONANSWER_DATA@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UQUESTIONANSWER_DATA@@@std@@QAEXPAUQUESTIONANSWER_DATA@@I@Z PROC ; std::allocator<QUESTIONANSWER_DATA>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 182  : 		::operator delete(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4

; 183  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?deallocate@?$allocator@UQUESTIONANSWER_DATA@@@std@@QAEXPAUQUESTIONANSWER_DATA@@I@Z ENDP ; std::allocator<QUESTIONANSWER_DATA>::deallocate
_TEXT	ENDS
PUBLIC	??$_Umove@PAUQUESTIONANSWER_TIME@@@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@IAEPAUQUESTIONANSWER_TIME@@PAU2@00@Z ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::_Umove<QUESTIONANSWER_TIME *>
PUBLIC	?allocate@?$allocator@UQUESTIONANSWER_TIME@@@std@@QAEPAUQUESTIONANSWER_TIME@@I@Z ; std::allocator<QUESTIONANSWER_TIME>::allocate
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\vector
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Size$229675 = -28					; size = 4
__Ptr$229668 = -24					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?reserve@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAEXI@Z PROC ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?reserve@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 747  : 		if (max_size() < _Count)

  0002f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?max_size@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QBEIXZ ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::max_size
  00037	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0003a	73 0d		 jae	 SHORT $LN5@reserve@2

; 748  : 			_Xlen();	// result too long

  0003c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@IBEXXZ ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::_Xlen
  00044	e9 eb 00 00 00	 jmp	 $LN7@reserve@2
$LN5@reserve@2:

; 749  : 		else if (capacity() < _Count)

  00049	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?capacity@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QBEIXZ ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::capacity
  00051	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  00054	0f 83 da 00 00
	00		 jae	 $LN7@reserve@2

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  0005a	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00064	e8 00 00 00 00	 call	 ?allocate@?$allocator@UQUESTIONANSWER_TIME@@@std@@QAEPAUQUESTIONANSWER_TIME@@I@Z ; std::allocator<QUESTIONANSWER_TIME>::allocate
  00069	89 45 e8	 mov	 DWORD PTR __Ptr$229668[ebp], eax

; 752  : 
; 753  : 			_TRY_BEGIN

  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00073	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$229668[ebp]
  00076	50		 push	 eax
  00077	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007d	52		 push	 edx
  0007e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 08		 mov	 ecx, DWORD PTR [eax]
  00083	51		 push	 ecx
  00084	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	e8 00 00 00 00	 call	 ??$_Umove@PAUQUESTIONANSWER_TIME@@@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@IAEPAUQUESTIONANSWER_TIME@@PAU2@00@Z ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::_Umove<QUESTIONANSWER_TIME *>
  0008c	eb 29		 jmp	 SHORT $LN8@reserve@2
__catch$?reserve@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  0008e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00091	50		 push	 eax
  00092	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$229668[ebp]
  00095	51		 push	 ecx
  00096	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0009c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UQUESTIONANSWER_TIME@@@std@@QAEXPAUQUESTIONANSWER_TIME@@I@Z ; std::allocator<QUESTIONANSWER_TIME>::deallocate

; 757  : 			_RERAISE;

  000a1	6a 00		 push	 0
  000a3	6a 00		 push	 0
  000a5	e8 00 00 00 00	 call	 __CxxThrowException@8

; 758  : 			_CATCH_END

  000aa	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000b1	b8 00 00 00 00	 mov	 eax, __tryend$?reserve@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAEXI@Z$1
  000b6	c3		 ret	 0
$LN8@reserve@2:
  000b7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?reserve@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAEXI@Z$1:

; 759  : 
; 760  : 			size_type _Size = size();

  000be	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	e8 00 00 00 00	 call	 ?size@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QBEIXZ ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::size
  000c6	89 45 e4	 mov	 DWORD PTR __Size$229675[ebp], eax

; 761  : 			if (this->_Myfirst != 0)

  000c9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000cc	83 38 00	 cmp	 DWORD PTR [eax], 0
  000cf	74 35		 je	 SHORT $LN1@reserve@2

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);

  000d1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d7	51		 push	 ecx
  000d8	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000db	8b 02		 mov	 eax, DWORD PTR [edx]
  000dd	50		 push	 eax
  000de	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@IAEXPAUQUESTIONANSWER_TIME@@0@Z ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::_Destroy

; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  000e6	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000ef	2b 11		 sub	 edx, DWORD PTR [ecx]
  000f1	c1 fa 03	 sar	 edx, 3
  000f4	52		 push	 edx
  000f5	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000f8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fa	51		 push	 ecx
  000fb	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000fe	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00101	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UQUESTIONANSWER_TIME@@@std@@QAEXPAUQUESTIONANSWER_TIME@@I@Z ; std::allocator<QUESTIONANSWER_TIME>::deallocate
$LN1@reserve@2:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();

  00106	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 769  : 			this->_Myend = _Ptr + _Count;

  0010e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00111	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$229668[ebp]
  00114	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  00117	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0011a	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 770  : 			this->_Mylast = _Ptr + _Size;

  0011d	8b 45 e4	 mov	 eax, DWORD PTR __Size$229675[ebp]
  00120	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$229668[ebp]
  00123	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  00126	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00129	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 771  : 			this->_Myfirst = _Ptr;

  0012c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0012f	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$229668[ebp]
  00132	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@reserve@2:

; 772  : 			}
; 773  : 		}

  00134	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00137	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0013e	59		 pop	 ecx
  0013f	5f		 pop	 edi
  00140	5e		 pop	 esi
  00141	5b		 pop	 ebx
  00142	8b e5		 mov	 esp, ebp
  00144	5d		 pop	 ebp
  00145	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QAEXI@Z ENDP ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::reserve
; Function compile flags: /Odtp /ZI
;	COMDAT ?capacity@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?capacity@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QBEIXZ PROC ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::capacity, COMDAT
; _this$ = ecx

; 776  : 		{	// return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	c1 f8 03	 sar	 eax, 3

; 778  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?capacity@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QBEIXZ ENDP ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::capacity
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@2@@Z PROC ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::_Make_iter, COMDAT
; _this$ = ecx

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  : 		return (iterator(_Where._Ptr, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QAE@PAUQUESTIONANSWER_TIME@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >::_Vector_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 803  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
?_Make_iter@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@2@@Z ENDP ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::_Make_iter
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?size@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QBEIXZ PROC ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::size, COMDAT
; _this$ = ecx

; 878  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00015	2b 01		 sub	 eax, DWORD PTR [ecx]
  00017	c1 f8 03	 sar	 eax, 3

; 880  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?size@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QBEIXZ ENDP ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UQUESTIONANSWER_TIME@@@std@@QBEIXZ ; std::allocator<QUESTIONANSWER_TIME>::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?max_size@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QBEIXZ PROC ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::max_size, COMDAT
; _this$ = ecx

; 883  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		return (this->_Alval.max_size());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00012	e8 00 00 00 00	 call	 ?max_size@?$allocator@UQUESTIONANSWER_TIME@@@std@@QBEIXZ ; std::allocator<QUESTIONANSWER_TIME>::max_size

; 885  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?max_size@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QBEIXZ ENDP ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@YAXPAUQUESTIONANSWER_TIME@@0AAV?$allocator@UQUESTIONANSWER_TIME@@@0@@Z ; std::_Destroy_range<std::allocator<QUESTIONANSWER_TIME> >
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Destroy@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@IAEXPAUQUESTIONANSWER_TIME@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@IAEXPAUQUESTIONANSWER_TIME@@0@Z PROC ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::_Destroy, COMDAT
; _this$ = ecx

; 1269 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@YAXPAUQUESTIONANSWER_TIME@@0AAV?$allocator@UQUESTIONANSWER_TIME@@@0@@Z ; std::_Destroy_range<std::allocator<QUESTIONANSWER_TIME> >
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1271 : 		}

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
?_Destroy@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@IAEXPAUQUESTIONANSWER_TIME@@0@Z ENDP ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::_Destroy
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Grow_to@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -76						; size = 4
__Capacity$ = -8					; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@IBEII@Z PROC ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1275 : 		size_type _Capacity = capacity();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?capacity@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QBEIXZ ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::capacity
  00014	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@QBEIXZ ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::max_size
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  00022	d1 e9		 shr	 ecx, 1
  00024	2b c1		 sub	 eax, ecx
  00026	3b 45 f8	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  00029	73 09		 jae	 SHORT $LN4@Grow_to@2
  0002b	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  00032	eb 0b		 jmp	 SHORT $LN5@Grow_to@2
$LN4@Grow_to@2:
  00034	8b 55 f8	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00037	d1 ea		 shr	 edx, 1
  00039	03 55 f8	 add	 edx, DWORD PTR __Capacity$[ebp]
  0003c	89 55 b4	 mov	 DWORD PTR tv73[ebp], edx
$LN5@Grow_to@2:
  0003f	8b 45 b4	 mov	 eax, DWORD PTR tv73[ebp]
  00042	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1279 : 		if (_Capacity < _Count)

  00045	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00048	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0004b	73 06		 jae	 SHORT $LN1@Grow_to@2

; 1280 : 			_Capacity = _Count;

  0004d	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00050	89 45 f8	 mov	 DWORD PTR __Capacity$[ebp], eax
$LN1@Grow_to@2:

; 1281 : 		return (_Capacity);

  00053	8b 45 f8	 mov	 eax, DWORD PTR __Capacity$[ebp]

; 1282 : 		}

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
?_Grow_to@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@IBEII@Z ENDP ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::_Grow_to
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@IBEXXZ PROC ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::_Xlen, COMDAT
; _this$ = ecx

; 1426 : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00011	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen@2:

; 1428 : 		}

  00016	5f		 pop	 edi
  00017	5e		 pop	 esi
  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Xlen@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@IBEXXZ ENDP ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::_Xlen
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UQUESTIONANSWER_TIME@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@UQUESTIONANSWER_TIME@@@std@@QAE@ABV01@@Z PROC ; std::allocator<QUESTIONANSWER_TIME>::allocator<QUESTIONANSWER_TIME>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$allocator@UQUESTIONANSWER_TIME@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<QUESTIONANSWER_TIME>::allocator<QUESTIONANSWER_TIME>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UQUESTIONANSWER_TIME@@@std@@QAEXPAUQUESTIONANSWER_TIME@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UQUESTIONANSWER_TIME@@@std@@QAEXPAUQUESTIONANSWER_TIME@@I@Z PROC ; std::allocator<QUESTIONANSWER_TIME>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 182  : 		::operator delete(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4

; 183  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?deallocate@?$allocator@UQUESTIONANSWER_TIME@@@std@@QAEXPAUQUESTIONANSWER_TIME@@I@Z ENDP ; std::allocator<QUESTIONANSWER_TIME>::deallocate
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QAE@PAUQUESTIONANSWER_TIME@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QAE@PAUQUESTIONANSWER_TIME@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 47   : 		}

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QAE@PAUQUESTIONANSWER_TIME@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QBEABUQUESTIONANSWER_TIME@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QBEABUQUESTIONANSWER_TIME@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >::operator*, COMDAT
; _this$ = ecx

; 63   : 		{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
$LN2@operator:

; 64   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 65   : 		if (this->_Getcont() == 0
; 66   : 			|| this->_Ptr == 0
; 67   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 68   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 69   : 			{	// report error
; 70   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 71   : 			_SCL_SECURE_OUT_OF_RANGE;
; 72   : 			}
; 73   : 
; 74   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 75   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 76   : 		_SCL_SECURE_VALIDATE_RANGE(
; 77   : 			this->_Ptr != 0
; 78   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 79   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 80   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 81   : 
; 82   : 		__analysis_assume(this->_Ptr != 0);

  0000c	33 c0		 xor	 eax, eax
  0000e	75 fc		 jne	 SHORT $LN2@operator

; 83   : 
; 84   : 		return (*this->_Ptr);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 00		 mov	 eax, DWORD PTR [eax]

; 85   : 		}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QBEABUQUESTIONANSWER_TIME@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >::operator*
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >::operator++, COMDAT
; _this$ = ecx

; 93   : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 94   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 95   : 		if (this->_Getcont() == 0
; 96   : 			|| this->_Ptr == 0
; 97   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 98   : 			{	// report error
; 99   : 			_DEBUG_ERROR("vector iterator not incrementable");
; 100  : 			_SCL_SECURE_OUT_OF_RANGE;
; 101  : 			}
; 102  : 
; 103  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 104  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 105  : 		_SCL_SECURE_VALIDATE_RANGE(
; 106  : 			this->_Ptr != 0
; 107  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 108  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 109  : 
; 110  : 		++this->_Ptr;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	83 c1 08	 add	 ecx, 8
  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	89 0a		 mov	 DWORD PTR [edx], ecx

; 111  : 		return (*this);

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 112  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >::operator++
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >::_Compat, COMDAT
; _this$ = ecx

; 252  : 		{	// test for compatible iterator pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 253  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> > >::_Compat
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@std@@QAE@PAUQUESTIONANSWER_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> > >::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@std@@QAE@PAUQUESTIONANSWER_DATA@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@std@@QAE@PAUQUESTIONANSWER_DATA@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> > >::_Vector_iterator<std::_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@std@@QAE@PAUQUESTIONANSWER_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> > >::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> > >

; 305  : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@std@@QAE@PAUQUESTIONANSWER_DATA@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> > >::_Vector_iterator<std::_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> > >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> > >::operator==
; Function compile flags: /Odtp /ZI
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 208  : 		return (!(*this == _Right));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??8?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> > >::operator==
  00018	0f b6 c0	 movzx	 eax, al
  0001b	f7 d8		 neg	 eax
  0001d	1b c0		 sbb	 eax, eax
  0001f	83 c0 01	 add	 eax, 1

; 209  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> > >::operator!=
_TEXT	ENDS
PUBLIC	??$_Allocate@UQUESTIONANSWER_DATA@@@std@@YAPAUQUESTIONANSWER_DATA@@IPAU1@@Z ; std::_Allocate<QUESTIONANSWER_DATA>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@UQUESTIONANSWER_DATA@@@std@@QAEPAUQUESTIONANSWER_DATA@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UQUESTIONANSWER_DATA@@@std@@QAEPAUQUESTIONANSWER_DATA@@I@Z PROC ; std::allocator<QUESTIONANSWER_DATA>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 187  : 		return (_Allocate(_Count, (pointer)0));

  0000c	6a 00		 push	 0
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Allocate@UQUESTIONANSWER_DATA@@@std@@YAPAUQUESTIONANSWER_DATA@@IPAU1@@Z ; std::_Allocate<QUESTIONANSWER_DATA>
  00017	83 c4 08	 add	 esp, 8

; 188  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?allocate@?$allocator@UQUESTIONANSWER_DATA@@@std@@QAEPAUQUESTIONANSWER_DATA@@I@Z ENDP ; std::allocator<QUESTIONANSWER_DATA>::allocate
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UQUESTIONANSWER_DATA@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -76						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@UQUESTIONANSWER_DATA@@@std@@QBEIXZ PROC ; std::allocator<QUESTIONANSWER_DATA>::max_size, COMDAT
; _this$ = ecx

; 217  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  0000c	c7 45 f8 ff ff
	ff 01		 mov	 DWORD PTR __Count$[ebp], 33554431 ; 01ffffffH

; 219  : 		return (0 < _Count ? _Count : 1);

  00013	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00017	76 08		 jbe	 SHORT $LN3@max_size
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0001c	89 45 b4	 mov	 DWORD PTR tv65[ebp], eax
  0001f	eb 07		 jmp	 SHORT $LN4@max_size
$LN3@max_size:
  00021	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$LN4@max_size:
  00028	8b 45 b4	 mov	 eax, DWORD PTR tv65[ebp]

; 220  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?max_size@?$allocator@UQUESTIONANSWER_DATA@@@std@@QBEIXZ ENDP ; std::allocator<QUESTIONANSWER_DATA>::max_size
_TEXT	ENDS
PUBLIC	??$_Allocate@UQUESTIONANSWER_TIME@@@std@@YAPAUQUESTIONANSWER_TIME@@IPAU1@@Z ; std::_Allocate<QUESTIONANSWER_TIME>
; Function compile flags: /Odtp /ZI
;	COMDAT ?allocate@?$allocator@UQUESTIONANSWER_TIME@@@std@@QAEPAUQUESTIONANSWER_TIME@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UQUESTIONANSWER_TIME@@@std@@QAEPAUQUESTIONANSWER_TIME@@I@Z PROC ; std::allocator<QUESTIONANSWER_TIME>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 187  : 		return (_Allocate(_Count, (pointer)0));

  0000c	6a 00		 push	 0
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Allocate@UQUESTIONANSWER_TIME@@@std@@YAPAUQUESTIONANSWER_TIME@@IPAU1@@Z ; std::_Allocate<QUESTIONANSWER_TIME>
  00017	83 c4 08	 add	 esp, 8

; 188  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?allocate@?$allocator@UQUESTIONANSWER_TIME@@@std@@QAEPAUQUESTIONANSWER_TIME@@I@Z ENDP ; std::allocator<QUESTIONANSWER_TIME>::allocate
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UQUESTIONANSWER_TIME@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -76						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@UQUESTIONANSWER_TIME@@@std@@QBEIXZ PROC ; std::allocator<QUESTIONANSWER_TIME>::max_size, COMDAT
; _this$ = ecx

; 217  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  0000c	c7 45 f8 ff ff
	ff 1f		 mov	 DWORD PTR __Count$[ebp], 536870911 ; 1fffffffH

; 219  : 		return (0 < _Count ? _Count : 1);

  00013	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00017	76 08		 jbe	 SHORT $LN3@max_size@2
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0001c	89 45 b4	 mov	 DWORD PTR tv65[ebp], eax
  0001f	eb 07		 jmp	 SHORT $LN4@max_size@2
$LN3@max_size@2:
  00021	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$LN4@max_size@2:
  00028	8b 45 b4	 mov	 eax, DWORD PTR tv65[ebp]

; 220  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?max_size@?$allocator@UQUESTIONANSWER_TIME@@@std@@QBEIXZ ENDP ; std::allocator<QUESTIONANSWER_TIME>::max_size
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@std@@QAE@PAUQUESTIONANSWER_DATA@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@std@@QAE@PAUQUESTIONANSWER_DATA@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> > >::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 47   : 		}

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@std@@QAE@PAUQUESTIONANSWER_DATA@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> > >::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> > >
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> > >::_Compat
; Function compile flags: /Odtp /ZI
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		_Compat(_Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> > >::_Compat

; 203  : 		return (this->_Ptr == _Right._Ptr);

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001e	8b 10		 mov	 edx, DWORD PTR [eax]
  00020	33 c0		 xor	 eax, eax
  00022	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00024	0f 94 c0	 sete	 al

; 204  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> > >::operator==
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> > >::_Compat, COMDAT
; _this$ = ecx

; 252  : 		{	// test for compatible iterator pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 253  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> > >::_Compat
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$addressof@$$CBUQUESTIONANSWER_DATA@@@std@@YAPBUQUESTIONANSWER_DATA@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUQUESTIONANSWER_DATA@@@std@@YAPBUQUESTIONANSWER_DATA@@ABU1@@Z PROC ; std::addressof<QUESTIONANSWER_DATA const >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 111  : 	return ((_Ty *) &(char&)_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@$$CBUQUESTIONANSWER_DATA@@@std@@YAPBUQUESTIONANSWER_DATA@@ABU1@@Z ENDP ; std::addressof<QUESTIONANSWER_DATA const >
_TEXT	ENDS
PUBLIC	??$construct@AAUQUESTIONANSWER_DATA@@@?$allocator@UQUESTIONANSWER_DATA@@@std@@QAEXPAUQUESTIONANSWER_DATA@@AAU2@@Z ; std::allocator<QUESTIONANSWER_DATA>::construct<QUESTIONANSWER_DATA &>
PUBLIC	??$forward@AAUQUESTIONANSWER_DATA@@@std@@YAAAUQUESTIONANSWER_DATA@@AAU1@@Z ; std::forward<QUESTIONANSWER_DATA &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UQUESTIONANSWER_DATA@@@std@@UQUESTIONANSWER_DATA@@AAU3@@std@@YAXAAV?$allocator@UQUESTIONANSWER_DATA@@@0@PAUQUESTIONANSWER_DATA@@AAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UQUESTIONANSWER_DATA@@@std@@UQUESTIONANSWER_DATA@@AAU3@@std@@YAXAAV?$allocator@UQUESTIONANSWER_DATA@@@0@PAUQUESTIONANSWER_DATA@@AAU2@@Z PROC ; std::_Cons_val<std::allocator<QUESTIONANSWER_DATA>,QUESTIONANSWER_DATA,QUESTIONANSWER_DATA &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@AAUQUESTIONANSWER_DATA@@@std@@YAAAUQUESTIONANSWER_DATA@@AAU1@@Z ; std::forward<QUESTIONANSWER_DATA &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ??$construct@AAUQUESTIONANSWER_DATA@@@?$allocator@UQUESTIONANSWER_DATA@@@std@@QAEXPAUQUESTIONANSWER_DATA@@AAU2@@Z ; std::allocator<QUESTIONANSWER_DATA>::construct<QUESTIONANSWER_DATA &>

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UQUESTIONANSWER_DATA@@@std@@UQUESTIONANSWER_DATA@@AAU3@@std@@YAXAAV?$allocator@UQUESTIONANSWER_DATA@@@0@PAUQUESTIONANSWER_DATA@@AAU2@@Z ENDP ; std::_Cons_val<std::allocator<QUESTIONANSWER_DATA>,QUESTIONANSWER_DATA,QUESTIONANSWER_DATA &>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UQUESTIONANSWER_DATA@@@std@@QAEXPAUQUESTIONANSWER_DATA@@ABU3@@Z ; std::allocator<QUESTIONANSWER_DATA>::construct
PUBLIC	??$forward@ABUQUESTIONANSWER_DATA@@@std@@YAABUQUESTIONANSWER_DATA@@ABU1@@Z ; std::forward<QUESTIONANSWER_DATA const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UQUESTIONANSWER_DATA@@@std@@UQUESTIONANSWER_DATA@@ABU3@@std@@YAXAAV?$allocator@UQUESTIONANSWER_DATA@@@0@PAUQUESTIONANSWER_DATA@@ABU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UQUESTIONANSWER_DATA@@@std@@UQUESTIONANSWER_DATA@@ABU3@@std@@YAXAAV?$allocator@UQUESTIONANSWER_DATA@@@0@PAUQUESTIONANSWER_DATA@@ABU2@@Z PROC ; std::_Cons_val<std::allocator<QUESTIONANSWER_DATA>,QUESTIONANSWER_DATA,QUESTIONANSWER_DATA const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@ABUQUESTIONANSWER_DATA@@@std@@YAABUQUESTIONANSWER_DATA@@ABU1@@Z ; std::forward<QUESTIONANSWER_DATA const &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@UQUESTIONANSWER_DATA@@@std@@QAEXPAUQUESTIONANSWER_DATA@@ABU3@@Z ; std::allocator<QUESTIONANSWER_DATA>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UQUESTIONANSWER_DATA@@@std@@UQUESTIONANSWER_DATA@@ABU3@@std@@YAXAAV?$allocator@UQUESTIONANSWER_DATA@@@0@PAUQUESTIONANSWER_DATA@@ABU2@@Z ENDP ; std::_Cons_val<std::allocator<QUESTIONANSWER_DATA>,QUESTIONANSWER_DATA,QUESTIONANSWER_DATA const &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$addressof@$$CBUQUESTIONANSWER_TIME@@@std@@YAPBUQUESTIONANSWER_TIME@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUQUESTIONANSWER_TIME@@@std@@YAPBUQUESTIONANSWER_TIME@@ABU1@@Z PROC ; std::addressof<QUESTIONANSWER_TIME const >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 111  : 	return ((_Ty *) &(char&)_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@$$CBUQUESTIONANSWER_TIME@@@std@@YAPBUQUESTIONANSWER_TIME@@ABU1@@Z ENDP ; std::addressof<QUESTIONANSWER_TIME const >
_TEXT	ENDS
PUBLIC	??$construct@AAUQUESTIONANSWER_TIME@@@?$allocator@UQUESTIONANSWER_TIME@@@std@@QAEXPAUQUESTIONANSWER_TIME@@AAU2@@Z ; std::allocator<QUESTIONANSWER_TIME>::construct<QUESTIONANSWER_TIME &>
PUBLIC	??$forward@AAUQUESTIONANSWER_TIME@@@std@@YAAAUQUESTIONANSWER_TIME@@AAU1@@Z ; std::forward<QUESTIONANSWER_TIME &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UQUESTIONANSWER_TIME@@@std@@UQUESTIONANSWER_TIME@@AAU3@@std@@YAXAAV?$allocator@UQUESTIONANSWER_TIME@@@0@PAUQUESTIONANSWER_TIME@@AAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UQUESTIONANSWER_TIME@@@std@@UQUESTIONANSWER_TIME@@AAU3@@std@@YAXAAV?$allocator@UQUESTIONANSWER_TIME@@@0@PAUQUESTIONANSWER_TIME@@AAU2@@Z PROC ; std::_Cons_val<std::allocator<QUESTIONANSWER_TIME>,QUESTIONANSWER_TIME,QUESTIONANSWER_TIME &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@AAUQUESTIONANSWER_TIME@@@std@@YAAAUQUESTIONANSWER_TIME@@AAU1@@Z ; std::forward<QUESTIONANSWER_TIME &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ??$construct@AAUQUESTIONANSWER_TIME@@@?$allocator@UQUESTIONANSWER_TIME@@@std@@QAEXPAUQUESTIONANSWER_TIME@@AAU2@@Z ; std::allocator<QUESTIONANSWER_TIME>::construct<QUESTIONANSWER_TIME &>

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UQUESTIONANSWER_TIME@@@std@@UQUESTIONANSWER_TIME@@AAU3@@std@@YAXAAV?$allocator@UQUESTIONANSWER_TIME@@@0@PAUQUESTIONANSWER_TIME@@AAU2@@Z ENDP ; std::_Cons_val<std::allocator<QUESTIONANSWER_TIME>,QUESTIONANSWER_TIME,QUESTIONANSWER_TIME &>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UQUESTIONANSWER_TIME@@@std@@QAEXPAUQUESTIONANSWER_TIME@@ABU3@@Z ; std::allocator<QUESTIONANSWER_TIME>::construct
PUBLIC	??$forward@ABUQUESTIONANSWER_TIME@@@std@@YAABUQUESTIONANSWER_TIME@@ABU1@@Z ; std::forward<QUESTIONANSWER_TIME const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UQUESTIONANSWER_TIME@@@std@@UQUESTIONANSWER_TIME@@ABU3@@std@@YAXAAV?$allocator@UQUESTIONANSWER_TIME@@@0@PAUQUESTIONANSWER_TIME@@ABU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UQUESTIONANSWER_TIME@@@std@@UQUESTIONANSWER_TIME@@ABU3@@std@@YAXAAV?$allocator@UQUESTIONANSWER_TIME@@@0@PAUQUESTIONANSWER_TIME@@ABU2@@Z PROC ; std::_Cons_val<std::allocator<QUESTIONANSWER_TIME>,QUESTIONANSWER_TIME,QUESTIONANSWER_TIME const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@ABUQUESTIONANSWER_TIME@@@std@@YAABUQUESTIONANSWER_TIME@@ABU1@@Z ; std::forward<QUESTIONANSWER_TIME const &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@UQUESTIONANSWER_TIME@@@std@@QAEXPAUQUESTIONANSWER_TIME@@ABU3@@Z ; std::allocator<QUESTIONANSWER_TIME>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UQUESTIONANSWER_TIME@@@std@@UQUESTIONANSWER_TIME@@ABU3@@std@@YAXAAV?$allocator@UQUESTIONANSWER_TIME@@@0@PAUQUESTIONANSWER_TIME@@ABU2@@Z ENDP ; std::_Cons_val<std::allocator<QUESTIONANSWER_TIME>,QUESTIONANSWER_TIME,QUESTIONANSWER_TIME const &>
_TEXT	ENDS
PUBLIC	??$_Move@PAUQUESTIONANSWER_DATA@@PAU1@@std@@YAPAUQUESTIONANSWER_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<QUESTIONANSWER_DATA *,QUESTIONANSWER_DATA *>
PUBLIC	??$_Ptr_cat@UQUESTIONANSWER_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUQUESTIONANSWER_DATA@@0@Z ; std::_Ptr_cat<QUESTIONANSWER_DATA,QUESTIONANSWER_DATA>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAUQUESTIONANSWER_DATA@@PAU1@@std@@YAPAUQUESTIONANSWER_DATA@@PAU1@00@Z
_TEXT	SEGMENT
$T231232 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAUQUESTIONANSWER_DATA@@PAU1@@std@@YAPAUQUESTIONANSWER_DATA@@PAU1@00@Z PROC ; std::_Move<QUESTIONANSWER_DATA *,QUESTIONANSWER_DATA *>, COMDAT

; 2533 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2534 : 	return (_Move(_First, _Last,
; 2535 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UQUESTIONANSWER_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUQUESTIONANSWER_DATA@@0@Z ; std::_Ptr_cat<QUESTIONANSWER_DATA,QUESTIONANSWER_DATA>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T231232[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T231232[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Move@PAUQUESTIONANSWER_DATA@@PAU1@@std@@YAPAUQUESTIONANSWER_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<QUESTIONANSWER_DATA *,QUESTIONANSWER_DATA *>
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 2536 : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Move@PAUQUESTIONANSWER_DATA@@PAU1@@std@@YAPAUQUESTIONANSWER_DATA@@PAU1@00@Z ENDP ; std::_Move<QUESTIONANSWER_DATA *,QUESTIONANSWER_DATA *>
_TEXT	ENDS
PUBLIC	??$_Move@PAUQUESTIONANSWER_TIME@@PAU1@@std@@YAPAUQUESTIONANSWER_TIME@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<QUESTIONANSWER_TIME *,QUESTIONANSWER_TIME *>
PUBLIC	??$_Ptr_cat@UQUESTIONANSWER_TIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUQUESTIONANSWER_TIME@@0@Z ; std::_Ptr_cat<QUESTIONANSWER_TIME,QUESTIONANSWER_TIME>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Move@PAUQUESTIONANSWER_TIME@@PAU1@@std@@YAPAUQUESTIONANSWER_TIME@@PAU1@00@Z
_TEXT	SEGMENT
$T231235 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAUQUESTIONANSWER_TIME@@PAU1@@std@@YAPAUQUESTIONANSWER_TIME@@PAU1@00@Z PROC ; std::_Move<QUESTIONANSWER_TIME *,QUESTIONANSWER_TIME *>, COMDAT

; 2533 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2534 : 	return (_Move(_First, _Last,
; 2535 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UQUESTIONANSWER_TIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUQUESTIONANSWER_TIME@@0@Z ; std::_Ptr_cat<QUESTIONANSWER_TIME,QUESTIONANSWER_TIME>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T231235[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T231235[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Move@PAUQUESTIONANSWER_TIME@@PAU1@@std@@YAPAUQUESTIONANSWER_TIME@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<QUESTIONANSWER_TIME *,QUESTIONANSWER_TIME *>
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 2536 : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Move@PAUQUESTIONANSWER_TIME@@PAU1@@std@@YAPAUQUESTIONANSWER_TIME@@PAU1@00@Z ENDP ; std::_Move<QUESTIONANSWER_TIME *,QUESTIONANSWER_TIME *>
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAUQUESTIONANSWER_DATA@@PAU1@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@YAPAUQUESTIONANSWER_DATA@@PAU1@00AAV?$allocator@UQUESTIONANSWER_DATA@@@0@@Z ; std::_Uninitialized_move<QUESTIONANSWER_DATA *,QUESTIONANSWER_DATA *,std::allocator<QUESTIONANSWER_DATA> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??$_Umove@PAUQUESTIONANSWER_DATA@@@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@IAEPAUQUESTIONANSWER_DATA@@PAU2@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAUQUESTIONANSWER_DATA@@@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@IAEPAUQUESTIONANSWER_DATA@@PAU2@00@Z PROC ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::_Umove<QUESTIONANSWER_DATA *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUQUESTIONANSWER_DATA@@PAU1@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@YAPAUQUESTIONANSWER_DATA@@PAU1@00AAV?$allocator@UQUESTIONANSWER_DATA@@@0@@Z ; std::_Uninitialized_move<QUESTIONANSWER_DATA *,QUESTIONANSWER_DATA *,std::allocator<QUESTIONANSWER_DATA> >
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 1326 : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUQUESTIONANSWER_DATA@@@?$vector@UQUESTIONANSWER_DATA@@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@IAEPAUQUESTIONANSWER_DATA@@PAU2@00@Z ENDP ; std::vector<QUESTIONANSWER_DATA,std::allocator<QUESTIONANSWER_DATA> >::_Umove<QUESTIONANSWER_DATA *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@YAXPAUQUESTIONANSWER_DATA@@0AAV?$allocator@UQUESTIONANSWER_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<QUESTIONANSWER_DATA> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@YAXPAUQUESTIONANSWER_DATA@@0AAV?$allocator@UQUESTIONANSWER_DATA@@@0@@Z
_TEXT	SEGMENT
$T231240 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@YAXPAUQUESTIONANSWER_DATA@@0AAV?$allocator@UQUESTIONANSWER_DATA@@@0@@Z PROC ; std::_Destroy_range<std::allocator<QUESTIONANSWER_DATA> >, COMDAT

; 87   : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UQUESTIONANSWER_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUQUESTIONANSWER_DATA@@0@Z ; std::_Ptr_cat<QUESTIONANSWER_DATA,QUESTIONANSWER_DATA>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T231240[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T231240[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@YAXPAUQUESTIONANSWER_DATA@@0AAV?$allocator@UQUESTIONANSWER_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<QUESTIONANSWER_DATA> >
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 89   : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Destroy_range@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@YAXPAUQUESTIONANSWER_DATA@@0AAV?$allocator@UQUESTIONANSWER_DATA@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<QUESTIONANSWER_DATA> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAUQUESTIONANSWER_TIME@@PAU1@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@YAPAUQUESTIONANSWER_TIME@@PAU1@00AAV?$allocator@UQUESTIONANSWER_TIME@@@0@@Z ; std::_Uninitialized_move<QUESTIONANSWER_TIME *,QUESTIONANSWER_TIME *,std::allocator<QUESTIONANSWER_TIME> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??$_Umove@PAUQUESTIONANSWER_TIME@@@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@IAEPAUQUESTIONANSWER_TIME@@PAU2@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAUQUESTIONANSWER_TIME@@@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@IAEPAUQUESTIONANSWER_TIME@@PAU2@00@Z PROC ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::_Umove<QUESTIONANSWER_TIME *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUQUESTIONANSWER_TIME@@PAU1@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@YAPAUQUESTIONANSWER_TIME@@PAU1@00AAV?$allocator@UQUESTIONANSWER_TIME@@@0@@Z ; std::_Uninitialized_move<QUESTIONANSWER_TIME *,QUESTIONANSWER_TIME *,std::allocator<QUESTIONANSWER_TIME> >
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 1326 : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUQUESTIONANSWER_TIME@@@?$vector@UQUESTIONANSWER_TIME@@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@IAEPAUQUESTIONANSWER_TIME@@PAU2@00@Z ENDP ; std::vector<QUESTIONANSWER_TIME,std::allocator<QUESTIONANSWER_TIME> >::_Umove<QUESTIONANSWER_TIME *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@YAXPAUQUESTIONANSWER_TIME@@0AAV?$allocator@UQUESTIONANSWER_TIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<QUESTIONANSWER_TIME> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@YAXPAUQUESTIONANSWER_TIME@@0AAV?$allocator@UQUESTIONANSWER_TIME@@@0@@Z
_TEXT	SEGMENT
$T231245 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@YAXPAUQUESTIONANSWER_TIME@@0AAV?$allocator@UQUESTIONANSWER_TIME@@@0@@Z PROC ; std::_Destroy_range<std::allocator<QUESTIONANSWER_TIME> >, COMDAT

; 87   : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UQUESTIONANSWER_TIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUQUESTIONANSWER_TIME@@0@Z ; std::_Ptr_cat<QUESTIONANSWER_TIME,QUESTIONANSWER_TIME>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T231245[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T231245[ebp]
  00020	52		 push	 edx
  00021	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@YAXPAUQUESTIONANSWER_TIME@@0AAV?$allocator@UQUESTIONANSWER_TIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<QUESTIONANSWER_TIME> >
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 89   : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Destroy_range@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@YAXPAUQUESTIONANSWER_TIME@@0AAV?$allocator@UQUESTIONANSWER_TIME@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<QUESTIONANSWER_TIME> >
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Allocate@UQUESTIONANSWER_DATA@@@std@@YAPAUQUESTIONANSWER_DATA@@IPAU1@@Z
_TEXT	SEGMENT
$T231248 = -80						; size = 12
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UQUESTIONANSWER_DATA@@@std@@YAPAUQUESTIONANSWER_DATA@@IPAU1@@Z PROC ; std::_Allocate<QUESTIONANSWER_DATA>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 31   : 	void *_Ptr = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 32   : 
; 33   : 	if (_Count <= 0)

  00010	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	77 09		 ja	 SHORT $LN4@Allocate

; 34   : 		_Count = 0;

  00016	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __Count$[ebp], 0

; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0001d	eb 39		 jmp	 SHORT $LN3@Allocate
$LN4@Allocate:

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0001f	81 7d 08 ff ff
	ff 01		 cmp	 DWORD PTR __Count$[ebp], 33554431 ; 01ffffffH
  00026	77 18		 ja	 SHORT $LN1@Allocate
  00028	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002b	c1 e0 07	 shl	 eax, 7
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 fc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0003a	83 7d fc 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  0003e	75 18		 jne	 SHORT $LN3@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00040	6a 00		 push	 0
  00042	8d 4d b0	 lea	 ecx, DWORD PTR $T231248[ebp]
  00045	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0004a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0004f	8d 45 b0	 lea	 eax, DWORD PTR $T231248[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Allocate:

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00058	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 40   : 	}

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
??$_Allocate@UQUESTIONANSWER_DATA@@@std@@YAPAUQUESTIONANSWER_DATA@@IPAU1@@Z ENDP ; std::_Allocate<QUESTIONANSWER_DATA>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Allocate@UQUESTIONANSWER_TIME@@@std@@YAPAUQUESTIONANSWER_TIME@@IPAU1@@Z
_TEXT	SEGMENT
$T231251 = -80						; size = 12
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UQUESTIONANSWER_TIME@@@std@@YAPAUQUESTIONANSWER_TIME@@IPAU1@@Z PROC ; std::_Allocate<QUESTIONANSWER_TIME>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 31   : 	void *_Ptr = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 32   : 
; 33   : 	if (_Count <= 0)

  00010	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	77 09		 ja	 SHORT $LN4@Allocate@2

; 34   : 		_Count = 0;

  00016	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __Count$[ebp], 0

; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0001d	eb 39		 jmp	 SHORT $LN3@Allocate@2
$LN4@Allocate@2:

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0001f	81 7d 08 ff ff
	ff 1f		 cmp	 DWORD PTR __Count$[ebp], 536870911 ; 1fffffffH
  00026	77 18		 ja	 SHORT $LN1@Allocate@2
  00028	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002b	c1 e0 03	 shl	 eax, 3
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 fc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0003a	83 7d fc 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  0003e	75 18		 jne	 SHORT $LN3@Allocate@2
$LN1@Allocate@2:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00040	6a 00		 push	 0
  00042	8d 4d b0	 lea	 ecx, DWORD PTR $T231251[ebp]
  00045	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0004a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0004f	8d 45 b0	 lea	 eax, DWORD PTR $T231251[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Allocate@2:

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00058	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate@2:

; 40   : 	}

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
??$_Allocate@UQUESTIONANSWER_TIME@@@std@@YAPAUQUESTIONANSWER_TIME@@IPAU1@@Z ENDP ; std::_Allocate<QUESTIONANSWER_TIME>
_TEXT	ENDS
PUBLIC	??$_Construct@UQUESTIONANSWER_DATA@@ABU1@@std@@YAXPAUQUESTIONANSWER_DATA@@ABU1@@Z ; std::_Construct<QUESTIONANSWER_DATA,QUESTIONANSWER_DATA const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ?construct@?$allocator@UQUESTIONANSWER_DATA@@@std@@QAEXPAUQUESTIONANSWER_DATA@@ABU3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UQUESTIONANSWER_DATA@@@std@@QAEXPAUQUESTIONANSWER_DATA@@ABU3@@Z PROC ; std::allocator<QUESTIONANSWER_DATA>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 197  : 		_Construct(_Ptr, _Val);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ??$_Construct@UQUESTIONANSWER_DATA@@ABU1@@std@@YAXPAUQUESTIONANSWER_DATA@@ABU1@@Z ; std::_Construct<QUESTIONANSWER_DATA,QUESTIONANSWER_DATA const &>
  00019	83 c4 08	 add	 esp, 8

; 198  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
?construct@?$allocator@UQUESTIONANSWER_DATA@@@std@@QAEXPAUQUESTIONANSWER_DATA@@ABU3@@Z ENDP ; std::allocator<QUESTIONANSWER_DATA>::construct
_TEXT	ENDS
PUBLIC	??$_Construct@UQUESTIONANSWER_TIME@@ABU1@@std@@YAXPAUQUESTIONANSWER_TIME@@ABU1@@Z ; std::_Construct<QUESTIONANSWER_TIME,QUESTIONANSWER_TIME const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ?construct@?$allocator@UQUESTIONANSWER_TIME@@@std@@QAEXPAUQUESTIONANSWER_TIME@@ABU3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UQUESTIONANSWER_TIME@@@std@@QAEXPAUQUESTIONANSWER_TIME@@ABU3@@Z PROC ; std::allocator<QUESTIONANSWER_TIME>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 197  : 		_Construct(_Ptr, _Val);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ??$_Construct@UQUESTIONANSWER_TIME@@ABU1@@std@@YAXPAUQUESTIONANSWER_TIME@@ABU1@@Z ; std::_Construct<QUESTIONANSWER_TIME,QUESTIONANSWER_TIME const &>
  00019	83 c4 08	 add	 esp, 8

; 198  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
?construct@?$allocator@UQUESTIONANSWER_TIME@@@std@@QAEXPAUQUESTIONANSWER_TIME@@ABU3@@Z ENDP ; std::allocator<QUESTIONANSWER_TIME>::construct
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@AAUQUESTIONANSWER_DATA@@@std@@YAAAUQUESTIONANSWER_DATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUQUESTIONANSWER_DATA@@@std@@YAAAUQUESTIONANSWER_DATA@@AAU1@@Z PROC ; std::forward<QUESTIONANSWER_DATA &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAUQUESTIONANSWER_DATA@@@std@@YAAAUQUESTIONANSWER_DATA@@AAU1@@Z ENDP ; std::forward<QUESTIONANSWER_DATA &>
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??2@YAPAXIPAX@Z					; operator new
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$construct@AAUQUESTIONANSWER_DATA@@@?$allocator@UQUESTIONANSWER_DATA@@@std@@QAEXPAUQUESTIONANSWER_DATA@@AAU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@AAUQUESTIONANSWER_DATA@@@?$allocator@UQUESTIONANSWER_DATA@@@std@@QAEXPAUQUESTIONANSWER_DATA@@AAU2@@Z$0
__ehfuncinfo$??$construct@AAUQUESTIONANSWER_DATA@@@?$allocator@UQUESTIONANSWER_DATA@@@std@@QAEXPAUQUESTIONANSWER_DATA@@AAU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@AAUQUESTIONANSWER_DATA@@@?$allocator@UQUESTIONANSWER_DATA@@@std@@QAEXPAUQUESTIONANSWER_DATA@@AAU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$construct@AAUQUESTIONANSWER_DATA@@@?$allocator@UQUESTIONANSWER_DATA@@@std@@QAEXPAUQUESTIONANSWER_DATA@@AAU2@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T231260 = -88						; size = 4
$T231261 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAUQUESTIONANSWER_DATA@@@?$allocator@UQUESTIONANSWER_DATA@@@std@@QAEXPAUQUESTIONANSWER_DATA@@AAU2@@Z PROC ; std::allocator<QUESTIONANSWER_DATA>::construct<QUESTIONANSWER_DATA &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@AAUQUESTIONANSWER_DATA@@@?$allocator@UQUESTIONANSWER_DATA@@@std@@QAEXPAUQUESTIONANSWER_DATA@@AAU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	68 80 00 00 00	 push	 128			; 00000080H
  00034	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00039	83 c4 08	 add	 esp, 8
  0003c	89 45 ac	 mov	 DWORD PTR $T231261[ebp], eax
  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00046	83 7d ac 00	 cmp	 DWORD PTR $T231261[ebp], 0
  0004a	74 20		 je	 SHORT $LN3@construct
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ??$forward@AAUQUESTIONANSWER_DATA@@@std@@YAAAUQUESTIONANSWER_DATA@@AAU1@@Z ; std::forward<QUESTIONANSWER_DATA &>
  00055	83 c4 04	 add	 esp, 4
  00058	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0005d	8b f0		 mov	 esi, eax
  0005f	8b 7d ac	 mov	 edi, DWORD PTR $T231261[ebp]
  00062	f3 a5		 rep movsd
  00064	8b 55 ac	 mov	 edx, DWORD PTR $T231261[ebp]
  00067	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  0006a	eb 07		 jmp	 SHORT $LN4@construct
$LN3@construct:
  0006c	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct:
  00073	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00076	89 45 a8	 mov	 DWORD PTR $T231260[ebp], eax
  00079	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 209  : 		}

  00080	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00083	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008a	59		 pop	 ecx
  0008b	5f		 pop	 edi
  0008c	5e		 pop	 esi
  0008d	5b		 pop	 ebx
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@AAUQUESTIONANSWER_DATA@@@?$allocator@UQUESTIONANSWER_DATA@@@std@@QAEXPAUQUESTIONANSWER_DATA@@AAU2@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T231261[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@AAUQUESTIONANSWER_DATA@@@?$allocator@UQUESTIONANSWER_DATA@@@std@@QAEXPAUQUESTIONANSWER_DATA@@AAU2@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@AAUQUESTIONANSWER_DATA@@@?$allocator@UQUESTIONANSWER_DATA@@@std@@QAEXPAUQUESTIONANSWER_DATA@@AAU2@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@AAUQUESTIONANSWER_DATA@@@?$allocator@UQUESTIONANSWER_DATA@@@std@@QAEXPAUQUESTIONANSWER_DATA@@AAU2@@Z ENDP ; std::allocator<QUESTIONANSWER_DATA>::construct<QUESTIONANSWER_DATA &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 81   :         {return (_Where); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 83   :         {return; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@ABUQUESTIONANSWER_DATA@@@std@@YAABUQUESTIONANSWER_DATA@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUQUESTIONANSWER_DATA@@@std@@YAABUQUESTIONANSWER_DATA@@ABU1@@Z PROC ; std::forward<QUESTIONANSWER_DATA const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@ABUQUESTIONANSWER_DATA@@@std@@YAABUQUESTIONANSWER_DATA@@ABU1@@Z ENDP ; std::forward<QUESTIONANSWER_DATA const &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@AAUQUESTIONANSWER_TIME@@@std@@YAAAUQUESTIONANSWER_TIME@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUQUESTIONANSWER_TIME@@@std@@YAAAUQUESTIONANSWER_TIME@@AAU1@@Z PROC ; std::forward<QUESTIONANSWER_TIME &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAUQUESTIONANSWER_TIME@@@std@@YAAAUQUESTIONANSWER_TIME@@AAU1@@Z ENDP ; std::forward<QUESTIONANSWER_TIME &>
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$construct@AAUQUESTIONANSWER_TIME@@@?$allocator@UQUESTIONANSWER_TIME@@@std@@QAEXPAUQUESTIONANSWER_TIME@@AAU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@AAUQUESTIONANSWER_TIME@@@?$allocator@UQUESTIONANSWER_TIME@@@std@@QAEXPAUQUESTIONANSWER_TIME@@AAU2@@Z$0
__ehfuncinfo$??$construct@AAUQUESTIONANSWER_TIME@@@?$allocator@UQUESTIONANSWER_TIME@@@std@@QAEXPAUQUESTIONANSWER_TIME@@AAU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@AAUQUESTIONANSWER_TIME@@@?$allocator@UQUESTIONANSWER_TIME@@@std@@QAEXPAUQUESTIONANSWER_TIME@@AAU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$construct@AAUQUESTIONANSWER_TIME@@@?$allocator@UQUESTIONANSWER_TIME@@@std@@QAEXPAUQUESTIONANSWER_TIME@@AAU2@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T231281 = -88						; size = 4
$T231282 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAUQUESTIONANSWER_TIME@@@?$allocator@UQUESTIONANSWER_TIME@@@std@@QAEXPAUQUESTIONANSWER_TIME@@AAU2@@Z PROC ; std::allocator<QUESTIONANSWER_TIME>::construct<QUESTIONANSWER_TIME &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@AAUQUESTIONANSWER_TIME@@@?$allocator@UQUESTIONANSWER_TIME@@@std@@QAEXPAUQUESTIONANSWER_TIME@@AAU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 08		 push	 8
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T231282[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T231282[ebp], 0
  00047	74 21		 je	 SHORT $LN3@construct@2
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@AAUQUESTIONANSWER_TIME@@@std@@YAAAUQUESTIONANSWER_TIME@@AAU1@@Z ; std::forward<QUESTIONANSWER_TIME &>
  00052	83 c4 04	 add	 esp, 4
  00055	8b 10		 mov	 edx, DWORD PTR [eax]
  00057	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005a	8b 4d ac	 mov	 ecx, DWORD PTR $T231282[ebp]
  0005d	89 11		 mov	 DWORD PTR [ecx], edx
  0005f	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00062	8b 55 ac	 mov	 edx, DWORD PTR $T231282[ebp]
  00065	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  00068	eb 07		 jmp	 SHORT $LN4@construct@2
$LN3@construct@2:
  0006a	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct@2:
  00071	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00074	89 45 a8	 mov	 DWORD PTR $T231281[ebp], eax
  00077	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 209  : 		}

  0007e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00081	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00088	59		 pop	 ecx
  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@AAUQUESTIONANSWER_TIME@@@?$allocator@UQUESTIONANSWER_TIME@@@std@@QAEXPAUQUESTIONANSWER_TIME@@AAU2@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T231282[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@AAUQUESTIONANSWER_TIME@@@?$allocator@UQUESTIONANSWER_TIME@@@std@@QAEXPAUQUESTIONANSWER_TIME@@AAU2@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@AAUQUESTIONANSWER_TIME@@@?$allocator@UQUESTIONANSWER_TIME@@@std@@QAEXPAUQUESTIONANSWER_TIME@@AAU2@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@AAUQUESTIONANSWER_TIME@@@?$allocator@UQUESTIONANSWER_TIME@@@std@@QAEXPAUQUESTIONANSWER_TIME@@AAU2@@Z ENDP ; std::allocator<QUESTIONANSWER_TIME>::construct<QUESTIONANSWER_TIME &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@ABUQUESTIONANSWER_TIME@@@std@@YAABUQUESTIONANSWER_TIME@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUQUESTIONANSWER_TIME@@@std@@YAABUQUESTIONANSWER_TIME@@ABU1@@Z PROC ; std::forward<QUESTIONANSWER_TIME const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@ABUQUESTIONANSWER_TIME@@@std@@YAABUQUESTIONANSWER_TIME@@ABU1@@Z ENDP ; std::forward<QUESTIONANSWER_TIME const &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@UQUESTIONANSWER_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUQUESTIONANSWER_DATA@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UQUESTIONANSWER_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUQUESTIONANSWER_DATA@@0@Z PROC ; std::_Ptr_cat<QUESTIONANSWER_DATA,QUESTIONANSWER_DATA>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00009	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Ptr_cat@UQUESTIONANSWER_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUQUESTIONANSWER_DATA@@0@Z ENDP ; std::_Ptr_cat<QUESTIONANSWER_DATA,QUESTIONANSWER_DATA>
_TEXT	ENDS
PUBLIC	??$move@AAUQUESTIONANSWER_DATA@@@std@@YA$$QAUQUESTIONANSWER_DATA@@AAU1@@Z ; std::move<QUESTIONANSWER_DATA &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Move@PAUQUESTIONANSWER_DATA@@PAU1@@std@@YAPAUQUESTIONANSWER_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAUQUESTIONANSWER_DATA@@PAU1@@std@@YAPAUQUESTIONANSWER_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<QUESTIONANSWER_DATA *,QUESTIONANSWER_DATA *>, COMDAT

; 2512 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2513 : 	for (; _First != _Last; ++_Dest, ++_First)

  00009	eb 17		 jmp	 SHORT $LN3@Move
$LN2@Move:
  0000b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000e	05 80 00 00 00	 add	 eax, 128		; 00000080H
  00013	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00016	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00019	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0001f	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN3@Move:
  00022	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00025	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00028	74 1a		 je	 SHORT $LN1@Move

; 2514 : 		*_Dest = _STD move(*_First);

  0002a	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 ??$move@AAUQUESTIONANSWER_DATA@@@std@@YA$$QAUQUESTIONANSWER_DATA@@AAU1@@Z ; std::move<QUESTIONANSWER_DATA &>
  00033	83 c4 04	 add	 esp, 4
  00036	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0003b	8b f0		 mov	 esi, eax
  0003d	8b 7d 10	 mov	 edi, DWORD PTR __Dest$[ebp]
  00040	f3 a5		 rep movsd
  00042	eb c7		 jmp	 SHORT $LN2@Move
$LN1@Move:

; 2515 : 	return (_Dest);

  00044	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 2516 : 	}

  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
  00049	5b		 pop	 ebx
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
??$_Move@PAUQUESTIONANSWER_DATA@@PAU1@@std@@YAPAUQUESTIONANSWER_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<QUESTIONANSWER_DATA *,QUESTIONANSWER_DATA *>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@UQUESTIONANSWER_TIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUQUESTIONANSWER_TIME@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UQUESTIONANSWER_TIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUQUESTIONANSWER_TIME@@0@Z PROC ; std::_Ptr_cat<QUESTIONANSWER_TIME,QUESTIONANSWER_TIME>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00009	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Ptr_cat@UQUESTIONANSWER_TIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUQUESTIONANSWER_TIME@@0@Z ENDP ; std::_Ptr_cat<QUESTIONANSWER_TIME,QUESTIONANSWER_TIME>
_TEXT	ENDS
PUBLIC	??$move@AAUQUESTIONANSWER_TIME@@@std@@YA$$QAUQUESTIONANSWER_TIME@@AAU1@@Z ; std::move<QUESTIONANSWER_TIME &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Move@PAUQUESTIONANSWER_TIME@@PAU1@@std@@YAPAUQUESTIONANSWER_TIME@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAUQUESTIONANSWER_TIME@@PAU1@@std@@YAPAUQUESTIONANSWER_TIME@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<QUESTIONANSWER_TIME *,QUESTIONANSWER_TIME *>, COMDAT

; 2512 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2513 : 	for (; _First != _Last; ++_Dest, ++_First)

  00009	eb 12		 jmp	 SHORT $LN3@Move@2
$LN2@Move@2:
  0000b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000e	83 c0 08	 add	 eax, 8
  00011	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00017	83 c1 08	 add	 ecx, 8
  0001a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN3@Move@2:
  0001d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00020	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00023	74 1b		 je	 SHORT $LN1@Move@2

; 2514 : 		*_Dest = _STD move(*_First);

  00025	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??$move@AAUQUESTIONANSWER_TIME@@@std@@YA$$QAUQUESTIONANSWER_TIME@@AAU1@@Z ; std::move<QUESTIONANSWER_TIME &>
  0002e	83 c4 04	 add	 esp, 4
  00031	8b 08		 mov	 ecx, DWORD PTR [eax]
  00033	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00036	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00039	89 08		 mov	 DWORD PTR [eax], ecx
  0003b	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0003e	eb cb		 jmp	 SHORT $LN2@Move@2
$LN1@Move@2:

; 2515 : 	return (_Dest);

  00040	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 2516 : 	}

  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
??$_Move@PAUQUESTIONANSWER_TIME@@PAU1@@std@@YAPAUQUESTIONANSWER_TIME@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<QUESTIONANSWER_TIME *,QUESTIONANSWER_TIME *>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUQUESTIONANSWER_DATA@@PAU1@V?$allocator@UQUESTIONANSWER_DATA@@@std@@U1@@std@@YAPAUQUESTIONANSWER_DATA@@PAU1@00AAV?$allocator@UQUESTIONANSWER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<QUESTIONANSWER_DATA *,QUESTIONANSWER_DATA *,std::allocator<QUESTIONANSWER_DATA>,QUESTIONANSWER_DATA>
PUBLIC	??$_Val_type@PAUQUESTIONANSWER_DATA@@@std@@YAPAUQUESTIONANSWER_DATA@@PAU1@@Z ; std::_Val_type<QUESTIONANSWER_DATA *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_move@PAUQUESTIONANSWER_DATA@@PAU1@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@YAPAUQUESTIONANSWER_DATA@@PAU1@00AAV?$allocator@UQUESTIONANSWER_DATA@@@0@@Z
_TEXT	SEGMENT
$T231304 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUQUESTIONANSWER_DATA@@PAU1@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@YAPAUQUESTIONANSWER_DATA@@PAU1@00AAV?$allocator@UQUESTIONANSWER_DATA@@@0@@Z PROC ; std::_Uninitialized_move<QUESTIONANSWER_DATA *,QUESTIONANSWER_DATA *,std::allocator<QUESTIONANSWER_DATA> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UQUESTIONANSWER_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUQUESTIONANSWER_DATA@@0@Z ; std::_Ptr_cat<QUESTIONANSWER_DATA,QUESTIONANSWER_DATA>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T231304[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T231304[ebp]
  00020	52		 push	 edx
  00021	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??$_Val_type@PAUQUESTIONANSWER_DATA@@@std@@YAPAUQUESTIONANSWER_DATA@@PAU1@@Z ; std::_Val_type<QUESTIONANSWER_DATA *>
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00031	51		 push	 ecx
  00032	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00035	52		 push	 edx
  00036	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUQUESTIONANSWER_DATA@@PAU1@V?$allocator@UQUESTIONANSWER_DATA@@@std@@U1@@std@@YAPAUQUESTIONANSWER_DATA@@PAU1@00AAV?$allocator@UQUESTIONANSWER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<QUESTIONANSWER_DATA *,QUESTIONANSWER_DATA *,std::allocator<QUESTIONANSWER_DATA>,QUESTIONANSWER_DATA>
  00043	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
??$_Uninitialized_move@PAUQUESTIONANSWER_DATA@@PAU1@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@YAPAUQUESTIONANSWER_DATA@@PAU1@00AAV?$allocator@UQUESTIONANSWER_DATA@@@0@@Z ENDP ; std::_Uninitialized_move<QUESTIONANSWER_DATA *,QUESTIONANSWER_DATA *,std::allocator<QUESTIONANSWER_DATA> >
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@UQUESTIONANSWER_DATA@@@std@@UQUESTIONANSWER_DATA@@@std@@YAXAAV?$allocator@UQUESTIONANSWER_DATA@@@0@PAUQUESTIONANSWER_DATA@@@Z ; std::_Dest_val<std::allocator<QUESTIONANSWER_DATA>,QUESTIONANSWER_DATA>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@YAXPAUQUESTIONANSWER_DATA@@0AAV?$allocator@UQUESTIONANSWER_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@YAXPAUQUESTIONANSWER_DATA@@0AAV?$allocator@UQUESTIONANSWER_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<QUESTIONANSWER_DATA> >, COMDAT

; 95   : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 96   : 	for (; _First != _Last; ++_First)

  00009	eb 0b		 jmp	 SHORT $LN3@Destroy_ra
$LN2@Destroy_ra:
  0000b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000e	05 80 00 00 00	 add	 eax, 128		; 00000080H
  00013	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra:
  00016	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00019	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0001c	74 12		 je	 SHORT $LN4@Destroy_ra

; 97   : 		_Dest_val(_Al, _First);

  0001e	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@UQUESTIONANSWER_DATA@@@std@@UQUESTIONANSWER_DATA@@@std@@YAXAAV?$allocator@UQUESTIONANSWER_DATA@@@0@PAUQUESTIONANSWER_DATA@@@Z ; std::_Dest_val<std::allocator<QUESTIONANSWER_DATA>,QUESTIONANSWER_DATA>
  0002b	83 c4 08	 add	 esp, 8
  0002e	eb db		 jmp	 SHORT $LN2@Destroy_ra
$LN4@Destroy_ra:

; 98   : 	}

  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
??$_Destroy_range@V?$allocator@UQUESTIONANSWER_DATA@@@std@@@std@@YAXPAUQUESTIONANSWER_DATA@@0AAV?$allocator@UQUESTIONANSWER_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<QUESTIONANSWER_DATA> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUQUESTIONANSWER_TIME@@PAU1@V?$allocator@UQUESTIONANSWER_TIME@@@std@@U1@@std@@YAPAUQUESTIONANSWER_TIME@@PAU1@00AAV?$allocator@UQUESTIONANSWER_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<QUESTIONANSWER_TIME *,QUESTIONANSWER_TIME *,std::allocator<QUESTIONANSWER_TIME>,QUESTIONANSWER_TIME>
PUBLIC	??$_Val_type@PAUQUESTIONANSWER_TIME@@@std@@YAPAUQUESTIONANSWER_TIME@@PAU1@@Z ; std::_Val_type<QUESTIONANSWER_TIME *>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_move@PAUQUESTIONANSWER_TIME@@PAU1@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@YAPAUQUESTIONANSWER_TIME@@PAU1@00AAV?$allocator@UQUESTIONANSWER_TIME@@@0@@Z
_TEXT	SEGMENT
$T231309 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUQUESTIONANSWER_TIME@@PAU1@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@YAPAUQUESTIONANSWER_TIME@@PAU1@00AAV?$allocator@UQUESTIONANSWER_TIME@@@0@@Z PROC ; std::_Uninitialized_move<QUESTIONANSWER_TIME *,QUESTIONANSWER_TIME *,std::allocator<QUESTIONANSWER_TIME> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@UQUESTIONANSWER_TIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUQUESTIONANSWER_TIME@@0@Z ; std::_Ptr_cat<QUESTIONANSWER_TIME,QUESTIONANSWER_TIME>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T231309[ebp], al
  0001c	0f b6 55 bf	 movzx	 edx, BYTE PTR $T231309[ebp]
  00020	52		 push	 edx
  00021	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??$_Val_type@PAUQUESTIONANSWER_TIME@@@std@@YAPAUQUESTIONANSWER_TIME@@PAU1@@Z ; std::_Val_type<QUESTIONANSWER_TIME *>
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00031	51		 push	 ecx
  00032	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00035	52		 push	 edx
  00036	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUQUESTIONANSWER_TIME@@PAU1@V?$allocator@UQUESTIONANSWER_TIME@@@std@@U1@@std@@YAPAUQUESTIONANSWER_TIME@@PAU1@00AAV?$allocator@UQUESTIONANSWER_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<QUESTIONANSWER_TIME *,QUESTIONANSWER_TIME *,std::allocator<QUESTIONANSWER_TIME>,QUESTIONANSWER_TIME>
  00043	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
??$_Uninitialized_move@PAUQUESTIONANSWER_TIME@@PAU1@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@YAPAUQUESTIONANSWER_TIME@@PAU1@00AAV?$allocator@UQUESTIONANSWER_TIME@@@0@@Z ENDP ; std::_Uninitialized_move<QUESTIONANSWER_TIME *,QUESTIONANSWER_TIME *,std::allocator<QUESTIONANSWER_TIME> >
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@UQUESTIONANSWER_TIME@@@std@@UQUESTIONANSWER_TIME@@@std@@YAXAAV?$allocator@UQUESTIONANSWER_TIME@@@0@PAUQUESTIONANSWER_TIME@@@Z ; std::_Dest_val<std::allocator<QUESTIONANSWER_TIME>,QUESTIONANSWER_TIME>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@YAXPAUQUESTIONANSWER_TIME@@0AAV?$allocator@UQUESTIONANSWER_TIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@YAXPAUQUESTIONANSWER_TIME@@0AAV?$allocator@UQUESTIONANSWER_TIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<QUESTIONANSWER_TIME> >, COMDAT

; 95   : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 96   : 	for (; _First != _Last; ++_First)

  00009	eb 09		 jmp	 SHORT $LN3@Destroy_ra@2
$LN2@Destroy_ra@2:
  0000b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000e	83 c0 08	 add	 eax, 8
  00011	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra@2:
  00014	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00017	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0001a	74 12		 je	 SHORT $LN4@Destroy_ra@2

; 97   : 		_Dest_val(_Al, _First);

  0001c	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@UQUESTIONANSWER_TIME@@@std@@UQUESTIONANSWER_TIME@@@std@@YAXAAV?$allocator@UQUESTIONANSWER_TIME@@@0@PAUQUESTIONANSWER_TIME@@@Z ; std::_Dest_val<std::allocator<QUESTIONANSWER_TIME>,QUESTIONANSWER_TIME>
  00029	83 c4 08	 add	 esp, 8
  0002c	eb dd		 jmp	 SHORT $LN2@Destroy_ra@2
$LN4@Destroy_ra@2:

; 98   : 	}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$_Destroy_range@V?$allocator@UQUESTIONANSWER_TIME@@@std@@@std@@YAXPAUQUESTIONANSWER_TIME@@0AAV?$allocator@UQUESTIONANSWER_TIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<QUESTIONANSWER_TIME> >
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Construct@UQUESTIONANSWER_DATA@@ABU1@@std@@YAXPAUQUESTIONANSWER_DATA@@ABU1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@UQUESTIONANSWER_DATA@@ABU1@@std@@YAXPAUQUESTIONANSWER_DATA@@ABU1@@Z$0
__ehfuncinfo$??$_Construct@UQUESTIONANSWER_DATA@@ABU1@@std@@YAXPAUQUESTIONANSWER_DATA@@ABU1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@UQUESTIONANSWER_DATA@@ABU1@@std@@YAXPAUQUESTIONANSWER_DATA@@ABU1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Construct@UQUESTIONANSWER_DATA@@ABU1@@std@@YAXPAUQUESTIONANSWER_DATA@@ABU1@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T231314 = -88						; size = 4
$T231315 = -84						; size = 4
__Vptr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UQUESTIONANSWER_DATA@@ABU1@@std@@YAXPAUQUESTIONANSWER_DATA@@ABU1@@Z PROC ; std::_Construct<QUESTIONANSWER_DATA,QUESTIONANSWER_DATA const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Construct@UQUESTIONANSWER_DATA@@ABU1@@std@@YAXPAUQUESTIONANSWER_DATA@@ABU1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 47   : 	void _FARQ *_Vptr = _Ptr;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002b	89 45 f0	 mov	 DWORD PTR __Vptr$[ebp], eax

; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  0002e	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00031	50		 push	 eax
  00032	68 80 00 00 00	 push	 128			; 00000080H
  00037	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0003c	83 c4 08	 add	 esp, 8
  0003f	89 45 ac	 mov	 DWORD PTR $T231315[ebp], eax
  00042	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00049	83 7d ac 00	 cmp	 DWORD PTR $T231315[ebp], 0
  0004d	74 20		 je	 SHORT $LN3@Construct
  0004f	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  00052	51		 push	 ecx
  00053	e8 00 00 00 00	 call	 ??$forward@ABUQUESTIONANSWER_DATA@@@std@@YAABUQUESTIONANSWER_DATA@@ABU1@@Z ; std::forward<QUESTIONANSWER_DATA const &>
  00058	83 c4 04	 add	 esp, 4
  0005b	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00060	8b f0		 mov	 esi, eax
  00062	8b 7d ac	 mov	 edi, DWORD PTR $T231315[ebp]
  00065	f3 a5		 rep movsd
  00067	8b 55 ac	 mov	 edx, DWORD PTR $T231315[ebp]
  0006a	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  0006d	eb 07		 jmp	 SHORT $LN4@Construct
$LN3@Construct:
  0006f	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@Construct:
  00076	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00079	89 45 a8	 mov	 DWORD PTR $T231314[ebp], eax
  0007c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 49   : 	}

  00083	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00086	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008d	59		 pop	 ecx
  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@UQUESTIONANSWER_DATA@@ABU1@@std@@YAXPAUQUESTIONANSWER_DATA@@ABU1@@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T231315[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Construct@UQUESTIONANSWER_DATA@@ABU1@@std@@YAXPAUQUESTIONANSWER_DATA@@ABU1@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Construct@UQUESTIONANSWER_DATA@@ABU1@@std@@YAXPAUQUESTIONANSWER_DATA@@ABU1@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Construct@UQUESTIONANSWER_DATA@@ABU1@@std@@YAXPAUQUESTIONANSWER_DATA@@ABU1@@Z ENDP ; std::_Construct<QUESTIONANSWER_DATA,QUESTIONANSWER_DATA const &>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Construct@UQUESTIONANSWER_TIME@@ABU1@@std@@YAXPAUQUESTIONANSWER_TIME@@ABU1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@UQUESTIONANSWER_TIME@@ABU1@@std@@YAXPAUQUESTIONANSWER_TIME@@ABU1@@Z$0
__ehfuncinfo$??$_Construct@UQUESTIONANSWER_TIME@@ABU1@@std@@YAXPAUQUESTIONANSWER_TIME@@ABU1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@UQUESTIONANSWER_TIME@@ABU1@@std@@YAXPAUQUESTIONANSWER_TIME@@ABU1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Construct@UQUESTIONANSWER_TIME@@ABU1@@std@@YAXPAUQUESTIONANSWER_TIME@@ABU1@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T231327 = -88						; size = 4
$T231328 = -84						; size = 4
__Vptr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UQUESTIONANSWER_TIME@@ABU1@@std@@YAXPAUQUESTIONANSWER_TIME@@ABU1@@Z PROC ; std::_Construct<QUESTIONANSWER_TIME,QUESTIONANSWER_TIME const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Construct@UQUESTIONANSWER_TIME@@ABU1@@std@@YAXPAUQUESTIONANSWER_TIME@@ABU1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 47   : 	void _FARQ *_Vptr = _Ptr;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002b	89 45 f0	 mov	 DWORD PTR __Vptr$[ebp], eax

; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  0002e	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00031	50		 push	 eax
  00032	6a 08		 push	 8
  00034	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00039	83 c4 08	 add	 esp, 8
  0003c	89 45 ac	 mov	 DWORD PTR $T231328[ebp], eax
  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00046	83 7d ac 00	 cmp	 DWORD PTR $T231328[ebp], 0
  0004a	74 21		 je	 SHORT $LN3@Construct@2
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ??$forward@ABUQUESTIONANSWER_TIME@@@std@@YAABUQUESTIONANSWER_TIME@@ABU1@@Z ; std::forward<QUESTIONANSWER_TIME const &>
  00055	83 c4 04	 add	 esp, 4
  00058	8b 10		 mov	 edx, DWORD PTR [eax]
  0005a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005d	8b 4d ac	 mov	 ecx, DWORD PTR $T231328[ebp]
  00060	89 11		 mov	 DWORD PTR [ecx], edx
  00062	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00065	8b 55 ac	 mov	 edx, DWORD PTR $T231328[ebp]
  00068	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  0006b	eb 07		 jmp	 SHORT $LN4@Construct@2
$LN3@Construct@2:
  0006d	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@Construct@2:
  00074	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00077	89 45 a8	 mov	 DWORD PTR $T231327[ebp], eax
  0007a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 49   : 	}

  00081	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00084	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008b	59		 pop	 ecx
  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi
  0008e	5b		 pop	 ebx
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@UQUESTIONANSWER_TIME@@ABU1@@std@@YAXPAUQUESTIONANSWER_TIME@@ABU1@@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T231328[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Construct@UQUESTIONANSWER_TIME@@ABU1@@std@@YAXPAUQUESTIONANSWER_TIME@@ABU1@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Construct@UQUESTIONANSWER_TIME@@ABU1@@std@@YAXPAUQUESTIONANSWER_TIME@@ABU1@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Construct@UQUESTIONANSWER_TIME@@ABU1@@std@@YAXPAUQUESTIONANSWER_TIME@@ABU1@@Z ENDP ; std::_Construct<QUESTIONANSWER_TIME,QUESTIONANSWER_TIME const &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$move@AAUQUESTIONANSWER_DATA@@@std@@YA$$QAUQUESTIONANSWER_DATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAUQUESTIONANSWER_DATA@@@std@@YA$$QAUQUESTIONANSWER_DATA@@AAU1@@Z PROC ; std::move<QUESTIONANSWER_DATA &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$move@AAUQUESTIONANSWER_DATA@@@std@@YA$$QAUQUESTIONANSWER_DATA@@AAU1@@Z ENDP ; std::move<QUESTIONANSWER_DATA &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$move@AAUQUESTIONANSWER_TIME@@@std@@YA$$QAUQUESTIONANSWER_TIME@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAUQUESTIONANSWER_TIME@@@std@@YA$$QAUQUESTIONANSWER_TIME@@AAU1@@Z PROC ; std::move<QUESTIONANSWER_TIME &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$move@AAUQUESTIONANSWER_TIME@@@std@@YA$$QAUQUESTIONANSWER_TIME@@AAU1@@Z ENDP ; std::move<QUESTIONANSWER_TIME &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Val_type@PAUQUESTIONANSWER_DATA@@@std@@YAPAUQUESTIONANSWER_DATA@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUQUESTIONANSWER_DATA@@@std@@YAPAUQUESTIONANSWER_DATA@@PAU1@@Z PROC ; std::_Val_type<QUESTIONANSWER_DATA *>, COMDAT

; 789  : 	{	// return value type from arbitrary argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 790  : 	return (0);

  00009	33 c0		 xor	 eax, eax

; 791  : 	}

  0000b	5f		 pop	 edi
  0000c	5e		 pop	 esi
  0000d	5b		 pop	 ebx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Val_type@PAUQUESTIONANSWER_DATA@@@std@@YAPAUQUESTIONANSWER_DATA@@PAU1@@Z ENDP ; std::_Val_type<QUESTIONANSWER_DATA *>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UQUESTIONANSWER_DATA@@@std@@UQUESTIONANSWER_DATA@@U3@@std@@YAXAAV?$allocator@UQUESTIONANSWER_DATA@@@0@PAUQUESTIONANSWER_DATA@@$$QAU2@@Z ; std::_Cons_val<std::allocator<QUESTIONANSWER_DATA>,QUESTIONANSWER_DATA,QUESTIONANSWER_DATA>
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_move@PAUQUESTIONANSWER_DATA@@PAU1@V?$allocator@UQUESTIONANSWER_DATA@@@std@@U1@@std@@YAPAUQUESTIONANSWER_DATA@@PAU1@00AAV?$allocator@UQUESTIONANSWER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_move@PAUQUESTIONANSWER_DATA@@PAU1@V?$allocator@UQUESTIONANSWER_DATA@@@std@@U1@@std@@YAPAUQUESTIONANSWER_DATA@@PAU1@00AAV?$allocator@UQUESTIONANSWER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_move@PAUQUESTIONANSWER_DATA@@PAU1@V?$allocator@UQUESTIONANSWER_DATA@@@std@@U1@@std@@YAPAUQUESTIONANSWER_DATA@@PAU1@00AAV?$allocator@UQUESTIONANSWER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_move@PAUQUESTIONANSWER_DATA@@PAU1@V?$allocator@UQUESTIONANSWER_DATA@@@std@@U1@@std@@YAPAUQUESTIONANSWER_DATA@@PAU1@00AAV?$allocator@UQUESTIONANSWER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_move@PAUQUESTIONANSWER_DATA@@PAU1@V?$allocator@UQUESTIONANSWER_DATA@@@std@@U1@@std@@YAPAUQUESTIONANSWER_DATA@@PAU1@00AAV?$allocator@UQUESTIONANSWER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_move@PAUQUESTIONANSWER_DATA@@PAU1@V?$allocator@UQUESTIONANSWER_DATA@@@std@@U1@@std@@YAPAUQUESTIONANSWER_DATA@@PAU1@00AAV?$allocator@UQUESTIONANSWER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_move@PAUQUESTIONANSWER_DATA@@PAU1@V?$allocator@UQUESTIONANSWER_DATA@@@std@@U1@@std@@YAPAUQUESTIONANSWER_DATA@@PAU1@00AAV?$allocator@UQUESTIONANSWER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_move@PAUQUESTIONANSWER_DATA@@PAU1@V?$allocator@UQUESTIONANSWER_DATA@@@std@@U1@@std@@YAPAUQUESTIONANSWER_DATA@@PAU1@00AAV?$allocator@UQUESTIONANSWER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Uninit_move@PAUQUESTIONANSWER_DATA@@PAU1@V?$allocator@UQUESTIONANSWER_DATA@@@std@@U1@@std@@YAPAUQUESTIONANSWER_DATA@@PAU1@00AAV?$allocator@UQUESTIONANSWER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUQUESTIONANSWER_DATA@@PAU1@V?$allocator@UQUESTIONANSWER_DATA@@@std@@U1@@std@@YAPAUQUESTIONANSWER_DATA@@PAU1@00AAV?$allocator@UQUESTIONANSWER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<QUESTIONANSWER_DATA *,QUESTIONANSWER_DATA *,std::allocator<QUESTIONANSWER_DATA>,QUESTIONANSWER_DATA>, COMDAT

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_move@PAUQUESTIONANSWER_DATA@@PAU1@V?$allocator@UQUESTIONANSWER_DATA@@@std@@U1@@std@@YAPAUQUESTIONANSWER_DATA@@PAU1@00AAV?$allocator@UQUESTIONANSWER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 44	 sub	 esp, 68			; 00000044H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;

  0002c	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0002f	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 428  : 
; 429  : 	_TRY_BEGIN

  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00039	eb 17		 jmp	 SHORT $LN6@Uninit_mov
$LN5@Uninit_mov:

; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  0003b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0003e	05 80 00 00 00	 add	 eax, 128		; 00000080H
  00043	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00046	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00049	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0004f	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN6@Uninit_mov:
  00052	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00055	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00058	74 16		 je	 SHORT $LN4@Uninit_mov

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

  0005a	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00061	51		 push	 ecx
  00062	8b 55 14	 mov	 edx, DWORD PTR __Al$[ebp]
  00065	52		 push	 edx
  00066	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UQUESTIONANSWER_DATA@@@std@@UQUESTIONANSWER_DATA@@U3@@std@@YAXAAV?$allocator@UQUESTIONANSWER_DATA@@@0@PAUQUESTIONANSWER_DATA@@$$QAU2@@Z ; std::_Cons_val<std::allocator<QUESTIONANSWER_DATA>,QUESTIONANSWER_DATA,QUESTIONANSWER_DATA>
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006e	eb cb		 jmp	 SHORT $LN5@Uninit_mov
$LN4@Uninit_mov:
  00070	eb 3d		 jmp	 SHORT $LN10@Uninit_mov
__catch$??$_Uninit_move@PAUQUESTIONANSWER_DATA@@PAU1@V?$allocator@UQUESTIONANSWER_DATA@@@std@@U1@@std@@YAPAUQUESTIONANSWER_DATA@@PAU1@00AAV?$allocator@UQUESTIONANSWER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 432  : 	_CATCH_ALL

  00072	eb 0b		 jmp	 SHORT $LN3@Uninit_mov
$LN2@Uninit_mov:

; 433  : 	for (; _Next != _Dest; ++_Next)

  00074	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00077	05 80 00 00 00	 add	 eax, 128		; 00000080H
  0007c	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax
$LN3@Uninit_mov:
  0007f	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00082	3b 45 10	 cmp	 eax, DWORD PTR __Dest$[ebp]
  00085	74 12		 je	 SHORT $LN1@Uninit_mov

; 434  : 		_Dest_val(_Al, _Next);

  00087	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  0008a	50		 push	 eax
  0008b	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  0008e	51		 push	 ecx
  0008f	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@UQUESTIONANSWER_DATA@@@std@@UQUESTIONANSWER_DATA@@@std@@YAXAAV?$allocator@UQUESTIONANSWER_DATA@@@0@PAUQUESTIONANSWER_DATA@@@Z ; std::_Dest_val<std::allocator<QUESTIONANSWER_DATA>,QUESTIONANSWER_DATA>
  00094	83 c4 08	 add	 esp, 8
  00097	eb db		 jmp	 SHORT $LN2@Uninit_mov
$LN1@Uninit_mov:

; 435  : 	_RERAISE;

  00099	6a 00		 push	 0
  0009b	6a 00		 push	 0
  0009d	e8 00 00 00 00	 call	 __CxxThrowException@8

; 436  : 	_CATCH_END

  000a2	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000a9	b8 00 00 00 00	 mov	 eax, __tryend$??$_Uninit_move@PAUQUESTIONANSWER_DATA@@PAU1@V?$allocator@UQUESTIONANSWER_DATA@@@std@@U1@@std@@YAPAUQUESTIONANSWER_DATA@@PAU1@00AAV?$allocator@UQUESTIONANSWER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1
  000ae	c3		 ret	 0
$LN10@Uninit_mov:
  000af	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_move@PAUQUESTIONANSWER_DATA@@PAU1@V?$allocator@UQUESTIONANSWER_DATA@@@std@@U1@@std@@YAPAUQUESTIONANSWER_DATA@@PAU1@00AAV?$allocator@UQUESTIONANSWER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1:

; 437  : 	return (_Dest);

  000b6	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_mov:

; 438  : 	}

  000b9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000bc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c3	59		 pop	 ecx
  000c4	5f		 pop	 edi
  000c5	5e		 pop	 esi
  000c6	5b		 pop	 ebx
  000c7	8b e5		 mov	 esp, ebp
  000c9	5d		 pop	 ebp
  000ca	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_move@PAUQUESTIONANSWER_DATA@@PAU1@V?$allocator@UQUESTIONANSWER_DATA@@@std@@U1@@std@@YAPAUQUESTIONANSWER_DATA@@PAU1@00AAV?$allocator@UQUESTIONANSWER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninit_move@PAUQUESTIONANSWER_DATA@@PAU1@V?$allocator@UQUESTIONANSWER_DATA@@@std@@U1@@std@@YAPAUQUESTIONANSWER_DATA@@PAU1@00AAV?$allocator@UQUESTIONANSWER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninit_move@PAUQUESTIONANSWER_DATA@@PAU1@V?$allocator@UQUESTIONANSWER_DATA@@@std@@U1@@std@@YAPAUQUESTIONANSWER_DATA@@PAU1@00AAV?$allocator@UQUESTIONANSWER_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<QUESTIONANSWER_DATA *,QUESTIONANSWER_DATA *,std::allocator<QUESTIONANSWER_DATA>,QUESTIONANSWER_DATA>
PUBLIC	?destroy@?$allocator@UQUESTIONANSWER_DATA@@@std@@QAEXPAUQUESTIONANSWER_DATA@@@Z ; std::allocator<QUESTIONANSWER_DATA>::destroy
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Dest_val@V?$allocator@UQUESTIONANSWER_DATA@@@std@@UQUESTIONANSWER_DATA@@@std@@YAXAAV?$allocator@UQUESTIONANSWER_DATA@@@0@PAUQUESTIONANSWER_DATA@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@UQUESTIONANSWER_DATA@@@std@@UQUESTIONANSWER_DATA@@@std@@YAXAAV?$allocator@UQUESTIONANSWER_DATA@@@0@PAUQUESTIONANSWER_DATA@@@Z PROC ; std::_Dest_val<std::allocator<QUESTIONANSWER_DATA>,QUESTIONANSWER_DATA>, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 287  : 	_Alval.destroy(_Pdest);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  00010	e8 00 00 00 00	 call	 ?destroy@?$allocator@UQUESTIONANSWER_DATA@@@std@@QAEXPAUQUESTIONANSWER_DATA@@@Z ; std::allocator<QUESTIONANSWER_DATA>::destroy

; 288  : 	}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Dest_val@V?$allocator@UQUESTIONANSWER_DATA@@@std@@UQUESTIONANSWER_DATA@@@std@@YAXAAV?$allocator@UQUESTIONANSWER_DATA@@@0@PAUQUESTIONANSWER_DATA@@@Z ENDP ; std::_Dest_val<std::allocator<QUESTIONANSWER_DATA>,QUESTIONANSWER_DATA>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Val_type@PAUQUESTIONANSWER_TIME@@@std@@YAPAUQUESTIONANSWER_TIME@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUQUESTIONANSWER_TIME@@@std@@YAPAUQUESTIONANSWER_TIME@@PAU1@@Z PROC ; std::_Val_type<QUESTIONANSWER_TIME *>, COMDAT

; 789  : 	{	// return value type from arbitrary argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 790  : 	return (0);

  00009	33 c0		 xor	 eax, eax

; 791  : 	}

  0000b	5f		 pop	 edi
  0000c	5e		 pop	 esi
  0000d	5b		 pop	 ebx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Val_type@PAUQUESTIONANSWER_TIME@@@std@@YAPAUQUESTIONANSWER_TIME@@PAU1@@Z ENDP ; std::_Val_type<QUESTIONANSWER_TIME *>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UQUESTIONANSWER_TIME@@@std@@UQUESTIONANSWER_TIME@@U3@@std@@YAXAAV?$allocator@UQUESTIONANSWER_TIME@@@0@PAUQUESTIONANSWER_TIME@@$$QAU2@@Z ; std::_Cons_val<std::allocator<QUESTIONANSWER_TIME>,QUESTIONANSWER_TIME,QUESTIONANSWER_TIME>
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_move@PAUQUESTIONANSWER_TIME@@PAU1@V?$allocator@UQUESTIONANSWER_TIME@@@std@@U1@@std@@YAPAUQUESTIONANSWER_TIME@@PAU1@00AAV?$allocator@UQUESTIONANSWER_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_move@PAUQUESTIONANSWER_TIME@@PAU1@V?$allocator@UQUESTIONANSWER_TIME@@@std@@U1@@std@@YAPAUQUESTIONANSWER_TIME@@PAU1@00AAV?$allocator@UQUESTIONANSWER_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_move@PAUQUESTIONANSWER_TIME@@PAU1@V?$allocator@UQUESTIONANSWER_TIME@@@std@@U1@@std@@YAPAUQUESTIONANSWER_TIME@@PAU1@00AAV?$allocator@UQUESTIONANSWER_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_move@PAUQUESTIONANSWER_TIME@@PAU1@V?$allocator@UQUESTIONANSWER_TIME@@@std@@U1@@std@@YAPAUQUESTIONANSWER_TIME@@PAU1@00AAV?$allocator@UQUESTIONANSWER_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_move@PAUQUESTIONANSWER_TIME@@PAU1@V?$allocator@UQUESTIONANSWER_TIME@@@std@@U1@@std@@YAPAUQUESTIONANSWER_TIME@@PAU1@00AAV?$allocator@UQUESTIONANSWER_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_move@PAUQUESTIONANSWER_TIME@@PAU1@V?$allocator@UQUESTIONANSWER_TIME@@@std@@U1@@std@@YAPAUQUESTIONANSWER_TIME@@PAU1@00AAV?$allocator@UQUESTIONANSWER_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_move@PAUQUESTIONANSWER_TIME@@PAU1@V?$allocator@UQUESTIONANSWER_TIME@@@std@@U1@@std@@YAPAUQUESTIONANSWER_TIME@@PAU1@00AAV?$allocator@UQUESTIONANSWER_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_move@PAUQUESTIONANSWER_TIME@@PAU1@V?$allocator@UQUESTIONANSWER_TIME@@@std@@U1@@std@@YAPAUQUESTIONANSWER_TIME@@PAU1@00AAV?$allocator@UQUESTIONANSWER_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Uninit_move@PAUQUESTIONANSWER_TIME@@PAU1@V?$allocator@UQUESTIONANSWER_TIME@@@std@@U1@@std@@YAPAUQUESTIONANSWER_TIME@@PAU1@00AAV?$allocator@UQUESTIONANSWER_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUQUESTIONANSWER_TIME@@PAU1@V?$allocator@UQUESTIONANSWER_TIME@@@std@@U1@@std@@YAPAUQUESTIONANSWER_TIME@@PAU1@00AAV?$allocator@UQUESTIONANSWER_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<QUESTIONANSWER_TIME *,QUESTIONANSWER_TIME *,std::allocator<QUESTIONANSWER_TIME>,QUESTIONANSWER_TIME>, COMDAT

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_move@PAUQUESTIONANSWER_TIME@@PAU1@V?$allocator@UQUESTIONANSWER_TIME@@@std@@U1@@std@@YAPAUQUESTIONANSWER_TIME@@PAU1@00AAV?$allocator@UQUESTIONANSWER_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 44	 sub	 esp, 68			; 00000044H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;

  0002c	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0002f	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 428  : 
; 429  : 	_TRY_BEGIN

  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00039	eb 12		 jmp	 SHORT $LN6@Uninit_mov@2
$LN5@Uninit_mov@2:

; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  0003b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0003e	83 c0 08	 add	 eax, 8
  00041	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00044	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00047	83 c1 08	 add	 ecx, 8
  0004a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN6@Uninit_mov@2:
  0004d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00050	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00053	74 16		 je	 SHORT $LN4@Uninit_mov@2

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

  00055	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00058	50		 push	 eax
  00059	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0005c	51		 push	 ecx
  0005d	8b 55 14	 mov	 edx, DWORD PTR __Al$[ebp]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UQUESTIONANSWER_TIME@@@std@@UQUESTIONANSWER_TIME@@U3@@std@@YAXAAV?$allocator@UQUESTIONANSWER_TIME@@@0@PAUQUESTIONANSWER_TIME@@$$QAU2@@Z ; std::_Cons_val<std::allocator<QUESTIONANSWER_TIME>,QUESTIONANSWER_TIME,QUESTIONANSWER_TIME>
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
  00069	eb d0		 jmp	 SHORT $LN5@Uninit_mov@2
$LN4@Uninit_mov@2:
  0006b	eb 3b		 jmp	 SHORT $LN10@Uninit_mov@2
__catch$??$_Uninit_move@PAUQUESTIONANSWER_TIME@@PAU1@V?$allocator@UQUESTIONANSWER_TIME@@@std@@U1@@std@@YAPAUQUESTIONANSWER_TIME@@PAU1@00AAV?$allocator@UQUESTIONANSWER_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 432  : 	_CATCH_ALL

  0006d	eb 09		 jmp	 SHORT $LN3@Uninit_mov@2
$LN2@Uninit_mov@2:

; 433  : 	for (; _Next != _Dest; ++_Next)

  0006f	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00072	83 c0 08	 add	 eax, 8
  00075	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax
$LN3@Uninit_mov@2:
  00078	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  0007b	3b 45 10	 cmp	 eax, DWORD PTR __Dest$[ebp]
  0007e	74 12		 je	 SHORT $LN1@Uninit_mov@2

; 434  : 		_Dest_val(_Al, _Next);

  00080	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00083	50		 push	 eax
  00084	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@UQUESTIONANSWER_TIME@@@std@@UQUESTIONANSWER_TIME@@@std@@YAXAAV?$allocator@UQUESTIONANSWER_TIME@@@0@PAUQUESTIONANSWER_TIME@@@Z ; std::_Dest_val<std::allocator<QUESTIONANSWER_TIME>,QUESTIONANSWER_TIME>
  0008d	83 c4 08	 add	 esp, 8
  00090	eb dd		 jmp	 SHORT $LN2@Uninit_mov@2
$LN1@Uninit_mov@2:

; 435  : 	_RERAISE;

  00092	6a 00		 push	 0
  00094	6a 00		 push	 0
  00096	e8 00 00 00 00	 call	 __CxxThrowException@8

; 436  : 	_CATCH_END

  0009b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000a2	b8 00 00 00 00	 mov	 eax, __tryend$??$_Uninit_move@PAUQUESTIONANSWER_TIME@@PAU1@V?$allocator@UQUESTIONANSWER_TIME@@@std@@U1@@std@@YAPAUQUESTIONANSWER_TIME@@PAU1@00AAV?$allocator@UQUESTIONANSWER_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1
  000a7	c3		 ret	 0
$LN10@Uninit_mov@2:
  000a8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_move@PAUQUESTIONANSWER_TIME@@PAU1@V?$allocator@UQUESTIONANSWER_TIME@@@std@@U1@@std@@YAPAUQUESTIONANSWER_TIME@@PAU1@00AAV?$allocator@UQUESTIONANSWER_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1:

; 437  : 	return (_Dest);

  000af	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_mov@2:

; 438  : 	}

  000b2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000b5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000bc	59		 pop	 ecx
  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_move@PAUQUESTIONANSWER_TIME@@PAU1@V?$allocator@UQUESTIONANSWER_TIME@@@std@@U1@@std@@YAPAUQUESTIONANSWER_TIME@@PAU1@00AAV?$allocator@UQUESTIONANSWER_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninit_move@PAUQUESTIONANSWER_TIME@@PAU1@V?$allocator@UQUESTIONANSWER_TIME@@@std@@U1@@std@@YAPAUQUESTIONANSWER_TIME@@PAU1@00AAV?$allocator@UQUESTIONANSWER_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninit_move@PAUQUESTIONANSWER_TIME@@PAU1@V?$allocator@UQUESTIONANSWER_TIME@@@std@@U1@@std@@YAPAUQUESTIONANSWER_TIME@@PAU1@00AAV?$allocator@UQUESTIONANSWER_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<QUESTIONANSWER_TIME *,QUESTIONANSWER_TIME *,std::allocator<QUESTIONANSWER_TIME>,QUESTIONANSWER_TIME>
PUBLIC	?destroy@?$allocator@UQUESTIONANSWER_TIME@@@std@@QAEXPAUQUESTIONANSWER_TIME@@@Z ; std::allocator<QUESTIONANSWER_TIME>::destroy
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Dest_val@V?$allocator@UQUESTIONANSWER_TIME@@@std@@UQUESTIONANSWER_TIME@@@std@@YAXAAV?$allocator@UQUESTIONANSWER_TIME@@@0@PAUQUESTIONANSWER_TIME@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@UQUESTIONANSWER_TIME@@@std@@UQUESTIONANSWER_TIME@@@std@@YAXAAV?$allocator@UQUESTIONANSWER_TIME@@@0@PAUQUESTIONANSWER_TIME@@@Z PROC ; std::_Dest_val<std::allocator<QUESTIONANSWER_TIME>,QUESTIONANSWER_TIME>, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 287  : 	_Alval.destroy(_Pdest);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  00010	e8 00 00 00 00	 call	 ?destroy@?$allocator@UQUESTIONANSWER_TIME@@@std@@QAEXPAUQUESTIONANSWER_TIME@@@Z ; std::allocator<QUESTIONANSWER_TIME>::destroy

; 288  : 	}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Dest_val@V?$allocator@UQUESTIONANSWER_TIME@@@std@@UQUESTIONANSWER_TIME@@@std@@YAXAAV?$allocator@UQUESTIONANSWER_TIME@@@0@PAUQUESTIONANSWER_TIME@@@Z ENDP ; std::_Dest_val<std::allocator<QUESTIONANSWER_TIME>,QUESTIONANSWER_TIME>
_TEXT	ENDS
PUBLIC	??$_Destroy@UQUESTIONANSWER_DATA@@@std@@YAXPAUQUESTIONANSWER_DATA@@@Z ; std::_Destroy<QUESTIONANSWER_DATA>
; Function compile flags: /Odtp /ZI
;	COMDAT ?destroy@?$allocator@UQUESTIONANSWER_DATA@@@std@@QAEXPAUQUESTIONANSWER_DATA@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UQUESTIONANSWER_DATA@@@std@@QAEXPAUQUESTIONANSWER_DATA@@@Z PROC ; std::allocator<QUESTIONANSWER_DATA>::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 213  : 		_Destroy(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Destroy@UQUESTIONANSWER_DATA@@@std@@YAXPAUQUESTIONANSWER_DATA@@@Z ; std::_Destroy<QUESTIONANSWER_DATA>
  00015	83 c4 04	 add	 esp, 4

; 214  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?destroy@?$allocator@UQUESTIONANSWER_DATA@@@std@@QAEXPAUQUESTIONANSWER_DATA@@@Z ENDP ; std::allocator<QUESTIONANSWER_DATA>::destroy
_TEXT	ENDS
PUBLIC	??$_Destroy@UQUESTIONANSWER_TIME@@@std@@YAXPAUQUESTIONANSWER_TIME@@@Z ; std::_Destroy<QUESTIONANSWER_TIME>
; Function compile flags: /Odtp /ZI
;	COMDAT ?destroy@?$allocator@UQUESTIONANSWER_TIME@@@std@@QAEXPAUQUESTIONANSWER_TIME@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UQUESTIONANSWER_TIME@@@std@@QAEXPAUQUESTIONANSWER_TIME@@@Z PROC ; std::allocator<QUESTIONANSWER_TIME>::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 213  : 		_Destroy(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Destroy@UQUESTIONANSWER_TIME@@@std@@YAXPAUQUESTIONANSWER_TIME@@@Z ; std::_Destroy<QUESTIONANSWER_TIME>
  00015	83 c4 04	 add	 esp, 4

; 214  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?destroy@?$allocator@UQUESTIONANSWER_TIME@@@std@@QAEXPAUQUESTIONANSWER_TIME@@@Z ENDP ; std::allocator<QUESTIONANSWER_TIME>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UQUESTIONANSWER_DATA@@@std@@QAEXPAUQUESTIONANSWER_DATA@@$$QAU3@@Z ; std::allocator<QUESTIONANSWER_DATA>::construct
PUBLIC	??$forward@UQUESTIONANSWER_DATA@@@std@@YA$$QAUQUESTIONANSWER_DATA@@AAU1@@Z ; std::forward<QUESTIONANSWER_DATA>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UQUESTIONANSWER_DATA@@@std@@UQUESTIONANSWER_DATA@@U3@@std@@YAXAAV?$allocator@UQUESTIONANSWER_DATA@@@0@PAUQUESTIONANSWER_DATA@@$$QAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UQUESTIONANSWER_DATA@@@std@@UQUESTIONANSWER_DATA@@U3@@std@@YAXAAV?$allocator@UQUESTIONANSWER_DATA@@@0@PAUQUESTIONANSWER_DATA@@$$QAU2@@Z PROC ; std::_Cons_val<std::allocator<QUESTIONANSWER_DATA>,QUESTIONANSWER_DATA,QUESTIONANSWER_DATA>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@UQUESTIONANSWER_DATA@@@std@@YA$$QAUQUESTIONANSWER_DATA@@AAU1@@Z ; std::forward<QUESTIONANSWER_DATA>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@UQUESTIONANSWER_DATA@@@std@@QAEXPAUQUESTIONANSWER_DATA@@$$QAU3@@Z ; std::allocator<QUESTIONANSWER_DATA>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UQUESTIONANSWER_DATA@@@std@@UQUESTIONANSWER_DATA@@U3@@std@@YAXAAV?$allocator@UQUESTIONANSWER_DATA@@@0@PAUQUESTIONANSWER_DATA@@$$QAU2@@Z ENDP ; std::_Cons_val<std::allocator<QUESTIONANSWER_DATA>,QUESTIONANSWER_DATA,QUESTIONANSWER_DATA>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UQUESTIONANSWER_TIME@@@std@@QAEXPAUQUESTIONANSWER_TIME@@$$QAU3@@Z ; std::allocator<QUESTIONANSWER_TIME>::construct
PUBLIC	??$forward@UQUESTIONANSWER_TIME@@@std@@YA$$QAUQUESTIONANSWER_TIME@@AAU1@@Z ; std::forward<QUESTIONANSWER_TIME>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UQUESTIONANSWER_TIME@@@std@@UQUESTIONANSWER_TIME@@U3@@std@@YAXAAV?$allocator@UQUESTIONANSWER_TIME@@@0@PAUQUESTIONANSWER_TIME@@$$QAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UQUESTIONANSWER_TIME@@@std@@UQUESTIONANSWER_TIME@@U3@@std@@YAXAAV?$allocator@UQUESTIONANSWER_TIME@@@0@PAUQUESTIONANSWER_TIME@@$$QAU2@@Z PROC ; std::_Cons_val<std::allocator<QUESTIONANSWER_TIME>,QUESTIONANSWER_TIME,QUESTIONANSWER_TIME>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@UQUESTIONANSWER_TIME@@@std@@YA$$QAUQUESTIONANSWER_TIME@@AAU1@@Z ; std::forward<QUESTIONANSWER_TIME>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@UQUESTIONANSWER_TIME@@@std@@QAEXPAUQUESTIONANSWER_TIME@@$$QAU3@@Z ; std::allocator<QUESTIONANSWER_TIME>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UQUESTIONANSWER_TIME@@@std@@UQUESTIONANSWER_TIME@@U3@@std@@YAXAAV?$allocator@UQUESTIONANSWER_TIME@@@0@PAUQUESTIONANSWER_TIME@@$$QAU2@@Z ENDP ; std::_Cons_val<std::allocator<QUESTIONANSWER_TIME>,QUESTIONANSWER_TIME,QUESTIONANSWER_TIME>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Destroy@UQUESTIONANSWER_DATA@@@std@@YAXPAUQUESTIONANSWER_DATA@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UQUESTIONANSWER_DATA@@@std@@YAXPAUQUESTIONANSWER_DATA@@@Z PROC ; std::_Destroy<QUESTIONANSWER_DATA>, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Destroy@UQUESTIONANSWER_DATA@@@std@@YAXPAUQUESTIONANSWER_DATA@@@Z ENDP ; std::_Destroy<QUESTIONANSWER_DATA>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$_Destroy@UQUESTIONANSWER_TIME@@@std@@YAXPAUQUESTIONANSWER_TIME@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UQUESTIONANSWER_TIME@@@std@@YAXPAUQUESTIONANSWER_TIME@@@Z PROC ; std::_Destroy<QUESTIONANSWER_TIME>, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Destroy@UQUESTIONANSWER_TIME@@@std@@YAXPAUQUESTIONANSWER_TIME@@@Z ENDP ; std::_Destroy<QUESTIONANSWER_TIME>
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@UQUESTIONANSWER_DATA@@@std@@QAEXPAUQUESTIONANSWER_DATA@@$$QAU3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@UQUESTIONANSWER_DATA@@@std@@QAEXPAUQUESTIONANSWER_DATA@@$$QAU3@@Z$0
__ehfuncinfo$?construct@?$allocator@UQUESTIONANSWER_DATA@@@std@@QAEXPAUQUESTIONANSWER_DATA@@$$QAU3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@UQUESTIONANSWER_DATA@@@std@@QAEXPAUQUESTIONANSWER_DATA@@$$QAU3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@UQUESTIONANSWER_DATA@@@std@@QAEXPAUQUESTIONANSWER_DATA@@$$QAU3@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T231394 = -88						; size = 4
$T231395 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UQUESTIONANSWER_DATA@@@std@@QAEXPAUQUESTIONANSWER_DATA@@$$QAU3@@Z PROC ; std::allocator<QUESTIONANSWER_DATA>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?construct@?$allocator@UQUESTIONANSWER_DATA@@@std@@QAEXPAUQUESTIONANSWER_DATA@@$$QAU3@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	68 80 00 00 00	 push	 128			; 00000080H
  00034	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00039	83 c4 08	 add	 esp, 8
  0003c	89 45 ac	 mov	 DWORD PTR $T231395[ebp], eax
  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00046	83 7d ac 00	 cmp	 DWORD PTR $T231395[ebp], 0
  0004a	74 20		 je	 SHORT $LN3@construct@3
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ??$forward@UQUESTIONANSWER_DATA@@@std@@YA$$QAUQUESTIONANSWER_DATA@@AAU1@@Z ; std::forward<QUESTIONANSWER_DATA>
  00055	83 c4 04	 add	 esp, 4
  00058	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0005d	8b f0		 mov	 esi, eax
  0005f	8b 7d ac	 mov	 edi, DWORD PTR $T231395[ebp]
  00062	f3 a5		 rep movsd
  00064	8b 55 ac	 mov	 edx, DWORD PTR $T231395[ebp]
  00067	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  0006a	eb 07		 jmp	 SHORT $LN4@construct@3
$LN3@construct@3:
  0006c	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct@3:
  00073	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00076	89 45 a8	 mov	 DWORD PTR $T231394[ebp], eax
  00079	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 203  : 		}

  00080	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00083	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008a	59		 pop	 ecx
  0008b	5f		 pop	 edi
  0008c	5e		 pop	 esi
  0008d	5b		 pop	 ebx
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@UQUESTIONANSWER_DATA@@@std@@QAEXPAUQUESTIONANSWER_DATA@@$$QAU3@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T231395[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$?construct@?$allocator@UQUESTIONANSWER_DATA@@@std@@QAEXPAUQUESTIONANSWER_DATA@@$$QAU3@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?construct@?$allocator@UQUESTIONANSWER_DATA@@@std@@QAEXPAUQUESTIONANSWER_DATA@@$$QAU3@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@UQUESTIONANSWER_DATA@@@std@@QAEXPAUQUESTIONANSWER_DATA@@$$QAU3@@Z ENDP ; std::allocator<QUESTIONANSWER_DATA>::construct
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@UQUESTIONANSWER_TIME@@@std@@QAEXPAUQUESTIONANSWER_TIME@@$$QAU3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@UQUESTIONANSWER_TIME@@@std@@QAEXPAUQUESTIONANSWER_TIME@@$$QAU3@@Z$0
__ehfuncinfo$?construct@?$allocator@UQUESTIONANSWER_TIME@@@std@@QAEXPAUQUESTIONANSWER_TIME@@$$QAU3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@UQUESTIONANSWER_TIME@@@std@@QAEXPAUQUESTIONANSWER_TIME@@$$QAU3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@UQUESTIONANSWER_TIME@@@std@@QAEXPAUQUESTIONANSWER_TIME@@$$QAU3@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T231407 = -88						; size = 4
$T231408 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UQUESTIONANSWER_TIME@@@std@@QAEXPAUQUESTIONANSWER_TIME@@$$QAU3@@Z PROC ; std::allocator<QUESTIONANSWER_TIME>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?construct@?$allocator@UQUESTIONANSWER_TIME@@@std@@QAEXPAUQUESTIONANSWER_TIME@@$$QAU3@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	6a 08		 push	 8
  00031	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 ac	 mov	 DWORD PTR $T231408[ebp], eax
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	83 7d ac 00	 cmp	 DWORD PTR $T231408[ebp], 0
  00047	74 21		 je	 SHORT $LN3@construct@4
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$forward@UQUESTIONANSWER_TIME@@@std@@YA$$QAUQUESTIONANSWER_TIME@@AAU1@@Z ; std::forward<QUESTIONANSWER_TIME>
  00052	83 c4 04	 add	 esp, 4
  00055	8b 10		 mov	 edx, DWORD PTR [eax]
  00057	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005a	8b 4d ac	 mov	 ecx, DWORD PTR $T231408[ebp]
  0005d	89 11		 mov	 DWORD PTR [ecx], edx
  0005f	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00062	8b 55 ac	 mov	 edx, DWORD PTR $T231408[ebp]
  00065	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  00068	eb 07		 jmp	 SHORT $LN4@construct@4
$LN3@construct@4:
  0006a	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct@4:
  00071	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00074	89 45 a8	 mov	 DWORD PTR $T231407[ebp], eax
  00077	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 203  : 		}

  0007e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00081	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00088	59		 pop	 ecx
  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@UQUESTIONANSWER_TIME@@@std@@QAEXPAUQUESTIONANSWER_TIME@@$$QAU3@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T231408[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$?construct@?$allocator@UQUESTIONANSWER_TIME@@@std@@QAEXPAUQUESTIONANSWER_TIME@@$$QAU3@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?construct@?$allocator@UQUESTIONANSWER_TIME@@@std@@QAEXPAUQUESTIONANSWER_TIME@@$$QAU3@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@UQUESTIONANSWER_TIME@@@std@@QAEXPAUQUESTIONANSWER_TIME@@$$QAU3@@Z ENDP ; std::allocator<QUESTIONANSWER_TIME>::construct
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@UQUESTIONANSWER_DATA@@@std@@YA$$QAUQUESTIONANSWER_DATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UQUESTIONANSWER_DATA@@@std@@YA$$QAUQUESTIONANSWER_DATA@@AAU1@@Z PROC ; std::forward<QUESTIONANSWER_DATA>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@UQUESTIONANSWER_DATA@@@std@@YA$$QAUQUESTIONANSWER_DATA@@AAU1@@Z ENDP ; std::forward<QUESTIONANSWER_DATA>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$forward@UQUESTIONANSWER_TIME@@@std@@YA$$QAUQUESTIONANSWER_TIME@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UQUESTIONANSWER_TIME@@@std@@YA$$QAUQUESTIONANSWER_TIME@@AAU1@@Z PROC ; std::forward<QUESTIONANSWER_TIME>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@UQUESTIONANSWER_TIME@@@std@@YA$$QAUQUESTIONANSWER_TIME@@AAU1@@Z ENDP ; std::forward<QUESTIONANSWER_TIME>
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File d:\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
; Function compile flags: /Odtp /ZI
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ ; std::bad_alloc::~bad_alloc
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 37   : 		{	// orphan all iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 38   : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 48   : 		{	// adopt this iterator by parent

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 49   : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\questionanswer.cpp
;	COMDAT ??__Eg_QuestionAnswer@@YAXXZ
text$yc	SEGMENT
??__Eg_QuestionAnswer@@YAXXZ PROC			; `dynamic initializer for 'g_QuestionAnswer'', COMDAT

; 12   : CQuestionAnswer g_QuestionAnswer;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestionAnswer@@3VCQuestionAnswer@@A ; g_QuestionAnswer
  0000e	e8 00 00 00 00	 call	 ??0CQuestionAnswer@@QAE@XZ ; CQuestionAnswer::CQuestionAnswer
  00013	68 00 00 00 00	 push	 OFFSET ??__Fg_QuestionAnswer@@YAXXZ ; `dynamic atexit destructor for 'g_QuestionAnswer''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??__Eg_QuestionAnswer@@YAXXZ ENDP			; `dynamic initializer for 'g_QuestionAnswer''
; Function compile flags: /Odtp /ZI
text$yc	ENDS
;	COMDAT ??__Fg_QuestionAnswer@@YAXXZ
text$yd	SEGMENT
??__Fg_QuestionAnswer@@YAXXZ PROC			; `dynamic atexit destructor for 'g_QuestionAnswer'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestionAnswer@@3VCQuestionAnswer@@A ; g_QuestionAnswer
  0000e	e8 00 00 00 00	 call	 ??1CQuestionAnswer@@QAE@XZ ; CQuestionAnswer::~CQuestionAnswer
  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__Fg_QuestionAnswer@@YAXXZ ENDP			; `dynamic atexit destructor for 'g_QuestionAnswer''
text$yd	ENDS
PUBLIC	?g_QuestionAnswer@@3VCQuestionAnswer@@A		; g_QuestionAnswer
_BSS	SEGMENT
?g_QuestionAnswer@@3VCQuestionAnswer@@A DB 038H DUP (?)	; g_QuestionAnswer
_BSS	ENDS
CRT$XCU	SEGMENT
_g_QuestionAnswer$initializer$ DD FLAT:??__Eg_QuestionAnswer@@YAXXZ
CRT$XCU	ENDS
END
