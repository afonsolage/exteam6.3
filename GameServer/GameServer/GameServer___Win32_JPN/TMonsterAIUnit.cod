; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	D:\Projects\ExTeam6.3\Source\GameServer\GameServer\TMonsterAIUnit.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?s_bDataLoad@TMonsterAIUnit@@2HA		; TMonsterAIUnit::s_bDataLoad
_BSS	SEGMENT
?s_bDataLoad@TMonsterAIUnit@@2HA DD 01H DUP (?)		; TMonsterAIUnit::s_bDataLoad
_BSS	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Odtp /ZI
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@vector:
  00009	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000c	83 e8 01	 sub	 eax, 1
  0000f	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00012	78 11		 js	 SHORT $LN3@vector
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00017	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  0001d	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00020	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00023	eb e4		 jmp	 SHORT $LN2@vector
$LN3@vector:
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?Reset@TMonsterAIUnit@@QAEXXZ			; TMonsterAIUnit::Reset
PUBLIC	??_7TMonsterAIUnit@@6B@				; TMonsterAIUnit::`vftable'
PUBLIC	??0TMonsterAIUnit@@QAE@XZ			; TMonsterAIUnit::TMonsterAIUnit
PUBLIC	??_R4TMonsterAIUnit@@6B@			; TMonsterAIUnit::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVTMonsterAIUnit@@@8			; TMonsterAIUnit `RTTI Type Descriptor'
PUBLIC	??_R3TMonsterAIUnit@@8				; TMonsterAIUnit::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2TMonsterAIUnit@@8				; TMonsterAIUnit::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@TMonsterAIUnit@@8			; TMonsterAIUnit::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ETMonsterAIUnit@@UAEPAXI@Z:PROC		; TMonsterAIUnit::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@TMonsterAIUnit@@8
; File d:\projects\exteam6.3\source\gameserver\gameserver\tmonsteraiunit.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@TMonsterAIUnit@@8 DD FLAT:??_R0?AVTMonsterAIUnit@@@8 ; TMonsterAIUnit::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3TMonsterAIUnit@@8
rdata$r	ENDS
;	COMDAT ??_R2TMonsterAIUnit@@8
rdata$r	SEGMENT
??_R2TMonsterAIUnit@@8 DD FLAT:??_R1A@?0A@EA@TMonsterAIUnit@@8 ; TMonsterAIUnit::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3TMonsterAIUnit@@8
rdata$r	SEGMENT
??_R3TMonsterAIUnit@@8 DD 00H				; TMonsterAIUnit::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2TMonsterAIUnit@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVTMonsterAIUnit@@@8
_DATA	SEGMENT
??_R0?AVTMonsterAIUnit@@@8 DD FLAT:??_7type_info@@6B@	; TMonsterAIUnit `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVTMonsterAIUnit@@', 00H
_DATA	ENDS
;	COMDAT ??_R4TMonsterAIUnit@@6B@
rdata$r	SEGMENT
??_R4TMonsterAIUnit@@6B@ DD 00H				; TMonsterAIUnit::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVTMonsterAIUnit@@@8
	DD	FLAT:??_R3TMonsterAIUnit@@8
rdata$r	ENDS
;	COMDAT ??_7TMonsterAIUnit@@6B@
CONST	SEGMENT
??_7TMonsterAIUnit@@6B@ DD FLAT:??_R4TMonsterAIUnit@@6B@ ; TMonsterAIUnit::`vftable'
	DD	FLAT:??_ETMonsterAIUnit@@UAEPAXI@Z
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0TMonsterAIUnit@@QAE@XZ PROC				; TMonsterAIUnit::TMonsterAIUnit
; _this$ = ecx

; 22   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7TMonsterAIUnit@@6B@

; 23   : 	this->Reset();

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?Reset@TMonsterAIUnit@@QAEXXZ ; TMonsterAIUnit::Reset

; 24   : }

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??0TMonsterAIUnit@@QAE@XZ ENDP				; TMonsterAIUnit::TMonsterAIUnit
_TEXT	ENDS
PUBLIC	??1TMonsterAIUnit@@UAE@XZ			; TMonsterAIUnit::~TMonsterAIUnit
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp /ZI
;	COMDAT ??_GTMonsterAIUnit@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GTMonsterAIUnit@@UAEPAXI@Z PROC			; TMonsterAIUnit::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1TMonsterAIUnit@@UAE@XZ ; TMonsterAIUnit::~TMonsterAIUnit
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_GTMonsterAIUnit@@UAEPAXI@Z ENDP			; TMonsterAIUnit::`scalar deleting destructor'
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1TMonsterAIUnit@@UAE@XZ PROC				; TMonsterAIUnit::~TMonsterAIUnit
; _this$ = ecx

; 27   : {

  00030	55		 push	 ebp
  00031	8b ec		 mov	 ebp, esp
  00033	83 ec 44	 sub	 esp, 68			; 00000044H
  00036	53		 push	 ebx
  00037	56		 push	 esi
  00038	57		 push	 edi
  00039	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0003c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7TMonsterAIUnit@@6B@

; 28   : 	return;
; 29   : }

  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	5b		 pop	 ebx
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
??1TMonsterAIUnit@@UAE@XZ ENDP				; TMonsterAIUnit::~TMonsterAIUnit
_TEXT	ENDS
EXTRN	_memset:PROC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Reset@TMonsterAIUnit@@QAEXXZ PROC			; TMonsterAIUnit::Reset
; _this$ = ecx

; 33   : {

  00050	55		 push	 ebp
  00051	8b ec		 mov	 ebp, esp
  00053	83 ec 44	 sub	 esp, 68			; 00000044H
  00056	53		 push	 ebx
  00057	56		 push	 esi
  00058	57		 push	 edi
  00059	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 34   : 	this->m_iUnitNumber = -1;

  0005c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	c7 40 38 ff ff
	ff ff		 mov	 DWORD PTR [eax+56], -1

; 35   : 	this->m_iDelayTime = NULL;

  00066	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00069	c7 40 3c 00 00
	00 00		 mov	 DWORD PTR [eax+60], 0

; 36   : 	this->m_lpAutomata = NULL;

  00070	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00073	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [eax+64], 0

; 37   : 	this->m_lpAIClassNormal = NULL;

  0007a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007d	c7 40 44 00 00
	00 00		 mov	 DWORD PTR [eax+68], 0

; 38   : 	this->m_lpAIClassMove = NULL;

  00084	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00087	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [eax+72], 0

; 39   : 	this->m_lpAIClassAttack = NULL;

  0008e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00091	c7 40 4c 00 00
	00 00		 mov	 DWORD PTR [eax+76], 0

; 40   : 	this->m_lpAIClassHeal = NULL;

  00098	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009b	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [eax+80], 0

; 41   : 	this->m_lpAIClassAvoid = NULL;

  000a2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a5	c7 40 54 00 00
	00 00		 mov	 DWORD PTR [eax+84], 0

; 42   : 	this->m_lpAIClassHelp = NULL;

  000ac	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000af	c7 40 58 00 00
	00 00		 mov	 DWORD PTR [eax+88], 0

; 43   : 	this->m_lpAIClassSpecial = NULL;

  000b6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b9	c7 40 5c 00 00
	00 00		 mov	 DWORD PTR [eax+92], 0

; 44   : 	this->m_lpAIClassEvent = NULL;

  000c0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c3	c7 40 60 00 00
	00 00		 mov	 DWORD PTR [eax+96], 0

; 45   : 	memset(this->m_szUnitName, 0, sizeof(this->m_szUnitName));

  000ca	6a 32		 push	 50			; 00000032H
  000cc	6a 00		 push	 0
  000ce	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000d1	83 c0 04	 add	 eax, 4
  000d4	50		 push	 eax
  000d5	e8 00 00 00 00	 call	 _memset
  000da	83 c4 0c	 add	 esp, 12			; 0000000cH

; 46   : 	this->m_lppAIClassMap[0] = &this->m_lpAIClassNormal;

  000dd	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000e0	83 c0 44	 add	 eax, 68			; 00000044H
  000e3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e6	89 41 64	 mov	 DWORD PTR [ecx+100], eax

; 47   : 	this->m_lppAIClassMap[1] = &this->m_lpAIClassMove;

  000e9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ec	83 c0 48	 add	 eax, 72			; 00000048H
  000ef	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f2	89 41 68	 mov	 DWORD PTR [ecx+104], eax

; 48   : 	this->m_lppAIClassMap[2] = &this->m_lpAIClassAttack;

  000f5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000f8	83 c0 4c	 add	 eax, 76			; 0000004cH
  000fb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000fe	89 41 6c	 mov	 DWORD PTR [ecx+108], eax

; 49   : 	this->m_lppAIClassMap[3] = &this->m_lpAIClassHeal;

  00101	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00104	83 c0 50	 add	 eax, 80			; 00000050H
  00107	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0010a	89 41 70	 mov	 DWORD PTR [ecx+112], eax

; 50   : 	this->m_lppAIClassMap[4] = &this->m_lpAIClassAvoid;

  0010d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00110	83 c0 54	 add	 eax, 84			; 00000054H
  00113	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00116	89 41 74	 mov	 DWORD PTR [ecx+116], eax

; 51   : 	this->m_lppAIClassMap[5] = &this->m_lpAIClassHelp;

  00119	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0011c	83 c0 58	 add	 eax, 88			; 00000058H
  0011f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00122	89 41 78	 mov	 DWORD PTR [ecx+120], eax

; 52   : 	this->m_lppAIClassMap[6] = &this->m_lpAIClassSpecial;

  00125	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00128	83 c0 5c	 add	 eax, 92			; 0000005cH
  0012b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0012e	89 41 7c	 mov	 DWORD PTR [ecx+124], eax

; 53   : 	this->m_lppAIClassMap[7] = &this->m_lpAIClassEvent;

  00131	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00134	83 c0 60	 add	 eax, 96			; 00000060H
  00137	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0013a	89 81 80 00 00
	00		 mov	 DWORD PTR [ecx+128], eax

; 54   : }

  00140	5f		 pop	 edi
  00141	5e		 pop	 esi
  00142	5b		 pop	 ebx
  00143	8b e5		 mov	 esp, ebp
  00145	5d		 pop	 ebp
  00146	c3		 ret	 0
?Reset@TMonsterAIUnit@@QAEXXZ ENDP			; TMonsterAIUnit::Reset
_TEXT	ENDS
PUBLIC	??_C@_0DI@PJDNLJBO@?$FLMonster?5AI?5Unit?$FN?5?9?5Loading?5Exce@ ; `string'
PUBLIC	??_C@_0CG@BFGLJJPL@?$FLMonster?5AI?5Unit?$FN?5?9?5?$CFs?5file?5is?5L@ ; `string'
PUBLIC	??_C@_0DI@CHPNDJKD@?$FLMonster?5AI?5Unit?$FN?5?9?5AutomatNumbe@ ; `string'
PUBLIC	??_C@_0DF@MPAINNCG@?$FLMonster?5AI?5Unit?$FN?5?9?5UnitNumber?$CI?$CF@ ; `string'
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	?DelAllAIUnit@TMonsterAIUnit@@SAHXZ		; TMonsterAIUnit::DelAllAIUnit
PUBLIC	??_C@_0CD@KLPHJBLC@?$FLMonster?5AI?5Unit?$FN?5?9?5Can?8t?5Open?5?$CF@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_0DG@DIIBNHKC@?$FLMonster?5AI?5Unit?$FN?5?9?5File?5load?5er@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?LoadData@TMonsterAIUnit@@SAHPAD@Z		; TMonsterAIUnit::LoadData
EXTRN	?LogAddC@@3P6AXEPADZZA:DWORD			; LogAddC
EXTRN	_fclose:PROC
EXTRN	?FindAIElement@TMonsterAIElement@@SAPAV1@H@Z:PROC ; TMonsterAIElement::FindAIElement
EXTRN	?FindAutomata@TMonsterAIAutomata@@SAPAV1@H@Z:PROC ; TMonsterAIAutomata::FindAutomata
EXTRN	_memcpy:PROC
EXTRN	_fopen:PROC
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	_strcmp:PROC
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memset:PROC
EXTRN	__ftol2_sse:PROC
_BSS	SEGMENT
_TokenString DB	064H DUP (?)
_TokenNumber DD	01H DUP (?)
_SMDFile DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0DI@PJDNLJBO@?$FLMonster?5AI?5Unit?$FN?5?9?5Loading?5Exce@
CONST	SEGMENT
??_C@_0DI@PJDNLJBO@?$FLMonster?5AI?5Unit?$FN?5?9?5Loading?5Exce@ DB '[Mon'
	DB	'ster AI Unit] - Loading Exception Error (%s) File. ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@BFGLJJPL@?$FLMonster?5AI?5Unit?$FN?5?9?5?$CFs?5file?5is?5L@
CONST	SEGMENT
??_C@_0CG@BFGLJJPL@?$FLMonster?5AI?5Unit?$FN?5?9?5?$CFs?5file?5is?5L@ DB '['
	DB	'Monster AI Unit] - %s file is Loaded', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@CHPNDJKD@?$FLMonster?5AI?5Unit?$FN?5?9?5AutomatNumbe@
CONST	SEGMENT
??_C@_0DI@CHPNDJKD@?$FLMonster?5AI?5Unit?$FN?5?9?5AutomatNumbe@ DB '[Mons'
	DB	'ter AI Unit] - AutomatNumber(%d) Error (%s) File. ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@MPAINNCG@?$FLMonster?5AI?5Unit?$FN?5?9?5UnitNumber?$CI?$CF@
CONST	SEGMENT
??_C@_0DF@MPAINNCG@?$FLMonster?5AI?5Unit?$FN?5?9?5UnitNumber?$CI?$CF@ DB '['
	DB	'Monster AI Unit] - UnitNumber(%d) Error (%s) File. ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@KLPHJBLC@?$FLMonster?5AI?5Unit?$FN?5?9?5Can?8t?5Open?5?$CF@
CONST	SEGMENT
??_C@_0CD@KLPHJBLC@?$FLMonster?5AI?5Unit?$FN?5?9?5Can?8t?5Open?5?$CF@ DB '['
	DB	'Monster AI Unit] - Can''t Open %s ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@DIIBNHKC@?$FLMonster?5AI?5Unit?$FN?5?9?5File?5load?5er@
CONST	SEGMENT
??_C@_0DG@DIIBNHKC@?$FLMonster?5AI?5Unit?$FN?5?9?5File?5load?5er@ DB '[Mo'
	DB	'nster AI Unit] - File load error : File Name Error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
xdata$x	SEGMENT
__catchsym$?LoadData@TMonsterAIUnit@@SAHPAD@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?LoadData@TMonsterAIUnit@@SAHPAD@Z$0
__unwindtable$?LoadData@TMonsterAIUnit@@SAHPAD@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?LoadData@TMonsterAIUnit@@SAHPAD@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?LoadData@TMonsterAIUnit@@SAHPAD@Z$2
__ehfuncinfo$?LoadData@TMonsterAIUnit@@SAHPAD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?LoadData@TMonsterAIUnit@@SAHPAD@Z
	DD	01H
	DD	FLAT:__tryblocktable$?LoadData@TMonsterAIUnit@@SAHPAD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
_TEXT	SEGMENT
tv242 = -192						; size = 4
tv241 = -192						; size = 4
tv240 = -192						; size = 4
tv239 = -192						; size = 4
tv238 = -192						; size = 4
tv237 = -192						; size = 4
tv236 = -192						; size = 4
tv235 = -192						; size = 4
tv234 = -192						; size = 4
tv233 = -192						; size = 4
tv232 = -192						; size = 4
tv231 = -192						; size = 4
tv230 = -192						; size = 4
tv229 = -192						; size = 4
tv228 = -192						; size = 4
tv227 = -192						; size = 4
tv226 = -192						; size = 4
tv225 = -192						; size = 4
tv224 = -192						; size = 4
tv223 = -192						; size = 4
tv222 = -192						; size = 4
tv221 = -192						; size = 4
_iAIClassEvent$219325 = -124				; size = 4
_iAIClassSpecial$219324 = -120				; size = 4
_iAIClassHelp$219323 = -116				; size = 4
_iAIClassAvoid$219322 = -112				; size = 4
_iAIClassHeal$219321 = -108				; size = 4
_iAIClassAttack$219320 = -104				; size = 4
_iAIClassMove$219319 = -100				; size = 4
_iAIClassNormal$219318 = -96				; size = 4
_iAutomata$219317 = -92					; size = 4
_iDelayTime$219316 = -88				; size = 4
_iUnitNumber$219315 = -84				; size = 4
_szUnitName$219314 = -80				; size = 50
_iType$219304 = -28					; size = 4
_Token$219300 = -24					; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_lpszFileName$ = 8					; size = 4
?LoadData@TMonsterAIUnit@@SAHPAD@Z PROC			; TMonsterAIUnit::LoadData

; 57   : {

  00150	55		 push	 ebp
  00151	8b ec		 mov	 ebp, esp
  00153	6a ff		 push	 -1
  00155	68 00 00 00 00	 push	 __ehhandler$?LoadData@TMonsterAIUnit@@SAHPAD@Z
  0015a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00160	50		 push	 eax
  00161	51		 push	 ecx
  00162	81 ec b0 00 00
	00		 sub	 esp, 176		; 000000b0H
  00168	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0016d	33 c5		 xor	 eax, ebp
  0016f	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00172	53		 push	 ebx
  00173	56		 push	 esi
  00174	57		 push	 edi
  00175	50		 push	 eax
  00176	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00179	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0017f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 58   : 	TMonsterAIUnit::s_bDataLoad = FALSE;

  00182	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?s_bDataLoad@TMonsterAIUnit@@2HA, 0 ; TMonsterAIUnit::s_bDataLoad

; 59   : 
; 60   : 	if ( !lpszFileName || !strcmp(lpszFileName, ""))

  0018c	83 7d 08 00	 cmp	 DWORD PTR _lpszFileName$[ebp], 0
  00190	74 15		 je	 SHORT $LN14@LoadData
  00192	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00197	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  0019a	50		 push	 eax
  0019b	e8 00 00 00 00	 call	 _strcmp
  001a0	83 c4 08	 add	 esp, 8
  001a3	85 c0		 test	 eax, eax
  001a5	75 14		 jne	 SHORT $LN15@LoadData
$LN14@LoadData:

; 61   : 	{
; 62   : 		MsgBox("[Monster AI Unit] - File load error : File Name Error");

  001a7	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@DIIBNHKC@?$FLMonster?5AI?5Unit?$FN?5?9?5File?5load?5er@
  001ac	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  001b1	83 c4 04	 add	 esp, 4

; 63   : 		return FALSE;

  001b4	33 c0		 xor	 eax, eax
  001b6	e9 03 05 00 00	 jmp	 $LN16@LoadData
$LN15@LoadData:

; 64   : 	}
; 65   : 
; 66   : 	try
; 67   : 	{

  001bb	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 68   : 		SMDToken Token;
; 69   : 		SMDFile = fopen(lpszFileName, "r");

  001c2	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  001c7	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  001ca	50		 push	 eax
  001cb	e8 00 00 00 00	 call	 _fopen
  001d0	83 c4 08	 add	 esp, 8
  001d3	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax

; 70   : 
; 71   : 		if ( SMDFile == NULL )

  001d8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SMDFile, 0
  001df	75 18		 jne	 SHORT $LN12@LoadData

; 72   : 		{
; 73   : 			MsgBox("[Monster AI Unit] - Can't Open %s ", lpszFileName);

  001e1	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  001e4	50		 push	 eax
  001e5	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@KLPHJBLC@?$FLMonster?5AI?5Unit?$FN?5?9?5Can?8t?5Open?5?$CF@
  001ea	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  001ef	83 c4 08	 add	 esp, 8

; 74   : 			return FALSE;

  001f2	33 c0		 xor	 eax, eax
  001f4	e9 c5 04 00 00	 jmp	 $LN16@LoadData
$LN12@LoadData:

; 75   : 		}
; 76   : 
; 77   : 		TMonsterAIUnit::DelAllAIUnit();

  001f9	e8 00 00 00 00	 call	 ?DelAllAIUnit@TMonsterAIUnit@@SAHXZ ; TMonsterAIUnit::DelAllAIUnit

; 78   : 		int iType = -1;

  001fe	c7 45 e4 ff ff
	ff ff		 mov	 DWORD PTR _iType$219304[ebp], -1
$LN11@LoadData:

; 79   : 
; 80   : 		while ( true )

  00205	b8 01 00 00 00	 mov	 eax, 1
  0020a	85 c0		 test	 eax, eax
  0020c	0f 84 57 04 00
	00		 je	 $LN10@LoadData

; 81   : 		{
; 82   : 			Token = GetToken();

  00212	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00217	89 85 40 ff ff
	ff		 mov	 DWORD PTR tv221[ebp], eax
  0021d	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR tv221[ebp]
  00223	89 45 e8	 mov	 DWORD PTR _Token$219300[ebp], eax

; 83   : 
; 84   : 			if ( Token == END )

  00226	83 7d e8 02	 cmp	 DWORD PTR _Token$219300[ebp], 2
  0022a	75 05		 jne	 SHORT $LN9@LoadData

; 85   : 				break;

  0022c	e9 38 04 00 00	 jmp	 $LN10@LoadData
$LN9@LoadData:

; 86   : 
; 87   : 			iType = (int)TokenNumber;

  00231	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00237	e8 00 00 00 00	 call	 __ftol2_sse
  0023c	89 45 e4	 mov	 DWORD PTR _iType$219304[ebp], eax
$LN8@LoadData:

; 88   : 
; 89   : 			while ( true )

  0023f	b8 01 00 00 00	 mov	 eax, 1
  00244	85 c0		 test	 eax, eax
  00246	0f 84 18 04 00
	00		 je	 $LN7@LoadData

; 90   : 			{
; 91   : 				if ( iType == 0 )

  0024c	83 7d e4 00	 cmp	 DWORD PTR _iType$219304[ebp], 0
  00250	0f 85 09 04 00
	00		 jne	 $LN6@LoadData

; 92   : 				{
; 93   : 					char szUnitName[50]={0};

  00256	c6 45 b0 00	 mov	 BYTE PTR _szUnitName$219314[ebp], 0
  0025a	6a 31		 push	 49			; 00000031H
  0025c	6a 00		 push	 0
  0025e	8d 45 b1	 lea	 eax, DWORD PTR _szUnitName$219314[ebp+1]
  00261	50		 push	 eax
  00262	e8 00 00 00 00	 call	 _memset
  00267	83 c4 0c	 add	 esp, 12			; 0000000cH

; 94   : 					int iUnitNumber = -1;

  0026a	c7 45 ac ff ff
	ff ff		 mov	 DWORD PTR _iUnitNumber$219315[ebp], -1

; 95   : 					int iDelayTime = 0;

  00271	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _iDelayTime$219316[ebp], 0

; 96   : 					int iAutomata = -1;

  00278	c7 45 a4 ff ff
	ff ff		 mov	 DWORD PTR _iAutomata$219317[ebp], -1

; 97   : 					int iAIClassNormal = -1;

  0027f	c7 45 a0 ff ff
	ff ff		 mov	 DWORD PTR _iAIClassNormal$219318[ebp], -1

; 98   : 					int iAIClassMove = -1;

  00286	c7 45 9c ff ff
	ff ff		 mov	 DWORD PTR _iAIClassMove$219319[ebp], -1

; 99   : 					int iAIClassAttack = -1;

  0028d	c7 45 98 ff ff
	ff ff		 mov	 DWORD PTR _iAIClassAttack$219320[ebp], -1

; 100  : 					int iAIClassHeal = -1;

  00294	c7 45 94 ff ff
	ff ff		 mov	 DWORD PTR _iAIClassHeal$219321[ebp], -1

; 101  : 					int iAIClassAvoid = -1;

  0029b	c7 45 90 ff ff
	ff ff		 mov	 DWORD PTR _iAIClassAvoid$219322[ebp], -1

; 102  : 					int iAIClassHelp = -1;

  002a2	c7 45 8c ff ff
	ff ff		 mov	 DWORD PTR _iAIClassHelp$219323[ebp], -1

; 103  : 					int iAIClassSpecial = -1;

  002a9	c7 45 88 ff ff
	ff ff		 mov	 DWORD PTR _iAIClassSpecial$219324[ebp], -1

; 104  : 					int iAIClassEvent = -1;

  002b0	c7 45 84 ff ff
	ff ff		 mov	 DWORD PTR _iAIClassEvent$219325[ebp], -1

; 105  : 
; 106  : 					Token = GetToken();

  002b7	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  002bc	89 85 40 ff ff
	ff		 mov	 DWORD PTR tv222[ebp], eax
  002c2	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR tv222[ebp]
  002c8	89 45 e8	 mov	 DWORD PTR _Token$219300[ebp], eax

; 107  : 
; 108  : 					if ( !strcmp("end", TokenString))

  002cb	68 00 00 00 00	 push	 OFFSET _TokenString
  002d0	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  002d5	e8 00 00 00 00	 call	 _strcmp
  002da	83 c4 08	 add	 esp, 8
  002dd	85 c0		 test	 eax, eax
  002df	75 05		 jne	 SHORT $LN5@LoadData

; 109  : 						break;

  002e1	e9 7e 03 00 00	 jmp	 $LN7@LoadData
$LN5@LoadData:

; 110  : 
; 111  : 					iUnitNumber = (int)TokenNumber;

  002e6	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  002ec	e8 00 00 00 00	 call	 __ftol2_sse
  002f1	89 45 ac	 mov	 DWORD PTR _iUnitNumber$219315[ebp], eax

; 112  : 
; 113  : 					Token = GetToken();

  002f4	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  002f9	89 85 40 ff ff
	ff		 mov	 DWORD PTR tv223[ebp], eax
  002ff	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR tv223[ebp]
  00305	89 45 e8	 mov	 DWORD PTR _Token$219300[ebp], eax

; 114  : 					memcpy(szUnitName, TokenString, 20);

  00308	6a 14		 push	 20			; 00000014H
  0030a	68 00 00 00 00	 push	 OFFSET _TokenString
  0030f	8d 45 b0	 lea	 eax, DWORD PTR _szUnitName$219314[ebp]
  00312	50		 push	 eax
  00313	e8 00 00 00 00	 call	 _memcpy
  00318	83 c4 0c	 add	 esp, 12			; 0000000cH

; 115  : 
; 116  : 					Token = GetToken();

  0031b	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00320	89 85 40 ff ff
	ff		 mov	 DWORD PTR tv224[ebp], eax
  00326	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR tv224[ebp]
  0032c	89 45 e8	 mov	 DWORD PTR _Token$219300[ebp], eax

; 117  : 					iDelayTime = (int)TokenNumber;

  0032f	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00335	e8 00 00 00 00	 call	 __ftol2_sse
  0033a	89 45 a8	 mov	 DWORD PTR _iDelayTime$219316[ebp], eax

; 118  : 
; 119  : 					Token = GetToken();

  0033d	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00342	89 85 40 ff ff
	ff		 mov	 DWORD PTR tv225[ebp], eax
  00348	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR tv225[ebp]
  0034e	89 45 e8	 mov	 DWORD PTR _Token$219300[ebp], eax

; 120  : 					iAutomata = (int)TokenNumber;

  00351	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00357	e8 00 00 00 00	 call	 __ftol2_sse
  0035c	89 45 a4	 mov	 DWORD PTR _iAutomata$219317[ebp], eax

; 121  : 
; 122  : 					Token = GetToken();

  0035f	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00364	89 85 40 ff ff
	ff		 mov	 DWORD PTR tv226[ebp], eax
  0036a	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR tv226[ebp]
  00370	89 45 e8	 mov	 DWORD PTR _Token$219300[ebp], eax

; 123  : 					iAIClassNormal = (int)TokenNumber;

  00373	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00379	e8 00 00 00 00	 call	 __ftol2_sse
  0037e	89 45 a0	 mov	 DWORD PTR _iAIClassNormal$219318[ebp], eax

; 124  : 
; 125  : 					Token = GetToken();

  00381	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00386	89 85 40 ff ff
	ff		 mov	 DWORD PTR tv227[ebp], eax
  0038c	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR tv227[ebp]
  00392	89 45 e8	 mov	 DWORD PTR _Token$219300[ebp], eax

; 126  : 					iAIClassMove = (int)TokenNumber;

  00395	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0039b	e8 00 00 00 00	 call	 __ftol2_sse
  003a0	89 45 9c	 mov	 DWORD PTR _iAIClassMove$219319[ebp], eax

; 127  : 
; 128  : 					Token = GetToken();

  003a3	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  003a8	89 85 40 ff ff
	ff		 mov	 DWORD PTR tv228[ebp], eax
  003ae	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR tv228[ebp]
  003b4	89 45 e8	 mov	 DWORD PTR _Token$219300[ebp], eax

; 129  : 					iAIClassAttack = (int)TokenNumber;

  003b7	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  003bd	e8 00 00 00 00	 call	 __ftol2_sse
  003c2	89 45 98	 mov	 DWORD PTR _iAIClassAttack$219320[ebp], eax

; 130  : 
; 131  : 					Token = GetToken();

  003c5	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  003ca	89 85 40 ff ff
	ff		 mov	 DWORD PTR tv229[ebp], eax
  003d0	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR tv229[ebp]
  003d6	89 45 e8	 mov	 DWORD PTR _Token$219300[ebp], eax

; 132  : 					iAIClassHeal = (int)TokenNumber;

  003d9	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  003df	e8 00 00 00 00	 call	 __ftol2_sse
  003e4	89 45 94	 mov	 DWORD PTR _iAIClassHeal$219321[ebp], eax

; 133  : 
; 134  : 					Token = GetToken();

  003e7	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  003ec	89 85 40 ff ff
	ff		 mov	 DWORD PTR tv230[ebp], eax
  003f2	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR tv230[ebp]
  003f8	89 45 e8	 mov	 DWORD PTR _Token$219300[ebp], eax

; 135  : 					iAIClassAvoid = (int)TokenNumber;

  003fb	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00401	e8 00 00 00 00	 call	 __ftol2_sse
  00406	89 45 90	 mov	 DWORD PTR _iAIClassAvoid$219322[ebp], eax

; 136  : 
; 137  : 					Token = GetToken();

  00409	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0040e	89 85 40 ff ff
	ff		 mov	 DWORD PTR tv231[ebp], eax
  00414	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR tv231[ebp]
  0041a	89 45 e8	 mov	 DWORD PTR _Token$219300[ebp], eax

; 138  : 					iAIClassHelp = (int)TokenNumber;

  0041d	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00423	e8 00 00 00 00	 call	 __ftol2_sse
  00428	89 45 8c	 mov	 DWORD PTR _iAIClassHelp$219323[ebp], eax

; 139  : 
; 140  : 					Token = GetToken();

  0042b	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00430	89 85 40 ff ff
	ff		 mov	 DWORD PTR tv232[ebp], eax
  00436	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR tv232[ebp]
  0043c	89 45 e8	 mov	 DWORD PTR _Token$219300[ebp], eax

; 141  : 					iAIClassSpecial = (int)TokenNumber;

  0043f	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00445	e8 00 00 00 00	 call	 __ftol2_sse
  0044a	89 45 88	 mov	 DWORD PTR _iAIClassSpecial$219324[ebp], eax

; 142  : 
; 143  : 					Token = GetToken();

  0044d	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00452	89 85 40 ff ff
	ff		 mov	 DWORD PTR tv233[ebp], eax
  00458	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR tv233[ebp]
  0045e	89 45 e8	 mov	 DWORD PTR _Token$219300[ebp], eax

; 144  : 					iAIClassEvent = (int)TokenNumber;

  00461	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00467	e8 00 00 00 00	 call	 __ftol2_sse
  0046c	89 45 84	 mov	 DWORD PTR _iAIClassEvent$219325[ebp], eax

; 145  : 
; 146  : 					if ( iUnitNumber < 0 || iUnitNumber >= MAX_MONSTER_AI_UNIT )

  0046f	83 7d ac 00	 cmp	 DWORD PTR _iUnitNumber$219315[ebp], 0
  00473	7c 06		 jl	 SHORT $LN3@LoadData
  00475	83 7d ac 64	 cmp	 DWORD PTR _iUnitNumber$219315[ebp], 100 ; 00000064H
  00479	7c 1a		 jl	 SHORT $LN4@LoadData
$LN3@LoadData:

; 147  : 					{
; 148  : 						MsgBox("[Monster AI Unit] - UnitNumber(%d) Error (%s) File. ", 
; 149  : 							iUnitNumber, lpszFileName);

  0047b	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  0047e	50		 push	 eax
  0047f	8b 4d ac	 mov	 ecx, DWORD PTR _iUnitNumber$219315[ebp]
  00482	51		 push	 ecx
  00483	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@MPAINNCG@?$FLMonster?5AI?5Unit?$FN?5?9?5UnitNumber?$CI?$CF@
  00488	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  0048d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 150  : 						continue;

  00490	e9 aa fd ff ff	 jmp	 $LN8@LoadData
$LN4@LoadData:

; 151  : 					}
; 152  : 
; 153  : 					if ( iAutomata < 0 || iAutomata >= MAX_MONSTER_AI_AUTOMATA )

  00495	83 7d a4 00	 cmp	 DWORD PTR _iAutomata$219317[ebp], 0
  00499	7c 09		 jl	 SHORT $LN1@LoadData
  0049b	81 7d a4 2c 01
	00 00		 cmp	 DWORD PTR _iAutomata$219317[ebp], 300 ; 0000012cH
  004a2	7c 1a		 jl	 SHORT $LN2@LoadData
$LN1@LoadData:

; 154  : 					{
; 155  : 						MsgBox("[Monster AI Unit] - AutomatNumber(%d) Error (%s) File. ", 
; 156  : 							iAutomata, lpszFileName);

  004a4	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  004a7	50		 push	 eax
  004a8	8b 4d a4	 mov	 ecx, DWORD PTR _iAutomata$219317[ebp]
  004ab	51		 push	 ecx
  004ac	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@CHPNDJKD@?$FLMonster?5AI?5Unit?$FN?5?9?5AutomatNumbe@
  004b1	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  004b6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 157  : 						continue;

  004b9	e9 81 fd ff ff	 jmp	 $LN8@LoadData
$LN2@LoadData:

; 158  : 					}
; 159  : 
; 160  : 					TMonsterAIUnit::s_MonsterAIUnitArray[iUnitNumber].m_iUnitNumber = iUnitNumber;

  004be	8b 45 ac	 mov	 eax, DWORD PTR _iUnitNumber$219315[ebp]
  004c1	69 c0 84 00 00
	00		 imul	 eax, 132		; 00000084H
  004c7	8b 4d ac	 mov	 ecx, DWORD PTR _iUnitNumber$219315[ebp]
  004ca	89 88 38 00 00
	00		 mov	 DWORD PTR ?s_MonsterAIUnitArray@TMonsterAIUnit@@2PAV1@A[eax+56], ecx

; 161  : 					TMonsterAIUnit::s_MonsterAIUnitArray[iUnitNumber].m_iDelayTime = iDelayTime;

  004d0	8b 45 ac	 mov	 eax, DWORD PTR _iUnitNumber$219315[ebp]
  004d3	69 c0 84 00 00
	00		 imul	 eax, 132		; 00000084H
  004d9	8b 4d a8	 mov	 ecx, DWORD PTR _iDelayTime$219316[ebp]
  004dc	89 88 3c 00 00
	00		 mov	 DWORD PTR ?s_MonsterAIUnitArray@TMonsterAIUnit@@2PAV1@A[eax+60], ecx

; 162  : 					TMonsterAIUnit::s_MonsterAIUnitArray[iUnitNumber].m_lpAutomata = TMonsterAIAutomata::FindAutomata(iAutomata);

  004e2	8b 45 a4	 mov	 eax, DWORD PTR _iAutomata$219317[ebp]
  004e5	50		 push	 eax
  004e6	e8 00 00 00 00	 call	 ?FindAutomata@TMonsterAIAutomata@@SAPAV1@H@Z ; TMonsterAIAutomata::FindAutomata
  004eb	83 c4 04	 add	 esp, 4
  004ee	89 85 40 ff ff
	ff		 mov	 DWORD PTR tv234[ebp], eax
  004f4	8b 4d ac	 mov	 ecx, DWORD PTR _iUnitNumber$219315[ebp]
  004f7	69 c9 84 00 00
	00		 imul	 ecx, 132		; 00000084H
  004fd	8b 95 40 ff ff
	ff		 mov	 edx, DWORD PTR tv234[ebp]
  00503	89 91 40 00 00
	00		 mov	 DWORD PTR ?s_MonsterAIUnitArray@TMonsterAIUnit@@2PAV1@A[ecx+64], edx

; 163  : 					TMonsterAIUnit::s_MonsterAIUnitArray[iUnitNumber].m_lpAIClassNormal = TMonsterAIElement::FindAIElement(iAIClassNormal);

  00509	8b 45 a0	 mov	 eax, DWORD PTR _iAIClassNormal$219318[ebp]
  0050c	50		 push	 eax
  0050d	e8 00 00 00 00	 call	 ?FindAIElement@TMonsterAIElement@@SAPAV1@H@Z ; TMonsterAIElement::FindAIElement
  00512	83 c4 04	 add	 esp, 4
  00515	89 85 40 ff ff
	ff		 mov	 DWORD PTR tv235[ebp], eax
  0051b	8b 4d ac	 mov	 ecx, DWORD PTR _iUnitNumber$219315[ebp]
  0051e	69 c9 84 00 00
	00		 imul	 ecx, 132		; 00000084H
  00524	8b 95 40 ff ff
	ff		 mov	 edx, DWORD PTR tv235[ebp]
  0052a	89 91 44 00 00
	00		 mov	 DWORD PTR ?s_MonsterAIUnitArray@TMonsterAIUnit@@2PAV1@A[ecx+68], edx

; 164  : 					TMonsterAIUnit::s_MonsterAIUnitArray[iUnitNumber].m_lpAIClassMove = TMonsterAIElement::FindAIElement(iAIClassMove);

  00530	8b 45 9c	 mov	 eax, DWORD PTR _iAIClassMove$219319[ebp]
  00533	50		 push	 eax
  00534	e8 00 00 00 00	 call	 ?FindAIElement@TMonsterAIElement@@SAPAV1@H@Z ; TMonsterAIElement::FindAIElement
  00539	83 c4 04	 add	 esp, 4
  0053c	89 85 40 ff ff
	ff		 mov	 DWORD PTR tv236[ebp], eax
  00542	8b 4d ac	 mov	 ecx, DWORD PTR _iUnitNumber$219315[ebp]
  00545	69 c9 84 00 00
	00		 imul	 ecx, 132		; 00000084H
  0054b	8b 95 40 ff ff
	ff		 mov	 edx, DWORD PTR tv236[ebp]
  00551	89 91 48 00 00
	00		 mov	 DWORD PTR ?s_MonsterAIUnitArray@TMonsterAIUnit@@2PAV1@A[ecx+72], edx

; 165  : 					TMonsterAIUnit::s_MonsterAIUnitArray[iUnitNumber].m_lpAIClassAttack = TMonsterAIElement::FindAIElement(iAIClassAttack);

  00557	8b 45 98	 mov	 eax, DWORD PTR _iAIClassAttack$219320[ebp]
  0055a	50		 push	 eax
  0055b	e8 00 00 00 00	 call	 ?FindAIElement@TMonsterAIElement@@SAPAV1@H@Z ; TMonsterAIElement::FindAIElement
  00560	83 c4 04	 add	 esp, 4
  00563	89 85 40 ff ff
	ff		 mov	 DWORD PTR tv237[ebp], eax
  00569	8b 4d ac	 mov	 ecx, DWORD PTR _iUnitNumber$219315[ebp]
  0056c	69 c9 84 00 00
	00		 imul	 ecx, 132		; 00000084H
  00572	8b 95 40 ff ff
	ff		 mov	 edx, DWORD PTR tv237[ebp]
  00578	89 91 4c 00 00
	00		 mov	 DWORD PTR ?s_MonsterAIUnitArray@TMonsterAIUnit@@2PAV1@A[ecx+76], edx

; 166  : 					TMonsterAIUnit::s_MonsterAIUnitArray[iUnitNumber].m_lpAIClassHeal = TMonsterAIElement::FindAIElement(iAIClassHeal);

  0057e	8b 45 94	 mov	 eax, DWORD PTR _iAIClassHeal$219321[ebp]
  00581	50		 push	 eax
  00582	e8 00 00 00 00	 call	 ?FindAIElement@TMonsterAIElement@@SAPAV1@H@Z ; TMonsterAIElement::FindAIElement
  00587	83 c4 04	 add	 esp, 4
  0058a	89 85 40 ff ff
	ff		 mov	 DWORD PTR tv238[ebp], eax
  00590	8b 4d ac	 mov	 ecx, DWORD PTR _iUnitNumber$219315[ebp]
  00593	69 c9 84 00 00
	00		 imul	 ecx, 132		; 00000084H
  00599	8b 95 40 ff ff
	ff		 mov	 edx, DWORD PTR tv238[ebp]
  0059f	89 91 50 00 00
	00		 mov	 DWORD PTR ?s_MonsterAIUnitArray@TMonsterAIUnit@@2PAV1@A[ecx+80], edx

; 167  : 					TMonsterAIUnit::s_MonsterAIUnitArray[iUnitNumber].m_lpAIClassAvoid = TMonsterAIElement::FindAIElement(iAIClassAvoid);

  005a5	8b 45 90	 mov	 eax, DWORD PTR _iAIClassAvoid$219322[ebp]
  005a8	50		 push	 eax
  005a9	e8 00 00 00 00	 call	 ?FindAIElement@TMonsterAIElement@@SAPAV1@H@Z ; TMonsterAIElement::FindAIElement
  005ae	83 c4 04	 add	 esp, 4
  005b1	89 85 40 ff ff
	ff		 mov	 DWORD PTR tv239[ebp], eax
  005b7	8b 4d ac	 mov	 ecx, DWORD PTR _iUnitNumber$219315[ebp]
  005ba	69 c9 84 00 00
	00		 imul	 ecx, 132		; 00000084H
  005c0	8b 95 40 ff ff
	ff		 mov	 edx, DWORD PTR tv239[ebp]
  005c6	89 91 54 00 00
	00		 mov	 DWORD PTR ?s_MonsterAIUnitArray@TMonsterAIUnit@@2PAV1@A[ecx+84], edx

; 168  : 					TMonsterAIUnit::s_MonsterAIUnitArray[iUnitNumber].m_lpAIClassHelp = TMonsterAIElement::FindAIElement(iAIClassHelp);

  005cc	8b 45 8c	 mov	 eax, DWORD PTR _iAIClassHelp$219323[ebp]
  005cf	50		 push	 eax
  005d0	e8 00 00 00 00	 call	 ?FindAIElement@TMonsterAIElement@@SAPAV1@H@Z ; TMonsterAIElement::FindAIElement
  005d5	83 c4 04	 add	 esp, 4
  005d8	89 85 40 ff ff
	ff		 mov	 DWORD PTR tv240[ebp], eax
  005de	8b 4d ac	 mov	 ecx, DWORD PTR _iUnitNumber$219315[ebp]
  005e1	69 c9 84 00 00
	00		 imul	 ecx, 132		; 00000084H
  005e7	8b 95 40 ff ff
	ff		 mov	 edx, DWORD PTR tv240[ebp]
  005ed	89 91 58 00 00
	00		 mov	 DWORD PTR ?s_MonsterAIUnitArray@TMonsterAIUnit@@2PAV1@A[ecx+88], edx

; 169  : 					TMonsterAIUnit::s_MonsterAIUnitArray[iUnitNumber].m_lpAIClassSpecial = TMonsterAIElement::FindAIElement(iAIClassSpecial);

  005f3	8b 45 88	 mov	 eax, DWORD PTR _iAIClassSpecial$219324[ebp]
  005f6	50		 push	 eax
  005f7	e8 00 00 00 00	 call	 ?FindAIElement@TMonsterAIElement@@SAPAV1@H@Z ; TMonsterAIElement::FindAIElement
  005fc	83 c4 04	 add	 esp, 4
  005ff	89 85 40 ff ff
	ff		 mov	 DWORD PTR tv241[ebp], eax
  00605	8b 4d ac	 mov	 ecx, DWORD PTR _iUnitNumber$219315[ebp]
  00608	69 c9 84 00 00
	00		 imul	 ecx, 132		; 00000084H
  0060e	8b 95 40 ff ff
	ff		 mov	 edx, DWORD PTR tv241[ebp]
  00614	89 91 5c 00 00
	00		 mov	 DWORD PTR ?s_MonsterAIUnitArray@TMonsterAIUnit@@2PAV1@A[ecx+92], edx

; 170  : 					TMonsterAIUnit::s_MonsterAIUnitArray[iUnitNumber].m_lpAIClassEvent = TMonsterAIElement::FindAIElement(iAIClassEvent);

  0061a	8b 45 84	 mov	 eax, DWORD PTR _iAIClassEvent$219325[ebp]
  0061d	50		 push	 eax
  0061e	e8 00 00 00 00	 call	 ?FindAIElement@TMonsterAIElement@@SAPAV1@H@Z ; TMonsterAIElement::FindAIElement
  00623	83 c4 04	 add	 esp, 4
  00626	89 85 40 ff ff
	ff		 mov	 DWORD PTR tv242[ebp], eax
  0062c	8b 4d ac	 mov	 ecx, DWORD PTR _iUnitNumber$219315[ebp]
  0062f	69 c9 84 00 00
	00		 imul	 ecx, 132		; 00000084H
  00635	8b 95 40 ff ff
	ff		 mov	 edx, DWORD PTR tv242[ebp]
  0063b	89 91 60 00 00
	00		 mov	 DWORD PTR ?s_MonsterAIUnitArray@TMonsterAIUnit@@2PAV1@A[ecx+96], edx

; 171  : 					memcpy(TMonsterAIUnit::s_MonsterAIUnitArray[iUnitNumber].m_szUnitName,
; 172  : 						szUnitName, sizeof(TMonsterAIUnit::s_MonsterAIUnitArray[iUnitNumber].m_szUnitName));

  00641	6a 32		 push	 50			; 00000032H
  00643	8d 45 b0	 lea	 eax, DWORD PTR _szUnitName$219314[ebp]
  00646	50		 push	 eax
  00647	8b 4d ac	 mov	 ecx, DWORD PTR _iUnitNumber$219315[ebp]
  0064a	69 c9 84 00 00
	00		 imul	 ecx, 132		; 00000084H
  00650	81 c1 04 00 00
	00		 add	 ecx, OFFSET ?s_MonsterAIUnitArray@TMonsterAIUnit@@2PAV1@A+4
  00656	51		 push	 ecx
  00657	e8 00 00 00 00	 call	 _memcpy
  0065c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@LoadData:

; 173  : 				}
; 174  : 			}

  0065f	e9 db fb ff ff	 jmp	 $LN8@LoadData
$LN7@LoadData:

; 175  : 		}

  00664	e9 9c fb ff ff	 jmp	 $LN11@LoadData
$LN10@LoadData:

; 176  : 
; 177  : 		fclose(SMDFile);

  00669	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0066e	50		 push	 eax
  0066f	e8 00 00 00 00	 call	 _fclose
  00674	83 c4 04	 add	 esp, 4

; 178  : 
; 179  : 		LogAddC(2, "[Monster AI Unit] - %s file is Loaded", lpszFileName);

  00677	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  0067a	50		 push	 eax
  0067b	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@BFGLJJPL@?$FLMonster?5AI?5Unit?$FN?5?9?5?$CFs?5file?5is?5L@
  00680	6a 02		 push	 2
  00682	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00688	83 c4 0c	 add	 esp, 12			; 0000000cH

; 180  : 
; 181  : 		TMonsterAIUnit::s_bDataLoad = TRUE;

  0068b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?s_bDataLoad@TMonsterAIUnit@@2HA, 1 ; TMonsterAIUnit::s_bDataLoad

; 182  : 	}

  00695	eb 1e		 jmp	 SHORT $LN18@LoadData
__catch$?LoadData@TMonsterAIUnit@@SAHPAD@Z$0:

; 183  : 	catch(...)
; 184  : 	{
; 185  : 		MsgBox("[Monster AI Unit] - Loading Exception Error (%s) File. ", lpszFileName);

  00697	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  0069a	50		 push	 eax
  0069b	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@PJDNLJBO@?$FLMonster?5AI?5Unit?$FN?5?9?5Loading?5Exce@
  006a0	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  006a5	83 c4 08	 add	 esp, 8

; 186  : 	}

  006a8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  006af	b8 00 00 00 00	 mov	 eax, $LN21@LoadData
  006b4	c3		 ret	 0
$LN18@LoadData:
  006b5	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$LN21@LoadData:

; 187  : 
; 188  : 	return FALSE;

  006bc	33 c0		 xor	 eax, eax
$LN16@LoadData:

; 189  : }

  006be	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  006c1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  006c8	59		 pop	 ecx
  006c9	5f		 pop	 edi
  006ca	5e		 pop	 esi
  006cb	5b		 pop	 ebx
  006cc	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006cf	33 cd		 xor	 ecx, ebp
  006d1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006d6	8b e5		 mov	 esp, ebp
  006d8	5d		 pop	 ebp
  006d9	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
__ehhandler$?LoadData@TMonsterAIUnit@@SAHPAD@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a 3c ff ff
	ff		 mov	 ecx, DWORD PTR [edx-196]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00017	33 c8		 xor	 ecx, eax
  00019	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?LoadData@TMonsterAIUnit@@SAHPAD@Z
  00023	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?LoadData@TMonsterAIUnit@@SAHPAD@Z ENDP			; TMonsterAIUnit::LoadData
PUBLIC	__$ArrayPad$
EXTRN	_isalnum:PROC
EXTRN	_isalpha:PROC
EXTRN	_atof:PROC
EXTRN	_isdigit:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_isspace:PROC
EXTRN	_fgetc:PROC
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_CurrentToken DD 01H DUP (?)
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\include\readscript.h
_BSS	ENDS
_TEXT	SEGMENT
tv90 = -180						; size = 4
_TempString$ = -112					; size = 100
_p$ = -12						; size = 4
_ch$ = -5						; size = 1
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken

; 24   : {

  006e0	55		 push	 ebp
  006e1	8b ec		 mov	 ebp, esp
  006e3	81 ec b4 00 00
	00		 sub	 esp, 180		; 000000b4H
  006e9	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  006ee	33 c5		 xor	 eax, ebp
  006f0	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  006f3	53		 push	 ebx
  006f4	56		 push	 esi
  006f5	57		 push	 edi

; 25   : 	char ch;
; 26   : 	char* p;
; 27   : 	char TempString[100];
; 28   : 
; 29   : 	TokenString[0]=0;

  006f6	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _TokenString, 0
$LN31@GetToken:

; 30   : 
; 31   : 	do
; 32   : 	{
; 33   : 		if ((ch=fgetc(SMDFile)) == -1)

  006fd	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00702	50		 push	 eax
  00703	e8 00 00 00 00	 call	 _fgetc
  00708	83 c4 04	 add	 esp, 4
  0070b	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0070e	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00712	83 f9 ff	 cmp	 ecx, -1
  00715	75 0c		 jne	 SHORT $LN28@GetToken

; 34   : 		{
; 35   : 			return END;	// End of FILE (EOF)

  00717	b8 02 00 00 00	 mov	 eax, 2
  0071c	e9 f7 02 00 00	 jmp	 $LN32@GetToken

; 36   : 		}
; 37   : 		else

  00721	eb 5b		 jmp	 SHORT $LN22@GetToken
$LN28@GetToken:

; 38   : 		{	
; 39   : 			if (ch=='/')		// this is /

  00723	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00727	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  0072a	75 52		 jne	 SHORT $LN22@GetToken

; 40   : 			{
; 41   : 				if((ch=fgetc(SMDFile)) == '/')

  0072c	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00731	50		 push	 eax
  00732	e8 00 00 00 00	 call	 _fgetc
  00737	83 c4 04	 add	 esp, 4
  0073a	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0073d	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00741	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  00744	75 38		 jne	 SHORT $LN22@GetToken
$LN24@GetToken:

; 42   : 				{
; 43   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  00746	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  0074a	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0074d	74 1c		 je	 SHORT $LN23@GetToken
  0074f	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00753	83 f8 ff	 cmp	 eax, -1
  00756	74 13		 je	 SHORT $LN23@GetToken

; 44   : 					{
; 45   : 						ch=fgetc(SMDFile);

  00758	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0075d	50		 push	 eax
  0075e	e8 00 00 00 00	 call	 _fgetc
  00763	83 c4 04	 add	 esp, 4
  00766	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al

; 46   : 					}

  00769	eb db		 jmp	 SHORT $LN24@GetToken
$LN23@GetToken:

; 47   : 	
; 48   : 					if (ch == -1)

  0076b	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  0076f	83 f8 ff	 cmp	 eax, -1
  00772	75 0a		 jne	 SHORT $LN22@GetToken

; 49   : 					{
; 50   : 						return END;	// End of FILE

  00774	b8 02 00 00 00	 mov	 eax, 2
  00779	e9 9a 02 00 00	 jmp	 $LN32@GetToken
$LN22@GetToken:

; 51   : 					}
; 52   : 				}
; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : 	while (isspace(ch) != 0);

  0077e	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00782	50		 push	 eax
  00783	e8 00 00 00 00	 call	 _isspace
  00788	83 c4 04	 add	 esp, 4
  0078b	85 c0		 test	 eax, eax
  0078d	0f 85 6a ff ff
	ff		 jne	 $LN31@GetToken

; 57   : 
; 58   : 	
; 59   : 	switch(ch)

  00793	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00797	89 85 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], eax
  0079d	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR tv90[ebp]
  007a3	83 e9 22	 sub	 ecx, 34			; 00000022H
  007a6	89 8d 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], ecx
  007ac	83 bd 4c ff ff
	ff 5b		 cmp	 DWORD PTR tv90[ebp], 91	; 0000005bH
  007b3	0f 87 a3 01 00
	00		 ja	 $LN6@GetToken
  007b9	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR tv90[ebp]
  007bf	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN34@GetToken[edx]
  007c6	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN35@GetToken[eax*4]
$LN19@GetToken:

; 60   : 	{
; 61   : 
; 62   : 	case 0x23:	// #
; 63   : 		return CurrentToken=COMMAND;

  007cd	c7 05 00 00 00
	00 23 00 00 00	 mov	 DWORD PTR _CurrentToken, 35 ; 00000023H
  007d7	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  007dc	e9 37 02 00 00	 jmp	 $LN32@GetToken

; 64   : 		break;

  007e1	e9 30 02 00 00	 jmp	 $LN20@GetToken
$LN18@GetToken:

; 65   : 	
; 66   : 	case 0x3B:	// ;
; 67   : 		return CurrentToken=SEMICOLON;

  007e6	c7 05 00 00 00
	00 3b 00 00 00	 mov	 DWORD PTR _CurrentToken, 59 ; 0000003bH
  007f0	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  007f5	e9 1e 02 00 00	 jmp	 $LN32@GetToken

; 68   : 		break;

  007fa	e9 17 02 00 00	 jmp	 $LN20@GetToken
$LN17@GetToken:

; 69   : 	
; 70   : 	case 0x2C:	// ,
; 71   : 
; 72   : 		return CurrentToken=COMMA;

  007ff	c7 05 00 00 00
	00 2c 00 00 00	 mov	 DWORD PTR _CurrentToken, 44 ; 0000002cH
  00809	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  0080e	e9 05 02 00 00	 jmp	 $LN32@GetToken

; 73   : 		break;

  00813	e9 fe 01 00 00	 jmp	 $LN20@GetToken
$LN16@GetToken:

; 74   : 	
; 75   : 	case 0x7B:	// {
; 76   : 		return CurrentToken = LP;

  00818	c7 05 00 00 00
	00 7b 00 00 00	 mov	 DWORD PTR _CurrentToken, 123 ; 0000007bH
  00822	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00827	e9 ec 01 00 00	 jmp	 $LN32@GetToken

; 77   : 		break;

  0082c	e9 e5 01 00 00	 jmp	 $LN20@GetToken
$LN15@GetToken:

; 78   : 
; 79   : 	case 0x7D:	// }
; 80   : 		return CurrentToken = RP;

  00831	c7 05 00 00 00
	00 7d 00 00 00	 mov	 DWORD PTR _CurrentToken, 125 ; 0000007dH
  0083b	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00840	e9 d3 01 00 00	 jmp	 $LN32@GetToken

; 81   : 		break;

  00845	e9 cc 01 00 00	 jmp	 $LN20@GetToken
$LN14@GetToken:

; 82   : 	// Nice Index Table :)	by Deathway
; 83   : 	// Numbers Case
; 84   : 	case 0x2D:	//-
; 85   : 	case 0x2E:	//.
; 86   : 	case '0':	//0
; 87   : 	case '1':	//1
; 88   : 	case '2':	//2
; 89   : 	case '3':	//3
; 90   : 	case '4':	//4		
; 91   : 	case '5':	//5
; 92   : 	case '6':	//6
; 93   : 	case '7':	//7
; 94   : 	case '8':	//8
; 95   : 	case '9':	//9
; 96   : 		ungetc(ch, SMDFile);

  0084a	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0084f	50		 push	 eax
  00850	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00854	51		 push	 ecx
  00855	e8 00 00 00 00	 call	 _ungetc
  0085a	83 c4 08	 add	 esp, 8

; 97   : 		p = TempString;

  0085d	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  00860	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN13@GetToken:

; 98   : 		
; 99   : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  00863	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00868	50		 push	 eax
  00869	e8 00 00 00 00	 call	 _getc
  0086e	83 c4 04	 add	 esp, 4
  00871	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00874	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00878	83 f9 ff	 cmp	 ecx, -1
  0087b	74 36		 je	 SHORT $LN12@GetToken
  0087d	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00881	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  00884	74 1a		 je	 SHORT $LN11@GetToken
  00886	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  0088a	50		 push	 eax
  0088b	e8 00 00 00 00	 call	 _isdigit
  00890	83 c4 04	 add	 esp, 4
  00893	85 c0		 test	 eax, eax
  00895	75 09		 jne	 SHORT $LN11@GetToken
  00897	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  0089b	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  0089e	75 13		 jne	 SHORT $LN12@GetToken
$LN11@GetToken:

; 100  : 		{
; 101  : 			*p = ch;	// Construct a String

  008a0	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  008a3	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  008a6	88 08		 mov	 BYTE PTR [eax], cl

; 102  : 			p++;

  008a8	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  008ab	83 c0 01	 add	 eax, 1
  008ae	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 103  : 		}		

  008b1	eb b0		 jmp	 SHORT $LN13@GetToken
$LN12@GetToken:

; 104  : 		*p = 0;

  008b3	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  008b6	c6 00 00	 mov	 BYTE PTR [eax], 0

; 105  : 		TokenNumber = atof( TempString);	// Select the first Byte as Main ID

  008b9	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  008bc	50		 push	 eax
  008bd	e8 00 00 00 00	 call	 _atof
  008c2	83 c4 04	 add	 esp, 4
  008c5	d9 1d 00 00 00
	00		 fstp	 DWORD PTR _TokenNumber

; 106  : 		return CurrentToken  = NUMBER ;

  008cb	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CurrentToken, 1
  008d5	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  008da	e9 39 01 00 00	 jmp	 $LN32@GetToken

; 107  : 		break;

  008df	e9 32 01 00 00	 jmp	 $LN20@GetToken
$LN10@GetToken:

; 108  : 
; 109  : 	case '\"':	// "	String Case
; 110  : 		p=&TokenString[0];

  008e4	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString
$LN9@GetToken:

; 111  : 		
; 112  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  008eb	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  008f0	50		 push	 eax
  008f1	e8 00 00 00 00	 call	 _getc
  008f6	83 c4 04	 add	 esp, 4
  008f9	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  008fc	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00900	83 f9 ff	 cmp	 ecx, -1
  00903	74 1c		 je	 SHORT $LN8@GetToken
  00905	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00909	83 f8 22	 cmp	 eax, 34			; 00000022H
  0090c	74 13		 je	 SHORT $LN8@GetToken

; 113  : 		{
; 114  : 			*p = ch;

  0090e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00911	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00914	88 08		 mov	 BYTE PTR [eax], cl

; 115  : 			p++;

  00916	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00919	83 c0 01	 add	 eax, 1
  0091c	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 116  : 		}

  0091f	eb ca		 jmp	 SHORT $LN9@GetToken
$LN8@GetToken:

; 117  : 		if (ch != 0x22 )

  00921	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00925	83 f8 22	 cmp	 eax, 34			; 00000022H
  00928	74 13		 je	 SHORT $LN7@GetToken

; 118  : 		{
; 119  : 			ungetc(ch, SMDFile);

  0092a	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0092f	50		 push	 eax
  00930	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00934	51		 push	 ecx
  00935	e8 00 00 00 00	 call	 _ungetc
  0093a	83 c4 08	 add	 esp, 8
$LN7@GetToken:

; 120  : 		}
; 121  : 		*p = 0;

  0093d	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00940	c6 00 00	 mov	 BYTE PTR [eax], 0

; 122  : 		return CurrentToken = NAME;

  00943	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0
  0094d	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00952	e9 c1 00 00 00	 jmp	 $LN32@GetToken

; 123  : 		break;

  00957	e9 ba 00 00 00	 jmp	 $LN20@GetToken
$LN6@GetToken:

; 124  : 
; 125  : 	default:	// Others
; 126  : 		if (isalpha(ch))

  0095c	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00960	50		 push	 eax
  00961	e8 00 00 00 00	 call	 _isalpha
  00966	83 c4 04	 add	 esp, 4
  00969	85 c0		 test	 eax, eax
  0096b	0f 84 94 00 00
	00		 je	 $LN5@GetToken

; 127  : 		{
; 128  : 			p=&TokenString[0];

  00971	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString

; 129  : 			*p=ch;

  00978	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0097b	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  0097e	88 08		 mov	 BYTE PTR [eax], cl

; 130  : 			p++;

  00980	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00983	83 c0 01	 add	 eax, 1
  00986	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN4@GetToken:

; 131  : 
; 132  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  00989	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0098e	50		 push	 eax
  0098f	e8 00 00 00 00	 call	 _getc
  00994	83 c4 04	 add	 esp, 4
  00997	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0099a	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  0099e	83 f9 ff	 cmp	 ecx, -1
  009a1	74 36		 je	 SHORT $LN3@GetToken
  009a3	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  009a7	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  009aa	74 1a		 je	 SHORT $LN2@GetToken
  009ac	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  009b0	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  009b3	74 11		 je	 SHORT $LN2@GetToken
  009b5	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  009b9	50		 push	 eax
  009ba	e8 00 00 00 00	 call	 _isalnum
  009bf	83 c4 04	 add	 esp, 4
  009c2	85 c0		 test	 eax, eax
  009c4	74 13		 je	 SHORT $LN3@GetToken
$LN2@GetToken:

; 133  : 			{
; 134  : 				*p=ch;

  009c6	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  009c9	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  009cc	88 08		 mov	 BYTE PTR [eax], cl

; 135  : 				p++;

  009ce	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  009d1	83 c0 01	 add	 eax, 1
  009d4	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 136  : 				
; 137  : 			}

  009d7	eb b0		 jmp	 SHORT $LN4@GetToken
$LN3@GetToken:

; 138  : 
; 139  : 			ungetc(ch, SMDFile);

  009d9	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  009de	50		 push	 eax
  009df	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  009e3	51		 push	 ecx
  009e4	e8 00 00 00 00	 call	 _ungetc
  009e9	83 c4 08	 add	 esp, 8

; 140  : 			*p=0;

  009ec	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  009ef	c6 00 00	 mov	 BYTE PTR [eax], 0

; 141  : 			CurrentToken=NAME;

  009f2	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0

; 142  : 			return CurrentToken;

  009fc	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00a01	eb 15		 jmp	 SHORT $LN32@GetToken

; 143  : 		}
; 144  : 		else

  00a03	eb 11		 jmp	 SHORT $LN1@GetToken
$LN5@GetToken:

; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'

  00a05	c7 05 00 00 00
	00 3c 00 00 00	 mov	 DWORD PTR _CurrentToken, 60 ; 0000003cH
  00a0f	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00a14	eb 02		 jmp	 SHORT $LN32@GetToken
$LN1@GetToken:
$LN20@GetToken:

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;

  00a16	33 c0		 xor	 eax, eax
$LN32@GetToken:

; 153  : }

  00a18	5f		 pop	 edi
  00a19	5e		 pop	 esi
  00a1a	5b		 pop	 ebx
  00a1b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00a1e	33 cd		 xor	 ecx, ebp
  00a20	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00a25	8b e5		 mov	 esp, ebp
  00a27	5d		 pop	 ebp
  00a28	c3		 ret	 0
  00a29	8d 49 00	 npad	 3
$LN35@GetToken:
  00a2c	00 00 00 00	 DD	 $LN10@GetToken
  00a30	00 00 00 00	 DD	 $LN19@GetToken
  00a34	00 00 00 00	 DD	 $LN17@GetToken
  00a38	00 00 00 00	 DD	 $LN14@GetToken
  00a3c	00 00 00 00	 DD	 $LN18@GetToken
  00a40	00 00 00 00	 DD	 $LN16@GetToken
  00a44	00 00 00 00	 DD	 $LN15@GetToken
  00a48	00 00 00 00	 DD	 $LN6@GetToken
$LN34@GetToken:
  00a4c	00		 DB	 0
  00a4d	01		 DB	 1
  00a4e	07		 DB	 7
  00a4f	07		 DB	 7
  00a50	07		 DB	 7
  00a51	07		 DB	 7
  00a52	07		 DB	 7
  00a53	07		 DB	 7
  00a54	07		 DB	 7
  00a55	07		 DB	 7
  00a56	02		 DB	 2
  00a57	03		 DB	 3
  00a58	03		 DB	 3
  00a59	07		 DB	 7
  00a5a	03		 DB	 3
  00a5b	03		 DB	 3
  00a5c	03		 DB	 3
  00a5d	03		 DB	 3
  00a5e	03		 DB	 3
  00a5f	03		 DB	 3
  00a60	03		 DB	 3
  00a61	03		 DB	 3
  00a62	03		 DB	 3
  00a63	03		 DB	 3
  00a64	07		 DB	 7
  00a65	04		 DB	 4
  00a66	07		 DB	 7
  00a67	07		 DB	 7
  00a68	07		 DB	 7
  00a69	07		 DB	 7
  00a6a	07		 DB	 7
  00a6b	07		 DB	 7
  00a6c	07		 DB	 7
  00a6d	07		 DB	 7
  00a6e	07		 DB	 7
  00a6f	07		 DB	 7
  00a70	07		 DB	 7
  00a71	07		 DB	 7
  00a72	07		 DB	 7
  00a73	07		 DB	 7
  00a74	07		 DB	 7
  00a75	07		 DB	 7
  00a76	07		 DB	 7
  00a77	07		 DB	 7
  00a78	07		 DB	 7
  00a79	07		 DB	 7
  00a7a	07		 DB	 7
  00a7b	07		 DB	 7
  00a7c	07		 DB	 7
  00a7d	07		 DB	 7
  00a7e	07		 DB	 7
  00a7f	07		 DB	 7
  00a80	07		 DB	 7
  00a81	07		 DB	 7
  00a82	07		 DB	 7
  00a83	07		 DB	 7
  00a84	07		 DB	 7
  00a85	07		 DB	 7
  00a86	07		 DB	 7
  00a87	07		 DB	 7
  00a88	07		 DB	 7
  00a89	07		 DB	 7
  00a8a	07		 DB	 7
  00a8b	07		 DB	 7
  00a8c	07		 DB	 7
  00a8d	07		 DB	 7
  00a8e	07		 DB	 7
  00a8f	07		 DB	 7
  00a90	07		 DB	 7
  00a91	07		 DB	 7
  00a92	07		 DB	 7
  00a93	07		 DB	 7
  00a94	07		 DB	 7
  00a95	07		 DB	 7
  00a96	07		 DB	 7
  00a97	07		 DB	 7
  00a98	07		 DB	 7
  00a99	07		 DB	 7
  00a9a	07		 DB	 7
  00a9b	07		 DB	 7
  00a9c	07		 DB	 7
  00a9d	07		 DB	 7
  00a9e	07		 DB	 7
  00a9f	07		 DB	 7
  00aa0	07		 DB	 7
  00aa1	07		 DB	 7
  00aa2	07		 DB	 7
  00aa3	07		 DB	 7
  00aa4	07		 DB	 7
  00aa5	05		 DB	 5
  00aa6	07		 DB	 7
  00aa7	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\tmonsteraiunit.cpp
_i$219349 = -4						; size = 4
?DelAllAIUnit@TMonsterAIUnit@@SAHXZ PROC		; TMonsterAIUnit::DelAllAIUnit

; 193  : {

  00ab0	55		 push	 ebp
  00ab1	8b ec		 mov	 ebp, esp
  00ab3	83 ec 44	 sub	 esp, 68			; 00000044H
  00ab6	53		 push	 ebx
  00ab7	56		 push	 esi
  00ab8	57		 push	 edi

; 194  : 	for (int i=0;i<MAX_MONSTER_AI_UNIT;i++)

  00ab9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$219349[ebp], 0
  00ac0	eb 09		 jmp	 SHORT $LN3@DelAllAIUn
$LN2@DelAllAIUn:
  00ac2	8b 45 fc	 mov	 eax, DWORD PTR _i$219349[ebp]
  00ac5	83 c0 01	 add	 eax, 1
  00ac8	89 45 fc	 mov	 DWORD PTR _i$219349[ebp], eax
$LN3@DelAllAIUn:
  00acb	83 7d fc 64	 cmp	 DWORD PTR _i$219349[ebp], 100 ; 00000064H
  00acf	7d 16		 jge	 SHORT $LN1@DelAllAIUn

; 195  : 	{
; 196  : 		TMonsterAIUnit::s_MonsterAIUnitArray[i].Reset();

  00ad1	8b 4d fc	 mov	 ecx, DWORD PTR _i$219349[ebp]
  00ad4	69 c9 84 00 00
	00		 imul	 ecx, 132		; 00000084H
  00ada	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?s_MonsterAIUnitArray@TMonsterAIUnit@@2PAV1@A ; TMonsterAIUnit::s_MonsterAIUnitArray
  00ae0	e8 00 00 00 00	 call	 ?Reset@TMonsterAIUnit@@QAEXXZ ; TMonsterAIUnit::Reset

; 197  : 	}

  00ae5	eb db		 jmp	 SHORT $LN2@DelAllAIUn
$LN1@DelAllAIUn:

; 198  : 
; 199  : 	return FALSE;

  00ae7	33 c0		 xor	 eax, eax

; 200  : }

  00ae9	5f		 pop	 edi
  00aea	5e		 pop	 esi
  00aeb	5b		 pop	 ebx
  00aec	8b e5		 mov	 esp, ebp
  00aee	5d		 pop	 ebp
  00aef	c3		 ret	 0
?DelAllAIUnit@TMonsterAIUnit@@SAHXZ ENDP		; TMonsterAIUnit::DelAllAIUnit
_TEXT	ENDS
PUBLIC	??_C@_0DI@EJBAFJF@?$FLMonster?5AI?5Unit?$FN?5FindAIUnit?$CI?$CJ?5E@ ; `string'
PUBLIC	?FindAIUnit@TMonsterAIUnit@@SAPAV1@H@Z		; TMonsterAIUnit::FindAIUnit
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
;	COMDAT ??_C@_0DI@EJBAFJF@?$FLMonster?5AI?5Unit?$FN?5FindAIUnit?$CI?$CJ?5E@
CONST	SEGMENT
??_C@_0DI@EJBAFJF@?$FLMonster?5AI?5Unit?$FN?5FindAIUnit?$CI?$CJ?5E@ DB '['
	DB	'Monster AI Unit] FindAIUnit() Error - (UnitNumber=%d) ', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_iUnitNumber$ = 8					; size = 4
?FindAIUnit@TMonsterAIUnit@@SAPAV1@H@Z PROC		; TMonsterAIUnit::FindAIUnit

; 204  : {

  00af0	55		 push	 ebp
  00af1	8b ec		 mov	 ebp, esp
  00af3	83 ec 40	 sub	 esp, 64			; 00000040H
  00af6	53		 push	 ebx
  00af7	56		 push	 esi
  00af8	57		 push	 edi

; 205  : 	if ( iUnitNumber < 0 || iUnitNumber >= MAX_MONSTER_AI_UNIT )

  00af9	83 7d 08 00	 cmp	 DWORD PTR _iUnitNumber$[ebp], 0
  00afd	7c 06		 jl	 SHORT $LN2@FindAIUnit
  00aff	83 7d 08 64	 cmp	 DWORD PTR _iUnitNumber$[ebp], 100 ; 00000064H
  00b03	7c 16		 jl	 SHORT $LN3@FindAIUnit
$LN2@FindAIUnit:

; 206  : 	{
; 207  : 		LogAddTD("[Monster AI Unit] FindAIUnit() Error - (UnitNumber=%d) ",
; 208  : 			iUnitNumber);

  00b05	8b 45 08	 mov	 eax, DWORD PTR _iUnitNumber$[ebp]
  00b08	50		 push	 eax
  00b09	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@EJBAFJF@?$FLMonster?5AI?5Unit?$FN?5FindAIUnit?$CI?$CJ?5E@
  00b0e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00b14	83 c4 08	 add	 esp, 8

; 209  : 
; 210  : 		return NULL;

  00b17	33 c0		 xor	 eax, eax
  00b19	eb 38		 jmp	 SHORT $LN4@FindAIUnit
$LN3@FindAIUnit:

; 211  : 	}
; 212  : 
; 213  : 	if ( TMonsterAIUnit::s_MonsterAIUnitArray[iUnitNumber].m_iUnitNumber == iUnitNumber )

  00b1b	8b 45 08	 mov	 eax, DWORD PTR _iUnitNumber$[ebp]
  00b1e	69 c0 84 00 00
	00		 imul	 eax, 132		; 00000084H
  00b24	8b 88 38 00 00
	00		 mov	 ecx, DWORD PTR ?s_MonsterAIUnitArray@TMonsterAIUnit@@2PAV1@A[eax+56]
  00b2a	3b 4d 08	 cmp	 ecx, DWORD PTR _iUnitNumber$[ebp]
  00b2d	75 10		 jne	 SHORT $LN1@FindAIUnit

; 214  : 	{
; 215  : 		return &TMonsterAIUnit::s_MonsterAIUnitArray[iUnitNumber];

  00b2f	8b 45 08	 mov	 eax, DWORD PTR _iUnitNumber$[ebp]
  00b32	69 c0 84 00 00
	00		 imul	 eax, 132		; 00000084H
  00b38	05 00 00 00 00	 add	 eax, OFFSET ?s_MonsterAIUnitArray@TMonsterAIUnit@@2PAV1@A ; TMonsterAIUnit::s_MonsterAIUnitArray
  00b3d	eb 14		 jmp	 SHORT $LN4@FindAIUnit
$LN1@FindAIUnit:

; 216  : 	}
; 217  : 
; 218  : 	LogAddTD("[Monster AI Unit] FindAIUnit() Error - (UnitNumber=%d) ",
; 219  : 		iUnitNumber);

  00b3f	8b 45 08	 mov	 eax, DWORD PTR _iUnitNumber$[ebp]
  00b42	50		 push	 eax
  00b43	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@EJBAFJF@?$FLMonster?5AI?5Unit?$FN?5FindAIUnit?$CI?$CJ?5E@
  00b48	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00b4e	83 c4 08	 add	 esp, 8

; 220  : 
; 221  : 	return NULL;

  00b51	33 c0		 xor	 eax, eax
$LN4@FindAIUnit:

; 222  : }

  00b53	5f		 pop	 edi
  00b54	5e		 pop	 esi
  00b55	5b		 pop	 ebx
  00b56	8b e5		 mov	 esp, ebp
  00b58	5d		 pop	 ebp
  00b59	c3		 ret	 0
?FindAIUnit@TMonsterAIUnit@@SAPAV1@H@Z ENDP		; TMonsterAIUnit::FindAIUnit
_TEXT	ENDS
PUBLIC	?RunAIUnit@TMonsterAIUnit@@QAEHH@Z		; TMonsterAIUnit::RunAIUnit
EXTRN	?ForceAIElement@TMonsterAIElement@@QAEHHHPAVTMonsterAIState@@@Z:PROC ; TMonsterAIElement::ForceAIElement
EXTRN	?RunAutomata@TMonsterAIAutomata@@QAEPAVTMonsterAIState@@H@Z:PROC ; TMonsterAIAutomata::RunAutomata
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_iRetExec$ = -20					; size = 4
_pAIElement$ = -16					; size = 4
_pAIState$ = -12					; size = 4
_lpObj$ = -8						; size = 4
_this$ = -4						; size = 4
_iIndex$ = 8						; size = 4
?RunAIUnit@TMonsterAIUnit@@QAEHH@Z PROC			; TMonsterAIUnit::RunAIUnit
; _this$ = ecx

; 227  : {

  00b60	55		 push	 ebp
  00b61	8b ec		 mov	 ebp, esp
  00b63	83 ec 54	 sub	 esp, 84			; 00000054H
  00b66	53		 push	 ebx
  00b67	56		 push	 esi
  00b68	57		 push	 edi
  00b69	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 228  : 	LPOBJ lpObj = &gObj[iIndex];

  00b6c	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00b6f	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  00b75	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00b7b	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 229  : 
; 230  : 	if ( this->m_lpAutomata == NULL )

  00b7e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00b81	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  00b85	75 07		 jne	 SHORT $LN5@RunAIUnit

; 231  : 		return FALSE;

  00b87	33 c0		 xor	 eax, eax
  00b89	e9 98 00 00 00	 jmp	 $LN6@RunAIUnit
$LN5@RunAIUnit:

; 232  : 
; 233  : 	if ( (GetTickCount() - lpObj->m_iLastAutomataRuntime) < lpObj->m_iLastAutomataDelay )

  00b8e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00b94	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00b97	2b 81 b8 1f 00
	00		 sub	 eax, DWORD PTR [ecx+8120]
  00b9d	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00ba0	3b 82 bc 1f 00
	00		 cmp	 eax, DWORD PTR [edx+8124]
  00ba6	73 04		 jae	 SHORT $LN4@RunAIUnit

; 234  : 		return FALSE;

  00ba8	33 c0		 xor	 eax, eax
  00baa	eb 7a		 jmp	 SHORT $LN6@RunAIUnit
$LN4@RunAIUnit:

; 235  : 
; 236  : 	TMonsterAIState * pAIState = this->m_lpAutomata->RunAutomata(iIndex);

  00bac	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00baf	50		 push	 eax
  00bb0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00bb3	8b 49 40	 mov	 ecx, DWORD PTR [ecx+64]
  00bb6	e8 00 00 00 00	 call	 ?RunAutomata@TMonsterAIAutomata@@QAEPAVTMonsterAIState@@H@Z ; TMonsterAIAutomata::RunAutomata
  00bbb	89 45 f4	 mov	 DWORD PTR _pAIState$[ebp], eax

; 237  : 
; 238  : 	if ( pAIState == NULL )

  00bbe	83 7d f4 00	 cmp	 DWORD PTR _pAIState$[ebp], 0
  00bc2	75 04		 jne	 SHORT $LN3@RunAIUnit

; 239  : 		return FALSE;

  00bc4	33 c0		 xor	 eax, eax
  00bc6	eb 5e		 jmp	 SHORT $LN6@RunAIUnit
$LN3@RunAIUnit:

; 240  : 
; 241  : 	lpObj->m_iLastAutomataRuntime = GetTickCount();

  00bc8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00bce	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00bd1	89 81 b8 1f 00
	00		 mov	 DWORD PTR [ecx+8120], eax

; 242  : 	TMonsterAIElement * pAIElement = *this->m_lppAIClassMap[pAIState->m_iNextState];

  00bd7	8b 45 f4	 mov	 eax, DWORD PTR _pAIState$[ebp]
  00bda	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00bdd	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00be0	8b 44 8a 64	 mov	 eax, DWORD PTR [edx+ecx*4+100]
  00be4	8b 08		 mov	 ecx, DWORD PTR [eax]
  00be6	89 4d f0	 mov	 DWORD PTR _pAIElement$[ebp], ecx

; 243  : 
; 244  : 	if ( pAIElement == NULL )

  00be9	83 7d f0 00	 cmp	 DWORD PTR _pAIElement$[ebp], 0
  00bed	75 04		 jne	 SHORT $LN2@RunAIUnit

; 245  : 		return FALSE;

  00bef	33 c0		 xor	 eax, eax
  00bf1	eb 33		 jmp	 SHORT $LN6@RunAIUnit
$LN2@RunAIUnit:

; 246  : 
; 247  : 	int iRetExec = pAIElement->ForceAIElement(iIndex, 0, pAIState);

  00bf3	8b 45 f4	 mov	 eax, DWORD PTR _pAIState$[ebp]
  00bf6	50		 push	 eax
  00bf7	6a 00		 push	 0
  00bf9	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00bfc	51		 push	 ecx
  00bfd	8b 4d f0	 mov	 ecx, DWORD PTR _pAIElement$[ebp]
  00c00	e8 00 00 00 00	 call	 ?ForceAIElement@TMonsterAIElement@@QAEHHHPAVTMonsterAIState@@@Z ; TMonsterAIElement::ForceAIElement
  00c05	89 45 ec	 mov	 DWORD PTR _iRetExec$[ebp], eax

; 248  : 
; 249  : 	if ( iRetExec == 0 )

  00c08	83 7d ec 00	 cmp	 DWORD PTR _iRetExec$[ebp], 0
  00c0c	75 04		 jne	 SHORT $LN1@RunAIUnit

; 250  : 		return FALSE;

  00c0e	33 c0		 xor	 eax, eax
  00c10	eb 14		 jmp	 SHORT $LN6@RunAIUnit
$LN1@RunAIUnit:

; 251  : 
; 252  : 	lpObj->m_iCurrentAIState = pAIState->m_iNextState;

  00c12	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c15	8b 4d f4	 mov	 ecx, DWORD PTR _pAIState$[ebp]
  00c18	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00c1b	89 90 7c 1c 00
	00		 mov	 DWORD PTR [eax+7292], edx

; 253  : 	
; 254  : 	return TRUE;

  00c21	b8 01 00 00 00	 mov	 eax, 1
$LN6@RunAIUnit:

; 255  : }

  00c26	5f		 pop	 edi
  00c27	5e		 pop	 esi
  00c28	5b		 pop	 ebx
  00c29	8b e5		 mov	 esp, ebp
  00c2b	5d		 pop	 ebp
  00c2c	c2 04 00	 ret	 4
?RunAIUnit@TMonsterAIUnit@@QAEHH@Z ENDP			; TMonsterAIUnit::RunAIUnit
_TEXT	ENDS
EXTRN	_atexit:PROC
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
; Function compile flags: /Odtp /ZI
;	COMDAT ??__E?s_MonsterAIUnitArray@TMonsterAIUnit@@2PAV1@A@@YAXXZ
text$yc	SEGMENT
??__E?s_MonsterAIUnitArray@TMonsterAIUnit@@2PAV1@A@@YAXXZ PROC ; `dynamic initializer for 'TMonsterAIUnit::s_MonsterAIUnitArray'', COMDAT

; 15   : TMonsterAIUnit TMonsterAIUnit::s_MonsterAIUnitArray[MAX_MONSTER_AI_UNIT];

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	68 00 00 00 00	 push	 OFFSET ??1TMonsterAIUnit@@UAE@XZ ; TMonsterAIUnit::~TMonsterAIUnit
  0000e	68 00 00 00 00	 push	 OFFSET ??0TMonsterAIUnit@@QAE@XZ ; TMonsterAIUnit::TMonsterAIUnit
  00013	6a 64		 push	 100			; 00000064H
  00015	68 84 00 00 00	 push	 132			; 00000084H
  0001a	68 00 00 00 00	 push	 OFFSET ?s_MonsterAIUnitArray@TMonsterAIUnit@@2PAV1@A ; TMonsterAIUnit::s_MonsterAIUnitArray
  0001f	e8 00 00 00 00	 call	 ??_L@YGXPAXIHP6EX0@Z1@Z
  00024	68 00 00 00 00	 push	 OFFSET ??__F?s_MonsterAIUnitArray@TMonsterAIUnit@@2PAV1@A@@YAXXZ ; `dynamic atexit destructor for 'TMonsterAIUnit::s_MonsterAIUnitArray''
  00029	e8 00 00 00 00	 call	 _atexit
  0002e	83 c4 04	 add	 esp, 4
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
??__E?s_MonsterAIUnitArray@TMonsterAIUnit@@2PAV1@A@@YAXXZ ENDP ; `dynamic initializer for 'TMonsterAIUnit::s_MonsterAIUnitArray''
text$yc	ENDS
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
; Function compile flags: /Odtp /ZI
;	COMDAT ??__F?s_MonsterAIUnitArray@TMonsterAIUnit@@2PAV1@A@@YAXXZ
text$yd	SEGMENT
??__F?s_MonsterAIUnitArray@TMonsterAIUnit@@2PAV1@A@@YAXXZ PROC ; `dynamic atexit destructor for 'TMonsterAIUnit::s_MonsterAIUnitArray'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	68 00 00 00 00	 push	 OFFSET ??1TMonsterAIUnit@@UAE@XZ ; TMonsterAIUnit::~TMonsterAIUnit
  0000e	6a 64		 push	 100			; 00000064H
  00010	68 84 00 00 00	 push	 132			; 00000084H
  00015	68 00 00 00 00	 push	 OFFSET ?s_MonsterAIUnitArray@TMonsterAIUnit@@2PAV1@A ; TMonsterAIUnit::s_MonsterAIUnitArray
  0001a	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??__F?s_MonsterAIUnitArray@TMonsterAIUnit@@2PAV1@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'TMonsterAIUnit::s_MonsterAIUnitArray''
text$yd	ENDS
PUBLIC	?s_MonsterAIUnitArray@TMonsterAIUnit@@2PAV1@A	; TMonsterAIUnit::s_MonsterAIUnitArray
_BSS	SEGMENT
?s_MonsterAIUnitArray@TMonsterAIUnit@@2PAV1@A DB 03390H DUP (?) ; TMonsterAIUnit::s_MonsterAIUnitArray
_BSS	ENDS
CRT$XCU	SEGMENT
?s_MonsterAIUnitArray$initializer$@TMonsterAIUnit@@2P6AXXZA DD FLAT:??__E?s_MonsterAIUnitArray@TMonsterAIUnit@@2PAV1@A@@YAXXZ ; TMonsterAIUnit::s_MonsterAIUnitArray$initializer$
CRT$XCU	ENDS
END
