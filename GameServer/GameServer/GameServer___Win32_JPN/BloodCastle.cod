; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	D:\Projects\ExTeam6.3\Source\GameServer\GameServer\BloodCastle.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
_g_btCastleEntranceMapXY DB 0dH
	DB	0fH
	DB	0fH
	DB	017H
	DB	0dH
	DB	0fH
	DB	0fH
	DB	017H
	DB	0dH
	DB	0fH
	DB	0fH
	DB	017H
	DB	0dH
	DB	0fH
	DB	0fH
	DB	017H
	DB	0dH
	DB	0fH
	DB	0fH
	DB	017H
	DB	0dH
	DB	0fH
	DB	0fH
	DB	017H
	DB	0dH
	DB	0fH
	DB	0fH
	DB	017H
	DB	0dH
	DB	0fH
	DB	0fH
	DB	017H
_g_btCastleBridgeMapXY DB 0dH
	DB	046H
	DB	0fH
	DB	04bH
	DB	0dH
	DB	046H
	DB	0fH
	DB	04bH
	DB	0dH
	DB	046H
	DB	0fH
	DB	04bH
	DB	0dH
	DB	046H
	DB	0fH
	DB	04bH
	DB	0dH
	DB	046H
	DB	0fH
	DB	04bH
	DB	0dH
	DB	046H
	DB	0fH
	DB	04bH
	DB	0dH
	DB	046H
	DB	0fH
	DB	04bH
	DB	0dH
	DB	046H
	DB	0fH
	DB	04bH
_g_btCastleDoorMapXY DB 0dH
	DB	04cH
	DB	0fH
	DB	04fH
	DB	0bH
	DB	050H
	DB	019H
	DB	059H
	DB	08H
	DB	050H
	DB	0aH
	DB	053H
	DB	0dH
	DB	04cH
	DB	0fH
	DB	04fH
	DB	0bH
	DB	050H
	DB	019H
	DB	059H
	DB	08H
	DB	050H
	DB	0aH
	DB	053H
	DB	0dH
	DB	04cH
	DB	0fH
	DB	04fH
	DB	0bH
	DB	050H
	DB	019H
	DB	059H
	DB	08H
	DB	050H
	DB	0aH
	DB	053H
	DB	0dH
	DB	04cH
	DB	0fH
	DB	04fH
	DB	0bH
	DB	050H
	DB	019H
	DB	059H
	DB	08H
	DB	050H
	DB	0aH
	DB	053H
	DB	0dH
	DB	04cH
	DB	0fH
	DB	04fH
	DB	0bH
	DB	050H
	DB	019H
	DB	059H
	DB	08H
	DB	050H
	DB	0aH
	DB	053H
	DB	0dH
	DB	04cH
	DB	0fH
	DB	04fH
	DB	0bH
	DB	050H
	DB	019H
	DB	059H
	DB	08H
	DB	050H
	DB	0aH
	DB	053H
	DB	0dH
	DB	04cH
	DB	0fH
	DB	04fH
	DB	0bH
	DB	050H
	DB	019H
	DB	059H
	DB	08H
	DB	050H
	DB	0aH
	DB	053H
	DB	0dH
	DB	04cH
	DB	0fH
	DB	04fH
	DB	0bH
	DB	050H
	DB	019H
	DB	059H
	DB	08H
	DB	050H
	DB	0aH
	DB	053H
_g_iQuestWinExpendZEN DD 04e20H
	DD	02710H
	DD	0c350H
	DD	061a8H
	DD	0186a0H
	DD	0c350H
	DD	0249f0H
	DD	013880H
	DD	030d40H
	DD	0186a0H
	DD	03d090H
	DD	01d4c0H
	DD	03d090H
	DD	01d4c0H
	DD	03d090H
	DD	01d4c0H
_g_iBC_ChoasMixSuccessRate DD 050H
	DD	050H
	DD	050H
	DD	050H
	DD	050H
	DD	050H
	DD	050H
	DD	050H
_g_iBC_ChoasMixMoney DD 0c350H
	DD	013880H
	DD	0249f0H
	DD	03d090H
	DD	061a80H
	DD	0927c0H
	DD	0cf850H
	DD	0100590H
_g_iBC_EventScore DD 0258H
	DD	012cH
	DD	03e8H
	DD	0320H
	DD	0190H
	DD	0258H
	DD	012cH
	DD	03e8H
	DD	0320H
	DD	0190H
	DD	0258H
	DD	012cH
	DD	03edH
	DD	0320H
	DD	0190H
	DD	0258H
	DD	012cH
	DD	03edH
	DD	0320H
	DD	0190H
	DD	0258H
	DD	012cH
	DD	03edH
	DD	0320H
	DD	0190H
	DD	0258H
	DD	012cH
	DD	03edH
	DD	0320H
	DD	0190H
	DD	0258H
	DD	012cH
	DD	03edH
	DD	0320H
	DD	0190H
	DD	0258H
	DD	012cH
	DD	03edH
	DD	0320H
	DD	0190H
_g_iBC_EventScore_Fail DD 0fffffed4H
	DD	0fffffed4H
	DD	0fffffed4H
	DD	0fffffed4H
	DD	0fffffed4H
	DD	0fffffed4H
	DD	0fffffed4H
	DD	0fffffed4H
_g_iBC_Add_Exp DD 04e20H
	DD	04e20H
	DD	01388H
	DD	0a0H
	DD	0c350H
	DD	0c350H
	DD	02710H
	DD	0b4H
	DD	013880H
	DD	013880H
	DD	03a98H
	DD	0c8H
	DD	015f90H
	DD	015f90H
	DD	04e20H
	DD	0dcH
	DD	0186a0H
	DD	0186a0H
	DD	061a8H
	DD	0f0H
	DD	01adb0H
	DD	01adb0H
	DD	07530H
	DD	0104H
	DD	01d4c0H
	DD	01d4c0H
	DD	088b8H
	DD	0118H
	DD	01fbd0H
	DD	01fbd0H
	DD	09c40H
	DD	012cH
_g_iBC_Party_EventPoint DD 05H
	DD	0aH
	DD	0fH
	DD	014H
	DD	01eH
	DD	023H
	DD	028H
	DD	02dH
	DD	032H
	DD	037H
_g_iBC_MONSTER_CHANGE_STATE DD 0aH
	DD	014H
	DD	0fffffff2H
	DD	014H
	DD	028H
	DD	0ffffffe0H
CONST	ENDS
_DATA	SEGMENT
_g_sttBLOODCASTLE_LEVEL DD 0fH
	DD	050H
	DD	0aH
	DD	03cH
	DD	051H
	DD	082H
	DD	03dH
	DD	06eH
	DD	083H
	DD	0b4H
	DD	06fH
	DD	0a0H
	DD	0b5H
	DD	0e6H
	DD	0a1H
	DD	0d2H
	DD	0e7H
	DD	0118H
	DD	0d3H
	DD	0104H
	DD	0119H
	DD	014aH
	DD	0105H
	DD	0136H
	DD	014bH
	DD	0190H
	DD	0137H
	DD	0190H
	DD	0fH
	DD	0257H
	DD	0aH
	DD	0257H
_g_sttCHAOSCASTLE_LEVEL DD 0fH
	DD	031H
	DD	0fH
	DD	01dH
	DD	032H
	DD	077H
	DD	01eH
	DD	063H
	DD	078H
	DD	0b3H
	DD	064H
	DD	09fH
	DD	0b4H
	DD	0efH
	DD	0a0H
	DD	0dbH
	DD	0f0H
	DD	012bH
	DD	0dcH
	DD	0117H
	DD	012cH
	DD	0190H
	DD	0118H
	DD	0190H
	DD	0190H
	DD	0257H
	DD	0190H
	DD	0257H
_g_iChaosCastle_BlowOutDistance DD 03H
	DD	04H
	DD	03H
	DD	04H
	DD	02H
	DD	03H
	DD	00H
	DD	01H
_g_iChaosCastle_BlowOutDamage DD 0fH
	DD	0fH
	DD	0aH
	DD	05H
_g_iChaosCastle_EnterCost DD 061a8H
	DD	013880H
	DD	0249f0H
	DD	03d090H
	DD	061a80H
	DD	09eb10H
	DD	0f4240H
_g_iChaosCastle_GuardSetValue DD 09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
_g_iChaosCastle_MonsterItems DD 01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	03H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	03H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	03H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	03H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	04H
_g_iChaosCastle_MonsterItemsNewServer DD 00H
	DD	00H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	03H
_g_iChaosCastle_GroundAxis DD 017H
	DD	04bH
	DD	02cH
	DD	06cH
_g_iChaosCastle_DamageAxis DD 017H
	DD	04bH
	DD	02cH
	DD	06cH
	DD	019H
	DD	04dH
	DD	02aH
	DD	06aH
	DD	01bH
	DD	04fH
	DD	028H
	DD	068H
	DD	01dH
	DD	051H
	DD	026H
	DD	066H
_g_iChaosCastle_MapHollowZone DD 017H
	DD	04bH
	DD	02cH
	DD	04cH
	DD	02bH
	DD	04dH
	DD	02cH
	DD	06cH
	DD	017H
	DD	06bH
	DD	02aH
	DD	06cH
	DD	017H
	DD	04dH
	DD	018H
	DD	06aH
	DD	017H
	DD	04bH
	DD	02cH
	DD	04cH
	DD	02bH
	DD	04dH
	DD	02cH
	DD	06cH
	DD	017H
	DD	06bH
	DD	02aH
	DD	06cH
	DD	017H
	DD	04dH
	DD	018H
	DD	06aH
	DD	019H
	DD	04dH
	DD	02aH
	DD	04eH
	DD	029H
	DD	04fH
	DD	02aH
	DD	06aH
	DD	019H
	DD	069H
	DD	028H
	DD	06aH
	DD	019H
	DD	04fH
	DD	01aH
	DD	068H
	DD	01bH
	DD	04fH
	DD	028H
	DD	050H
	DD	027H
	DD	051H
	DD	028H
	DD	068H
	DD	01bH
	DD	067H
	DD	026H
	DD	068H
	DD	01bH
	DD	051H
	DD	01cH
	DD	066H
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
_DATA	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Odtp /ZI
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@vector:
  00009	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000c	83 e8 01	 sub	 eax, 1
  0000f	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00012	78 11		 js	 SHORT $LN3@vector
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00017	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  0001d	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00020	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00023	eb e4		 jmp	 SHORT $LN2@vector
$LN3@vector:
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??1?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@XZ ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::~list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >
PUBLIC	?ClearBridgeData@CBloodCastle@@IAEXH@Z		; CBloodCastle::ClearBridgeData
PUBLIC	__real@3f800000
PUBLIC	?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z	; CBloodCastle::GetBridgeMapNumber
PUBLIC	??0?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@XZ ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >
PUBLIC	??_7CBloodCastle@@6B@				; CBloodCastle::`vftable'
PUBLIC	??0CBloodCastle@@QAE@XZ				; CBloodCastle::CBloodCastle
PUBLIC	??_R4CBloodCastle@@6B@				; CBloodCastle::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCBloodCastle@@@8			; CBloodCastle `RTTI Type Descriptor'
PUBLIC	??_R3CBloodCastle@@8				; CBloodCastle::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CBloodCastle@@8				; CBloodCastle::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CBloodCastle@@8			; CBloodCastle::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	__imp__InitializeCriticalSection@4:PROC
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__fltused:DWORD
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ECBloodCastle@@UAEPAXI@Z:PROC		; CBloodCastle::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CBloodCastle@@8
; File d:\projects\exteam6.3\source\gameserver\gameserver\bloodcastle.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@CBloodCastle@@8 DD FLAT:??_R0?AVCBloodCastle@@@8 ; CBloodCastle::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CBloodCastle@@8
rdata$r	ENDS
;	COMDAT ??_R2CBloodCastle@@8
rdata$r	SEGMENT
??_R2CBloodCastle@@8 DD FLAT:??_R1A@?0A@EA@CBloodCastle@@8 ; CBloodCastle::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CBloodCastle@@8
rdata$r	SEGMENT
??_R3CBloodCastle@@8 DD 00H				; CBloodCastle::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CBloodCastle@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCBloodCastle@@@8
_DATA	SEGMENT
??_R0?AVCBloodCastle@@@8 DD FLAT:??_7type_info@@6B@	; CBloodCastle `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCBloodCastle@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CBloodCastle@@6B@
rdata$r	SEGMENT
??_R4CBloodCastle@@6B@ DD 00H				; CBloodCastle::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCBloodCastle@@@8
	DD	FLAT:??_R3CBloodCastle@@8
rdata$r	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT ??_7CBloodCastle@@6B@
CONST	SEGMENT
??_7CBloodCastle@@6B@ DD FLAT:??_R4CBloodCastle@@6B@	; CBloodCastle::`vftable'
	DD	FLAT:??_ECBloodCastle@@UAEPAXI@Z
CONST	ENDS
xdata$x	SEGMENT
__unwindtable$??0CBloodCastle@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CBloodCastle@@QAE@XZ$0
__ehfuncinfo$??0CBloodCastle@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CBloodCastle@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
_TEXT	SEGMENT
_i$236418 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CBloodCastle@@QAE@XZ PROC				; CBloodCastle::CBloodCastle
; _this$ = ecx

; 122  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CBloodCastle@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 48	 sub	 esp, 72			; 00000048H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CBloodCastle@@6B@
  00034	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	81 c1 20 23 00
	00		 add	 ecx, 8992		; 00002320H
  0003d	e8 00 00 00 00	 call	 ??0?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@XZ ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >
  00042	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 123  : 	this->m_bBC_EVENT_ENABLE = false;

  00049	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	c6 80 04 23 00
	00 00		 mov	 BYTE PTR [eax+8964], 0

; 124  : 	this->m_iBC_TIME_MIN_OPEN = 10;

  00053	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00056	c7 80 08 23 00
	00 0a 00 00 00	 mov	 DWORD PTR [eax+8968], 10 ; 0000000aH

; 125  : 	this->m_iBC_NORMAL_ITEM_DROP = 100;

  00060	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00063	c7 80 14 23 00
	00 64 00 00 00	 mov	 DWORD PTR [eax+8980], 100 ; 00000064H

; 126  : 	this->m_iBC_EXCEL_ITEM_DROP = 1200;

  0006d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00070	c7 80 18 23 00
	00 b0 04 00 00	 mov	 DWORD PTR [eax+8984], 1200 ; 000004b0H

; 127  : 	this->m_iBC_MONSTER_REGEN = 0;

  0007a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0007d	c7 80 1c 23 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+8988], 0

; 128  : 
; 129  : 	for ( int i =0; i<MAX_BLOOD_CASTLE_LEVEL ; i++ )

  00087	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$236418[ebp], 0
  0008e	eb 09		 jmp	 SHORT $LN3@CBloodCast
$LN2@CBloodCast:
  00090	8b 45 ec	 mov	 eax, DWORD PTR _i$236418[ebp]
  00093	83 c0 01	 add	 eax, 1
  00096	89 45 ec	 mov	 DWORD PTR _i$236418[ebp], eax
$LN3@CBloodCast:
  00099	83 7d ec 08	 cmp	 DWORD PTR _i$236418[ebp], 8
  0009d	0f 8d fc 00 00
	00		 jge	 $LN1@CBloodCast

; 130  : 	{
; 131  : 		this->m_BridgeData[i].m_iBC_STATE = BC_STATE_NONE;

  000a3	8b 45 ec	 mov	 eax, DWORD PTR _i$236418[ebp]
  000a6	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  000ac	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000af	c7 84 01 a8 03
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+936], 0

; 132  : 		this->m_BridgeData[i].m_iMapNumber = this->GetBridgeMapNumber(i);

  000ba	8b 45 ec	 mov	 eax, DWORD PTR _i$236418[ebp]
  000bd	50		 push	 eax
  000be	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	e8 00 00 00 00	 call	 ?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeMapNumber
  000c6	8b 4d ec	 mov	 ecx, DWORD PTR _i$236418[ebp]
  000c9	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  000cf	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000d2	89 84 0a 98 03
	00 00		 mov	 DWORD PTR [edx+ecx+920], eax

; 133  : 		this->m_BridgeData[i].m_iBridgeIndex = i;

  000d9	8b 45 ec	 mov	 eax, DWORD PTR _i$236418[ebp]
  000dc	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  000e2	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000e5	8b 55 ec	 mov	 edx, DWORD PTR _i$236418[ebp]
  000e8	89 94 01 9c 03
	00 00		 mov	 DWORD PTR [ecx+eax+924], edx

; 134  : 		this->m_BridgeData[i].m_iBC_REMAIN_MSEC = -1;

  000ef	8b 45 ec	 mov	 eax, DWORD PTR _i$236418[ebp]
  000f2	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  000f8	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000fb	c7 84 01 ac 03
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+940], -1

; 135  : 		this->m_BridgeData[i].m_iBC_TICK_COUNT = -1;

  00106	8b 45 ec	 mov	 eax, DWORD PTR _i$236418[ebp]
  00109	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0010f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00112	c7 84 01 b0 03
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+944], -1

; 136  : 		this->m_BridgeData[i].m_nSaintStatuePosNum = -1;

  0011d	8b 45 ec	 mov	 eax, DWORD PTR _i$236418[ebp]
  00120	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  00126	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00129	c7 84 01 8c 03
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+908], -1

; 137  : 		this->m_BridgeData[i].m_nCastleDoorPosNum = -1;

  00134	8b 45 ec	 mov	 eax, DWORD PTR _i$236418[ebp]
  00137	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0013d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00140	c7 84 01 90 03
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+912], -1

; 138  : 		this->m_BridgeData[i].m_iAngelKingPosNum = -1;

  0014b	8b 45 ec	 mov	 eax, DWORD PTR _i$236418[ebp]
  0014e	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  00154	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00157	c7 84 01 f4 03
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+1012], -1

; 139  : 		this->m_BridgeData[i].m_iBC_REWARD_EXP = 1.0f; //season 4.5 add-on

  00162	8b 45 ec	 mov	 eax, DWORD PTR _i$236418[ebp]
  00165	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0016b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0016e	d9 e8		 fld1
  00170	d9 9c 01 60 04
	00 00		 fstp	 DWORD PTR [ecx+eax+1120]

; 140  : 		InitializeCriticalSection(&this->m_BridgeData[i].m_critUserData);

  00177	8b 45 ec	 mov	 eax, DWORD PTR _i$236418[ebp]
  0017a	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  00180	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00183	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00187	52		 push	 edx
  00188	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4

; 141  : 		this->ClearBridgeData(i);

  0018e	8b 45 ec	 mov	 eax, DWORD PTR _i$236418[ebp]
  00191	50		 push	 eax
  00192	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00195	e8 00 00 00 00	 call	 ?ClearBridgeData@CBloodCastle@@IAEXH@Z ; CBloodCastle::ClearBridgeData

; 142  : 	}

  0019a	e9 f1 fe ff ff	 jmp	 $LN2@CBloodCast
$LN1@CBloodCast:

; 143  : }

  0019f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  001a6	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  001a9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001ac	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001b3	59		 pop	 ecx
  001b4	5f		 pop	 edi
  001b5	5e		 pop	 esi
  001b6	5b		 pop	 ebx
  001b7	8b e5		 mov	 esp, ebp
  001b9	5d		 pop	 ebp
  001ba	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0CBloodCastle@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	81 c1 20 23 00
	00		 add	 ecx, 8992		; 00002320H
  00009	e9 00 00 00 00	 jmp	 ??1?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@XZ ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::~list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >
__ehhandler$??0CBloodCastle@@QAE@XZ:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CBloodCastle@@QAE@XZ
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CBloodCastle@@QAE@XZ ENDP				; CBloodCastle::CBloodCastle
PUBLIC	??1CBloodCastle@@UAE@XZ				; CBloodCastle::~CBloodCastle
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp /ZI
;	COMDAT ??_GCBloodCastle@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCBloodCastle@@UAEPAXI@Z PROC			; CBloodCastle::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1CBloodCastle@@UAE@XZ	; CBloodCastle::~CBloodCastle
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_GCBloodCastle@@UAEPAXI@Z ENDP			; CBloodCastle::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp__DeleteCriticalSection@4:PROC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_i$236429 = -8						; size = 4
_this$ = -4						; size = 4
??1CBloodCastle@@UAE@XZ PROC				; CBloodCastle::~CBloodCastle
; _this$ = ecx

; 146  : {

  001c0	55		 push	 ebp
  001c1	8b ec		 mov	 ebp, esp
  001c3	83 ec 48	 sub	 esp, 72			; 00000048H
  001c6	53		 push	 ebx
  001c7	56		 push	 esi
  001c8	57		 push	 edi
  001c9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  001cc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001cf	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CBloodCastle@@6B@

; 147  : 	for ( int i =0; i<MAX_BLOOD_CASTLE_LEVEL ; i++ )

  001d5	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$236429[ebp], 0
  001dc	eb 09		 jmp	 SHORT $LN3@CBloodCast@2
$LN2@CBloodCast@2:
  001de	8b 45 f8	 mov	 eax, DWORD PTR _i$236429[ebp]
  001e1	83 c0 01	 add	 eax, 1
  001e4	89 45 f8	 mov	 DWORD PTR _i$236429[ebp], eax
$LN3@CBloodCast@2:
  001e7	83 7d f8 08	 cmp	 DWORD PTR _i$236429[ebp], 8
  001eb	7d 19		 jge	 SHORT $LN4@CBloodCast@2

; 148  : 	{
; 149  : 		DeleteCriticalSection(&this->m_BridgeData[i].m_critUserData);

  001ed	8b 45 f8	 mov	 eax, DWORD PTR _i$236429[ebp]
  001f0	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  001f6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001f9	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  001fd	52		 push	 edx
  001fe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4

; 150  : 	}

  00204	eb d8		 jmp	 SHORT $LN2@CBloodCast@2
$LN4@CBloodCast@2:

; 151  : }

  00206	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00209	81 c1 20 23 00
	00		 add	 ecx, 8992		; 00002320H
  0020f	e8 00 00 00 00	 call	 ??1?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@XZ ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::~list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >
  00214	5f		 pop	 edi
  00215	5e		 pop	 esi
  00216	5b		 pop	 ebx
  00217	8b e5		 mov	 esp, ebp
  00219	5d		 pop	 ebp
  0021a	c3		 ret	 0
??1CBloodCastle@@UAE@XZ ENDP				; CBloodCastle::~CBloodCastle
_TEXT	ENDS
PUBLIC	?SetState@CBloodCastle@@QAEXHH@Z		; CBloodCastle::SetState
PUBLIC	?GetBridgeIndex@CBloodCastle@@QAEHH@Z		; CBloodCastle::GetBridgeIndex
PUBLIC	?Init@CBloodCastle@@QAEX_N@Z			; CBloodCastle::Init
EXTRN	?gMSetBase@@3VCMonsterSetBase@@A:BYTE		; gMSetBase
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv129 = -104						; size = 4
tv157 = -100						; size = 4
tv130 = -100						; size = 4
_i$236479 = -32						; size = 4
_l$236474 = -28						; size = 4
_btBloodCastleIndex$236468 = -22			; size = 1
_btMapNumber$236467 = -21				; size = 1
_wMonsterType$236466 = -20				; size = 2
_n$236445 = -16						; size = 4
_n$236441 = -12						; size = 4
_i$236437 = -8						; size = 4
_this$ = -4						; size = 4
_bEVENT_ENABLE$ = 8					; size = 1
?Init@CBloodCastle@@QAEX_N@Z PROC			; CBloodCastle::Init
; _this$ = ecx

; 156  : {

  00220	55		 push	 ebp
  00221	8b ec		 mov	 ebp, esp
  00223	83 ec 68	 sub	 esp, 104		; 00000068H
  00226	53		 push	 ebx
  00227	56		 push	 esi
  00228	57		 push	 edi
  00229	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 157  : 	this->m_bBC_EVENT_ENABLE = bEVENT_ENABLE;

  0022c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0022f	8a 4d 08	 mov	 cl, BYTE PTR _bEVENT_ENABLE$[ebp]
  00232	88 88 04 23 00
	00		 mov	 BYTE PTR [eax+8964], cl

; 158  : 
; 159  : 	for ( int i=0; i<MAX_BLOOD_CASTLE_LEVEL ; i++ )

  00238	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$236437[ebp], 0
  0023f	eb 09		 jmp	 SHORT $LN22@Init
$LN21@Init:
  00241	8b 45 f8	 mov	 eax, DWORD PTR _i$236437[ebp]
  00244	83 c0 01	 add	 eax, 1
  00247	89 45 f8	 mov	 DWORD PTR _i$236437[ebp], eax
$LN22@Init:
  0024a	83 7d f8 08	 cmp	 DWORD PTR _i$236437[ebp], 8
  0024e	7d 51		 jge	 SHORT $LN20@Init

; 160  : 	{
; 161  : 		for ( int n=0;n<MAX_BLOOD_CASTLE_BOSS_MONSTER;n++)

  00250	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _n$236441[ebp], 0
  00257	eb 09		 jmp	 SHORT $LN19@Init
$LN18@Init:
  00259	8b 45 f4	 mov	 eax, DWORD PTR _n$236441[ebp]
  0025c	83 c0 01	 add	 eax, 1
  0025f	89 45 f4	 mov	 DWORD PTR _n$236441[ebp], eax
$LN19@Init:
  00262	83 7d f4 14	 cmp	 DWORD PTR _n$236441[ebp], 20 ; 00000014H
  00266	7d 37		 jge	 SHORT $LN17@Init

; 162  : 		{
; 163  : 			this->m_BridgeData[i].m_iAngelKingPosNum = -1;

  00268	8b 45 f8	 mov	 eax, DWORD PTR _i$236437[ebp]
  0026b	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  00271	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00274	c7 84 01 f4 03
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+1012], -1

; 164  : 			this->m_BridgeData[i].m_nBossMonsterPosNum[n] = -1;

  0027f	8b 45 f8	 mov	 eax, DWORD PTR _i$236437[ebp]
  00282	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  00288	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0028b	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0028f	8b 45 f4	 mov	 eax, DWORD PTR _n$236441[ebp]
  00292	c7 84 82 38 03
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [edx+eax*4+824], -1

; 165  : 		}

  0029d	eb ba		 jmp	 SHORT $LN18@Init
$LN17@Init:

; 166  : 	}

  0029f	eb a0		 jmp	 SHORT $LN21@Init
$LN20@Init:

; 167  : 
; 168  : 	for ( int n =0; n<gMSetBase.m_Count;n++)

  002a1	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _n$236445[ebp], 0
  002a8	eb 09		 jmp	 SHORT $LN16@Init
$LN15@Init:
  002aa	8b 45 f0	 mov	 eax, DWORD PTR _n$236445[ebp]
  002ad	83 c0 01	 add	 eax, 1
  002b0	89 45 f0	 mov	 DWORD PTR _n$236445[ebp], eax
$LN16@Init:
  002b3	8b 45 f0	 mov	 eax, DWORD PTR _n$236445[ebp]
  002b6	3b 05 84 2c 03
	00		 cmp	 eax, DWORD PTR ?gMSetBase@@3VCMonsterSetBase@@A+208004
  002bc	0f 8d d2 01 00
	00		 jge	 $LN14@Init

; 169  : 	{
; 170  : 		if ( BC_MAP_RANGE(gMSetBase.m_Mp[n].m_MapNumber ) != FALSE )

  002c2	8b 45 f0	 mov	 eax, DWORD PTR _n$236445[ebp]
  002c5	c1 e0 04	 shl	 eax, 4
  002c8	0f b6 88 08 00
	00 00		 movzx	 ecx, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+8]
  002cf	83 f9 34	 cmp	 ecx, 52			; 00000034H
  002d2	75 09		 jne	 SHORT $LN27@Init
  002d4	c7 45 9c 01 00
	00 00		 mov	 DWORD PTR tv130[ebp], 1
  002db	eb 39		 jmp	 SHORT $LN28@Init
$LN27@Init:
  002dd	8b 55 f0	 mov	 edx, DWORD PTR _n$236445[ebp]
  002e0	c1 e2 04	 shl	 edx, 4
  002e3	0f b6 82 08 00
	00 00		 movzx	 eax, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[edx+8]
  002ea	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  002ed	7d 09		 jge	 SHORT $LN25@Init
  002ef	c7 45 98 00 00
	00 00		 mov	 DWORD PTR tv129[ebp], 0
  002f6	eb 18		 jmp	 SHORT $LN26@Init
$LN25@Init:
  002f8	8b 4d f0	 mov	 ecx, DWORD PTR _n$236445[ebp]
  002fb	c1 e1 04	 shl	 ecx, 4
  002fe	0f b6 91 08 00
	00 00		 movzx	 edx, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[ecx+8]
  00305	33 c0		 xor	 eax, eax
  00307	83 fa 11	 cmp	 edx, 17			; 00000011H
  0030a	0f 9e c0	 setle	 al
  0030d	89 45 98	 mov	 DWORD PTR tv129[ebp], eax
$LN26@Init:
  00310	8b 4d 98	 mov	 ecx, DWORD PTR tv129[ebp]
  00313	89 4d 9c	 mov	 DWORD PTR tv130[ebp], ecx
$LN28@Init:
  00316	83 7d 9c 00	 cmp	 DWORD PTR tv130[ebp], 0
  0031a	0f 84 6f 01 00
	00		 je	 $LN13@Init

; 171  : 		{
; 172  : 			WORD wMonsterType = gMSetBase.m_Mp[n].m_Type; //season3 changed

  00320	8b 45 f0	 mov	 eax, DWORD PTR _n$236445[ebp]
  00323	c1 e0 04	 shl	 eax, 4
  00326	66 8b 88 06 00
	00 00		 mov	 cx, WORD PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+6]
  0032d	66 89 4d ec	 mov	 WORD PTR _wMonsterType$236466[ebp], cx

; 173  : 			BYTE btMapNumber = gMSetBase.m_Mp[n].m_MapNumber;

  00331	8b 45 f0	 mov	 eax, DWORD PTR _n$236445[ebp]
  00334	c1 e0 04	 shl	 eax, 4
  00337	8a 88 08 00 00
	00		 mov	 cl, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+8]
  0033d	88 4d eb	 mov	 BYTE PTR _btMapNumber$236467[ebp], cl

; 174  : 			BYTE btBloodCastleIndex = this->GetBridgeIndex(btMapNumber); //season3 changed

  00340	0f b6 45 eb	 movzx	 eax, BYTE PTR _btMapNumber$236467[ebp]
  00344	50		 push	 eax
  00345	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00348	e8 00 00 00 00	 call	 ?GetBridgeIndex@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeIndex
  0034d	88 45 ea	 mov	 BYTE PTR _btBloodCastleIndex$236468[ebp], al

; 175  : 
; 176  : 			if ( wMonsterType == 232 )

  00350	0f b7 45 ec	 movzx	 eax, WORD PTR _wMonsterType$236466[ebp]
  00354	3d e8 00 00 00	 cmp	 eax, 232		; 000000e8H
  00359	75 1c		 jne	 SHORT $LN12@Init

; 177  : 			{
; 178  : 				this->m_BridgeData[btBloodCastleIndex].m_iAngelKingPosNum = n;

  0035b	0f b6 45 ea	 movzx	 eax, BYTE PTR _btBloodCastleIndex$236468[ebp]
  0035f	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  00365	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00368	8b 55 f0	 mov	 edx, DWORD PTR _n$236445[ebp]
  0036b	89 94 01 f4 03
	00 00		 mov	 DWORD PTR [ecx+eax+1012], edx

; 179  : 				continue;

  00372	e9 33 ff ff ff	 jmp	 $LN15@Init
$LN12@Init:

; 180  : 			}
; 181  : 			
; 182  : 			if ( BC_STATUE_RANGE(wMonsterType - 132) != FALSE )

  00377	0f b7 45 ec	 movzx	 eax, WORD PTR _wMonsterType$236466[ebp]
  0037b	2d 84 00 00 00	 sub	 eax, 132		; 00000084H
  00380	79 09		 jns	 SHORT $LN29@Init
  00382	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv157[ebp], 0
  00389	eb 15		 jmp	 SHORT $LN30@Init
$LN29@Init:
  0038b	0f b7 4d ec	 movzx	 ecx, WORD PTR _wMonsterType$236466[ebp]
  0038f	81 e9 84 00 00
	00		 sub	 ecx, 132		; 00000084H
  00395	33 d2		 xor	 edx, edx
  00397	83 f9 02	 cmp	 ecx, 2
  0039a	0f 9e c2	 setle	 dl
  0039d	89 55 9c	 mov	 DWORD PTR tv157[ebp], edx
$LN30@Init:
  003a0	83 7d 9c 00	 cmp	 DWORD PTR tv157[ebp], 0
  003a4	74 1c		 je	 SHORT $LN11@Init

; 183  : 			{
; 184  : 				this->m_BridgeData[btBloodCastleIndex].m_nSaintStatuePosNum = n;

  003a6	0f b6 45 ea	 movzx	 eax, BYTE PTR _btBloodCastleIndex$236468[ebp]
  003aa	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  003b0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003b3	8b 55 f0	 mov	 edx, DWORD PTR _n$236445[ebp]
  003b6	89 94 01 8c 03
	00 00		 mov	 DWORD PTR [ecx+eax+908], edx

; 185  : 				continue;

  003bd	e9 e8 fe ff ff	 jmp	 $LN15@Init
$LN11@Init:

; 186  : 			}
; 187  : 			
; 188  : 			if ( wMonsterType == 131 )

  003c2	0f b7 45 ec	 movzx	 eax, WORD PTR _wMonsterType$236466[ebp]
  003c6	3d 83 00 00 00	 cmp	 eax, 131		; 00000083H
  003cb	75 1c		 jne	 SHORT $LN10@Init

; 189  : 			{
; 190  : 				this->m_BridgeData[btBloodCastleIndex].m_nCastleDoorPosNum = n;

  003cd	0f b6 45 ea	 movzx	 eax, BYTE PTR _btBloodCastleIndex$236468[ebp]
  003d1	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  003d7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003da	8b 55 f0	 mov	 edx, DWORD PTR _n$236445[ebp]
  003dd	89 94 01 90 03
	00 00		 mov	 DWORD PTR [ecx+eax+912], edx

; 191  : 				continue;

  003e4	e9 c1 fe ff ff	 jmp	 $LN15@Init
$LN10@Init:

; 192  : 			}
; 193  : 			
; 194  : 			if ( wMonsterType == 89 || wMonsterType == 95 || wMonsterType == 112 || wMonsterType == 118 || wMonsterType == 124 || wMonsterType == 130 || wMonsterType == 143 || wMonsterType == 433 )

  003e9	0f b7 45 ec	 movzx	 eax, WORD PTR _wMonsterType$236466[ebp]
  003ed	83 f8 59	 cmp	 eax, 89			; 00000059H
  003f0	74 45		 je	 SHORT $LN8@Init
  003f2	0f b7 45 ec	 movzx	 eax, WORD PTR _wMonsterType$236466[ebp]
  003f6	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  003f9	74 3c		 je	 SHORT $LN8@Init
  003fb	0f b7 45 ec	 movzx	 eax, WORD PTR _wMonsterType$236466[ebp]
  003ff	83 f8 70	 cmp	 eax, 112		; 00000070H
  00402	74 33		 je	 SHORT $LN8@Init
  00404	0f b7 45 ec	 movzx	 eax, WORD PTR _wMonsterType$236466[ebp]
  00408	83 f8 76	 cmp	 eax, 118		; 00000076H
  0040b	74 2a		 je	 SHORT $LN8@Init
  0040d	0f b7 45 ec	 movzx	 eax, WORD PTR _wMonsterType$236466[ebp]
  00411	83 f8 7c	 cmp	 eax, 124		; 0000007cH
  00414	74 21		 je	 SHORT $LN8@Init
  00416	0f b7 45 ec	 movzx	 eax, WORD PTR _wMonsterType$236466[ebp]
  0041a	3d 82 00 00 00	 cmp	 eax, 130		; 00000082H
  0041f	74 16		 je	 SHORT $LN8@Init
  00421	0f b7 45 ec	 movzx	 eax, WORD PTR _wMonsterType$236466[ebp]
  00425	3d 8f 00 00 00	 cmp	 eax, 143		; 0000008fH
  0042a	74 0b		 je	 SHORT $LN8@Init
  0042c	0f b7 45 ec	 movzx	 eax, WORD PTR _wMonsterType$236466[ebp]
  00430	3d b1 01 00 00	 cmp	 eax, 433		; 000001b1H
  00435	75 58		 jne	 SHORT $LN13@Init
$LN8@Init:

; 195  : 			{
; 196  : 				for ( int l=0;l<MAX_BLOOD_CASTLE_BOSS_MONSTER;l++)

  00437	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _l$236474[ebp], 0
  0043e	eb 09		 jmp	 SHORT $LN7@Init
$LN6@Init:
  00440	8b 45 e4	 mov	 eax, DWORD PTR _l$236474[ebp]
  00443	83 c0 01	 add	 eax, 1
  00446	89 45 e4	 mov	 DWORD PTR _l$236474[ebp], eax
$LN7@Init:
  00449	83 7d e4 14	 cmp	 DWORD PTR _l$236474[ebp], 20 ; 00000014H
  0044d	7d 40		 jge	 SHORT $LN13@Init

; 197  : 				{
; 198  : 					if ( this->m_BridgeData[btBloodCastleIndex].m_nBossMonsterPosNum[l] == -1 )

  0044f	0f b6 45 ea	 movzx	 eax, BYTE PTR _btBloodCastleIndex$236468[ebp]
  00453	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  00459	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0045c	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00460	8b 45 e4	 mov	 eax, DWORD PTR _l$236474[ebp]
  00463	83 bc 82 38 03
	00 00 ff	 cmp	 DWORD PTR [edx+eax*4+824], -1
  0046b	75 20		 jne	 SHORT $LN4@Init

; 199  : 					{
; 200  : 						this->m_BridgeData[btBloodCastleIndex].m_nBossMonsterPosNum[l] = n;

  0046d	0f b6 45 ea	 movzx	 eax, BYTE PTR _btBloodCastleIndex$236468[ebp]
  00471	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  00477	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0047a	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0047e	8b 45 e4	 mov	 eax, DWORD PTR _l$236474[ebp]
  00481	8b 4d f0	 mov	 ecx, DWORD PTR _n$236445[ebp]
  00484	89 8c 82 38 03
	00 00		 mov	 DWORD PTR [edx+eax*4+824], ecx

; 201  : 						break;

  0048b	eb 02		 jmp	 SHORT $LN13@Init
$LN4@Init:

; 202  : 					}
; 203  : 				}

  0048d	eb b1		 jmp	 SHORT $LN6@Init
$LN13@Init:

; 204  : 			}
; 205  : 		}
; 206  : 
; 207  : 	}

  0048f	e9 16 fe ff ff	 jmp	 $LN15@Init
$LN14@Init:

; 208  : 
; 209  : 	for (int i=0;i<MAX_BLOOD_CASTLE_LEVEL;i++)

  00494	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _i$236479[ebp], 0
  0049b	eb 09		 jmp	 SHORT $LN3@Init
$LN2@Init:
  0049d	8b 45 e0	 mov	 eax, DWORD PTR _i$236479[ebp]
  004a0	83 c0 01	 add	 eax, 1
  004a3	89 45 e0	 mov	 DWORD PTR _i$236479[ebp], eax
$LN3@Init:
  004a6	83 7d e0 08	 cmp	 DWORD PTR _i$236479[ebp], 8
  004aa	7d 10		 jge	 SHORT $LN23@Init

; 210  : 	{
; 211  : 		this->SetState(i, BC_STATE_CLOSED);

  004ac	6a 01		 push	 1
  004ae	8b 45 e0	 mov	 eax, DWORD PTR _i$236479[ebp]
  004b1	50		 push	 eax
  004b2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  004b5	e8 00 00 00 00	 call	 ?SetState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SetState

; 212  : 	}

  004ba	eb e1		 jmp	 SHORT $LN2@Init
$LN23@Init:

; 213  : }

  004bc	5f		 pop	 edi
  004bd	5e		 pop	 esi
  004be	5b		 pop	 ebx
  004bf	8b e5		 mov	 esp, ebp
  004c1	5d		 pop	 ebp
  004c2	c2 04 00	 ret	 4
?Init@CBloodCastle@@QAEX_N@Z ENDP			; CBloodCastle::Init
_TEXT	ENDS
PUBLIC	??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@	; `string'
PUBLIC	?push_back@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEXABUBLOODCASTLE_START_TIME@@@Z ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::push_back
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	??_C@_0CI@EIBEEFOB@?$FLBlood?5Castle?$FN?5Info?5file?5Load?5Fa@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	?Load@CBloodCastle@@QAEXPAD@Z			; CBloodCastle::Load
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	_fclose:PROC
EXTRN	_strcmp:PROC
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	_fopen:PROC
EXTRN	__ftol2_sse:PROC
_BSS	SEGMENT
_TokenString DB	064H DUP (?)
_TokenNumber DD	01H DUP (?)
_SMDFile DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@
CONST	SEGMENT
??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@ DB '%s file load!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@EIBEEFOB@?$FLBlood?5Castle?$FN?5Info?5file?5Load?5Fa@
CONST	SEGMENT
??_C@_0CI@EIBEEFOB@?$FLBlood?5Castle?$FN?5Info?5file?5Load?5Fa@ DB '[Bloo'
	DB	'd Castle] Info file Load Fail [%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv169 = -96						; size = 4
tv145 = -96						; size = 4
_Schedule$236529 = -28					; size = 8
_iBridgeNum$ = -20					; size = 4
_BridgeCount$ = -16					; size = 4
_type$ = -12						; size = 4
_Token$ = -8						; size = 4
_this$ = -4						; size = 4
_filename$ = 8						; size = 4
?Load@CBloodCastle@@QAEXPAD@Z PROC			; CBloodCastle::Load
; _this$ = ecx

; 216  : {

  004d0	55		 push	 ebp
  004d1	8b ec		 mov	 ebp, esp
  004d3	83 ec 60	 sub	 esp, 96			; 00000060H
  004d6	53		 push	 ebx
  004d7	56		 push	 esi
  004d8	57		 push	 edi
  004d9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 217  : 	int Token;
; 218  : 	int type;
; 219  : 	int BridgeCount;
; 220  : 	int iBridgeNum;
; 221  : 	SMDFile=fopen(filename, "r");

  004dc	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  004e1	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  004e4	50		 push	 eax
  004e5	e8 00 00 00 00	 call	 _fopen
  004ea	83 c4 08	 add	 esp, 8
  004ed	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax

; 222  : 
; 223  : 	if (SMDFile == 0)

  004f2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _SMDFile, 0
  004f9	75 16		 jne	 SHORT $LN24@Load

; 224  : 	{
; 225  : 		MsgBox("[Blood Castle] Info file Load Fail [%s]", filename);

  004fb	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  004fe	50		 push	 eax
  004ff	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@EIBEEFOB@?$FLBlood?5Castle?$FN?5Info?5file?5Load?5Fa@
  00504	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00509	83 c4 08	 add	 esp, 8

; 226  : 		return;

  0050c	e9 fd 02 00 00	 jmp	 $LN25@Load
$LN24@Load:

; 227  : 	}
; 228  : 
; 229  : 	type=-1;

  00511	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _type$[ebp], -1

; 230  : 	BridgeCount=-1;

  00518	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _BridgeCount$[ebp], -1
$LN23@Load:

; 231  : 
; 232  : 	while ( true )

  0051f	b8 01 00 00 00	 mov	 eax, 1
  00524	85 c0		 test	 eax, eax
  00526	0f 84 c2 02 00
	00		 je	 $LN22@Load

; 233  : 	{
; 234  : 		Token=GetToken();

  0052c	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00531	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 235  : 
; 236  : 		if ( Token == 2 )

  00534	83 7d f8 02	 cmp	 DWORD PTR _Token$[ebp], 2
  00538	75 05		 jne	 SHORT $LN21@Load

; 237  : 		{
; 238  : 			break;

  0053a	e9 af 02 00 00	 jmp	 $LN22@Load
$LN21@Load:

; 239  : 		}
; 240  : 
; 241  : 		type=(int)TokenNumber;

  0053f	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00545	e8 00 00 00 00	 call	 __ftol2_sse
  0054a	89 45 f4	 mov	 DWORD PTR _type$[ebp], eax
$LN20@Load:

; 242  : 
; 243  : 		while ( true )

  0054d	b8 01 00 00 00	 mov	 eax, 1
  00552	85 c0		 test	 eax, eax
  00554	0f 84 8f 02 00
	00		 je	 $LN19@Load

; 244  : 		{
; 245  : 			if ( type == 0 )

  0055a	83 7d f4 00	 cmp	 DWORD PTR _type$[ebp], 0
  0055e	75 74		 jne	 SHORT $LN18@Load

; 246  : 			{
; 247  : 				Token=GetToken();

  00560	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00565	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 248  : 
; 249  : 				if (strcmp("end", &TokenString[0]) == 0)

  00568	68 00 00 00 00	 push	 OFFSET _TokenString
  0056d	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  00572	e8 00 00 00 00	 call	 _strcmp
  00577	83 c4 08	 add	 esp, 8
  0057a	85 c0		 test	 eax, eax
  0057c	75 05		 jne	 SHORT $LN17@Load

; 250  : 				{
; 251  : 					break;

  0057e	e9 66 02 00 00	 jmp	 $LN19@Load
$LN17@Load:

; 252  : 				}
; 253  : 
; 254  : 				this->m_iBC_TIME_MIN_OPEN = (int)TokenNumber;

  00583	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00589	e8 00 00 00 00	 call	 __ftol2_sse
  0058e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00591	89 81 08 23 00
	00		 mov	 DWORD PTR [ecx+8968], eax

; 255  : 
; 256  : 				Token = GetToken();

  00597	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0059c	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 257  : 				this->m_iBC_TIME_MIN_PLAY =(int)TokenNumber;

  0059f	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  005a5	e8 00 00 00 00	 call	 __ftol2_sse
  005aa	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  005ad	89 81 0c 23 00
	00		 mov	 DWORD PTR [ecx+8972], eax

; 258  : 
; 259  : 				Token = GetToken();

  005b3	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  005b8	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 260  : 				this->m_iBC_TIME_MIN_REST = (int)TokenNumber;

  005bb	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  005c1	e8 00 00 00 00	 call	 __ftol2_sse
  005c6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  005c9	89 81 10 23 00
	00		 mov	 DWORD PTR [ecx+8976], eax
  005cf	e9 10 02 00 00	 jmp	 $LN2@Load
$LN18@Load:

; 261  : 			}
; 262  : 			else if ( type == 1 )

  005d4	83 7d f4 01	 cmp	 DWORD PTR _type$[ebp], 1
  005d8	75 74		 jne	 SHORT $LN15@Load

; 263  : 			{
; 264  : 				Token = GetToken();

  005da	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  005df	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 265  : 
; 266  : 				if (strcmp("end", &TokenString[0]) == 0)

  005e2	68 00 00 00 00	 push	 OFFSET _TokenString
  005e7	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  005ec	e8 00 00 00 00	 call	 _strcmp
  005f1	83 c4 08	 add	 esp, 8
  005f4	85 c0		 test	 eax, eax
  005f6	75 05		 jne	 SHORT $LN14@Load

; 267  : 				{
; 268  : 					break;

  005f8	e9 ec 01 00 00	 jmp	 $LN19@Load
$LN14@Load:

; 269  : 				}
; 270  : 
; 271  : 				this->m_iBC_NORMAL_ITEM_DROP = (int)TokenNumber;

  005fd	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00603	e8 00 00 00 00	 call	 __ftol2_sse
  00608	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0060b	89 81 14 23 00
	00		 mov	 DWORD PTR [ecx+8980], eax

; 272  : 
; 273  : 				Token = GetToken();

  00611	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00616	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 274  : 				this->m_iBC_EXCEL_ITEM_DROP = (int)TokenNumber;

  00619	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0061f	e8 00 00 00 00	 call	 __ftol2_sse
  00624	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00627	89 81 18 23 00
	00		 mov	 DWORD PTR [ecx+8984], eax

; 275  : 
; 276  : 				Token = GetToken();

  0062d	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00632	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 277  : 				this->m_iBC_MONSTER_REGEN = (int)TokenNumber;

  00635	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0063b	e8 00 00 00 00	 call	 __ftol2_sse
  00640	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00643	89 81 1c 23 00
	00		 mov	 DWORD PTR [ecx+8988], eax
  00649	e9 96 01 00 00	 jmp	 $LN2@Load
$LN15@Load:

; 278  : 			}
; 279  : 			else if ( type == 2 )

  0064e	83 7d f4 02	 cmp	 DWORD PTR _type$[ebp], 2
  00652	0f 85 ab 00 00
	00		 jne	 $LN12@Load

; 280  : 			{
; 281  : 				Token = GetToken();

  00658	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0065d	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 282  : 
; 283  : 				if (strcmp("end", &TokenString[0]) == 0)

  00660	68 00 00 00 00	 push	 OFFSET _TokenString
  00665	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  0066a	e8 00 00 00 00	 call	 _strcmp
  0066f	83 c4 08	 add	 esp, 8
  00672	85 c0		 test	 eax, eax
  00674	75 05		 jne	 SHORT $LN11@Load

; 284  : 				{
; 285  : 					break;

  00676	e9 6e 01 00 00	 jmp	 $LN19@Load
$LN11@Load:

; 286  : 				}
; 287  : 			
; 288  : 				iBridgeNum = (int)TokenNumber;

  0067b	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00681	e8 00 00 00 00	 call	 __ftol2_sse
  00686	89 45 ec	 mov	 DWORD PTR _iBridgeNum$[ebp], eax

; 289  : 
; 290  : 				if ( BC_BRIDGE_RANGE(iBridgeNum) != FALSE )

  00689	83 7d ec 00	 cmp	 DWORD PTR _iBridgeNum$[ebp], 0
  0068d	7d 09		 jge	 SHORT $LN27@Load
  0068f	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv145[ebp], 0
  00696	eb 0c		 jmp	 SHORT $LN28@Load
$LN27@Load:
  00698	33 c0		 xor	 eax, eax
  0069a	83 7d ec 07	 cmp	 DWORD PTR _iBridgeNum$[ebp], 7
  0069e	0f 9e c0	 setle	 al
  006a1	89 45 a0	 mov	 DWORD PTR tv145[ebp], eax
$LN28@Load:
  006a4	83 7d a0 00	 cmp	 DWORD PTR tv145[ebp], 0
  006a8	74 44		 je	 SHORT $LN10@Load

; 291  : 				{
; 292  : 					Token = GetToken();

  006aa	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  006af	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 293  : 					this->m_BridgeData[iBridgeNum].m_iCastleStatueHealth = TokenNumber;

  006b2	8b 45 ec	 mov	 eax, DWORD PTR _iBridgeNum$[ebp]
  006b5	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  006bb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  006be	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  006c4	d9 9c 01 c4 03
	00 00		 fstp	 DWORD PTR [ecx+eax+964]

; 294  : 
; 295  : 					Token = GetToken();

  006cb	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  006d0	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 296  : 					this->m_BridgeData[iBridgeNum].m_iCastleDoorHealth = TokenNumber;

  006d3	8b 45 ec	 mov	 eax, DWORD PTR _iBridgeNum$[ebp]
  006d6	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  006dc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  006df	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  006e5	d9 9c 01 c8 03
	00 00		 fstp	 DWORD PTR [ecx+eax+968]

; 297  : 				}
; 298  : 				else

  006ec	eb 10		 jmp	 SHORT $LN9@Load
$LN10@Load:

; 299  : 				{
; 300  : 					Token = GetToken();

  006ee	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  006f3	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 301  : 					Token = GetToken();

  006f6	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  006fb	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax
$LN9@Load:

; 302  : 				}

  006fe	e9 e1 00 00 00	 jmp	 $LN2@Load
$LN12@Load:

; 303  : 			}
; 304  : 			else if ( type == 3 )

  00703	83 7d f4 03	 cmp	 DWORD PTR _type$[ebp], 3
  00707	75 7f		 jne	 SHORT $LN7@Load

; 305  : 			{
; 306  : 				Token = GetToken();

  00709	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0070e	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 307  : 
; 308  : 				if (strcmp("end", &TokenString[0]) == 0)

  00711	68 00 00 00 00	 push	 OFFSET _TokenString
  00716	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  0071b	e8 00 00 00 00	 call	 _strcmp
  00720	83 c4 08	 add	 esp, 8
  00723	85 c0		 test	 eax, eax
  00725	75 05		 jne	 SHORT $LN6@Load

; 309  : 				{
; 310  : 					break;

  00727	e9 bd 00 00 00	 jmp	 $LN19@Load
$LN6@Load:

; 311  : 				}
; 312  : 			
; 313  : 				iBridgeNum = (int)TokenNumber;

  0072c	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00732	e8 00 00 00 00	 call	 __ftol2_sse
  00737	89 45 ec	 mov	 DWORD PTR _iBridgeNum$[ebp], eax

; 314  : 
; 315  : 				if ( BC_BRIDGE_RANGE(iBridgeNum) != FALSE )

  0073a	83 7d ec 00	 cmp	 DWORD PTR _iBridgeNum$[ebp], 0
  0073e	7d 09		 jge	 SHORT $LN29@Load
  00740	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv169[ebp], 0
  00747	eb 0c		 jmp	 SHORT $LN30@Load
$LN29@Load:
  00749	33 c0		 xor	 eax, eax
  0074b	83 7d ec 07	 cmp	 DWORD PTR _iBridgeNum$[ebp], 7
  0074f	0f 9e c0	 setle	 al
  00752	89 45 a0	 mov	 DWORD PTR tv169[ebp], eax
$LN30@Load:
  00755	83 7d a0 00	 cmp	 DWORD PTR tv169[ebp], 0
  00759	74 23		 je	 SHORT $LN5@Load

; 316  : 				{
; 317  : 					Token = GetToken();

  0075b	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00760	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 318  : 					this->m_BridgeData[iBridgeNum].m_iBC_REWARD_EXP = TokenNumber;

  00763	8b 45 ec	 mov	 eax, DWORD PTR _iBridgeNum$[ebp]
  00766	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0076c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0076f	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00775	d9 9c 01 60 04
	00 00		 fstp	 DWORD PTR [ecx+eax+1120]

; 319  : 				}
; 320  : 				else

  0077c	eb 08		 jmp	 SHORT $LN4@Load
$LN5@Load:

; 321  : 				{
; 322  : 					Token = GetToken();

  0077e	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00783	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax
$LN4@Load:

; 323  : 				}

  00786	eb 5c		 jmp	 SHORT $LN2@Load
$LN7@Load:

; 324  : 			}
; 325  : 			else if ( type == 4 )

  00788	83 7d f4 04	 cmp	 DWORD PTR _type$[ebp], 4
  0078c	75 56		 jne	 SHORT $LN2@Load

; 326  : 			{
; 327  : 				Token = GetToken();

  0078e	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00793	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 328  : 
; 329  : 				if (strcmp("end", &TokenString[0]) == 0)

  00796	68 00 00 00 00	 push	 OFFSET _TokenString
  0079b	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  007a0	e8 00 00 00 00	 call	 _strcmp
  007a5	83 c4 08	 add	 esp, 8
  007a8	85 c0		 test	 eax, eax
  007aa	75 02		 jne	 SHORT $LN1@Load

; 330  : 				{
; 331  : 					break;

  007ac	eb 3b		 jmp	 SHORT $LN19@Load
$LN1@Load:

; 332  : 				}
; 333  : 
; 334  : 				BLOODCASTLE_START_TIME Schedule;
; 335  : 
; 336  : 				Schedule.m_iHour = (int)TokenNumber;

  007ae	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  007b4	e8 00 00 00 00	 call	 __ftol2_sse
  007b9	89 45 e4	 mov	 DWORD PTR _Schedule$236529[ebp], eax

; 337  : 
; 338  : 				Token = GetToken();

  007bc	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  007c1	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 339  : 				Schedule.m_iMinute = (int)TokenNumber;

  007c4	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  007ca	e8 00 00 00 00	 call	 __ftol2_sse
  007cf	89 45 e8	 mov	 DWORD PTR _Schedule$236529[ebp+4], eax

; 340  : 
; 341  : 				this->m_listBloodCastleOpenTime.push_back(Schedule);

  007d2	8d 45 e4	 lea	 eax, DWORD PTR _Schedule$236529[ebp]
  007d5	50		 push	 eax
  007d6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  007d9	81 c1 20 23 00
	00		 add	 ecx, 8992		; 00002320H
  007df	e8 00 00 00 00	 call	 ?push_back@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEXABUBLOODCASTLE_START_TIME@@@Z ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::push_back
$LN2@Load:

; 342  : 			}
; 343  : 		}

  007e4	e9 64 fd ff ff	 jmp	 $LN20@Load
$LN19@Load:

; 344  : 	}

  007e9	e9 31 fd ff ff	 jmp	 $LN23@Load
$LN22@Load:

; 345  : 
; 346  : 	fclose(SMDFile);

  007ee	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  007f3	50		 push	 eax
  007f4	e8 00 00 00 00	 call	 _fclose
  007f9	83 c4 04	 add	 esp, 4

; 347  : 
; 348  : 	LogAdd("%s file load!", filename);

  007fc	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  007ff	50		 push	 eax
  00800	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@
  00805	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0080b	83 c4 08	 add	 esp, 8
$LN25@Load:

; 349  : }

  0080e	5f		 pop	 edi
  0080f	5e		 pop	 esi
  00810	5b		 pop	 ebx
  00811	8b e5		 mov	 esp, ebp
  00813	5d		 pop	 ebp
  00814	c2 04 00	 ret	 4
?Load@CBloodCastle@@QAEXPAD@Z ENDP			; CBloodCastle::Load
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_isalnum:PROC
EXTRN	_isalpha:PROC
EXTRN	_atof:PROC
EXTRN	_isdigit:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_isspace:PROC
EXTRN	_fgetc:PROC
_BSS	SEGMENT
_CurrentToken DD 01H DUP (?)
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\include\readscript.h
_BSS	ENDS
_TEXT	SEGMENT
tv90 = -180						; size = 4
_TempString$ = -112					; size = 100
_p$ = -12						; size = 4
_ch$ = -5						; size = 1
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken

; 24   : {

  00820	55		 push	 ebp
  00821	8b ec		 mov	 ebp, esp
  00823	81 ec b4 00 00
	00		 sub	 esp, 180		; 000000b4H
  00829	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0082e	33 c5		 xor	 eax, ebp
  00830	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00833	53		 push	 ebx
  00834	56		 push	 esi
  00835	57		 push	 edi

; 25   : 	char ch;
; 26   : 	char* p;
; 27   : 	char TempString[100];
; 28   : 
; 29   : 	TokenString[0]=0;

  00836	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _TokenString, 0
$LN31@GetToken:

; 30   : 
; 31   : 	do
; 32   : 	{
; 33   : 		if ((ch=fgetc(SMDFile)) == -1)

  0083d	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00842	50		 push	 eax
  00843	e8 00 00 00 00	 call	 _fgetc
  00848	83 c4 04	 add	 esp, 4
  0084b	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0084e	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00852	83 f9 ff	 cmp	 ecx, -1
  00855	75 0c		 jne	 SHORT $LN28@GetToken

; 34   : 		{
; 35   : 			return END;	// End of FILE (EOF)

  00857	b8 02 00 00 00	 mov	 eax, 2
  0085c	e9 f7 02 00 00	 jmp	 $LN32@GetToken

; 36   : 		}
; 37   : 		else

  00861	eb 5b		 jmp	 SHORT $LN22@GetToken
$LN28@GetToken:

; 38   : 		{	
; 39   : 			if (ch=='/')		// this is /

  00863	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00867	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  0086a	75 52		 jne	 SHORT $LN22@GetToken

; 40   : 			{
; 41   : 				if((ch=fgetc(SMDFile)) == '/')

  0086c	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00871	50		 push	 eax
  00872	e8 00 00 00 00	 call	 _fgetc
  00877	83 c4 04	 add	 esp, 4
  0087a	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0087d	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00881	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  00884	75 38		 jne	 SHORT $LN22@GetToken
$LN24@GetToken:

; 42   : 				{
; 43   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  00886	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  0088a	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0088d	74 1c		 je	 SHORT $LN23@GetToken
  0088f	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00893	83 f8 ff	 cmp	 eax, -1
  00896	74 13		 je	 SHORT $LN23@GetToken

; 44   : 					{
; 45   : 						ch=fgetc(SMDFile);

  00898	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0089d	50		 push	 eax
  0089e	e8 00 00 00 00	 call	 _fgetc
  008a3	83 c4 04	 add	 esp, 4
  008a6	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al

; 46   : 					}

  008a9	eb db		 jmp	 SHORT $LN24@GetToken
$LN23@GetToken:

; 47   : 	
; 48   : 					if (ch == -1)

  008ab	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  008af	83 f8 ff	 cmp	 eax, -1
  008b2	75 0a		 jne	 SHORT $LN22@GetToken

; 49   : 					{
; 50   : 						return END;	// End of FILE

  008b4	b8 02 00 00 00	 mov	 eax, 2
  008b9	e9 9a 02 00 00	 jmp	 $LN32@GetToken
$LN22@GetToken:

; 51   : 					}
; 52   : 				}
; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : 	while (isspace(ch) != 0);

  008be	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  008c2	50		 push	 eax
  008c3	e8 00 00 00 00	 call	 _isspace
  008c8	83 c4 04	 add	 esp, 4
  008cb	85 c0		 test	 eax, eax
  008cd	0f 85 6a ff ff
	ff		 jne	 $LN31@GetToken

; 57   : 
; 58   : 	
; 59   : 	switch(ch)

  008d3	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  008d7	89 85 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], eax
  008dd	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR tv90[ebp]
  008e3	83 e9 22	 sub	 ecx, 34			; 00000022H
  008e6	89 8d 4c ff ff
	ff		 mov	 DWORD PTR tv90[ebp], ecx
  008ec	83 bd 4c ff ff
	ff 5b		 cmp	 DWORD PTR tv90[ebp], 91	; 0000005bH
  008f3	0f 87 a3 01 00
	00		 ja	 $LN6@GetToken
  008f9	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR tv90[ebp]
  008ff	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN34@GetToken[edx]
  00906	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN35@GetToken[eax*4]
$LN19@GetToken:

; 60   : 	{
; 61   : 
; 62   : 	case 0x23:	// #
; 63   : 		return CurrentToken=COMMAND;

  0090d	c7 05 00 00 00
	00 23 00 00 00	 mov	 DWORD PTR _CurrentToken, 35 ; 00000023H
  00917	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  0091c	e9 37 02 00 00	 jmp	 $LN32@GetToken

; 64   : 		break;

  00921	e9 30 02 00 00	 jmp	 $LN20@GetToken
$LN18@GetToken:

; 65   : 	
; 66   : 	case 0x3B:	// ;
; 67   : 		return CurrentToken=SEMICOLON;

  00926	c7 05 00 00 00
	00 3b 00 00 00	 mov	 DWORD PTR _CurrentToken, 59 ; 0000003bH
  00930	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00935	e9 1e 02 00 00	 jmp	 $LN32@GetToken

; 68   : 		break;

  0093a	e9 17 02 00 00	 jmp	 $LN20@GetToken
$LN17@GetToken:

; 69   : 	
; 70   : 	case 0x2C:	// ,
; 71   : 
; 72   : 		return CurrentToken=COMMA;

  0093f	c7 05 00 00 00
	00 2c 00 00 00	 mov	 DWORD PTR _CurrentToken, 44 ; 0000002cH
  00949	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  0094e	e9 05 02 00 00	 jmp	 $LN32@GetToken

; 73   : 		break;

  00953	e9 fe 01 00 00	 jmp	 $LN20@GetToken
$LN16@GetToken:

; 74   : 	
; 75   : 	case 0x7B:	// {
; 76   : 		return CurrentToken = LP;

  00958	c7 05 00 00 00
	00 7b 00 00 00	 mov	 DWORD PTR _CurrentToken, 123 ; 0000007bH
  00962	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00967	e9 ec 01 00 00	 jmp	 $LN32@GetToken

; 77   : 		break;

  0096c	e9 e5 01 00 00	 jmp	 $LN20@GetToken
$LN15@GetToken:

; 78   : 
; 79   : 	case 0x7D:	// }
; 80   : 		return CurrentToken = RP;

  00971	c7 05 00 00 00
	00 7d 00 00 00	 mov	 DWORD PTR _CurrentToken, 125 ; 0000007dH
  0097b	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00980	e9 d3 01 00 00	 jmp	 $LN32@GetToken

; 81   : 		break;

  00985	e9 cc 01 00 00	 jmp	 $LN20@GetToken
$LN14@GetToken:

; 82   : 	// Nice Index Table :)	by Deathway
; 83   : 	// Numbers Case
; 84   : 	case 0x2D:	//-
; 85   : 	case 0x2E:	//.
; 86   : 	case '0':	//0
; 87   : 	case '1':	//1
; 88   : 	case '2':	//2
; 89   : 	case '3':	//3
; 90   : 	case '4':	//4		
; 91   : 	case '5':	//5
; 92   : 	case '6':	//6
; 93   : 	case '7':	//7
; 94   : 	case '8':	//8
; 95   : 	case '9':	//9
; 96   : 		ungetc(ch, SMDFile);

  0098a	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0098f	50		 push	 eax
  00990	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00994	51		 push	 ecx
  00995	e8 00 00 00 00	 call	 _ungetc
  0099a	83 c4 08	 add	 esp, 8

; 97   : 		p = TempString;

  0099d	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  009a0	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN13@GetToken:

; 98   : 		
; 99   : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  009a3	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  009a8	50		 push	 eax
  009a9	e8 00 00 00 00	 call	 _getc
  009ae	83 c4 04	 add	 esp, 4
  009b1	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  009b4	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  009b8	83 f9 ff	 cmp	 ecx, -1
  009bb	74 36		 je	 SHORT $LN12@GetToken
  009bd	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  009c1	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  009c4	74 1a		 je	 SHORT $LN11@GetToken
  009c6	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  009ca	50		 push	 eax
  009cb	e8 00 00 00 00	 call	 _isdigit
  009d0	83 c4 04	 add	 esp, 4
  009d3	85 c0		 test	 eax, eax
  009d5	75 09		 jne	 SHORT $LN11@GetToken
  009d7	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  009db	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  009de	75 13		 jne	 SHORT $LN12@GetToken
$LN11@GetToken:

; 100  : 		{
; 101  : 			*p = ch;	// Construct a String

  009e0	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  009e3	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  009e6	88 08		 mov	 BYTE PTR [eax], cl

; 102  : 			p++;

  009e8	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  009eb	83 c0 01	 add	 eax, 1
  009ee	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 103  : 		}		

  009f1	eb b0		 jmp	 SHORT $LN13@GetToken
$LN12@GetToken:

; 104  : 		*p = 0;

  009f3	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  009f6	c6 00 00	 mov	 BYTE PTR [eax], 0

; 105  : 		TokenNumber = atof( TempString);	// Select the first Byte as Main ID

  009f9	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  009fc	50		 push	 eax
  009fd	e8 00 00 00 00	 call	 _atof
  00a02	83 c4 04	 add	 esp, 4
  00a05	d9 1d 00 00 00
	00		 fstp	 DWORD PTR _TokenNumber

; 106  : 		return CurrentToken  = NUMBER ;

  00a0b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CurrentToken, 1
  00a15	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00a1a	e9 39 01 00 00	 jmp	 $LN32@GetToken

; 107  : 		break;

  00a1f	e9 32 01 00 00	 jmp	 $LN20@GetToken
$LN10@GetToken:

; 108  : 
; 109  : 	case '\"':	// "	String Case
; 110  : 		p=&TokenString[0];

  00a24	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString
$LN9@GetToken:

; 111  : 		
; 112  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  00a2b	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00a30	50		 push	 eax
  00a31	e8 00 00 00 00	 call	 _getc
  00a36	83 c4 04	 add	 esp, 4
  00a39	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00a3c	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00a40	83 f9 ff	 cmp	 ecx, -1
  00a43	74 1c		 je	 SHORT $LN8@GetToken
  00a45	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00a49	83 f8 22	 cmp	 eax, 34			; 00000022H
  00a4c	74 13		 je	 SHORT $LN8@GetToken

; 113  : 		{
; 114  : 			*p = ch;

  00a4e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00a51	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00a54	88 08		 mov	 BYTE PTR [eax], cl

; 115  : 			p++;

  00a56	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00a59	83 c0 01	 add	 eax, 1
  00a5c	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 116  : 		}

  00a5f	eb ca		 jmp	 SHORT $LN9@GetToken
$LN8@GetToken:

; 117  : 		if (ch != 0x22 )

  00a61	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00a65	83 f8 22	 cmp	 eax, 34			; 00000022H
  00a68	74 13		 je	 SHORT $LN7@GetToken

; 118  : 		{
; 119  : 			ungetc(ch, SMDFile);

  00a6a	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00a6f	50		 push	 eax
  00a70	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00a74	51		 push	 ecx
  00a75	e8 00 00 00 00	 call	 _ungetc
  00a7a	83 c4 08	 add	 esp, 8
$LN7@GetToken:

; 120  : 		}
; 121  : 		*p = 0;

  00a7d	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00a80	c6 00 00	 mov	 BYTE PTR [eax], 0

; 122  : 		return CurrentToken = NAME;

  00a83	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0
  00a8d	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00a92	e9 c1 00 00 00	 jmp	 $LN32@GetToken

; 123  : 		break;

  00a97	e9 ba 00 00 00	 jmp	 $LN20@GetToken
$LN6@GetToken:

; 124  : 
; 125  : 	default:	// Others
; 126  : 		if (isalpha(ch))

  00a9c	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00aa0	50		 push	 eax
  00aa1	e8 00 00 00 00	 call	 _isalpha
  00aa6	83 c4 04	 add	 esp, 4
  00aa9	85 c0		 test	 eax, eax
  00aab	0f 84 94 00 00
	00		 je	 $LN5@GetToken

; 127  : 		{
; 128  : 			p=&TokenString[0];

  00ab1	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET _TokenString

; 129  : 			*p=ch;

  00ab8	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00abb	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00abe	88 08		 mov	 BYTE PTR [eax], cl

; 130  : 			p++;

  00ac0	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00ac3	83 c0 01	 add	 eax, 1
  00ac6	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN4@GetToken:

; 131  : 
; 132  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  00ac9	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00ace	50		 push	 eax
  00acf	e8 00 00 00 00	 call	 _getc
  00ad4	83 c4 04	 add	 esp, 4
  00ad7	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00ada	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00ade	83 f9 ff	 cmp	 ecx, -1
  00ae1	74 36		 je	 SHORT $LN3@GetToken
  00ae3	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00ae7	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  00aea	74 1a		 je	 SHORT $LN2@GetToken
  00aec	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00af0	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  00af3	74 11		 je	 SHORT $LN2@GetToken
  00af5	0f be 45 fb	 movsx	 eax, BYTE PTR _ch$[ebp]
  00af9	50		 push	 eax
  00afa	e8 00 00 00 00	 call	 _isalnum
  00aff	83 c4 04	 add	 esp, 4
  00b02	85 c0		 test	 eax, eax
  00b04	74 13		 je	 SHORT $LN3@GetToken
$LN2@GetToken:

; 133  : 			{
; 134  : 				*p=ch;

  00b06	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00b09	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00b0c	88 08		 mov	 BYTE PTR [eax], cl

; 135  : 				p++;

  00b0e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00b11	83 c0 01	 add	 eax, 1
  00b14	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 136  : 				
; 137  : 			}

  00b17	eb b0		 jmp	 SHORT $LN4@GetToken
$LN3@GetToken:

; 138  : 
; 139  : 			ungetc(ch, SMDFile);

  00b19	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00b1e	50		 push	 eax
  00b1f	0f be 4d fb	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00b23	51		 push	 ecx
  00b24	e8 00 00 00 00	 call	 _ungetc
  00b29	83 c4 08	 add	 esp, 8

; 140  : 			*p=0;

  00b2c	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00b2f	c6 00 00	 mov	 BYTE PTR [eax], 0

; 141  : 			CurrentToken=NAME;

  00b32	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0

; 142  : 			return CurrentToken;

  00b3c	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00b41	eb 15		 jmp	 SHORT $LN32@GetToken

; 143  : 		}
; 144  : 		else

  00b43	eb 11		 jmp	 SHORT $LN1@GetToken
$LN5@GetToken:

; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'

  00b45	c7 05 00 00 00
	00 3c 00 00 00	 mov	 DWORD PTR _CurrentToken, 60 ; 0000003cH
  00b4f	a1 00 00 00 00	 mov	 eax, DWORD PTR _CurrentToken
  00b54	eb 02		 jmp	 SHORT $LN32@GetToken
$LN1@GetToken:
$LN20@GetToken:

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;

  00b56	33 c0		 xor	 eax, eax
$LN32@GetToken:

; 153  : }

  00b58	5f		 pop	 edi
  00b59	5e		 pop	 esi
  00b5a	5b		 pop	 ebx
  00b5b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00b5e	33 cd		 xor	 ecx, ebp
  00b60	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00b65	8b e5		 mov	 esp, ebp
  00b67	5d		 pop	 ebp
  00b68	c3		 ret	 0
  00b69	8d 49 00	 npad	 3
$LN35@GetToken:
  00b6c	00 00 00 00	 DD	 $LN10@GetToken
  00b70	00 00 00 00	 DD	 $LN19@GetToken
  00b74	00 00 00 00	 DD	 $LN17@GetToken
  00b78	00 00 00 00	 DD	 $LN14@GetToken
  00b7c	00 00 00 00	 DD	 $LN18@GetToken
  00b80	00 00 00 00	 DD	 $LN16@GetToken
  00b84	00 00 00 00	 DD	 $LN15@GetToken
  00b88	00 00 00 00	 DD	 $LN6@GetToken
$LN34@GetToken:
  00b8c	00		 DB	 0
  00b8d	01		 DB	 1
  00b8e	07		 DB	 7
  00b8f	07		 DB	 7
  00b90	07		 DB	 7
  00b91	07		 DB	 7
  00b92	07		 DB	 7
  00b93	07		 DB	 7
  00b94	07		 DB	 7
  00b95	07		 DB	 7
  00b96	02		 DB	 2
  00b97	03		 DB	 3
  00b98	03		 DB	 3
  00b99	07		 DB	 7
  00b9a	03		 DB	 3
  00b9b	03		 DB	 3
  00b9c	03		 DB	 3
  00b9d	03		 DB	 3
  00b9e	03		 DB	 3
  00b9f	03		 DB	 3
  00ba0	03		 DB	 3
  00ba1	03		 DB	 3
  00ba2	03		 DB	 3
  00ba3	03		 DB	 3
  00ba4	07		 DB	 7
  00ba5	04		 DB	 4
  00ba6	07		 DB	 7
  00ba7	07		 DB	 7
  00ba8	07		 DB	 7
  00ba9	07		 DB	 7
  00baa	07		 DB	 7
  00bab	07		 DB	 7
  00bac	07		 DB	 7
  00bad	07		 DB	 7
  00bae	07		 DB	 7
  00baf	07		 DB	 7
  00bb0	07		 DB	 7
  00bb1	07		 DB	 7
  00bb2	07		 DB	 7
  00bb3	07		 DB	 7
  00bb4	07		 DB	 7
  00bb5	07		 DB	 7
  00bb6	07		 DB	 7
  00bb7	07		 DB	 7
  00bb8	07		 DB	 7
  00bb9	07		 DB	 7
  00bba	07		 DB	 7
  00bbb	07		 DB	 7
  00bbc	07		 DB	 7
  00bbd	07		 DB	 7
  00bbe	07		 DB	 7
  00bbf	07		 DB	 7
  00bc0	07		 DB	 7
  00bc1	07		 DB	 7
  00bc2	07		 DB	 7
  00bc3	07		 DB	 7
  00bc4	07		 DB	 7
  00bc5	07		 DB	 7
  00bc6	07		 DB	 7
  00bc7	07		 DB	 7
  00bc8	07		 DB	 7
  00bc9	07		 DB	 7
  00bca	07		 DB	 7
  00bcb	07		 DB	 7
  00bcc	07		 DB	 7
  00bcd	07		 DB	 7
  00bce	07		 DB	 7
  00bcf	07		 DB	 7
  00bd0	07		 DB	 7
  00bd1	07		 DB	 7
  00bd2	07		 DB	 7
  00bd3	07		 DB	 7
  00bd4	07		 DB	 7
  00bd5	07		 DB	 7
  00bd6	07		 DB	 7
  00bd7	07		 DB	 7
  00bd8	07		 DB	 7
  00bd9	07		 DB	 7
  00bda	07		 DB	 7
  00bdb	07		 DB	 7
  00bdc	07		 DB	 7
  00bdd	07		 DB	 7
  00bde	07		 DB	 7
  00bdf	07		 DB	 7
  00be0	07		 DB	 7
  00be1	07		 DB	 7
  00be2	07		 DB	 7
  00be3	07		 DB	 7
  00be4	07		 DB	 7
  00be5	05		 DB	 5
  00be6	07		 DB	 7
  00be7	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
PUBLIC	??_C@_0O@FHPHMJJK@StoneItemDrop?$AA@		; `string'
PUBLIC	??_C@_0O@PBCFFJJH@StoneDropRate?$AA@		; `string'
PUBLIC	??_C@_0BC@NGLLHLOE@BloodBoneDropRate?$AA@	; `string'
PUBLIC	??_C@_0BI@KPDDGOOE@AngelKingsPaperDropRate?$AA@	; `string'
PUBLIC	??_C@_0P@EMJDPFDH@GameServerInfo?$AA@		; `string'
PUBLIC	??_C@_0BB@DHAFCNAC@BloodCastleEvent?$AA@	; `string'
PUBLIC	??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@	; `string'
PUBLIC	?LoadItemDropRate@CBloodCastle@@QAEXXZ		; CBloodCastle::LoadItemDropRate
EXTRN	?g_bStoneItemDrop@@3HA:DWORD			; g_bStoneItemDrop
EXTRN	?g_iStoneDropRate@@3HA:DWORD			; g_iStoneDropRate
EXTRN	?g_iBloodBoneDropRate@@3HA:DWORD		; g_iBloodBoneDropRate
EXTRN	?g_iAngelKingsPaperDropRate@@3HA:DWORD		; g_iAngelKingsPaperDropRate
EXTRN	?g_bBloodCastle@@3HA:DWORD			; g_bBloodCastle
EXTRN	__imp__GetPrivateProfileIntA@16:PROC
EXTRN	?GetNewPath@CDirPath@@QAEPADPAD@Z:PROC		; CDirPath::GetNewPath
EXTRN	?gDirPath@@3VCDirPath@@A:BYTE			; gDirPath
;	COMDAT ??_C@_0O@FHPHMJJK@StoneItemDrop?$AA@
; File d:\projects\exteam6.3\source\gameserver\gameserver\bloodcastle.cpp
CONST	SEGMENT
??_C@_0O@FHPHMJJK@StoneItemDrop?$AA@ DB 'StoneItemDrop', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PBCFFJJH@StoneDropRate?$AA@
CONST	SEGMENT
??_C@_0O@PBCFFJJH@StoneDropRate?$AA@ DB 'StoneDropRate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NGLLHLOE@BloodBoneDropRate?$AA@
CONST	SEGMENT
??_C@_0BC@NGLLHLOE@BloodBoneDropRate?$AA@ DB 'BloodBoneDropRate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KPDDGOOE@AngelKingsPaperDropRate?$AA@
CONST	SEGMENT
??_C@_0BI@KPDDGOOE@AngelKingsPaperDropRate?$AA@ DB 'AngelKingsPaperDropRa'
	DB	'te', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
CONST	SEGMENT
??_C@_0P@EMJDPFDH@GameServerInfo?$AA@ DB 'GameServerInfo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DHAFCNAC@BloodCastleEvent?$AA@
CONST	SEGMENT
??_C@_0BB@DHAFCNAC@BloodCastleEvent?$AA@ DB 'BloodCastleEvent', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
CONST	SEGMENT
??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@ DB 'commonserver.cfg', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
?LoadItemDropRate@CBloodCastle@@QAEXXZ PROC		; CBloodCastle::LoadItemDropRate
; _this$ = ecx

; 352  : {

  00bf0	55		 push	 ebp
  00bf1	8b ec		 mov	 ebp, esp
  00bf3	83 ec 44	 sub	 esp, 68			; 00000044H
  00bf6	53		 push	 ebx
  00bf7	56		 push	 esi
  00bf8	57		 push	 edi
  00bf9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 353  : 	g_bBloodCastle=GetPrivateProfileInt(COMMONSERVER_MAINSECTION, "BloodCastleEvent", 0, gDirPath.GetNewPath(COMMONSERVER_FILE));

  00bfc	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  00c01	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00c06	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00c0b	50		 push	 eax
  00c0c	6a 00		 push	 0
  00c0e	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@DHAFCNAC@BloodCastleEvent?$AA@
  00c13	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  00c18	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  00c1e	a3 00 00 00 00	 mov	 DWORD PTR ?g_bBloodCastle@@3HA, eax ; g_bBloodCastle

; 354  : 	g_iAngelKingsPaperDropRate=GetPrivateProfileInt(COMMONSERVER_MAINSECTION, "AngelKingsPaperDropRate", 0, gDirPath.GetNewPath(COMMONSERVER_FILE));

  00c23	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  00c28	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00c2d	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00c32	50		 push	 eax
  00c33	6a 00		 push	 0
  00c35	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@KPDDGOOE@AngelKingsPaperDropRate?$AA@
  00c3a	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  00c3f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  00c45	a3 00 00 00 00	 mov	 DWORD PTR ?g_iAngelKingsPaperDropRate@@3HA, eax ; g_iAngelKingsPaperDropRate

; 355  : 	g_iBloodBoneDropRate=GetPrivateProfileInt(COMMONSERVER_MAINSECTION, "BloodBoneDropRate", 0, gDirPath.GetNewPath(COMMONSERVER_FILE));

  00c4a	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  00c4f	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00c54	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00c59	50		 push	 eax
  00c5a	6a 00		 push	 0
  00c5c	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@NGLLHLOE@BloodBoneDropRate?$AA@
  00c61	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  00c66	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  00c6c	a3 00 00 00 00	 mov	 DWORD PTR ?g_iBloodBoneDropRate@@3HA, eax ; g_iBloodBoneDropRate

; 356  : 	g_iStoneDropRate=GetPrivateProfileInt(COMMONSERVER_MAINSECTION, "StoneDropRate", 0, gDirPath.GetNewPath(COMMONSERVER_FILE));

  00c71	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  00c76	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00c7b	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00c80	50		 push	 eax
  00c81	6a 00		 push	 0
  00c83	68 00 00 00 00	 push	 OFFSET ??_C@_0O@PBCFFJJH@StoneDropRate?$AA@
  00c88	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  00c8d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  00c93	a3 00 00 00 00	 mov	 DWORD PTR ?g_iStoneDropRate@@3HA, eax ; g_iStoneDropRate

; 357  : 	g_bStoneItemDrop=GetPrivateProfileInt(COMMONSERVER_MAINSECTION, "StoneItemDrop", 0, gDirPath.GetNewPath(COMMONSERVER_FILE));

  00c98	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  00c9d	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00ca2	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00ca7	50		 push	 eax
  00ca8	6a 00		 push	 0
  00caa	68 00 00 00 00	 push	 OFFSET ??_C@_0O@FHPHMJJK@StoneItemDrop?$AA@
  00caf	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  00cb4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  00cba	a3 00 00 00 00	 mov	 DWORD PTR ?g_bStoneItemDrop@@3HA, eax ; g_bStoneItemDrop

; 358  : }

  00cbf	5f		 pop	 edi
  00cc0	5e		 pop	 esi
  00cc1	5b		 pop	 ebx
  00cc2	8b e5		 mov	 esp, ebp
  00cc4	5d		 pop	 ebp
  00cc5	c3		 ret	 0
?LoadItemDropRate@CBloodCastle@@QAEXXZ ENDP		; CBloodCastle::LoadItemDropRate
_TEXT	ENDS
PUBLIC	??_C@_0DE@JOEGJLEF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Sync?5Open?5Ti@ ; `string'
PUBLIC	??E?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator++
PUBLIC	??8?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator==
PUBLIC	??9?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator!=
PUBLIC	?end@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@2@XZ ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::end
PUBLIC	??E?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator++
PUBLIC	??D?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBEAAUBLOODCASTLE_START_TIME@@XZ ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator*
PUBLIC	?begin@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@2@XZ ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::begin
PUBLIC	??_C@_0CJ@HNEOPLMK@Error?5?3?5Blood?5Castle?5StartTime?5s@ ; `string'
PUBLIC	?size@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QBEIXZ ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::size
PUBLIC	??0?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE@XZ ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >
PUBLIC	?CheckSync@CBloodCastle@@IAEXH@Z		; CBloodCastle::CheckSync
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	__imp__GetTickCount@0:PROC
;	COMDAT ??_C@_0DE@JOEGJLEF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Sync?5Open?5Ti@
CONST	SEGMENT
??_C@_0DE@JOEGJLEF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Sync?5Open?5Ti@ DB '['
	DB	'Blood Castle] (%d) Sync Open Time. [%d] min remain', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@HNEOPLMK@Error?5?3?5Blood?5Castle?5StartTime?5s@
CONST	SEGMENT
??_C@_0CJ@HNEOPLMK@Error?5?3?5Blood?5Castle?5StartTime?5s@ DB 'Error : Bl'
	DB	'ood Castle StartTime size is 0', 00H	; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv67 = -152						; size = 4
$T239139 = -148						; size = 4
$T239140 = -144						; size = 4
$T239141 = -140						; size = 4
$T239142 = -136						; size = 4
$T239143 = -132						; size = 4
$T239144 = -128						; size = 4
$T239145 = -124						; size = 4
_loc13$ = -56						; size = 4
_loc12$ = -52						; size = 4
_ltime$ = -48						; size = 8
_today$ = -40						; size = 4
_CurrentTime$ = -36					; size = 4
_CheckTime$ = -32					; size = 4
_BaseTime$ = -28					; size = 4
_WebzenVar2$ = -24					; size = 8
_WebzenVar1$ = -16					; size = 8
_it$ = -8						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?CheckSync@CBloodCastle@@IAEXH@Z PROC			; CBloodCastle::CheckSync
; _this$ = ecx

; 361  : {

  00cd0	55		 push	 ebp
  00cd1	8b ec		 mov	 ebp, esp
  00cd3	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H
  00cd9	53		 push	 ebx
  00cda	56		 push	 esi
  00cdb	57		 push	 edi
  00cdc	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 362  : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00cdf	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  00ce3	7d 0c		 jge	 SHORT $LN20@CheckSync
  00ce5	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv67[ebp], 0
  00cef	eb 0f		 jmp	 SHORT $LN21@CheckSync
$LN20@CheckSync:
  00cf1	33 c0		 xor	 eax, eax
  00cf3	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  00cf7	0f 9e c0	 setle	 al
  00cfa	89 85 68 ff ff
	ff		 mov	 DWORD PTR tv67[ebp], eax
$LN21@CheckSync:
  00d00	83 bd 68 ff ff
	ff 00		 cmp	 DWORD PTR tv67[ebp], 0
  00d07	75 05		 jne	 SHORT $LN17@CheckSync

; 363  : 	{
; 364  : 		return;

  00d09	e9 2c 03 00 00	 jmp	 $LN18@CheckSync
$LN17@CheckSync:

; 365  : 	}
; 366  : 
; 367  : 	std::list<BLOODCASTLE_START_TIME>::iterator it;

  00d0e	8d 4d f8	 lea	 ecx, DWORD PTR _it$[ebp]
  00d11	e8 00 00 00 00	 call	 ??0?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE@XZ ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >

; 368  : 	BLOODCASTLE_START_TIME WebzenVar1;
; 369  : 	BLOODCASTLE_START_TIME WebzenVar2;
; 370  : 	int BaseTime = 0; //7

  00d16	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _BaseTime$[ebp], 0

; 371  : 	int CheckTime = 0; //8

  00d1d	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _CheckTime$[ebp], 0

; 372  : 	DWORD CurrentTime = 0; //9

  00d24	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _CurrentTime$[ebp], 0

; 373  : 	
; 374  : 	tm * today; //10
; 375  : 	time_t ltime; //11
; 376  : 
; 377  : 	int loc12;
; 378  : 	int loc13;
; 379  : 
; 380  : 	this->m_BridgeData[iBridgeIndex].m_iBC_TICK_COUNT = GetTickCount();

  00d2b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00d31	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  00d34	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  00d3a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00d3d	89 84 0a b0 03
	00 00		 mov	 DWORD PTR [edx+ecx+944], eax

; 381  : 
; 382  : 	if(this->m_listBloodCastleOpenTime.size() == 0)

  00d44	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00d47	81 c1 20 23 00
	00		 add	 ecx, 8992		; 00002320H
  00d4d	e8 00 00 00 00	 call	 ?size@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QBEIXZ ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::size
  00d52	85 c0		 test	 eax, eax
  00d54	75 12		 jne	 SHORT $LN16@CheckSync

; 383  : 	{
; 384  : 		MsgBox("Error : Blood Castle StartTime size is 0");

  00d56	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@HNEOPLMK@Error?5?3?5Blood?5Castle?5StartTime?5s@
  00d5b	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00d60	83 c4 04	 add	 esp, 4

; 385  : 		return;

  00d63	e9 d2 02 00 00	 jmp	 $LN18@CheckSync
$LN16@CheckSync:

; 386  : 	}
; 387  : 
; 388  : 	time(&ltime);

  00d68	8d 45 d0	 lea	 eax, DWORD PTR _ltime$[ebp]
  00d6b	50		 push	 eax
  00d6c	e8 00 00 00 00	 call	 _time
  00d71	83 c4 04	 add	 esp, 4

; 389  : 	today = localtime(&ltime);

  00d74	8d 45 d0	 lea	 eax, DWORD PTR _ltime$[ebp]
  00d77	50		 push	 eax
  00d78	e8 00 00 00 00	 call	 _localtime
  00d7d	83 c4 04	 add	 esp, 4
  00d80	89 45 d8	 mov	 DWORD PTR _today$[ebp], eax

; 390  : 
; 391  : 	
; 392  : 	CurrentTime = (today->tm_hour * 60) + today->tm_min;

  00d83	8b 45 d8	 mov	 eax, DWORD PTR _today$[ebp]
  00d86	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00d89	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  00d8c	8b 55 d8	 mov	 edx, DWORD PTR _today$[ebp]
  00d8f	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00d92	89 4d dc	 mov	 DWORD PTR _CurrentTime$[ebp], ecx

; 393  : 	WebzenVar1 = *this->m_listBloodCastleOpenTime.begin();

  00d95	8d 85 6c ff ff
	ff		 lea	 eax, DWORD PTR $T239139[ebp]
  00d9b	50		 push	 eax
  00d9c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00d9f	81 c1 20 23 00
	00		 add	 ecx, 8992		; 00002320H
  00da5	e8 00 00 00 00	 call	 ?begin@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@2@XZ ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::begin
  00daa	8b c8		 mov	 ecx, eax
  00dac	e8 00 00 00 00	 call	 ??D?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBEAAUBLOODCASTLE_START_TIME@@XZ ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator*
  00db1	8b 08		 mov	 ecx, DWORD PTR [eax]
  00db3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00db6	89 4d f0	 mov	 DWORD PTR _WebzenVar1$[ebp], ecx
  00db9	89 55 f4	 mov	 DWORD PTR _WebzenVar1$[ebp+4], edx

; 394  : 
; 395  : 	for( it = this->m_listBloodCastleOpenTime.begin(); it != this->m_listBloodCastleOpenTime.end(); ++it )

  00dbc	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR $T239140[ebp]
  00dc2	50		 push	 eax
  00dc3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00dc6	81 c1 20 23 00
	00		 add	 ecx, 8992		; 00002320H
  00dcc	e8 00 00 00 00	 call	 ?begin@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@2@XZ ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::begin
  00dd1	8b 08		 mov	 ecx, DWORD PTR [eax]
  00dd3	89 4d f8	 mov	 DWORD PTR _it$[ebp], ecx
  00dd6	eb 08		 jmp	 SHORT $LN15@CheckSync
$LN14@CheckSync:
  00dd8	8d 4d f8	 lea	 ecx, DWORD PTR _it$[ebp]
  00ddb	e8 00 00 00 00	 call	 ??E?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator++
$LN15@CheckSync:
  00de0	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR $T239141[ebp]
  00de6	50		 push	 eax
  00de7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00dea	81 c1 20 23 00
	00		 add	 ecx, 8992		; 00002320H
  00df0	e8 00 00 00 00	 call	 ?end@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@2@XZ ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::end
  00df5	50		 push	 eax
  00df6	8d 4d f8	 lea	 ecx, DWORD PTR _it$[ebp]
  00df9	e8 00 00 00 00	 call	 ??9?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator!=
  00dfe	0f b6 c8	 movzx	 ecx, al
  00e01	85 c9		 test	 ecx, ecx
  00e03	74 7e		 je	 SHORT $LN13@CheckSync

; 396  : 	{
; 397  : 		WebzenVar2 = *it;

  00e05	8d 4d f8	 lea	 ecx, DWORD PTR _it$[ebp]
  00e08	e8 00 00 00 00	 call	 ??D?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBEAAUBLOODCASTLE_START_TIME@@XZ ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator*
  00e0d	8b 08		 mov	 ecx, DWORD PTR [eax]
  00e0f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00e12	89 4d e8	 mov	 DWORD PTR _WebzenVar2$[ebp], ecx
  00e15	89 55 ec	 mov	 DWORD PTR _WebzenVar2$[ebp+4], edx

; 398  : 		BaseTime = (WebzenVar1.m_iHour * 60) + WebzenVar1.m_iMinute;

  00e18	8b 45 f0	 mov	 eax, DWORD PTR _WebzenVar1$[ebp]
  00e1b	6b c0 3c	 imul	 eax, 60			; 0000003cH
  00e1e	03 45 f4	 add	 eax, DWORD PTR _WebzenVar1$[ebp+4]
  00e21	89 45 e4	 mov	 DWORD PTR _BaseTime$[ebp], eax

; 399  : 		CheckTime =	(WebzenVar2.m_iHour * 60) + WebzenVar2.m_iMinute;

  00e24	8b 45 e8	 mov	 eax, DWORD PTR _WebzenVar2$[ebp]
  00e27	6b c0 3c	 imul	 eax, 60			; 0000003cH
  00e2a	03 45 ec	 add	 eax, DWORD PTR _WebzenVar2$[ebp+4]
  00e2d	89 45 e0	 mov	 DWORD PTR _CheckTime$[ebp], eax

; 400  : 
; 401  : 		if( BaseTime == CheckTime )

  00e30	8b 45 e4	 mov	 eax, DWORD PTR _BaseTime$[ebp]
  00e33	3b 45 e0	 cmp	 eax, DWORD PTR _CheckTime$[ebp]
  00e36	75 1f		 jne	 SHORT $LN12@CheckSync

; 402  : 		{
; 403  : 			if( CurrentTime < CheckTime )

  00e38	8b 45 dc	 mov	 eax, DWORD PTR _CurrentTime$[ebp]
  00e3b	3b 45 e0	 cmp	 eax, DWORD PTR _CheckTime$[ebp]
  00e3e	73 15		 jae	 SHORT $LN11@CheckSync

; 404  : 			{
; 405  : 				WebzenVar2 = *it;

  00e40	8d 4d f8	 lea	 ecx, DWORD PTR _it$[ebp]
  00e43	e8 00 00 00 00	 call	 ??D?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBEAAUBLOODCASTLE_START_TIME@@XZ ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator*
  00e48	8b 08		 mov	 ecx, DWORD PTR [eax]
  00e4a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00e4d	89 4d e8	 mov	 DWORD PTR _WebzenVar2$[ebp], ecx
  00e50	89 55 ec	 mov	 DWORD PTR _WebzenVar2$[ebp+4], edx

; 406  : 				break;

  00e53	eb 2e		 jmp	 SHORT $LN13@CheckSync
$LN11@CheckSync:

; 407  : 			}
; 408  : 			continue;

  00e55	eb 81		 jmp	 SHORT $LN14@CheckSync
$LN12@CheckSync:

; 409  : 		}
; 410  : 		
; 411  : 		if( CurrentTime >= BaseTime && CurrentTime < CheckTime )

  00e57	8b 45 dc	 mov	 eax, DWORD PTR _CurrentTime$[ebp]
  00e5a	3b 45 e4	 cmp	 eax, DWORD PTR _BaseTime$[ebp]
  00e5d	72 0c		 jb	 SHORT $LN10@CheckSync
  00e5f	8b 45 dc	 mov	 eax, DWORD PTR _CurrentTime$[ebp]
  00e62	3b 45 e0	 cmp	 eax, DWORD PTR _CheckTime$[ebp]
  00e65	73 04		 jae	 SHORT $LN10@CheckSync

; 412  : 		{
; 413  : 			break;

  00e67	eb 1a		 jmp	 SHORT $LN13@CheckSync

; 414  : 		}
; 415  : 		else

  00e69	eb 13		 jmp	 SHORT $LN9@CheckSync
$LN10@CheckSync:

; 416  : 		{
; 417  : 			WebzenVar1 = *it;

  00e6b	8d 4d f8	 lea	 ecx, DWORD PTR _it$[ebp]
  00e6e	e8 00 00 00 00	 call	 ??D?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBEAAUBLOODCASTLE_START_TIME@@XZ ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator*
  00e73	8b 08		 mov	 ecx, DWORD PTR [eax]
  00e75	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00e78	89 4d f0	 mov	 DWORD PTR _WebzenVar1$[ebp], ecx
  00e7b	89 55 f4	 mov	 DWORD PTR _WebzenVar1$[ebp+4], edx
$LN9@CheckSync:

; 418  : 		}
; 419  : 	}

  00e7e	e9 55 ff ff ff	 jmp	 $LN14@CheckSync
$LN13@CheckSync:

; 420  : 
; 421  : 	for(loc12 = 2;loc12--;)

  00e83	c7 45 cc 02 00
	00 00		 mov	 DWORD PTR _loc12$[ebp], 2
$LN8@CheckSync:
  00e8a	8b 45 cc	 mov	 eax, DWORD PTR _loc12$[ebp]
  00e8d	8b 4d cc	 mov	 ecx, DWORD PTR _loc12$[ebp]
  00e90	83 e9 01	 sub	 ecx, 1
  00e93	89 4d cc	 mov	 DWORD PTR _loc12$[ebp], ecx
  00e96	85 c0		 test	 eax, eax
  00e98	0f 84 2f 01 00
	00		 je	 $LN7@CheckSync

; 422  : 	{
; 423  : 		if(it == this->m_listBloodCastleOpenTime.end())

  00e9e	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR $T239142[ebp]
  00ea4	50		 push	 eax
  00ea5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00ea8	81 c1 20 23 00
	00		 add	 ecx, 8992		; 00002320H
  00eae	e8 00 00 00 00	 call	 ?end@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@2@XZ ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::end
  00eb3	50		 push	 eax
  00eb4	8d 4d f8	 lea	 ecx, DWORD PTR _it$[ebp]
  00eb7	e8 00 00 00 00	 call	 ??8?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator==
  00ebc	0f b6 c8	 movzx	 ecx, al
  00ebf	85 c9		 test	 ecx, ecx
  00ec1	74 2d		 je	 SHORT $LN6@CheckSync

; 424  : 		{
; 425  : 			it = this->m_listBloodCastleOpenTime.begin();

  00ec3	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR $T239143[ebp]
  00ec9	50		 push	 eax
  00eca	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00ecd	81 c1 20 23 00
	00		 add	 ecx, 8992		; 00002320H
  00ed3	e8 00 00 00 00	 call	 ?begin@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@2@XZ ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::begin
  00ed8	8b 08		 mov	 ecx, DWORD PTR [eax]
  00eda	89 4d f8	 mov	 DWORD PTR _it$[ebp], ecx

; 426  : 
; 427  : 			WebzenVar2 = (*it);

  00edd	8d 4d f8	 lea	 ecx, DWORD PTR _it$[ebp]
  00ee0	e8 00 00 00 00	 call	 ??D?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBEAAUBLOODCASTLE_START_TIME@@XZ ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator*
  00ee5	8b 08		 mov	 ecx, DWORD PTR [eax]
  00ee7	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00eea	89 4d e8	 mov	 DWORD PTR _WebzenVar2$[ebp], ecx
  00eed	89 55 ec	 mov	 DWORD PTR _WebzenVar2$[ebp+4], edx
$LN6@CheckSync:

; 428  : 		}
; 429  : 
; 430  : 		CheckTime = WebzenVar2.m_iHour*60+WebzenVar2.m_iMinute;

  00ef0	8b 45 e8	 mov	 eax, DWORD PTR _WebzenVar2$[ebp]
  00ef3	6b c0 3c	 imul	 eax, 60			; 0000003cH
  00ef6	03 45 ec	 add	 eax, DWORD PTR _WebzenVar2$[ebp+4]
  00ef9	89 45 e0	 mov	 DWORD PTR _CheckTime$[ebp], eax

; 431  : 
; 432  : 		if(today->tm_hour <= WebzenVar2.m_iHour && CheckTime > CurrentTime)

  00efc	8b 45 d8	 mov	 eax, DWORD PTR _today$[ebp]
  00eff	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00f02	3b 4d e8	 cmp	 ecx, DWORD PTR _WebzenVar2$[ebp]
  00f05	7f 2c		 jg	 SHORT $LN5@CheckSync
  00f07	8b 45 e0	 mov	 eax, DWORD PTR _CheckTime$[ebp]
  00f0a	3b 45 dc	 cmp	 eax, DWORD PTR _CurrentTime$[ebp]
  00f0d	76 24		 jbe	 SHORT $LN5@CheckSync

; 433  : 		{
; 434  : 			this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC = ((CheckTime - CurrentTime)*60)*1000;

  00f0f	8b 45 e0	 mov	 eax, DWORD PTR _CheckTime$[ebp]
  00f12	2b 45 dc	 sub	 eax, DWORD PTR _CurrentTime$[ebp]
  00f15	6b c0 3c	 imul	 eax, 60			; 0000003cH
  00f18	69 c0 e8 03 00
	00		 imul	 eax, 1000		; 000003e8H
  00f1e	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  00f21	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  00f27	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00f2a	89 84 0a ac 03
	00 00		 mov	 DWORD PTR [edx+ecx+940], eax

; 435  : 		}
; 436  : 		else

  00f31	eb 27		 jmp	 SHORT $LN4@CheckSync
$LN5@CheckSync:

; 437  : 		{
; 438  : 			this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC = ((1440-CurrentTime+CheckTime)*60)*1000;

  00f33	b8 a0 05 00 00	 mov	 eax, 1440		; 000005a0H
  00f38	2b 45 dc	 sub	 eax, DWORD PTR _CurrentTime$[ebp]
  00f3b	03 45 e0	 add	 eax, DWORD PTR _CheckTime$[ebp]
  00f3e	6b c0 3c	 imul	 eax, 60			; 0000003cH
  00f41	69 c0 e8 03 00
	00		 imul	 eax, 1000		; 000003e8H
  00f47	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  00f4a	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  00f50	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00f53	89 84 0a ac 03
	00 00		 mov	 DWORD PTR [edx+ecx+940], eax
$LN4@CheckSync:

; 439  : 		}
; 440  : 
; 441  : 		if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= ( this->m_iBC_TIME_MIN_OPEN * 60 * 1000 ))

  00f5a	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00f5d	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  00f63	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00f66	8b 91 08 23 00
	00		 mov	 edx, DWORD PTR [ecx+8968]
  00f6c	6b d2 3c	 imul	 edx, 60			; 0000003cH
  00f6f	69 d2 e8 03 00
	00		 imul	 edx, 1000		; 000003e8H
  00f75	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00f78	39 94 01 ac 03
	00 00		 cmp	 DWORD PTR [ecx+eax+940], edx
  00f7f	7f 45		 jg	 SHORT $LN3@CheckSync

; 442  : 		{
; 443  : 			it++;

  00f81	6a 00		 push	 0
  00f83	8d 45 80	 lea	 eax, DWORD PTR $T239144[ebp]
  00f86	50		 push	 eax
  00f87	8d 4d f8	 lea	 ecx, DWORD PTR _it$[ebp]
  00f8a	e8 00 00 00 00	 call	 ??E?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator++

; 444  : 
; 445  : 			if(it != this->m_listBloodCastleOpenTime.end())

  00f8f	8d 45 84	 lea	 eax, DWORD PTR $T239145[ebp]
  00f92	50		 push	 eax
  00f93	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00f96	81 c1 20 23 00
	00		 add	 ecx, 8992		; 00002320H
  00f9c	e8 00 00 00 00	 call	 ?end@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@2@XZ ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::end
  00fa1	50		 push	 eax
  00fa2	8d 4d f8	 lea	 ecx, DWORD PTR _it$[ebp]
  00fa5	e8 00 00 00 00	 call	 ??9?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator!=
  00faa	0f b6 c8	 movzx	 ecx, al
  00fad	85 c9		 test	 ecx, ecx
  00faf	74 13		 je	 SHORT $LN2@CheckSync

; 446  : 			{
; 447  : 				WebzenVar2 = (*it);

  00fb1	8d 4d f8	 lea	 ecx, DWORD PTR _it$[ebp]
  00fb4	e8 00 00 00 00	 call	 ??D?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBEAAUBLOODCASTLE_START_TIME@@XZ ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator*
  00fb9	8b 08		 mov	 ecx, DWORD PTR [eax]
  00fbb	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00fbe	89 4d e8	 mov	 DWORD PTR _WebzenVar2$[ebp], ecx
  00fc1	89 55 ec	 mov	 DWORD PTR _WebzenVar2$[ebp+4], edx
$LN2@CheckSync:

; 448  : 			}
; 449  : 		}
; 450  : 		else

  00fc4	eb 02		 jmp	 SHORT $LN1@CheckSync
$LN3@CheckSync:

; 451  : 		{
; 452  : 			break;

  00fc6	eb 05		 jmp	 SHORT $LN7@CheckSync
$LN1@CheckSync:

; 453  : 		}
; 454  : 	}

  00fc8	e9 bd fe ff ff	 jmp	 $LN8@CheckSync
$LN7@CheckSync:

; 455  : 
; 456  : 	loc13 = GetTickCount();

  00fcd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00fd3	89 45 c8	 mov	 DWORD PTR _loc13$[ebp], eax

; 457  : 	this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC -= today->tm_sec * 1000;

  00fd6	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00fd9	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  00fdf	8b 4d d8	 mov	 ecx, DWORD PTR _today$[ebp]
  00fe2	8b 11		 mov	 edx, DWORD PTR [ecx]
  00fe4	69 d2 e8 03 00
	00		 imul	 edx, 1000		; 000003e8H
  00fea	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00fed	8b 84 01 ac 03
	00 00		 mov	 eax, DWORD PTR [ecx+eax+940]
  00ff4	2b c2		 sub	 eax, edx
  00ff6	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  00ff9	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  00fff	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01002	89 84 0a ac 03
	00 00		 mov	 DWORD PTR [edx+ecx+940], eax

; 458  : 
; 459  : 	LogAddTD("[Blood Castle] (%d) Sync Open Time. [%d] min remain", iBridgeIndex+1, this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC/60000);

  01009	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0100c	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  01012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01015	8b 84 01 ac 03
	00 00		 mov	 eax, DWORD PTR [ecx+eax+940]
  0101c	99		 cdq
  0101d	b9 60 ea 00 00	 mov	 ecx, 60000		; 0000ea60H
  01022	f7 f9		 idiv	 ecx
  01024	50		 push	 eax
  01025	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  01028	83 c2 01	 add	 edx, 1
  0102b	52		 push	 edx
  0102c	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@JOEGJLEF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Sync?5Open?5Ti@
  01031	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01037	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN18@CheckSync:

; 460  : }

  0103a	5f		 pop	 edi
  0103b	5e		 pop	 esi
  0103c	5b		 pop	 ebx
  0103d	8b e5		 mov	 esp, ebp
  0103f	5d		 pop	 ebp
  01040	c2 04 00	 ret	 4
?CheckSync@CBloodCastle@@IAEXH@Z ENDP			; CBloodCastle::CheckSync
_TEXT	ENDS
EXTRN	__localtime64:PROC
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\time.inl
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_localtime PROC

; 113  : {

  01050	55		 push	 ebp
  01051	8b ec		 mov	 ebp, esp
  01053	83 ec 40	 sub	 esp, 64			; 00000040H
  01056	53		 push	 ebx
  01057	56		 push	 esi
  01058	57		 push	 edi

; 114  : #pragma warning( push )
; 115  : #pragma warning( disable : 4996 )
; 116  :     return _localtime64(_Time);

  01059	8b 45 08	 mov	 eax, DWORD PTR __Time$[ebp]
  0105c	50		 push	 eax
  0105d	e8 00 00 00 00	 call	 __localtime64
  01062	83 c4 04	 add	 esp, 4

; 117  : #pragma warning( pop )
; 118  : }

  01065	5f		 pop	 edi
  01066	5e		 pop	 esi
  01067	5b		 pop	 ebx
  01068	8b e5		 mov	 esp, ebp
  0106a	5d		 pop	 ebp
  0106b	c3		 ret	 0
_localtime ENDP
_TEXT	ENDS
EXTRN	__time64:PROC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_time	PROC

; 132  : {

  01070	55		 push	 ebp
  01071	8b ec		 mov	 ebp, esp
  01073	83 ec 40	 sub	 esp, 64			; 00000040H
  01076	53		 push	 ebx
  01077	56		 push	 esi
  01078	57		 push	 edi

; 133  :     return _time64(_Time);

  01079	8b 45 08	 mov	 eax, DWORD PTR __Time$[ebp]
  0107c	50		 push	 eax
  0107d	e8 00 00 00 00	 call	 __time64
  01082	83 c4 04	 add	 esp, 4

; 134  : }

  01085	5f		 pop	 edi
  01086	5e		 pop	 esi
  01087	5b		 pop	 ebx
  01088	8b e5		 mov	 esp, ebp
  0108a	5d		 pop	 ebp
  0108b	c3		 ret	 0
_time	ENDP
_TEXT	ENDS
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	_memset:PROC
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\bloodcastle.cpp
_TEXT	SEGMENT
tv67 = -76						; size = 4
_i$236745 = -8						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?ClearBridgeData@CBloodCastle@@IAEXH@Z PROC		; CBloodCastle::ClearBridgeData
; _this$ = ecx

; 463  : {

  01090	55		 push	 ebp
  01091	8b ec		 mov	 ebp, esp
  01093	83 ec 4c	 sub	 esp, 76			; 0000004cH
  01096	53		 push	 ebx
  01097	56		 push	 esi
  01098	57		 push	 edi
  01099	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 464  : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  0109c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  010a0	7d 09		 jge	 SHORT $LN8@ClearBridg
  010a2	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  010a9	eb 0c		 jmp	 SHORT $LN9@ClearBridg
$LN8@ClearBridg:
  010ab	33 c0		 xor	 eax, eax
  010ad	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  010b1	0f 9e c0	 setle	 al
  010b4	89 45 b4	 mov	 DWORD PTR tv67[ebp], eax
$LN9@ClearBridg:
  010b7	83 7d b4 00	 cmp	 DWORD PTR tv67[ebp], 0
  010bb	75 05		 jne	 SHORT $LN5@ClearBridg

; 465  : 	{
; 466  : 		return;

  010bd	e9 3e 05 00 00	 jmp	 $LN6@ClearBridg
$LN5@ClearBridg:

; 467  : 	}
; 468  : 
; 469  : 	this->m_BridgeData[iBridgeIndex].m_iTOTAL_EXP = 0;

  010c2	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  010c5	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  010cb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  010ce	c7 84 01 94 03
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+916], 0

; 470  : 	this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_MAX_COUNT = 0;

  010d9	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  010dc	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  010e2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  010e5	c7 84 01 cc 03
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+972], 0

; 471  : 	this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_KILL_COUNT = 0;

  010f0	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  010f3	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  010f9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  010fc	c7 84 01 d0 03
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+976], 0

; 472  : 	this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_SUCCESS_MSG_COUNT = 0;

  01107	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0110a	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  01110	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01113	c7 84 01 d4 03
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+980], 0

; 473  : 	this->m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_MAX_COUNT = 0;

  0111e	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01121	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  01127	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0112a	c7 84 01 dc 03
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+988], 0

; 474  : 	this->m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_KILL_COUNT = 0;

  01135	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01138	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0113e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01141	c7 84 01 e0 03
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+992], 0

; 475  : 	this->m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_SUCCESS_MSG_COUNT = 0;

  0114c	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0114f	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  01155	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01158	c7 84 01 e4 03
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+996], 0

; 476  : 	this->m_BridgeData[iBridgeIndex].m_btBC_QUEST_ITEM_NUMBER = 0;

  01163	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01166	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0116c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0116f	c6 84 01 f0 03
	00 00 00	 mov	 BYTE PTR [ecx+eax+1008], 0

; 477  : 	this->m_BridgeData[iBridgeIndex].m_dwBC_TICK_DOOR_OPEN = -1;

  01177	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0117a	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  01180	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01183	c7 84 01 d8 03
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+984], -1

; 478  : 	this->m_BridgeData[iBridgeIndex].m_nBC_QUESTITEM_SERIAL = -1;

  0118e	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01191	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  01197	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0119a	c7 84 01 e8 03
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+1000], -1

; 479  : 	this->m_BridgeData[iBridgeIndex].m_iBC_QUEST_ITEM_USER_INDEX = -1;

  011a5	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  011a8	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  011ae	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  011b1	c7 84 01 ec 03
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+1004], -1

; 480  : 	this->m_BridgeData[iBridgeIndex].m_iMISSION_SUCCESS = -1;

  011bc	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  011bf	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  011c5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  011c8	c7 84 01 a0 03
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+928], -1

; 481  : 	this->m_BridgeData[iBridgeIndex].m_iBC_NOTIFY_COUNT = -1;

  011d3	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  011d6	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  011dc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  011df	c7 84 01 b4 03
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+948], -1

; 482  : 	this->m_BridgeData[iBridgeIndex].m_bCASTLE_DOOR_LIVE = TRUE;

  011ea	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  011ed	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  011f3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  011f6	c7 84 01 a4 03
	00 00 01 00 00
	00		 mov	 DWORD PTR [ecx+eax+932], 1

; 483  : 	this->m_BridgeData[iBridgeIndex].m_bBC_REWARDED = false;

  01201	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01204	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0120a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0120d	c6 84 01 be 03
	00 00 00	 mov	 BYTE PTR [ecx+eax+958], 0

; 484  : 	this->m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_ENTER = false;

  01215	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01218	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0121e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01221	c6 84 01 bf 03
	00 00 00	 mov	 BYTE PTR [ecx+eax+959], 0

; 485  : 	this->m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_PLAY = false;

  01229	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0122c	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  01232	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01235	c6 84 01 c0 03
	00 00 00	 mov	 BYTE PTR [ecx+eax+960], 0

; 486  : 	this->m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_END = false;

  0123d	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01240	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  01246	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01249	c6 84 01 c1 03
	00 00 00	 mov	 BYTE PTR [ecx+eax+961], 0

; 487  : 	this->m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_QUIT = false;

  01251	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01254	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0125a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0125d	c6 84 01 c2 03
	00 00 00	 mov	 BYTE PTR [ecx+eax+962], 0

; 488  : 	this->m_BridgeData[iBridgeIndex].m_bBC_CAN_ENTER = false;

  01265	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01268	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0126e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01271	c6 84 01 bb 03
	00 00 00	 mov	 BYTE PTR [ecx+eax+955], 0

; 489  : 	this->m_BridgeData[iBridgeIndex].m_bBC_CAN_PARTY = false;

  01279	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0127c	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  01282	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01285	c6 84 01 bc 03
	00 00 00	 mov	 BYTE PTR [ecx+eax+956], 0

; 490  : 	this->m_BridgeData[iBridgeIndex].m_bBC_PLAY_START = false;

  0128d	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01290	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  01296	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01299	c6 84 01 bd 03
	00 00 00	 mov	 BYTE PTR [ecx+eax+957], 0

; 491  : 	this->m_BridgeData[iBridgeIndex].m_bBC_MONSTER_KILL_COMPLETE = false;

  012a1	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  012a4	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  012aa	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  012ad	c6 84 01 b8 03
	00 00 00	 mov	 BYTE PTR [ecx+eax+952], 0

; 492  : 	this->m_BridgeData[iBridgeIndex].m_bBC_BOSS_MONSTER_KILL_COMPLETE = false;

  012b5	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  012b8	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  012be	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  012c1	c6 84 01 b9 03
	00 00 00	 mov	 BYTE PTR [ecx+eax+953], 0

; 493  : 	this->m_BridgeData[iBridgeIndex].m_bBC_DOOR_TERMINATE_COMPLETE = false;

  012c9	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  012cc	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  012d2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  012d5	c6 84 01 ba 03
	00 00 00	 mov	 BYTE PTR [ecx+eax+954], 0

; 494  : 	this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Door_Index = -10;

  012dd	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  012e0	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  012e6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  012e9	c7 84 01 fc 03
	00 00 f6 ff ff
	ff		 mov	 DWORD PTR [ecx+eax+1020], -10 ; fffffff6H

; 495  : 	this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Door_Party = -10;

  012f4	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  012f7	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  012fd	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01300	c7 84 01 f8 03
	00 00 f6 ff ff
	ff		 mov	 DWORD PTR [ecx+eax+1016], -10 ; fffffff6H

; 496  : 	this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Statue_Index = -10;

  0130b	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0130e	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  01314	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01317	c7 84 01 1c 04
	00 00 f6 ff ff
	ff		 mov	 DWORD PTR [ecx+eax+1052], -10 ; fffffff6H

; 497  : 	this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Statue_Party = -10;

  01322	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01325	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0132b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0132e	c7 84 01 18 04
	00 00 f6 ff ff
	ff		 mov	 DWORD PTR [ecx+eax+1048], -10 ; fffffff6H

; 498  : 	this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Win_Quest_Index = -10;

  01339	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0133c	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  01342	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01345	c7 84 01 3c 04
	00 00 f6 ff ff
	ff		 mov	 DWORD PTR [ecx+eax+1084], -10 ; fffffff6H

; 499  : 	this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Win_Quest_Party = -10;

  01350	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01353	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  01359	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0135c	c7 84 01 38 04
	00 00 f6 ff ff
	ff		 mov	 DWORD PTR [ecx+eax+1080], -10 ; fffffff6H

; 500  : 
; 501  : 	memset(this->m_BridgeData[iBridgeIndex].m_szKill_Door_CharName , 0, sizeof(this->m_BridgeData[iBridgeIndex].m_szKill_Door_CharName));

  01367	6a 0b		 push	 11			; 0000000bH
  01369	6a 00		 push	 0
  0136b	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0136e	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  01374	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01377	8d 94 01 0b 04
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1035]
  0137e	52		 push	 edx
  0137f	e8 00 00 00 00	 call	 _memset
  01384	83 c4 0c	 add	 esp, 12			; 0000000cH

; 502  : 	memset(this->m_BridgeData[iBridgeIndex].m_szKill_Status_CharName, 0, sizeof(this->m_BridgeData[iBridgeIndex].m_szKill_Status_CharName));

  01387	6a 0b		 push	 11			; 0000000bH
  01389	6a 00		 push	 0
  0138b	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0138e	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  01394	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01397	8d 94 01 20 04
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1056]
  0139e	52		 push	 edx
  0139f	e8 00 00 00 00	 call	 _memset
  013a4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 503  : 	memset(this->m_BridgeData[iBridgeIndex].m_szWin_Quest_CharName, 0, sizeof(this->m_BridgeData[iBridgeIndex].m_szWin_Quest_CharName));

  013a7	6a 0b		 push	 11			; 0000000bH
  013a9	6a 00		 push	 0
  013ab	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  013ae	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  013b4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  013b7	8d 94 01 40 04
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1088]
  013be	52		 push	 edx
  013bf	e8 00 00 00 00	 call	 _memset
  013c4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 504  : 	memset(this->m_BridgeData[iBridgeIndex].m_szKill_Door_AccountID, 0, sizeof(this->m_BridgeData[iBridgeIndex].m_szKill_Door_AccountID));

  013c7	6a 0b		 push	 11			; 0000000bH
  013c9	6a 00		 push	 0
  013cb	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  013ce	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  013d4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  013d7	8d 94 01 00 04
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1024]
  013de	52		 push	 edx
  013df	e8 00 00 00 00	 call	 _memset
  013e4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 505  : 	memset(this->m_BridgeData[iBridgeIndex].m_szKill_Status_AccountID, 0, sizeof(this->m_BridgeData[iBridgeIndex].m_szKill_Status_AccountID));

  013e7	6a 0b		 push	 11			; 0000000bH
  013e9	6a 00		 push	 0
  013eb	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  013ee	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  013f4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  013f7	8d 94 01 2b 04
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1067]
  013fe	52		 push	 edx
  013ff	e8 00 00 00 00	 call	 _memset
  01404	83 c4 0c	 add	 esp, 12			; 0000000cH

; 506  : 	memset(this->m_BridgeData[iBridgeIndex].m_szWin_Quest_AccountID, 0, sizeof(this->m_BridgeData[iBridgeIndex].m_szWin_Quest_AccountID));

  01407	6a 0b		 push	 11			; 0000000bH
  01409	6a 00		 push	 0
  0140b	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0140e	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  01414	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01417	8d 94 01 4b 04
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1099]
  0141e	52		 push	 edx
  0141f	e8 00 00 00 00	 call	 _memset
  01424	83 c4 0c	 add	 esp, 12			; 0000000cH

; 507  : 	
; 508  : 
; 509  : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  01427	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$236745[ebp], 0
  0142e	eb 09		 jmp	 SHORT $LN4@ClearBridg
$LN3@ClearBridg:
  01430	8b 45 f8	 mov	 eax, DWORD PTR _i$236745[ebp]
  01433	83 c0 01	 add	 eax, 1
  01436	89 45 f8	 mov	 DWORD PTR _i$236745[ebp], eax
$LN4@ClearBridg:
  01439	83 7d f8 28	 cmp	 DWORD PTR _i$236745[ebp], 40 ; 00000028H
  0143d	0f 8d bd 01 00
	00		 jge	 $LN6@ClearBridg

; 510  : 	{
; 511  : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  01443	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01446	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0144c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0144f	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  01453	8b 45 f8	 mov	 eax, DWORD PTR _i$236745[ebp]
  01456	6b c0 14	 imul	 eax, 20			; 00000014H
  01459	83 7c 02 18 ff	 cmp	 DWORD PTR [edx+eax+24], -1
  0145e	0f 84 bb 00 00
	00		 je	 $LN1@ClearBridg

; 512  : 		{
; 513  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_iBloodCastleEXP = 0;

  01464	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01467	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0146d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01470	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  01474	8b 45 f8	 mov	 eax, DWORD PTR _i$236745[ebp]
  01477	6b c0 14	 imul	 eax, 20			; 00000014H
  0147a	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  0147e	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  01484	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0148a	c7 84 0a a0 0e
	00 00 00 00 00
	00		 mov	 DWORD PTR [edx+ecx+3744], 0

; 514  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex = -1;

  01495	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01498	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0149e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  014a1	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  014a5	8b 45 f8	 mov	 eax, DWORD PTR _i$236745[ebp]
  014a8	6b c0 14	 imul	 eax, 20			; 00000014H
  014ab	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  014af	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  014b5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  014bb	c6 84 0a 9e 0e
	00 00 ff	 mov	 BYTE PTR [edx+ecx+3742], -1

; 515  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex = -1;

  014c3	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  014c6	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  014cc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  014cf	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  014d3	8b 45 f8	 mov	 eax, DWORD PTR _i$236745[ebp]
  014d6	6b c0 14	 imul	 eax, 20			; 00000014H
  014d9	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  014dd	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  014e3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  014e9	c6 84 0a 9f 0e
	00 00 ff	 mov	 BYTE PTR [edx+ecx+3743], -1

; 516  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_bBloodCastleComplete = false;

  014f1	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  014f4	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  014fa	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  014fd	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  01501	8b 45 f8	 mov	 eax, DWORD PTR _i$236745[ebp]
  01504	6b c0 14	 imul	 eax, 20			; 00000014H
  01507	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  0150b	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  01511	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01517	c6 84 0a a4 0e
	00 00 00	 mov	 BYTE PTR [edx+ecx+3748], 0
$LN1@ClearBridg:

; 517  : 		}
; 518  : 
; 519  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iEXP = 0;

  0151f	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01522	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  01528	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0152b	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0152f	8b 45 f8	 mov	 eax, DWORD PTR _i$236745[ebp]
  01532	6b c0 14	 imul	 eax, 20			; 00000014H
  01535	c7 44 02 1c 00
	00 00 00	 mov	 DWORD PTR [edx+eax+28], 0

; 520  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iScore = 0;

  0153d	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01540	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  01546	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01549	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0154d	8b 45 f8	 mov	 eax, DWORD PTR _i$236745[ebp]
  01550	6b c0 14	 imul	 eax, 20			; 00000014H
  01553	c7 44 02 20 00
	00 00 00	 mov	 DWORD PTR [edx+eax+32], 0

; 521  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex = -1;

  0155b	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0155e	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  01564	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01567	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0156b	8b 45 f8	 mov	 eax, DWORD PTR _i$236745[ebp]
  0156e	6b c0 14	 imul	 eax, 20			; 00000014H
  01571	c7 44 02 18 ff
	ff ff ff	 mov	 DWORD PTR [edx+eax+24], -1

; 522  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState= 0;

  01579	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0157c	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  01582	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01585	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  01589	8b 45 f8	 mov	 eax, DWORD PTR _i$236745[ebp]
  0158c	6b c0 14	 imul	 eax, 20			; 00000014H
  0158f	c7 44 02 24 00
	00 00 00	 mov	 DWORD PTR [edx+eax+36], 0

; 523  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bSendQuitMsg = false;

  01597	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0159a	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  015a0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  015a3	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  015a7	8b 45 f8	 mov	 eax, DWORD PTR _i$236745[ebp]
  015aa	6b c0 14	 imul	 eax, 20			; 00000014H
  015ad	c6 44 02 28 00	 mov	 BYTE PTR [edx+eax+40], 0

; 524  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bLiveWhenDoorBreak = false;

  015b2	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  015b5	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  015bb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  015be	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  015c2	8b 45 f8	 mov	 eax, DWORD PTR _i$236745[ebp]
  015c5	6b c0 14	 imul	 eax, 20			; 00000014H
  015c8	c6 44 02 29 00	 mov	 BYTE PTR [edx+eax+41], 0

; 525  : 		this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX = -1;

  015cd	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  015d0	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  015d6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  015d9	c7 84 01 58 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+1112], -1

; 526  : 		this->m_BridgeData[iBridgeIndex].m_iBC_DOOR_MONSTER_INDEX = -1; //season 2.5 add-on

  015e4	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  015e7	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  015ed	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  015f0	c7 84 01 5c 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+1116], -1

; 527  : 	}

  015fb	e9 30 fe ff ff	 jmp	 $LN3@ClearBridg
$LN6@ClearBridg:

; 528  : }

  01600	5f		 pop	 edi
  01601	5e		 pop	 esi
  01602	5b		 pop	 ebx
  01603	8b e5		 mov	 esp, ebp
  01605	5d		 pop	 ebp
  01606	c2 04 00	 ret	 4
?ClearBridgeData@CBloodCastle@@IAEXH@Z ENDP		; CBloodCastle::ClearBridgeData
_TEXT	ENDS
PUBLIC	?SetState_PlayEnd@CBloodCastle@@IAEXH@Z		; CBloodCastle::SetState_PlayEnd
PUBLIC	?SetState_Playing@CBloodCastle@@IAEXH@Z		; CBloodCastle::SetState_Playing
PUBLIC	?SetState_Closed@CBloodCastle@@IAEXH@Z		; CBloodCastle::SetState_Closed
PUBLIC	?SetState_None@CBloodCastle@@IAEXH@Z		; CBloodCastle::SetState_None
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv79 = -72						; size = 4
tv67 = -72						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
_iBC_STATE$ = 12					; size = 4
?SetState@CBloodCastle@@QAEXHH@Z PROC			; CBloodCastle::SetState
; _this$ = ecx

; 531  : {

  01610	55		 push	 ebp
  01611	8b ec		 mov	 ebp, esp
  01613	83 ec 48	 sub	 esp, 72			; 00000048H
  01616	53		 push	 ebx
  01617	56		 push	 esi
  01618	57		 push	 edi
  01619	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 532  : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  0161c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  01620	7d 09		 jge	 SHORT $LN12@SetState
  01622	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  01629	eb 0c		 jmp	 SHORT $LN13@SetState
$LN12@SetState:
  0162b	33 c0		 xor	 eax, eax
  0162d	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  01631	0f 9e c0	 setle	 al
  01634	89 45 b8	 mov	 DWORD PTR tv67[ebp], eax
$LN13@SetState:
  01637	83 7d b8 00	 cmp	 DWORD PTR tv67[ebp], 0
  0163b	75 05		 jne	 SHORT $LN9@SetState

; 533  : 	{
; 534  : 		return;

  0163d	e9 80 00 00 00	 jmp	 $LN10@SetState
$LN9@SetState:

; 535  : 	}
; 536  : 
; 537  : 	if ( iBC_STATE < BC_STATE_NONE || iBC_STATE > BC_STATE_PLAYEND )

  01642	83 7d 0c 00	 cmp	 DWORD PTR _iBC_STATE$[ebp], 0
  01646	7c 06		 jl	 SHORT $LN7@SetState
  01648	83 7d 0c 03	 cmp	 DWORD PTR _iBC_STATE$[ebp], 3
  0164c	7e 02		 jle	 SHORT $LN8@SetState
$LN7@SetState:

; 538  : 	{
; 539  : 		return;

  0164e	eb 72		 jmp	 SHORT $LN10@SetState
$LN8@SetState:

; 540  : 	}
; 541  : 
; 542  : 	this->m_BridgeData[iBridgeIndex].m_iBC_STATE = iBC_STATE;

  01650	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01653	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  01659	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0165c	8b 55 0c	 mov	 edx, DWORD PTR _iBC_STATE$[ebp]
  0165f	89 94 01 a8 03
	00 00		 mov	 DWORD PTR [ecx+eax+936], edx

; 543  : 
; 544  : 	switch ( this->m_BridgeData[iBridgeIndex].m_iBC_STATE )

  01666	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01669	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0166f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01672	8b 94 01 a8 03
	00 00		 mov	 edx, DWORD PTR [ecx+eax+936]
  01679	89 55 b8	 mov	 DWORD PTR tv79[ebp], edx
  0167c	83 7d b8 03	 cmp	 DWORD PTR tv79[ebp], 3
  01680	77 40		 ja	 SHORT $LN10@SetState
  01682	8b 45 b8	 mov	 eax, DWORD PTR tv79[ebp]
  01685	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN14@SetState[eax*4]
$LN4@SetState:

; 545  : 	{
; 546  : 		case BC_STATE_NONE:
; 547  : 			this->SetState_None(iBridgeIndex);

  0168c	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0168f	50		 push	 eax
  01690	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01693	e8 00 00 00 00	 call	 ?SetState_None@CBloodCastle@@IAEXH@Z ; CBloodCastle::SetState_None

; 548  : 			break;

  01698	eb 28		 jmp	 SHORT $LN10@SetState
$LN3@SetState:

; 549  : 
; 550  : 		case BC_STATE_CLOSED:
; 551  : 			this->SetState_Closed(iBridgeIndex);

  0169a	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0169d	50		 push	 eax
  0169e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  016a1	e8 00 00 00 00	 call	 ?SetState_Closed@CBloodCastle@@IAEXH@Z ; CBloodCastle::SetState_Closed

; 552  : 			break;

  016a6	eb 1a		 jmp	 SHORT $LN10@SetState
$LN2@SetState:

; 553  : 
; 554  : 		case BC_STATE_PLAYING:
; 555  : 			this->SetState_Playing(iBridgeIndex);

  016a8	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  016ab	50		 push	 eax
  016ac	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  016af	e8 00 00 00 00	 call	 ?SetState_Playing@CBloodCastle@@IAEXH@Z ; CBloodCastle::SetState_Playing

; 556  : 			break;

  016b4	eb 0c		 jmp	 SHORT $LN10@SetState
$LN1@SetState:

; 557  : 
; 558  : 		case BC_STATE_PLAYEND:
; 559  : 			this->SetState_PlayEnd(iBridgeIndex);

  016b6	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  016b9	50		 push	 eax
  016ba	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  016bd	e8 00 00 00 00	 call	 ?SetState_PlayEnd@CBloodCastle@@IAEXH@Z ; CBloodCastle::SetState_PlayEnd
$LN10@SetState:

; 560  : 			break;
; 561  : 	}
; 562  : }

  016c2	5f		 pop	 edi
  016c3	5e		 pop	 esi
  016c4	5b		 pop	 ebx
  016c5	8b e5		 mov	 esp, ebp
  016c7	5d		 pop	 ebp
  016c8	c2 08 00	 ret	 8
  016cb	90		 npad	 1
$LN14@SetState:
  016cc	00 00 00 00	 DD	 $LN4@SetState
  016d0	00 00 00 00	 DD	 $LN3@SetState
  016d4	00 00 00 00	 DD	 $LN2@SetState
  016d8	00 00 00 00	 DD	 $LN1@SetState
?SetState@CBloodCastle@@QAEXHH@Z ENDP			; CBloodCastle::SetState
_TEXT	ENDS
PUBLIC	?ProcState_PlayEnd@CBloodCastle@@IAEXH@Z	; CBloodCastle::ProcState_PlayEnd
PUBLIC	?ProcState_Playing@CBloodCastle@@IAEXH@Z	; CBloodCastle::ProcState_Playing
PUBLIC	?ProcState_Closed@CBloodCastle@@IAEXH@Z		; CBloodCastle::ProcState_Closed
PUBLIC	?ProcState_None@CBloodCastle@@IAEXH@Z		; CBloodCastle::ProcState_None
PUBLIC	?Run@CBloodCastle@@QAEXXZ			; CBloodCastle::Run
EXTRN	?DestroyGIocp@@YAXXZ:PROC			; DestroyGIocp
EXTRN	?szAuthKey@@3PADA:BYTE				; szAuthKey
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv73 = -76						; size = 4
_iBridgeIndex$236770 = -8				; size = 4
_this$ = -4						; size = 4
?Run@CBloodCastle@@QAEXXZ PROC				; CBloodCastle::Run
; _this$ = ecx

; 565  : {

  016e0	55		 push	 ebp
  016e1	8b ec		 mov	 ebp, esp
  016e3	83 ec 4c	 sub	 esp, 76			; 0000004cH
  016e6	53		 push	 ebx
  016e7	56		 push	 esi
  016e8	57		 push	 edi
  016e9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 566  : 	if ( this->m_bBC_EVENT_ENABLE != false )

  016ec	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  016ef	0f b6 88 04 23
	00 00		 movzx	 ecx, BYTE PTR [eax+8964]
  016f6	85 c9		 test	 ecx, ecx
  016f8	0f 84 87 00 00
	00		 je	 $LN12@Run

; 567  : 	{
; 568  : 		for (int iBridgeIndex=0;iBridgeIndex<MAX_BLOOD_CASTLE_LEVEL;iBridgeIndex++)

  016fe	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iBridgeIndex$236770[ebp], 0
  01705	eb 09		 jmp	 SHORT $LN10@Run
$LN9@Run:
  01707	8b 45 f8	 mov	 eax, DWORD PTR _iBridgeIndex$236770[ebp]
  0170a	83 c0 01	 add	 eax, 1
  0170d	89 45 f8	 mov	 DWORD PTR _iBridgeIndex$236770[ebp], eax
$LN10@Run:
  01710	83 7d f8 08	 cmp	 DWORD PTR _iBridgeIndex$236770[ebp], 8
  01714	7d 5e		 jge	 SHORT $LN8@Run

; 569  : 		{
; 570  : 			switch ( this->m_BridgeData[iBridgeIndex].m_iBC_STATE )

  01716	8b 45 f8	 mov	 eax, DWORD PTR _iBridgeIndex$236770[ebp]
  01719	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0171f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01722	8b 94 01 a8 03
	00 00		 mov	 edx, DWORD PTR [ecx+eax+936]
  01729	89 55 b4	 mov	 DWORD PTR tv73[ebp], edx
  0172c	83 7d b4 03	 cmp	 DWORD PTR tv73[ebp], 3
  01730	77 40		 ja	 SHORT $LN6@Run
  01732	8b 45 b4	 mov	 eax, DWORD PTR tv73[ebp]
  01735	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN14@Run[eax*4]
$LN5@Run:

; 571  : 			{
; 572  : 				case BC_STATE_NONE:
; 573  : 					this->ProcState_None(iBridgeIndex);

  0173c	8b 45 f8	 mov	 eax, DWORD PTR _iBridgeIndex$236770[ebp]
  0173f	50		 push	 eax
  01740	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01743	e8 00 00 00 00	 call	 ?ProcState_None@CBloodCastle@@IAEXH@Z ; CBloodCastle::ProcState_None

; 574  : 					break;

  01748	eb 28		 jmp	 SHORT $LN6@Run
$LN4@Run:

; 575  : 
; 576  : 				case BC_STATE_CLOSED:
; 577  : 					this->ProcState_Closed(iBridgeIndex);

  0174a	8b 45 f8	 mov	 eax, DWORD PTR _iBridgeIndex$236770[ebp]
  0174d	50		 push	 eax
  0174e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01751	e8 00 00 00 00	 call	 ?ProcState_Closed@CBloodCastle@@IAEXH@Z ; CBloodCastle::ProcState_Closed

; 578  : 					break;

  01756	eb 1a		 jmp	 SHORT $LN6@Run
$LN3@Run:

; 579  : 
; 580  : 				case BC_STATE_PLAYING:
; 581  : 					this->ProcState_Playing(iBridgeIndex);

  01758	8b 45 f8	 mov	 eax, DWORD PTR _iBridgeIndex$236770[ebp]
  0175b	50		 push	 eax
  0175c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0175f	e8 00 00 00 00	 call	 ?ProcState_Playing@CBloodCastle@@IAEXH@Z ; CBloodCastle::ProcState_Playing

; 582  : 					break;

  01764	eb 0c		 jmp	 SHORT $LN6@Run
$LN2@Run:

; 583  : 
; 584  : 				case BC_STATE_PLAYEND:
; 585  : 					this->ProcState_PlayEnd(iBridgeIndex);

  01766	8b 45 f8	 mov	 eax, DWORD PTR _iBridgeIndex$236770[ebp]
  01769	50		 push	 eax
  0176a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0176d	e8 00 00 00 00	 call	 ?ProcState_PlayEnd@CBloodCastle@@IAEXH@Z ; CBloodCastle::ProcState_PlayEnd
$LN6@Run:

; 586  : 					break;
; 587  : 			}
; 588  : 		}

  01772	eb 93		 jmp	 SHORT $LN9@Run
$LN8@Run:

; 589  : 		if ( szAuthKey[13] != AUTHKEY13 )

  01774	0f be 05 0d 00
	00 00		 movsx	 eax, BYTE PTR ?szAuthKey@@3PADA+13
  0177b	83 f8 bb	 cmp	 eax, -69		; ffffffbbH
  0177e	74 05		 je	 SHORT $LN12@Run

; 590  : 		{
; 591  : 			DestroyGIocp();

  01780	e8 00 00 00 00	 call	 ?DestroyGIocp@@YAXXZ	; DestroyGIocp
$LN12@Run:

; 592  : 		}
; 593  : 	}
; 594  : 
; 595  : }

  01785	5f		 pop	 edi
  01786	5e		 pop	 esi
  01787	5b		 pop	 ebx
  01788	8b e5		 mov	 esp, ebp
  0178a	5d		 pop	 ebp
  0178b	c3		 ret	 0
$LN14@Run:
  0178c	00 00 00 00	 DD	 $LN5@Run
  01790	00 00 00 00	 DD	 $LN4@Run
  01794	00 00 00 00	 DD	 $LN3@Run
  01798	00 00 00 00	 DD	 $LN2@Run
?Run@CBloodCastle@@QAEXXZ ENDP				; CBloodCastle::Run
; Function compile flags: /Odtp /ZI
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?ProcState_None@CBloodCastle@@IAEXH@Z PROC		; CBloodCastle::ProcState_None
; _this$ = ecx

; 598  : {

  017a0	55		 push	 ebp
  017a1	8b ec		 mov	 ebp, esp
  017a3	83 ec 44	 sub	 esp, 68			; 00000044H
  017a6	53		 push	 ebx
  017a7	56		 push	 esi
  017a8	57		 push	 edi
  017a9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 599  : }

  017ac	5f		 pop	 edi
  017ad	5e		 pop	 esi
  017ae	5b		 pop	 ebx
  017af	8b e5		 mov	 esp, ebp
  017b1	5d		 pop	 ebp
  017b2	c2 04 00	 ret	 4
?ProcState_None@CBloodCastle@@IAEXH@Z ENDP		; CBloodCastle::ProcState_None
_TEXT	ENDS
PUBLIC	?SendAllUserAnyMsg@CBloodCastle@@QAEXPAEH@Z	; CBloodCastle::SendAllUserAnyMsg
PUBLIC	__$ArrayPad$
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	?PHeadSetB@@YAXPAEEH@Z:PROC			; PHeadSetB
EXTRN	?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ:PROC	; TNotice::MakeNoticeMsgEx
EXTRN	?Get@CMsg@@QAEPADH@Z:PROC			; CMsg::Get
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv259 = -364						; size = 4
tv240 = -364						; size = 4
tv260 = -360						; size = 4
tv241 = -360						; size = 4
_i$236803 = -292					; size = 4
_pMsg$236801 = -288					; size = 4
_pNotice$236797 = -284					; size = 272
_iTICK_MSEC$ = -12					; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
?ProcState_Closed@CBloodCastle@@IAEXH@Z PROC		; CBloodCastle::ProcState_Closed
; _this$ = ecx

; 602  : {

  017c0	55		 push	 ebp
  017c1	8b ec		 mov	 ebp, esp
  017c3	81 ec 6c 01 00
	00		 sub	 esp, 364		; 0000016cH
  017c9	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  017ce	33 c5		 xor	 eax, ebp
  017d0	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  017d3	53		 push	 ebx
  017d4	56		 push	 esi
  017d5	57		 push	 edi
  017d6	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 603  : 	int iTICK_MSEC = GetTickCount() - this->m_BridgeData[iBridgeIndex].m_iBC_TICK_COUNT;

  017d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  017df	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  017e2	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  017e8	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  017eb	2b 84 0a b0 03
	00 00		 sub	 eax, DWORD PTR [edx+ecx+944]
  017f2	89 45 f4	 mov	 DWORD PTR _iTICK_MSEC$[ebp], eax

; 604  : 
; 605  : 	if ( iTICK_MSEC >= 1000 )

  017f5	81 7d f4 e8 03
	00 00		 cmp	 DWORD PTR _iTICK_MSEC$[ebp], 1000 ; 000003e8H
  017fc	0f 8c f5 03 00
	00		 jl	 $LN16@ProcState_

; 606  : 	{
; 607  : 		this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC -= iTICK_MSEC;

  01802	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01805	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0180b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0180e	8b 94 01 ac 03
	00 00		 mov	 edx, DWORD PTR [ecx+eax+940]
  01815	2b 55 f4	 sub	 edx, DWORD PTR _iTICK_MSEC$[ebp]
  01818	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0181b	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  01821	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01824	89 94 01 ac 03
	00 00		 mov	 DWORD PTR [ecx+eax+940], edx

; 608  : 		this->m_BridgeData[iBridgeIndex].m_iBC_TICK_COUNT = GetTickCount();

  0182b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  01831	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  01834	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  0183a	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0183d	89 84 0a b0 03
	00 00		 mov	 DWORD PTR [edx+ecx+944], eax

; 609  : 
; 610  : 		if ( g_bBloodCastle != FALSE )

  01844	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bBloodCastle@@3HA, 0 ; g_bBloodCastle
  0184b	0f 84 a6 03 00
	00		 je	 $LN16@ProcState_

; 611  : 		{
; 612  : 			if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= ( this->m_iBC_TIME_MIN_OPEN * 60 * 1000 ) && this->m_BridgeData[iBridgeIndex].m_bBC_CAN_ENTER == false)

  01851	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01854	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0185a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0185d	8b 91 08 23 00
	00		 mov	 edx, DWORD PTR [ecx+8968]
  01863	6b d2 3c	 imul	 edx, 60			; 0000003cH
  01866	69 d2 e8 03 00
	00		 imul	 edx, 1000		; 000003e8H
  0186c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0186f	39 94 01 ac 03
	00 00		 cmp	 DWORD PTR [ecx+eax+940], edx
  01876	7f 40		 jg	 SHORT $LN14@ProcState_
  01878	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0187b	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  01881	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01884	0f b6 94 01 bb
	03 00 00	 movzx	 edx, BYTE PTR [ecx+eax+955]
  0188c	85 d2		 test	 edx, edx
  0188e	75 28		 jne	 SHORT $LN14@ProcState_

; 613  : 			{
; 614  : 				this->m_BridgeData[iBridgeIndex].m_bBC_CAN_ENTER = true;

  01890	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01893	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  01899	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0189c	c6 84 01 bb 03
	00 00 01	 mov	 BYTE PTR [ecx+eax+955], 1

; 615  : 				this->m_BridgeData[iBridgeIndex].m_bBC_CAN_PARTY = true;

  018a4	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  018a7	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  018ad	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  018b0	c6 84 01 bc 03
	00 00 01	 mov	 BYTE PTR [ecx+eax+956], 1
$LN14@ProcState_:

; 616  : 			}
; 617  : 
; 618  : 			if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= ( this->m_iBC_TIME_MIN_OPEN * 60 * 1000 ) && this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC > 0 && (this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC/60000) !=this->m_BridgeData[iBridgeIndex].m_iBC_NOTIFY_COUNT)

  018b8	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  018bb	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  018c1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  018c4	8b 91 08 23 00
	00		 mov	 edx, DWORD PTR [ecx+8968]
  018ca	6b d2 3c	 imul	 edx, 60			; 0000003cH
  018cd	69 d2 e8 03 00
	00		 imul	 edx, 1000		; 000003e8H
  018d3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  018d6	39 94 01 ac 03
	00 00		 cmp	 DWORD PTR [ecx+eax+940], edx
  018dd	0f 8f d1 00 00
	00		 jg	 $LN13@ProcState_
  018e3	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  018e6	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  018ec	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  018ef	83 bc 01 ac 03
	00 00 00	 cmp	 DWORD PTR [ecx+eax+940], 0
  018f7	0f 8e b7 00 00
	00		 jle	 $LN13@ProcState_
  018fd	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01900	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  01906	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01909	8b 84 01 ac 03
	00 00		 mov	 eax, DWORD PTR [ecx+eax+940]
  01910	99		 cdq
  01911	b9 60 ea 00 00	 mov	 ecx, 60000		; 0000ea60H
  01916	f7 f9		 idiv	 ecx
  01918	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  0191b	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  01921	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01924	3b 84 11 b4 03
	00 00		 cmp	 eax, DWORD PTR [ecx+edx+948]
  0192b	0f 84 83 00 00
	00		 je	 $LN13@ProcState_

; 619  : 			{
; 620  : 				this->m_BridgeData[iBridgeIndex].m_iBC_NOTIFY_COUNT = this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 60000;

  01931	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01934	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0193a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0193d	8b 84 01 ac 03
	00 00		 mov	 eax, DWORD PTR [ecx+eax+940]
  01944	99		 cdq
  01945	b9 60 ea 00 00	 mov	 ecx, 60000		; 0000ea60H
  0194a	f7 f9		 idiv	 ecx
  0194c	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  0194f	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  01955	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01958	89 84 11 b4 03
	00 00		 mov	 DWORD PTR [ecx+edx+948], eax

; 621  : 
; 622  : 				if ( iBridgeIndex == 0 )

  0195f	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  01963	75 4f		 jne	 SHORT $LN13@ProcState_

; 623  : 				{
; 624  : 					PMSG_NOTICE pNotice;
; 625  : 
; 626  : 					TNotice::MakeNoticeMsgEx(&pNotice, 0, lMsg.Get( MSGGET(4, 136)), this->m_BridgeData[iBridgeIndex].m_iBC_NOTIFY_COUNT+1);

  01965	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01968	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0196e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01971	8b 94 01 b4 03
	00 00		 mov	 edx, DWORD PTR [ecx+eax+948]
  01978	83 c2 01	 add	 edx, 1
  0197b	52		 push	 edx
  0197c	68 88 04 00 00	 push	 1160			; 00000488H
  01981	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  01986	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0198b	50		 push	 eax
  0198c	6a 00		 push	 0
  0198e	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$236797[ebp]
  01994	50		 push	 eax
  01995	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx
  0199a	83 c4 10	 add	 esp, 16			; 00000010H

; 627  : 					this->SendAllUserAnyMsg((LPBYTE)&pNotice, pNotice.h.size);

  0199d	0f b6 85 e5 fe
	ff ff		 movzx	 eax, BYTE PTR _pNotice$236797[ebp+1]
  019a4	50		 push	 eax
  019a5	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$236797[ebp]
  019ab	51		 push	 ecx
  019ac	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  019af	e8 00 00 00 00	 call	 ?SendAllUserAnyMsg@CBloodCastle@@QAEXPAEH@Z ; CBloodCastle::SendAllUserAnyMsg
$LN13@ProcState_:

; 628  : 				}
; 629  : 			}
; 630  : 
; 631  : 			if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= 30000 && this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC > 0 && this->m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_ENTER == false )

  019b4	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  019b7	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  019bd	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  019c0	81 bc 01 ac 03
	00 00 30 75 00
	00		 cmp	 DWORD PTR [ecx+eax+940], 30000 ; 00007530H
  019cb	0f 8f 26 02 00
	00		 jg	 $LN16@ProcState_
  019d1	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  019d4	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  019da	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  019dd	83 bc 01 ac 03
	00 00 00	 cmp	 DWORD PTR [ecx+eax+940], 0
  019e5	0f 8e 0c 02 00
	00		 jle	 $LN16@ProcState_
  019eb	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  019ee	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  019f4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  019f7	0f b6 94 01 bf
	03 00 00	 movzx	 edx, BYTE PTR [ecx+eax+959]
  019ff	85 d2		 test	 edx, edx
  01a01	0f 85 f0 01 00
	00		 jne	 $LN16@ProcState_

; 632  : 			{
; 633  : 				this->m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_ENTER = true;

  01a07	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01a0a	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  01a10	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01a13	c6 84 01 bf 03
	00 00 01	 mov	 BYTE PTR [ecx+eax+959], 1

; 634  : 
; 635  : 				if ( iBridgeIndex == 0 )

  01a1b	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  01a1f	0f 85 d2 01 00
	00		 jne	 $LN16@ProcState_

; 636  : 				{
; 637  : 					PMSG_SET_DEVILSQUARE pMsg;
; 638  : 
; 639  : 					PHeadSetB((LPBYTE)&pMsg, 0x92, sizeof(pMsg));

  01a25	6a 04		 push	 4
  01a27	68 92 00 00 00	 push	 146			; 00000092H
  01a2c	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$236801[ebp]
  01a32	50		 push	 eax
  01a33	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  01a38	83 c4 0c	 add	 esp, 12			; 0000000cH

; 640  : 					pMsg.Type = 3;

  01a3b	c6 85 e3 fe ff
	ff 03		 mov	 BYTE PTR _pMsg$236801[ebp+3], 3

; 641  : 
; 642  : 					for (int i= OBJ_STARTUSERINDEX;i<OBJMAX;i++)

  01a42	c7 85 dc fe ff
	ff b0 36 00 00	 mov	 DWORD PTR _i$236803[ebp], 14000 ; 000036b0H
  01a4c	eb 0f		 jmp	 SHORT $LN9@ProcState_
$LN8@ProcState_:
  01a4e	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _i$236803[ebp]
  01a54	83 c0 01	 add	 eax, 1
  01a57	89 85 dc fe ff
	ff		 mov	 DWORD PTR _i$236803[ebp], eax
$LN9@ProcState_:
  01a5d	81 bd dc fe ff
	ff 98 3a 00 00	 cmp	 DWORD PTR _i$236803[ebp], 15000 ; 00003a98H
  01a67	0f 8d 8a 01 00
	00		 jge	 $LN16@ProcState_

; 643  : 					{
; 644  : 						if ( gObj[i].Connected == PLAYER_PLAYING && gObj[i].Type == OBJ_USER)

  01a6d	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _i$236803[ebp]
  01a73	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01a79	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01a7f	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  01a84	0f 85 68 01 00
	00		 jne	 $LN6@ProcState_
  01a8a	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _i$236803[ebp]
  01a90	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01a96	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01a9c	0f b7 54 01 68	 movzx	 edx, WORD PTR [ecx+eax+104]
  01aa1	83 fa 01	 cmp	 edx, 1
  01aa4	0f 85 48 01 00
	00		 jne	 $LN6@ProcState_

; 645  : 						{
; 646  : 							if ( BC_MAP_RANGE(gObj[i].MapNumber) == FALSE )

  01aaa	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _i$236803[ebp]
  01ab0	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01ab6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01abc	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  01ac4	83 fa 34	 cmp	 edx, 52			; 00000034H
  01ac7	75 0c		 jne	 SHORT $LN21@ProcState_
  01ac9	c7 85 98 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv241[ebp], 1
  01ad3	eb 5f		 jmp	 SHORT $LN22@ProcState_
$LN21@ProcState_:
  01ad5	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _i$236803[ebp]
  01adb	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01ae1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01ae7	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  01aef	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  01af2	7d 0c		 jge	 SHORT $LN19@ProcState_
  01af4	c7 85 94 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv240[ebp], 0
  01afe	eb 28		 jmp	 SHORT $LN20@ProcState_
$LN19@ProcState_:
  01b00	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _i$236803[ebp]
  01b06	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01b0c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01b12	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  01b1a	33 c0		 xor	 eax, eax
  01b1c	83 fa 11	 cmp	 edx, 17			; 00000011H
  01b1f	0f 9e c0	 setle	 al
  01b22	89 85 94 fe ff
	ff		 mov	 DWORD PTR tv240[ebp], eax
$LN20@ProcState_:
  01b28	8b 8d 94 fe ff
	ff		 mov	 ecx, DWORD PTR tv240[ebp]
  01b2e	89 8d 98 fe ff
	ff		 mov	 DWORD PTR tv241[ebp], ecx
$LN22@ProcState_:
  01b34	83 bd 98 fe ff
	ff 00		 cmp	 DWORD PTR tv241[ebp], 0
  01b3b	0f 85 b1 00 00
	00		 jne	 $LN6@ProcState_

; 647  : 							{
; 648  : 								if ( CC_MAP_RANGE(gObj[i].MapNumber) == FALSE )

  01b41	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _i$236803[ebp]
  01b47	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01b4d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01b53	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  01b5b	83 fa 35	 cmp	 edx, 53			; 00000035H
  01b5e	75 0c		 jne	 SHORT $LN25@ProcState_
  01b60	c7 85 98 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv260[ebp], 1
  01b6a	eb 5f		 jmp	 SHORT $LN26@ProcState_
$LN25@ProcState_:
  01b6c	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _i$236803[ebp]
  01b72	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01b78	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01b7e	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  01b86	83 fa 12	 cmp	 edx, 18			; 00000012H
  01b89	7d 0c		 jge	 SHORT $LN23@ProcState_
  01b8b	c7 85 94 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv259[ebp], 0
  01b95	eb 28		 jmp	 SHORT $LN24@ProcState_
$LN23@ProcState_:
  01b97	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _i$236803[ebp]
  01b9d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  01ba3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01ba9	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  01bb1	33 c0		 xor	 eax, eax
  01bb3	83 fa 17	 cmp	 edx, 23			; 00000017H
  01bb6	0f 9e c0	 setle	 al
  01bb9	89 85 94 fe ff
	ff		 mov	 DWORD PTR tv259[ebp], eax
$LN24@ProcState_:
  01bbf	8b 8d 94 fe ff
	ff		 mov	 ecx, DWORD PTR tv259[ebp]
  01bc5	89 8d 98 fe ff
	ff		 mov	 DWORD PTR tv260[ebp], ecx
$LN26@ProcState_:
  01bcb	83 bd 98 fe ff
	ff 00		 cmp	 DWORD PTR tv260[ebp], 0
  01bd2	75 1e		 jne	 SHORT $LN6@ProcState_

; 649  : 								{
; 650  : 									DataSend(i,(LPBYTE)&pMsg, pMsg.h.size);

  01bd4	0f b6 85 e1 fe
	ff ff		 movzx	 eax, BYTE PTR _pMsg$236801[ebp+1]
  01bdb	50		 push	 eax
  01bdc	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _pMsg$236801[ebp]
  01be2	51		 push	 ecx
  01be3	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR _i$236803[ebp]
  01be9	52		 push	 edx
  01bea	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  01bef	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@ProcState_:

; 651  : 								}
; 652  : 							}
; 653  : 						}
; 654  : 					}

  01bf2	e9 57 fe ff ff	 jmp	 $LN8@ProcState_
$LN16@ProcState_:

; 655  : 				}
; 656  : 			}
; 657  : 		}
; 658  : 	}
; 659  : 
; 660  : 	if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= 0 )

  01bf7	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01bfa	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  01c00	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01c03	83 bc 01 ac 03
	00 00 00	 cmp	 DWORD PTR [ecx+eax+940], 0
  01c0b	7f 27		 jg	 SHORT $LN17@ProcState_

; 661  : 	{
; 662  : 		if ( g_bBloodCastle != FALSE )

  01c0d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bBloodCastle@@3HA, 0 ; g_bBloodCastle
  01c14	74 10		 je	 SHORT $LN2@ProcState_

; 663  : 		{
; 664  : 			this->SetState(iBridgeIndex, BC_STATE_PLAYING);

  01c16	6a 02		 push	 2
  01c18	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01c1b	50		 push	 eax
  01c1c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01c1f	e8 00 00 00 00	 call	 ?SetState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SetState

; 665  : 		}
; 666  : 		else

  01c24	eb 0e		 jmp	 SHORT $LN17@ProcState_
$LN2@ProcState_:

; 667  : 		{
; 668  : 			this->SetState(iBridgeIndex, BC_STATE_CLOSED);

  01c26	6a 01		 push	 1
  01c28	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01c2b	50		 push	 eax
  01c2c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01c2f	e8 00 00 00 00	 call	 ?SetState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SetState
$LN17@ProcState_:

; 669  : 		}
; 670  : 	}
; 671  : }

  01c34	5f		 pop	 edi
  01c35	5e		 pop	 esi
  01c36	5b		 pop	 ebx
  01c37	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01c3a	33 cd		 xor	 ecx, ebp
  01c3c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01c41	8b e5		 mov	 esp, ebp
  01c43	5d		 pop	 ebp
  01c44	c2 04 00	 ret	 4
?ProcState_Closed@CBloodCastle@@IAEXH@Z ENDP		; CBloodCastle::ProcState_Closed
_TEXT	ENDS
PUBLIC	??_C@_0DK@EOCANJIL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@ ; `string'
PUBLIC	??_C@_0DM@EMKPJGDI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CheckWinnerV@ ; `string'
PUBLIC	??_C@_0ED@LAGFFAOI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CheckWinnerP@ ; `string'
PUBLIC	?GiveReward_Win@CBloodCastle@@QAEXHH@Z		; CBloodCastle::GiveReward_Win
PUBLIC	?CheckWinnerPartyComplete@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckWinnerPartyComplete
PUBLIC	?CheckWinnerValid@CBloodCastle@@QAE_NH@Z	; CBloodCastle::CheckWinnerValid
PUBLIC	?CheckWinnerExist@CBloodCastle@@QAE_NH@Z	; CBloodCastle::CheckWinnerExist
PUBLIC	??_C@_0EA@OKAIGEKM@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@ ; `string'
PUBLIC	?GiveReward_Fail@CBloodCastle@@QAEXH@Z		; CBloodCastle::GiveReward_Fail
PUBLIC	??_C@_0FE@DMAGKDKC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@ ; `string'
PUBLIC	??_C@_0FD@DNPEIOMM@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@ ; `string'
PUBLIC	?CheckEveryUserDie@CBloodCastle@@QAE_NH@Z	; CBloodCastle::CheckEveryUserDie
PUBLIC	??_C@_0CN@CMBLFMKI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@ ; `string'
PUBLIC	?SendNoticeState@CBloodCastle@@QAEXHH@Z		; CBloodCastle::SendNoticeState
PUBLIC	?SetMonster@CBloodCastle@@QAEXH@Z		; CBloodCastle::SetMonster
PUBLIC	?SendCastleEntranceBlockInfo@CBloodCastle@@QAEXH_N@Z ; CBloodCastle::SendCastleEntranceBlockInfo
PUBLIC	?ReleaseCastleEntrance@CBloodCastle@@QAEXH@Z	; CBloodCastle::ReleaseCastleEntrance
PUBLIC	??_C@_0DN@HMEAEABF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5Subsist@ ; `string'
PUBLIC	??_C@_0CF@KANJAKKG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5Not?5Sub@ ; `string'
PUBLIC	??_C@_0DL@ILEHECHL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Bridge?5Chang@ ; `string'
PUBLIC	?SendCastleBridgeBlockInfo@CBloodCastle@@QAEXH_N@Z ; CBloodCastle::SendCastleBridgeBlockInfo
PUBLIC	?ReleaseCastleBridge@CBloodCastle@@QAEXH@Z	; CBloodCastle::ReleaseCastleBridge
PUBLIC	?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z	; CBloodCastle::SendBridgeAnyMsg
PUBLIC	__$ArrayPad$
EXTRN	?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z:PROC	; TNotice::MakeNoticeMsg
;	COMDAT ??_C@_0DK@EOCANJIL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@
CONST	SEGMENT
??_C@_0DK@EOCANJIL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@ DB '['
	DB	'Blood Castle] (%d) Blood Castle Quest Failed -> Time Out', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@EMKPJGDI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CheckWinnerV@
CONST	SEGMENT
??_C@_0DM@EMKPJGDI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CheckWinnerV@ DB '['
	DB	'Blood Castle] (%d) CheckWinnerValid(iBridgeIndex) == false', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@LAGFFAOI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CheckWinnerP@
CONST	SEGMENT
??_C@_0ED@LAGFFAOI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CheckWinnerP@ DB '['
	DB	'Blood Castle] (%d) CheckWinnerPartyComplete(iBridgeIndex) == '
	DB	'true', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@OKAIGEKM@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@
CONST	SEGMENT
??_C@_0EA@OKAIGEKM@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@ DB '['
	DB	'Blood Castle] (%d) Blood Castle Quest Failed -> Every User Ou'
	DB	't', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FE@DMAGKDKC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@
CONST	SEGMENT
??_C@_0FE@DMAGKDKC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@ DB '['
	DB	'Blood Castle] (%d) Blood Castle Quest Fail Result -> Destroy '
	DB	'Saint Status [%s][%s]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@DNPEIOMM@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@
CONST	SEGMENT
??_C@_0FD@DNPEIOMM@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@ DB '['
	DB	'Blood Castle] (%d) Blood Castle Quest Fail Result -> Destroy '
	DB	'Castle Door [%s][%s]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@CMBLFMKI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@
CONST	SEGMENT
??_C@_0CN@CMBLFMKI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@ DB '['
	DB	'Blood Castle] (%d) Blood Castle Quest Start', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@HMEAEABF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5Subsist@
CONST	SEGMENT
??_C@_0DN@HMEAEABF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5Subsist@ DB '['
	DB	'Blood Castle] (%d) Door Subsist (%d)(Name: %s)(Dieregen:%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@KANJAKKG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5Not?5Sub@
CONST	SEGMENT
??_C@_0CF@KANJAKKG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5Not?5Sub@ DB '['
	DB	'Blood Castle] (%d) Door Not Subsist', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@ILEHECHL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Bridge?5Chang@
CONST	SEGMENT
??_C@_0DL@ILEHECHL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Bridge?5Chang@ DB '['
	DB	'Blood Castle] (%d) Bridge Change Bridge Attribute -> Open', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
_pNotice$236843 = -564					; size = 272
_pMsg$236839 = -292					; size = 4
_pNotice$236834 = -288					; size = 272
_pMsg$236822 = -16					; size = 4
_iTICK_MSEC$ = -12					; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
?ProcState_Playing@CBloodCastle@@IAEXH@Z PROC		; CBloodCastle::ProcState_Playing
; _this$ = ecx

; 674  : {

  01c50	55		 push	 ebp
  01c51	8b ec		 mov	 ebp, esp
  01c53	81 ec 74 02 00
	00		 sub	 esp, 628		; 00000274H
  01c59	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  01c5e	33 c5		 xor	 eax, ebp
  01c60	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  01c63	53		 push	 ebx
  01c64	56		 push	 esi
  01c65	57		 push	 edi
  01c66	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 675  : 	int iTICK_MSEC = GetTickCount() - this->m_BridgeData[iBridgeIndex].m_iBC_TICK_COUNT;

  01c69	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  01c6f	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  01c72	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  01c78	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  01c7b	2b 84 0a b0 03
	00 00		 sub	 eax, DWORD PTR [edx+ecx+944]
  01c82	89 45 f4	 mov	 DWORD PTR _iTICK_MSEC$[ebp], eax

; 676  : 
; 677  : 	if ( iTICK_MSEC >= 1000 )

  01c85	81 7d f4 e8 03
	00 00		 cmp	 DWORD PTR _iTICK_MSEC$[ebp], 1000 ; 000003e8H
  01c8c	0f 8c cf 05 00
	00		 jl	 $LN22@ProcState_@2

; 678  : 	{
; 679  : 		this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC -= iTICK_MSEC;

  01c92	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01c95	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  01c9b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01c9e	8b 94 01 ac 03
	00 00		 mov	 edx, DWORD PTR [ecx+eax+940]
  01ca5	2b 55 f4	 sub	 edx, DWORD PTR _iTICK_MSEC$[ebp]
  01ca8	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01cab	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  01cb1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01cb4	89 94 01 ac 03
	00 00		 mov	 DWORD PTR [ecx+eax+940], edx

; 680  : 		this->m_BridgeData[iBridgeIndex].m_iBC_TICK_COUNT = GetTickCount();

  01cbb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  01cc1	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  01cc4	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  01cca	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  01ccd	89 84 0a b0 03
	00 00		 mov	 DWORD PTR [edx+ecx+944], eax

; 681  : 
; 682  : 		if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= ((this->m_iBC_TIME_MIN_PLAY*60-30)*1000) )

  01cd4	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01cd7	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  01cdd	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01ce0	8b 91 0c 23 00
	00		 mov	 edx, DWORD PTR [ecx+8972]
  01ce6	6b d2 3c	 imul	 edx, 60			; 0000003cH
  01ce9	83 ea 1e	 sub	 edx, 30			; 0000001eH
  01cec	69 d2 e8 03 00
	00		 imul	 edx, 1000		; 000003e8H
  01cf2	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01cf5	39 94 01 ac 03
	00 00		 cmp	 DWORD PTR [ecx+eax+940], edx
  01cfc	7f 55		 jg	 SHORT $LN21@ProcState_@2

; 683  : 		{
; 684  : 			if ( this->m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_PLAY == false )

  01cfe	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01d01	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  01d07	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01d0a	0f b6 94 01 c0
	03 00 00	 movzx	 edx, BYTE PTR [ecx+eax+960]
  01d12	85 d2		 test	 edx, edx
  01d14	75 3d		 jne	 SHORT $LN21@ProcState_@2

; 685  : 			{
; 686  : 				this->m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_PLAY = true;

  01d16	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01d19	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  01d1f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01d22	c6 84 01 c0 03
	00 00 01	 mov	 BYTE PTR [ecx+eax+960], 1

; 687  : 				
; 688  : 				PMSG_SET_DEVILSQUARE pMsg;
; 689  : 				PHeadSetB((LPBYTE)&pMsg, 0x92, sizeof(pMsg));

  01d2a	6a 04		 push	 4
  01d2c	68 92 00 00 00	 push	 146			; 00000092H
  01d31	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$236822[ebp]
  01d34	50		 push	 eax
  01d35	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  01d3a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 690  : 				pMsg.Type = 4;

  01d3d	c6 45 f3 04	 mov	 BYTE PTR _pMsg$236822[ebp+3], 4

; 691  : 				this->SendBridgeAnyMsg((LPBYTE)&pMsg, sizeof(pMsg), iBridgeIndex);

  01d41	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01d44	50		 push	 eax
  01d45	6a 04		 push	 4
  01d47	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$236822[ebp]
  01d4a	51		 push	 ecx
  01d4b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01d4e	e8 00 00 00 00	 call	 ?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z ; CBloodCastle::SendBridgeAnyMsg
$LN21@ProcState_@2:

; 692  : 			}
; 693  : 		}
; 694  : 
; 695  : 		if ( this->m_BridgeData[iBridgeIndex].m_bBC_MONSTER_KILL_COMPLETE != false	)

  01d53	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01d56	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  01d5c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01d5f	0f b6 94 01 b8
	03 00 00	 movzx	 edx, BYTE PTR [ecx+eax+952]
  01d67	85 d2		 test	 edx, edx
  01d69	0f 84 20 01 00
	00		 je	 $LN19@ProcState_@2

; 696  : 		{
; 697  : 			if ( this->m_BridgeData[iBridgeIndex].m_dwBC_TICK_DOOR_OPEN != -1 )

  01d6f	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01d72	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  01d78	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01d7b	83 bc 01 d8 03
	00 00 ff	 cmp	 DWORD PTR [ecx+eax+984], -1
  01d83	0f 84 06 01 00
	00		 je	 $LN19@ProcState_@2

; 698  : 			{
; 699  : 				if ( GetTickCount() > this->m_BridgeData[iBridgeIndex].m_dwBC_TICK_DOOR_OPEN )

  01d89	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  01d8f	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  01d92	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  01d98	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  01d9b	3b 84 0a d8 03
	00 00		 cmp	 eax, DWORD PTR [edx+ecx+984]
  01da2	0f 86 e7 00 00
	00		 jbe	 $LN19@ProcState_@2

; 700  : 				{
; 701  : 					this->ReleaseCastleBridge(iBridgeIndex);

  01da8	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01dab	50		 push	 eax
  01dac	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01daf	e8 00 00 00 00	 call	 ?ReleaseCastleBridge@CBloodCastle@@QAEXH@Z ; CBloodCastle::ReleaseCastleBridge

; 702  : 					this->SendCastleBridgeBlockInfo(iBridgeIndex, 0);

  01db4	6a 00		 push	 0
  01db6	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01db9	50		 push	 eax
  01dba	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01dbd	e8 00 00 00 00	 call	 ?SendCastleBridgeBlockInfo@CBloodCastle@@QAEXH_N@Z ; CBloodCastle::SendCastleBridgeBlockInfo

; 703  : 					LogAddTD("[Blood Castle] (%d) Bridge Change Bridge Attribute -> Open", iBridgeIndex+1);

  01dc2	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01dc5	83 c0 01	 add	 eax, 1
  01dc8	50		 push	 eax
  01dc9	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@ILEHECHL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Bridge?5Chang@
  01dce	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01dd4	83 c4 08	 add	 esp, 8

; 704  : 					this->m_BridgeData[iBridgeIndex].m_dwBC_TICK_DOOR_OPEN = -1; // Prevent multiple openings

  01dd7	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01dda	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  01de0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01de3	c7 84 01 d8 03
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+984], -1

; 705  : 
; 706  : 					if(this->m_BridgeData[iBridgeIndex].m_iBC_DOOR_MONSTER_INDEX == -1) //season 2.5 add-on

  01dee	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01df1	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  01df7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01dfa	83 bc 01 5c 04
	00 00 ff	 cmp	 DWORD PTR [ecx+eax+1116], -1
  01e02	75 17		 jne	 SHORT $LN16@ProcState_@2

; 707  : 					{
; 708  : 						LogAddTD("[Blood Castle] (%d) Door Not Subsist", iBridgeIndex+1);

  01e04	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01e07	83 c0 01	 add	 eax, 1
  01e0a	50		 push	 eax
  01e0b	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@KANJAKKG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5Not?5Sub@
  01e10	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01e16	83 c4 08	 add	 esp, 8

; 709  : 					}
; 710  : 					else

  01e19	eb 74		 jmp	 SHORT $LN19@ProcState_@2
$LN16@ProcState_@2:

; 711  : 					{
; 712  : 						LogAddTD("[Blood Castle] (%d) Door Subsist (%d)(Name: %s)(Dieregen:%d)", iBridgeIndex+1, this->m_BridgeData[iBridgeIndex].m_iBC_DOOR_MONSTER_INDEX, gObj[this->m_BridgeData[iBridgeIndex].m_iBC_DOOR_MONSTER_INDEX].Name, gObj[this->m_BridgeData[iBridgeIndex].m_iBC_DOOR_MONSTER_INDEX].DieRegen);

  01e1b	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01e1e	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  01e24	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01e27	8b 94 01 5c 04
	00 00		 mov	 edx, DWORD PTR [ecx+eax+1116]
  01e2e	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  01e34	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01e39	0f be 8c 10 a2
	03 00 00	 movsx	 ecx, BYTE PTR [eax+edx+930]
  01e41	51		 push	 ecx
  01e42	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  01e45	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  01e4b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  01e4e	8b 8c 10 5c 04
	00 00		 mov	 ecx, DWORD PTR [eax+edx+1116]
  01e55	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  01e5b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01e61	8d 44 0a 77	 lea	 eax, DWORD PTR [edx+ecx+119]
  01e65	50		 push	 eax
  01e66	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  01e69	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  01e6f	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  01e72	8b 84 0a 5c 04
	00 00		 mov	 eax, DWORD PTR [edx+ecx+1116]
  01e79	50		 push	 eax
  01e7a	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  01e7d	83 c1 01	 add	 ecx, 1
  01e80	51		 push	 ecx
  01e81	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@HMEAEABF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5Subsist@
  01e86	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01e8c	83 c4 14	 add	 esp, 20			; 00000014H
$LN19@ProcState_@2:

; 713  : 					}
; 714  : 				}
; 715  : 			}
; 716  : 		}
; 717  : 
; 718  : 		if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= ((this->m_iBC_TIME_MIN_PLAY*60-60)*1000) && this->m_BridgeData[iBridgeIndex].m_bBC_PLAY_START == false )

  01e8f	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01e92	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  01e98	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01e9b	8b 91 0c 23 00
	00		 mov	 edx, DWORD PTR [ecx+8972]
  01ea1	6b d2 3c	 imul	 edx, 60			; 0000003cH
  01ea4	83 ea 3c	 sub	 edx, 60			; 0000003cH
  01ea7	69 d2 e8 03 00
	00		 imul	 edx, 1000		; 000003e8H
  01ead	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01eb0	39 94 01 ac 03
	00 00		 cmp	 DWORD PTR [ecx+eax+940], edx
  01eb7	0f 8f f5 00 00
	00		 jg	 $LN14@ProcState_@2
  01ebd	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01ec0	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  01ec6	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01ec9	0f b6 94 01 bd
	03 00 00	 movzx	 edx, BYTE PTR [ecx+eax+957]
  01ed1	85 d2		 test	 edx, edx
  01ed3	0f 85 d9 00 00
	00		 jne	 $LN14@ProcState_@2

; 719  : 		{
; 720  : 			PMSG_NOTICE pNotice;
; 721  : 
; 722  : 			this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC = (this->m_iBC_TIME_MIN_PLAY*60)*1000;

  01ed9	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  01edc	8b 88 0c 23 00
	00		 mov	 ecx, DWORD PTR [eax+8972]
  01ee2	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  01ee5	69 c9 e8 03 00
	00		 imul	 ecx, 1000		; 000003e8H
  01eeb	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  01eee	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  01ef4	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  01ef7	89 8c 10 ac 03
	00 00		 mov	 DWORD PTR [eax+edx+940], ecx

; 723  : 			this->m_BridgeData[iBridgeIndex].m_bBC_CAN_PARTY = false;

  01efe	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01f01	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  01f07	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01f0a	c6 84 01 bc 03
	00 00 00	 mov	 BYTE PTR [ecx+eax+956], 0

; 724  : 			TNotice::MakeNoticeMsgEx((TNotice*)&pNotice, 0, lMsg.Get(MSGGET(4, 137)), iBridgeIndex+1);

  01f12	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01f15	83 c0 01	 add	 eax, 1
  01f18	50		 push	 eax
  01f19	68 89 04 00 00	 push	 1161			; 00000489H
  01f1e	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  01f23	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  01f28	50		 push	 eax
  01f29	6a 00		 push	 0
  01f2b	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$236834[ebp]
  01f31	51		 push	 ecx
  01f32	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx
  01f37	83 c4 10	 add	 esp, 16			; 00000010H

; 725  : 			this->SendBridgeAnyMsg( (LPBYTE)&pNotice, pNotice.h.size, iBridgeIndex);

  01f3a	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01f3d	50		 push	 eax
  01f3e	0f b6 8d e1 fe
	ff ff		 movzx	 ecx, BYTE PTR _pNotice$236834[ebp+1]
  01f45	51		 push	 ecx
  01f46	8d 95 e0 fe ff
	ff		 lea	 edx, DWORD PTR _pNotice$236834[ebp]
  01f4c	52		 push	 edx
  01f4d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01f50	e8 00 00 00 00	 call	 ?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z ; CBloodCastle::SendBridgeAnyMsg

; 726  : 			this->ReleaseCastleEntrance(iBridgeIndex);

  01f55	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01f58	50		 push	 eax
  01f59	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01f5c	e8 00 00 00 00	 call	 ?ReleaseCastleEntrance@CBloodCastle@@QAEXH@Z ; CBloodCastle::ReleaseCastleEntrance

; 727  : 			this->SendCastleEntranceBlockInfo(iBridgeIndex, 0);

  01f61	6a 00		 push	 0
  01f63	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01f66	50		 push	 eax
  01f67	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01f6a	e8 00 00 00 00	 call	 ?SendCastleEntranceBlockInfo@CBloodCastle@@QAEXH_N@Z ; CBloodCastle::SendCastleEntranceBlockInfo

; 728  : 			this->m_BridgeData[iBridgeIndex].m_bBC_PLAY_START = true;

  01f6f	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01f72	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  01f78	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01f7b	c6 84 01 bd 03
	00 00 01	 mov	 BYTE PTR [ecx+eax+957], 1

; 729  : 			this->SetMonster(iBridgeIndex);

  01f83	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01f86	50		 push	 eax
  01f87	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01f8a	e8 00 00 00 00	 call	 ?SetMonster@CBloodCastle@@QAEXH@Z ; CBloodCastle::SetMonster

; 730  : 			this->SendNoticeState(iBridgeIndex, false);

  01f8f	6a 00		 push	 0
  01f91	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01f94	50		 push	 eax
  01f95	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01f98	e8 00 00 00 00	 call	 ?SendNoticeState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SendNoticeState

; 731  : 
; 732  : 			LogAddTD("[Blood Castle] (%d) Blood Castle Quest Start", iBridgeIndex+1);

  01f9d	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01fa0	83 c0 01	 add	 eax, 1
  01fa3	50		 push	 eax
  01fa4	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@CMBLFMKI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@
  01fa9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01faf	83 c4 08	 add	 esp, 8
$LN14@ProcState_@2:

; 733  : 		}
; 734  : 
; 735  : 		if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= 30000 && this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC > 0 && this->m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_END == false)	// Set counter to kick

  01fb2	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01fb5	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  01fbb	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01fbe	81 bc 01 ac 03
	00 00 30 75 00
	00		 cmp	 DWORD PTR [ecx+eax+940], 30000 ; 00007530H
  01fc9	7f 74		 jg	 SHORT $LN13@ProcState_@2
  01fcb	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01fce	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  01fd4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01fd7	83 bc 01 ac 03
	00 00 00	 cmp	 DWORD PTR [ecx+eax+940], 0
  01fdf	7e 5e		 jle	 SHORT $LN13@ProcState_@2
  01fe1	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01fe4	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  01fea	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01fed	0f b6 94 01 c1
	03 00 00	 movzx	 edx, BYTE PTR [ecx+eax+961]
  01ff5	85 d2		 test	 edx, edx
  01ff7	75 46		 jne	 SHORT $LN13@ProcState_@2

; 736  : 		{
; 737  : 			this->m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_END = true;

  01ff9	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  01ffc	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  02002	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  02005	c6 84 01 c1 03
	00 00 01	 mov	 BYTE PTR [ecx+eax+961], 1

; 738  : 			PMSG_SET_DEVILSQUARE pMsg;
; 739  : 			PHeadSetB((LPBYTE)&pMsg, 0x92, sizeof(pMsg));

  0200d	6a 04		 push	 4
  0200f	68 92 00 00 00	 push	 146			; 00000092H
  02014	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$236839[ebp]
  0201a	50		 push	 eax
  0201b	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  02020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 740  : 			pMsg.Type = 5;

  02023	c6 85 df fe ff
	ff 05		 mov	 BYTE PTR _pMsg$236839[ebp+3], 5

; 741  : 			this->SendBridgeAnyMsg((LPBYTE)&pMsg, sizeof(pMsg), iBridgeIndex);

  0202a	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0202d	50		 push	 eax
  0202e	6a 04		 push	 4
  02030	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR _pMsg$236839[ebp]
  02036	51		 push	 ecx
  02037	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0203a	e8 00 00 00 00	 call	 ?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z ; CBloodCastle::SendBridgeAnyMsg
$LN13@ProcState_@2:

; 742  : 		}
; 743  : 
; 744  : 		if ( this->CheckEveryUserDie(iBridgeIndex) != false )

  0203f	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  02042	50		 push	 eax
  02043	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  02046	e8 00 00 00 00	 call	 ?CheckEveryUserDie@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckEveryUserDie
  0204b	0f b6 c8	 movzx	 ecx, al
  0204e	85 c9		 test	 ecx, ecx
  02050	0f 84 e7 00 00
	00		 je	 $LN12@ProcState_@2

; 745  : 		{
; 746  : 			PMSG_NOTICE pNotice;
; 747  : 
; 748  : 			TNotice::MakeNoticeMsg(&pNotice, 0, lMsg.Get(MSGGET(4, 138)));

  02056	68 8a 04 00 00	 push	 1162			; 0000048aH
  0205b	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  02060	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  02065	50		 push	 eax
  02066	6a 00		 push	 0
  02068	8d 85 cc fd ff
	ff		 lea	 eax, DWORD PTR _pNotice$236843[ebp]
  0206e	50		 push	 eax
  0206f	e8 00 00 00 00	 call	 ?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z ; TNotice::MakeNoticeMsg
  02074	83 c4 0c	 add	 esp, 12			; 0000000cH

; 749  : 			this->SendBridgeAnyMsg( (LPBYTE)&pNotice, pNotice.h.size, iBridgeIndex);

  02077	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0207a	50		 push	 eax
  0207b	0f b6 8d cd fd
	ff ff		 movzx	 ecx, BYTE PTR _pNotice$236843[ebp+1]
  02082	51		 push	 ecx
  02083	8d 95 cc fd ff
	ff		 lea	 edx, DWORD PTR _pNotice$236843[ebp]
  02089	52		 push	 edx
  0208a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0208d	e8 00 00 00 00	 call	 ?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z ; CBloodCastle::SendBridgeAnyMsg

; 750  : 
; 751  : 			LogAddTD("[Blood Castle] (%d) Blood Castle Quest Fail Result -> Destroy Castle Door [%s][%s]", iBridgeIndex+1, this->m_BridgeData[iBridgeIndex].m_szKill_Door_AccountID, this->m_BridgeData[iBridgeIndex].m_szKill_Door_CharName);

  02092	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  02095	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0209b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0209e	8d 94 01 0b 04
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1035]
  020a5	52		 push	 edx
  020a6	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  020a9	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  020af	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  020b2	8d 94 01 00 04
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1024]
  020b9	52		 push	 edx
  020ba	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  020bd	83 c0 01	 add	 eax, 1
  020c0	50		 push	 eax
  020c1	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@DNPEIOMM@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@
  020c6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  020cc	83 c4 10	 add	 esp, 16			; 00000010H

; 752  : 			LogAddTD("[Blood Castle] (%d) Blood Castle Quest Fail Result -> Destroy Saint Status [%s][%s]", iBridgeIndex+1, this->m_BridgeData[iBridgeIndex].m_szKill_Door_AccountID, this->m_BridgeData[iBridgeIndex].m_szKill_Status_CharName);

  020cf	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  020d2	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  020d8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  020db	8d 94 01 20 04
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1056]
  020e2	52		 push	 edx
  020e3	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  020e6	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  020ec	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  020ef	8d 94 01 00 04
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1024]
  020f6	52		 push	 edx
  020f7	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  020fa	83 c0 01	 add	 eax, 1
  020fd	50		 push	 eax
  020fe	68 00 00 00 00	 push	 OFFSET ??_C@_0FE@DMAGKDKC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@
  02103	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  02109	83 c4 10	 add	 esp, 16			; 00000010H

; 753  : 
; 754  : 			this->GiveReward_Fail(iBridgeIndex);

  0210c	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0210f	50		 push	 eax
  02110	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  02113	e8 00 00 00 00	 call	 ?GiveReward_Fail@CBloodCastle@@QAEXH@Z ; CBloodCastle::GiveReward_Fail

; 755  : 			this->SetState(iBridgeIndex, BC_STATE_CLOSED);

  02118	6a 01		 push	 1
  0211a	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0211d	50		 push	 eax
  0211e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  02121	e8 00 00 00 00	 call	 ?SetState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SetState

; 756  : 
; 757  : 			LogAddTD("[Blood Castle] (%d) Blood Castle Quest Failed -> Every User Out", iBridgeIndex+1);

  02126	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  02129	83 c0 01	 add	 eax, 1
  0212c	50		 push	 eax
  0212d	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@OKAIGEKM@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@
  02132	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  02138	83 c4 08	 add	 esp, 8

; 758  : 		}
; 759  : 		else

  0213b	eb 66		 jmp	 SHORT $LN11@ProcState_@2
$LN12@ProcState_@2:

; 760  : 		{
; 761  : 			if ( this->m_BridgeData[iBridgeIndex].m_bBC_PLAY_START != false )

  0213d	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  02140	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  02146	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  02149	0f b6 94 01 bd
	03 00 00	 movzx	 edx, BYTE PTR [ecx+eax+957]
  02151	85 d2		 test	 edx, edx
  02153	74 4e		 je	 SHORT $LN11@ProcState_@2

; 762  : 			{
; 763  : 				if ( this->m_BridgeData[iBridgeIndex].m_bBC_DOOR_TERMINATE_COMPLETE == false || this->m_BridgeData[iBridgeIndex].m_bBC_BOSS_MONSTER_KILL_COMPLETE != false )

  02155	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  02158	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0215e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  02161	0f b6 94 01 ba
	03 00 00	 movzx	 edx, BYTE PTR [ecx+eax+954]
  02169	85 d2		 test	 edx, edx
  0216b	74 18		 je	 SHORT $LN8@ProcState_@2
  0216d	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  02170	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  02176	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  02179	0f b6 94 01 b9
	03 00 00	 movzx	 edx, BYTE PTR [ecx+eax+953]
  02181	85 d2		 test	 edx, edx
  02183	74 10		 je	 SHORT $LN9@ProcState_@2
$LN8@ProcState_@2:

; 764  : 				{
; 765  : 					this->SendNoticeState(iBridgeIndex, 1);

  02185	6a 01		 push	 1
  02187	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0218a	50		 push	 eax
  0218b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0218e	e8 00 00 00 00	 call	 ?SendNoticeState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SendNoticeState

; 766  : 				}
; 767  : 				else

  02193	eb 0e		 jmp	 SHORT $LN11@ProcState_@2
$LN9@ProcState_@2:

; 768  : 				{
; 769  : 					this->SendNoticeState(iBridgeIndex, 4);

  02195	6a 04		 push	 4
  02197	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0219a	50		 push	 eax
  0219b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0219e	e8 00 00 00 00	 call	 ?SendNoticeState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SendNoticeState
$LN11@ProcState_@2:

; 770  : 				}
; 771  : 			}
; 772  : 		}
; 773  : 
; 774  : 		if ( this->CheckWinnerExist(iBridgeIndex) == true )

  021a3	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  021a6	50		 push	 eax
  021a7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  021aa	e8 00 00 00 00	 call	 ?CheckWinnerExist@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckWinnerExist
  021af	0f b6 c8	 movzx	 ecx, al
  021b2	83 f9 01	 cmp	 ecx, 1
  021b5	0f 85 a6 00 00
	00		 jne	 $LN22@ProcState_@2

; 775  : 		{
; 776  : 			if ( this->CheckWinnerValid(iBridgeIndex) == true )

  021bb	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  021be	50		 push	 eax
  021bf	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  021c2	e8 00 00 00 00	 call	 ?CheckWinnerValid@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckWinnerValid
  021c7	0f b6 c8	 movzx	 ecx, al
  021ca	83 f9 01	 cmp	 ecx, 1
  021cd	75 5e		 jne	 SHORT $LN5@ProcState_@2

; 777  : 			{
; 778  : 				if ( this->CheckWinnerPartyComplete(iBridgeIndex) == true )

  021cf	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  021d2	50		 push	 eax
  021d3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  021d6	e8 00 00 00 00	 call	 ?CheckWinnerPartyComplete@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckWinnerPartyComplete
  021db	0f b6 c8	 movzx	 ecx, al
  021de	83 f9 01	 cmp	 ecx, 1
  021e1	75 48		 jne	 SHORT $LN4@ProcState_@2

; 779  : 				{
; 780  : 					this->GiveReward_Win(this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX, iBridgeIndex);

  021e3	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  021e6	50		 push	 eax
  021e7	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  021ea	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  021f0	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  021f3	8b 84 0a 58 04
	00 00		 mov	 eax, DWORD PTR [edx+ecx+1112]
  021fa	50		 push	 eax
  021fb	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  021fe	e8 00 00 00 00	 call	 ?GiveReward_Win@CBloodCastle@@QAEXHH@Z ; CBloodCastle::GiveReward_Win

; 781  : 					this->SetState(iBridgeIndex, BC_STATE_PLAYEND);

  02203	6a 03		 push	 3
  02205	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  02208	50		 push	 eax
  02209	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0220c	e8 00 00 00 00	 call	 ?SetState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SetState

; 782  : 
; 783  : 					LogAddTD("[Blood Castle] (%d) CheckWinnerPartyComplete(iBridgeIndex) == true", iBridgeIndex+1);

  02211	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  02214	83 c0 01	 add	 eax, 1
  02217	50		 push	 eax
  02218	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@LAGFFAOI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CheckWinnerP@
  0221d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  02223	83 c4 08	 add	 esp, 8

; 784  : 					return;

  02226	e9 15 01 00 00	 jmp	 $LN23@ProcState_@2
$LN4@ProcState_@2:

; 785  : 				}
; 786  : 			}
; 787  : 			else

  0222b	eb 34		 jmp	 SHORT $LN22@ProcState_@2
$LN5@ProcState_@2:

; 788  : 			{
; 789  : 				this->GiveReward_Fail(iBridgeIndex);

  0222d	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  02230	50		 push	 eax
  02231	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  02234	e8 00 00 00 00	 call	 ?GiveReward_Fail@CBloodCastle@@QAEXH@Z ; CBloodCastle::GiveReward_Fail

; 790  : 				this->SetState(iBridgeIndex, BC_STATE_PLAYEND); 

  02239	6a 03		 push	 3
  0223b	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0223e	50		 push	 eax
  0223f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  02242	e8 00 00 00 00	 call	 ?SetState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SetState

; 791  : 
; 792  : 				LogAddTD("[Blood Castle] (%d) CheckWinnerValid(iBridgeIndex) == false", iBridgeIndex+1);

  02247	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0224a	83 c0 01	 add	 eax, 1
  0224d	50		 push	 eax
  0224e	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@EMKPJGDI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CheckWinnerV@
  02253	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  02259	83 c4 08	 add	 esp, 8

; 793  : 				return;

  0225c	e9 df 00 00 00	 jmp	 $LN23@ProcState_@2
$LN22@ProcState_@2:

; 794  : 			}
; 795  : 		}
; 796  : 	}
; 797  : 
; 798  : 	if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= 0 )

  02261	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  02264	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0226a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0226d	83 bc 01 ac 03
	00 00 00	 cmp	 DWORD PTR [ecx+eax+940], 0
  02275	0f 8f c5 00 00
	00		 jg	 $LN23@ProcState_@2

; 799  : 	{
; 800  : 		if ( this->m_BridgeData[iBridgeIndex].m_bBC_REWARDED == false )

  0227b	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0227e	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  02284	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  02287	0f b6 94 01 be
	03 00 00	 movzx	 edx, BYTE PTR [ecx+eax+958]
  0228f	85 d2		 test	 edx, edx
  02291	0f 85 9b 00 00
	00		 jne	 $LN1@ProcState_@2

; 801  : 		{
; 802  : 			LogAddTD("[Blood Castle] (%d) Blood Castle Quest Fail Result -> Destroy Castle Door [%s][%s]", iBridgeIndex+1, this->m_BridgeData[iBridgeIndex].m_szKill_Door_AccountID, this->m_BridgeData[iBridgeIndex].m_szKill_Door_CharName);

  02297	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0229a	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  022a0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  022a3	8d 94 01 0b 04
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1035]
  022aa	52		 push	 edx
  022ab	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  022ae	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  022b4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  022b7	8d 94 01 00 04
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1024]
  022be	52		 push	 edx
  022bf	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  022c2	83 c0 01	 add	 eax, 1
  022c5	50		 push	 eax
  022c6	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@DNPEIOMM@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@
  022cb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  022d1	83 c4 10	 add	 esp, 16			; 00000010H

; 803  : 			LogAddTD("[Blood Castle] (%d) Blood Castle Quest Fail Result -> Destroy Saint Status [%s][%s]", iBridgeIndex+1, this->m_BridgeData[iBridgeIndex].m_szKill_Status_AccountID, this->m_BridgeData[iBridgeIndex].m_szKill_Status_CharName);

  022d4	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  022d7	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  022dd	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  022e0	8d 94 01 20 04
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1056]
  022e7	52		 push	 edx
  022e8	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  022eb	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  022f1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  022f4	8d 94 01 2b 04
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1067]
  022fb	52		 push	 edx
  022fc	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  022ff	83 c0 01	 add	 eax, 1
  02302	50		 push	 eax
  02303	68 00 00 00 00	 push	 OFFSET ??_C@_0FE@DMAGKDKC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@
  02308	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0230e	83 c4 10	 add	 esp, 16			; 00000010H

; 804  : 
; 805  : 			this->GiveReward_Fail(iBridgeIndex);

  02311	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  02314	50		 push	 eax
  02315	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  02318	e8 00 00 00 00	 call	 ?GiveReward_Fail@CBloodCastle@@QAEXH@Z ; CBloodCastle::GiveReward_Fail

; 806  : 
; 807  : 			LogAddTD("[Blood Castle] (%d) Blood Castle Quest Failed -> Time Out", iBridgeIndex+1);

  0231d	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  02320	83 c0 01	 add	 eax, 1
  02323	50		 push	 eax
  02324	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@EOCANJIL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@
  02329	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0232f	83 c4 08	 add	 esp, 8
$LN1@ProcState_@2:

; 808  : 			
; 809  : 		}
; 810  : 
; 811  : 		this->SetState(iBridgeIndex, BC_STATE_PLAYEND);

  02332	6a 03		 push	 3
  02334	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  02337	50		 push	 eax
  02338	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0233b	e8 00 00 00 00	 call	 ?SetState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SetState
$LN23@ProcState_@2:

; 812  : 	}
; 813  : }

  02340	5f		 pop	 edi
  02341	5e		 pop	 esi
  02342	5b		 pop	 ebx
  02343	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  02346	33 cd		 xor	 ecx, ebp
  02348	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0234d	8b e5		 mov	 esp, ebp
  0234f	5d		 pop	 ebp
  02350	c2 04 00	 ret	 4
?ProcState_Playing@CBloodCastle@@IAEXH@Z ENDP		; CBloodCastle::ProcState_Playing
; Function compile flags: /Odtp /ZI
_pMsg$236869 = -12					; size = 4
_iTICK_MSEC$ = -8					; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?ProcState_PlayEnd@CBloodCastle@@IAEXH@Z PROC		; CBloodCastle::ProcState_PlayEnd
; _this$ = ecx

; 816  : {

  02360	55		 push	 ebp
  02361	8b ec		 mov	 ebp, esp
  02363	83 ec 4c	 sub	 esp, 76			; 0000004cH
  02366	53		 push	 ebx
  02367	56		 push	 esi
  02368	57		 push	 edi
  02369	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 817  : 	int iTICK_MSEC = GetTickCount() - this->m_BridgeData[iBridgeIndex].m_iBC_TICK_COUNT;

  0236c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  02372	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  02375	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  0237b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0237e	2b 84 0a b0 03
	00 00		 sub	 eax, DWORD PTR [edx+ecx+944]
  02385	89 45 f8	 mov	 DWORD PTR _iTICK_MSEC$[ebp], eax

; 818  : 
; 819  : 	if ( iTICK_MSEC >= 1000 )

  02388	81 7d f8 e8 03
	00 00		 cmp	 DWORD PTR _iTICK_MSEC$[ebp], 1000 ; 000003e8H
  0238f	0f 8c c6 00 00
	00		 jl	 $LN3@ProcState_@3

; 820  : 	{
; 821  : 		this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC -= iTICK_MSEC;

  02395	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  02398	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0239e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  023a1	8b 94 01 ac 03
	00 00		 mov	 edx, DWORD PTR [ecx+eax+940]
  023a8	2b 55 f8	 sub	 edx, DWORD PTR _iTICK_MSEC$[ebp]
  023ab	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  023ae	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  023b4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  023b7	89 94 01 ac 03
	00 00		 mov	 DWORD PTR [ecx+eax+940], edx

; 822  : 		this->m_BridgeData[iBridgeIndex].m_iBC_TICK_COUNT = GetTickCount();

  023be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  023c4	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  023c7	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  023cd	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  023d0	89 84 0a b0 03
	00 00		 mov	 DWORD PTR [edx+ecx+944], eax

; 823  : 
; 824  : 		if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= 30000 && this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC > 0 && this->m_BridgeData[iBridgeIndex]. m_bBC_MSG_BEFORE_QUIT == false)

  023d7	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  023da	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  023e0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  023e3	81 bc 01 ac 03
	00 00 30 75 00
	00		 cmp	 DWORD PTR [ecx+eax+940], 30000 ; 00007530H
  023ee	7f 6b		 jg	 SHORT $LN3@ProcState_@3
  023f0	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  023f3	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  023f9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  023fc	83 bc 01 ac 03
	00 00 00	 cmp	 DWORD PTR [ecx+eax+940], 0
  02404	7e 55		 jle	 SHORT $LN3@ProcState_@3
  02406	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  02409	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0240f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02412	0f b6 94 01 c2
	03 00 00	 movzx	 edx, BYTE PTR [ecx+eax+962]
  0241a	85 d2		 test	 edx, edx
  0241c	75 3d		 jne	 SHORT $LN3@ProcState_@3

; 825  : 		{
; 826  : 			this->m_BridgeData[iBridgeIndex]. m_bBC_MSG_BEFORE_QUIT = true;

  0241e	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  02421	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  02427	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0242a	c6 84 01 c2 03
	00 00 01	 mov	 BYTE PTR [ecx+eax+962], 1

; 827  : 
; 828  : 			PMSG_SET_DEVILSQUARE pMsg;
; 829  : 
; 830  : 			PHeadSetB((LPBYTE)&pMsg, 0x92, sizeof(pMsg));

  02432	6a 04		 push	 4
  02434	68 92 00 00 00	 push	 146			; 00000092H
  02439	8d 45 f4	 lea	 eax, DWORD PTR _pMsg$236869[ebp]
  0243c	50		 push	 eax
  0243d	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  02442	83 c4 0c	 add	 esp, 12			; 0000000cH

; 831  : 			pMsg.Type = 6;

  02445	c6 45 f7 06	 mov	 BYTE PTR _pMsg$236869[ebp+3], 6

; 832  : 
; 833  : 			this->SendBridgeAnyMsg((LPBYTE)&pMsg, sizeof(pMsg), iBridgeIndex);

  02449	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0244c	50		 push	 eax
  0244d	6a 04		 push	 4
  0244f	8d 4d f4	 lea	 ecx, DWORD PTR _pMsg$236869[ebp]
  02452	51		 push	 ecx
  02453	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02456	e8 00 00 00 00	 call	 ?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z ; CBloodCastle::SendBridgeAnyMsg
$LN3@ProcState_@3:

; 834  : 		}
; 835  : 
; 836  : 
; 837  : 	}
; 838  : 
; 839  : 	if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= 0 )

  0245b	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0245e	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  02464	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02467	83 bc 01 ac 03
	00 00 00	 cmp	 DWORD PTR [ecx+eax+940], 0
  0246f	7f 0e		 jg	 SHORT $LN4@ProcState_@3

; 840  : 	{
; 841  : 		this->SetState(iBridgeIndex, BC_STATE_CLOSED);

  02471	6a 01		 push	 1
  02473	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  02476	50		 push	 eax
  02477	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0247a	e8 00 00 00 00	 call	 ?SetState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SetState
$LN4@ProcState_@3:

; 842  : 	}
; 843  : }

  0247f	5f		 pop	 edi
  02480	5e		 pop	 esi
  02481	5b		 pop	 ebx
  02482	8b e5		 mov	 esp, ebp
  02484	5d		 pop	 ebp
  02485	c2 04 00	 ret	 4
?ProcState_PlayEnd@CBloodCastle@@IAEXH@Z ENDP		; CBloodCastle::ProcState_PlayEnd
_TEXT	ENDS
PUBLIC	?BlockCastleDoor@CBloodCastle@@QAEXH@Z		; CBloodCastle::BlockCastleDoor
PUBLIC	?ClearMonster@CBloodCastle@@QAEXH_N@Z		; CBloodCastle::ClearMonster
EXTRN	?gObjMoveGate@@YAHHH@Z:PROC			; gObjMoveGate
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv67 = -80						; size = 4
_iMapNumber$236882 = -12				; size = 4
_n$236878 = -8						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?SetState_None@CBloodCastle@@IAEXH@Z PROC		; CBloodCastle::SetState_None
; _this$ = ecx

; 847  : {

  02490	55		 push	 ebp
  02491	8b ec		 mov	 ebp, esp
  02493	83 ec 50	 sub	 esp, 80			; 00000050H
  02496	53		 push	 ebx
  02497	56		 push	 esi
  02498	57		 push	 edi
  02499	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 848  : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  0249c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  024a0	7d 09		 jge	 SHORT $LN8@SetState_N
  024a2	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  024a9	eb 0c		 jmp	 SHORT $LN9@SetState_N
$LN8@SetState_N:
  024ab	33 c0		 xor	 eax, eax
  024ad	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  024b1	0f 9e c0	 setle	 al
  024b4	89 45 b0	 mov	 DWORD PTR tv67[ebp], eax
$LN9@SetState_N:
  024b7	83 7d b0 00	 cmp	 DWORD PTR tv67[ebp], 0
  024bb	75 05		 jne	 SHORT $LN5@SetState_N

; 849  : 	{
; 850  : 		return;

  024bd	e9 ce 00 00 00	 jmp	 $LN6@SetState_N
$LN5@SetState_N:

; 851  : 	}
; 852  : 
; 853  : 	this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC = -1;

  024c2	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  024c5	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  024cb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  024ce	c7 84 01 ac 03
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+940], -1

; 854  : 	this->m_BridgeData[iBridgeIndex].m_iBC_TICK_COUNT = -1;

  024d9	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  024dc	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  024e2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  024e5	c7 84 01 b0 03
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+944], -1

; 855  : 	this->SendNoticeState(iBridgeIndex, 2);

  024f0	6a 02		 push	 2
  024f2	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  024f5	50		 push	 eax
  024f6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  024f9	e8 00 00 00 00	 call	 ?SendNoticeState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SendNoticeState

; 856  : 	this->ClearBridgeData(iBridgeIndex);

  024fe	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  02501	50		 push	 eax
  02502	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02505	e8 00 00 00 00	 call	 ?ClearBridgeData@CBloodCastle@@IAEXH@Z ; CBloodCastle::ClearBridgeData

; 857  : 	this->ClearMonster(iBridgeIndex, 1);

  0250a	6a 01		 push	 1
  0250c	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0250f	50		 push	 eax
  02510	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02513	e8 00 00 00 00	 call	 ?ClearMonster@CBloodCastle@@QAEXH_N@Z ; CBloodCastle::ClearMonster

; 858  : 
; 859  : 	for (int n=OBJ_STARTUSERINDEX;n<OBJMAX;n++)

  02518	c7 45 f8 b0 36
	00 00		 mov	 DWORD PTR _n$236878[ebp], 14000 ; 000036b0H
  0251f	eb 09		 jmp	 SHORT $LN4@SetState_N
$LN3@SetState_N:
  02521	8b 45 f8	 mov	 eax, DWORD PTR _n$236878[ebp]
  02524	83 c0 01	 add	 eax, 1
  02527	89 45 f8	 mov	 DWORD PTR _n$236878[ebp], eax
$LN4@SetState_N:
  0252a	81 7d f8 98 3a
	00 00		 cmp	 DWORD PTR _n$236878[ebp], 15000 ; 00003a98H
  02531	7d 51		 jge	 SHORT $LN2@SetState_N

; 860  : 	{
; 861  : 		int iMapNumber = this->GetBridgeMapNumber(iBridgeIndex); //season3 add-on

  02533	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  02536	50		 push	 eax
  02537	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0253a	e8 00 00 00 00	 call	 ?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeMapNumber
  0253f	89 45 f4	 mov	 DWORD PTR _iMapNumber$236882[ebp], eax

; 862  : 
; 863  : 		if ( gObj[n].MapNumber == iMapNumber && gObj[n].Connected == PLAYER_PLAYING ) //season3 changed

  02542	8b 45 f8	 mov	 eax, DWORD PTR _n$236878[ebp]
  02545	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0254b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02551	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  02559	3b 55 f4	 cmp	 edx, DWORD PTR _iMapNumber$236882[ebp]
  0255c	75 24		 jne	 SHORT $LN1@SetState_N
  0255e	8b 45 f8	 mov	 eax, DWORD PTR _n$236878[ebp]
  02561	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  02567	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0256d	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  02572	75 0e		 jne	 SHORT $LN1@SetState_N

; 864  : 		{
; 865  : 			gObjMoveGate(n, 22);

  02574	6a 16		 push	 22			; 00000016H
  02576	8b 45 f8	 mov	 eax, DWORD PTR _n$236878[ebp]
  02579	50		 push	 eax
  0257a	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  0257f	83 c4 08	 add	 esp, 8
$LN1@SetState_N:

; 866  : 		}
; 867  : 	}

  02582	eb 9d		 jmp	 SHORT $LN3@SetState_N
$LN2@SetState_N:

; 868  : 
; 869  : 	this->BlockCastleDoor(iBridgeIndex);

  02584	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  02587	50		 push	 eax
  02588	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0258b	e8 00 00 00 00	 call	 ?BlockCastleDoor@CBloodCastle@@QAEXH@Z ; CBloodCastle::BlockCastleDoor
$LN6@SetState_N:

; 870  : }

  02590	5f		 pop	 edi
  02591	5e		 pop	 esi
  02592	5b		 pop	 ebx
  02593	8b e5		 mov	 esp, ebp
  02595	5d		 pop	 ebp
  02596	c2 04 00	 ret	 4
?SetState_None@CBloodCastle@@IAEXH@Z ENDP		; CBloodCastle::SetState_None
_TEXT	ENDS
PUBLIC	??_C@_0CE@INEHOCBG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5CLO@ ; `string'
PUBLIC	?BlockCastleEntrance@CBloodCastle@@QAEXH@Z	; CBloodCastle::BlockCastleEntrance
PUBLIC	?BlockCastleBridge@CBloodCastle@@QAEXH@Z	; CBloodCastle::BlockCastleBridge
PUBLIC	?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDeleteQuestItem
PUBLIC	?CheckAngelKingExist@CBloodCastle@@QAE_NH@Z	; CBloodCastle::CheckAngelKingExist
;	COMDAT ??_C@_0CE@INEHOCBG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5CLO@
CONST	SEGMENT
??_C@_0CE@INEHOCBG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5CLO@ DB '['
	DB	'Blood Castle] (%d) SetState CLOSED', 00H	; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv67 = -80						; size = 4
_iMapNumber$236893 = -12				; size = 4
_n$236889 = -8						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?SetState_Closed@CBloodCastle@@IAEXH@Z PROC		; CBloodCastle::SetState_Closed
; _this$ = ecx

; 874  : {

  025a0	55		 push	 ebp
  025a1	8b ec		 mov	 ebp, esp
  025a3	83 ec 50	 sub	 esp, 80			; 00000050H
  025a6	53		 push	 ebx
  025a7	56		 push	 esi
  025a8	57		 push	 edi
  025a9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 875  : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  025ac	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  025b0	7d 09		 jge	 SHORT $LN8@SetState_C
  025b2	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  025b9	eb 0c		 jmp	 SHORT $LN9@SetState_C
$LN8@SetState_C:
  025bb	33 c0		 xor	 eax, eax
  025bd	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  025c1	0f 9e c0	 setle	 al
  025c4	89 45 b0	 mov	 DWORD PTR tv67[ebp], eax
$LN9@SetState_C:
  025c7	83 7d b0 00	 cmp	 DWORD PTR tv67[ebp], 0
  025cb	75 05		 jne	 SHORT $LN5@SetState_C

; 876  : 	{
; 877  : 		return;

  025cd	e9 f1 00 00 00	 jmp	 $LN6@SetState_C
$LN5@SetState_C:

; 878  : 	}
; 879  : 
; 880  : 	this->SendNoticeState(iBridgeIndex, 2);

  025d2	6a 02		 push	 2
  025d4	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  025d7	50		 push	 eax
  025d8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  025db	e8 00 00 00 00	 call	 ?SendNoticeState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SendNoticeState

; 881  : 	this->ClearBridgeData(iBridgeIndex);

  025e0	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  025e3	50		 push	 eax
  025e4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  025e7	e8 00 00 00 00	 call	 ?ClearBridgeData@CBloodCastle@@IAEXH@Z ; CBloodCastle::ClearBridgeData

; 882  : 	this->ClearMonster(iBridgeIndex, 1);

  025ec	6a 01		 push	 1
  025ee	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  025f1	50		 push	 eax
  025f2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  025f5	e8 00 00 00 00	 call	 ?ClearMonster@CBloodCastle@@QAEXH_N@Z ; CBloodCastle::ClearMonster

; 883  : 	this->CheckAngelKingExist(iBridgeIndex);

  025fa	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  025fd	50		 push	 eax
  025fe	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02601	e8 00 00 00 00	 call	 ?CheckAngelKingExist@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckAngelKingExist

; 884  : 
; 885  : 	for (int n=OBJ_STARTUSERINDEX;n<OBJMAX;n++)

  02606	c7 45 f8 b0 36
	00 00		 mov	 DWORD PTR _n$236889[ebp], 14000 ; 000036b0H
  0260d	eb 09		 jmp	 SHORT $LN4@SetState_C
$LN3@SetState_C:
  0260f	8b 45 f8	 mov	 eax, DWORD PTR _n$236889[ebp]
  02612	83 c0 01	 add	 eax, 1
  02615	89 45 f8	 mov	 DWORD PTR _n$236889[ebp], eax
$LN4@SetState_C:
  02618	81 7d f8 98 3a
	00 00		 cmp	 DWORD PTR _n$236889[ebp], 15000 ; 00003a98H
  0261f	7d 5d		 jge	 SHORT $LN2@SetState_C

; 886  : 	{
; 887  : 		int iMapNumber = this->GetBridgeMapNumber(iBridgeIndex); //season3 add-on

  02621	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  02624	50		 push	 eax
  02625	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02628	e8 00 00 00 00	 call	 ?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeMapNumber
  0262d	89 45 f4	 mov	 DWORD PTR _iMapNumber$236893[ebp], eax

; 888  : 
; 889  : 		if ( gObj[n].MapNumber == iMapNumber && gObj[n].Connected > PLAYER_LOGGED ) //season3 changed

  02630	8b 45 f8	 mov	 eax, DWORD PTR _n$236889[ebp]
  02633	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  02639	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0263f	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  02647	3b 55 f4	 cmp	 edx, DWORD PTR _iMapNumber$236893[ebp]
  0264a	75 30		 jne	 SHORT $LN1@SetState_C
  0264c	8b 45 f8	 mov	 eax, DWORD PTR _n$236889[ebp]
  0264f	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  02655	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0265b	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  02660	7e 1a		 jle	 SHORT $LN1@SetState_C

; 890  : 		{
; 891  : 			this->SearchUserDeleteQuestItem(n);

  02662	8b 45 f8	 mov	 eax, DWORD PTR _n$236889[ebp]
  02665	50		 push	 eax
  02666	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02669	e8 00 00 00 00	 call	 ?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDeleteQuestItem

; 892  : 			gObjMoveGate(n, 22);

  0266e	6a 16		 push	 22			; 00000016H
  02670	8b 45 f8	 mov	 eax, DWORD PTR _n$236889[ebp]
  02673	50		 push	 eax
  02674	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  02679	83 c4 08	 add	 esp, 8
$LN1@SetState_C:

; 893  : 		}
; 894  : 	}

  0267c	eb 91		 jmp	 SHORT $LN3@SetState_C
$LN2@SetState_C:

; 895  : 
; 896  : 	this->BlockCastleDoor(iBridgeIndex);

  0267e	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  02681	50		 push	 eax
  02682	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02685	e8 00 00 00 00	 call	 ?BlockCastleDoor@CBloodCastle@@QAEXH@Z ; CBloodCastle::BlockCastleDoor

; 897  : 	this->BlockCastleBridge(iBridgeIndex);

  0268a	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0268d	50		 push	 eax
  0268e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02691	e8 00 00 00 00	 call	 ?BlockCastleBridge@CBloodCastle@@QAEXH@Z ; CBloodCastle::BlockCastleBridge

; 898  : 	this->BlockCastleEntrance(iBridgeIndex);

  02696	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  02699	50		 push	 eax
  0269a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0269d	e8 00 00 00 00	 call	 ?BlockCastleEntrance@CBloodCastle@@QAEXH@Z ; CBloodCastle::BlockCastleEntrance

; 899  : 	this->CheckSync(iBridgeIndex);

  026a2	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  026a5	50		 push	 eax
  026a6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  026a9	e8 00 00 00 00	 call	 ?CheckSync@CBloodCastle@@IAEXH@Z ; CBloodCastle::CheckSync

; 900  : 	LogAddTD("[Blood Castle] (%d) SetState CLOSED", iBridgeIndex+1);

  026ae	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  026b1	83 c0 01	 add	 eax, 1
  026b4	50		 push	 eax
  026b5	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@INEHOCBG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5CLO@
  026ba	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  026c0	83 c4 08	 add	 esp, 8
$LN6@SetState_C:

; 901  : }

  026c3	5f		 pop	 edi
  026c4	5e		 pop	 esi
  026c5	5b		 pop	 ebx
  026c6	8b e5		 mov	 esp, ebp
  026c8	5d		 pop	 ebp
  026c9	c2 04 00	 ret	 4
?SetState_Closed@CBloodCastle@@IAEXH@Z ENDP		; CBloodCastle::SetState_Closed
_TEXT	ENDS
PUBLIC	??_C@_0CF@IOKOFOAG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@ ; `string'
PUBLIC	?CheckUsersOnConnect@CBloodCastle@@QAEXH@Z	; CBloodCastle::CheckUsersOnConnect
PUBLIC	__$ArrayPad$
EXTRN	?PHeadSubSetB@@YAXPAEEEH@Z:PROC			; PHeadSubSetB
;	COMDAT ??_C@_0CF@IOKOFOAG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@
CONST	SEGMENT
??_C@_0CF@IOKOFOAG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@ DB '['
	DB	'Blood Castle] (%d) SetState PLAYING', 00H	; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv67 = -360						; size = 4
_n$236906 = -292					; size = 4
_ServerCmd$ = -288					; size = 7
_pNotice$ = -280					; size = 272
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
?SetState_Playing@CBloodCastle@@IAEXH@Z PROC		; CBloodCastle::SetState_Playing
; _this$ = ecx

; 905  : {

  026d0	55		 push	 ebp
  026d1	8b ec		 mov	 ebp, esp
  026d3	81 ec 68 01 00
	00		 sub	 esp, 360		; 00000168H
  026d9	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  026de	33 c5		 xor	 eax, ebp
  026e0	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  026e3	53		 push	 ebx
  026e4	56		 push	 esi
  026e5	57		 push	 edi
  026e6	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 906  : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  026e9	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  026ed	7d 0c		 jge	 SHORT $LN8@SetState_P
  026ef	c7 85 98 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv67[ebp], 0
  026f9	eb 0f		 jmp	 SHORT $LN9@SetState_P
$LN8@SetState_P:
  026fb	33 c0		 xor	 eax, eax
  026fd	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  02701	0f 9e c0	 setle	 al
  02704	89 85 98 fe ff
	ff		 mov	 DWORD PTR tv67[ebp], eax
$LN9@SetState_P:
  0270a	83 bd 98 fe ff
	ff 00		 cmp	 DWORD PTR tv67[ebp], 0
  02711	75 05		 jne	 SHORT $LN5@SetState_P

; 907  : 	{
; 908  : 		return;

  02713	e9 62 01 00 00	 jmp	 $LN6@SetState_P
$LN5@SetState_P:

; 909  : 	}
; 910  : 
; 911  : 	this->m_BridgeData[iBridgeIndex].m_bBC_CAN_ENTER = false;

  02718	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0271b	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  02721	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  02724	c6 84 01 bb 03
	00 00 00	 mov	 BYTE PTR [ecx+eax+955], 0

; 912  : 	this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC = this->m_iBC_TIME_MIN_PLAY*60*1000;

  0272c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0272f	8b 88 0c 23 00
	00		 mov	 ecx, DWORD PTR [eax+8972]
  02735	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  02738	69 c9 e8 03 00
	00		 imul	 ecx, 1000		; 000003e8H
  0273e	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  02741	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  02747	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0274a	89 8c 10 ac 03
	00 00		 mov	 DWORD PTR [eax+edx+940], ecx

; 913  : 	this->CheckUsersOnConnect(iBridgeIndex);

  02751	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  02754	50		 push	 eax
  02755	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  02758	e8 00 00 00 00	 call	 ?CheckUsersOnConnect@CBloodCastle@@QAEXH@Z ; CBloodCastle::CheckUsersOnConnect

; 914  : 
; 915  : 	PMSG_NOTICE pNotice;
; 916  : 
; 917  : 	TNotice::MakeNoticeMsgEx(&pNotice, 1, lMsg.Get(MSGGET(4, 139)), iBridgeIndex+1, 60);

  0275d	6a 3c		 push	 60			; 0000003cH
  0275f	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  02762	83 c0 01	 add	 eax, 1
  02765	50		 push	 eax
  02766	68 8b 04 00 00	 push	 1163			; 0000048bH
  0276b	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  02770	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  02775	50		 push	 eax
  02776	6a 01		 push	 1
  02778	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$[ebp]
  0277e	51		 push	 ecx
  0277f	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx
  02784	83 c4 14	 add	 esp, 20			; 00000014H

; 918  : 	this->SendBridgeAnyMsg((LPBYTE)&pNotice, pNotice.h.size, iBridgeIndex);

  02787	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0278a	50		 push	 eax
  0278b	0f b6 8d e9 fe
	ff ff		 movzx	 ecx, BYTE PTR _pNotice$[ebp+1]
  02792	51		 push	 ecx
  02793	8d 95 e8 fe ff
	ff		 lea	 edx, DWORD PTR _pNotice$[ebp]
  02799	52		 push	 edx
  0279a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0279d	e8 00 00 00 00	 call	 ?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z ; CBloodCastle::SendBridgeAnyMsg

; 919  : 
; 920  : 	PMSG_SERVERCMD ServerCmd;
; 921  : 
; 922  : 	PHeadSubSetB((LPBYTE)&ServerCmd, 0xF3, 0x40, sizeof(ServerCmd));

  027a2	6a 07		 push	 7
  027a4	6a 40		 push	 64			; 00000040H
  027a6	68 f3 00 00 00	 push	 243			; 000000f3H
  027ab	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _ServerCmd$[ebp]
  027b1	50		 push	 eax
  027b2	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  027b7	83 c4 10	 add	 esp, 16			; 00000010H

; 923  : 	ServerCmd.CmdType = 1;

  027ba	c6 85 e4 fe ff
	ff 01		 mov	 BYTE PTR _ServerCmd$[ebp+4], 1

; 924  : 	ServerCmd.X = 45;

  027c1	c6 85 e5 fe ff
	ff 2d		 mov	 BYTE PTR _ServerCmd$[ebp+5], 45 ; 0000002dH

; 925  : 	ServerCmd.Y = 0;

  027c8	c6 85 e6 fe ff
	ff 00		 mov	 BYTE PTR _ServerCmd$[ebp+6], 0

; 926  : 
; 927  : 	this->SendBridgeAnyMsg((LPBYTE)&ServerCmd, ServerCmd.h.size, iBridgeIndex);

  027cf	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  027d2	50		 push	 eax
  027d3	0f b6 8d e1 fe
	ff ff		 movzx	 ecx, BYTE PTR _ServerCmd$[ebp+1]
  027da	51		 push	 ecx
  027db	8d 95 e0 fe ff
	ff		 lea	 edx, DWORD PTR _ServerCmd$[ebp]
  027e1	52		 push	 edx
  027e2	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  027e5	e8 00 00 00 00	 call	 ?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z ; CBloodCastle::SendBridgeAnyMsg

; 928  : 
; 929  : 	for (int n=OBJ_STARTUSERINDEX;n<OBJMAX;n++)

  027ea	c7 85 dc fe ff
	ff b0 36 00 00	 mov	 DWORD PTR _n$236906[ebp], 14000 ; 000036b0H
  027f4	eb 0f		 jmp	 SHORT $LN4@SetState_P
$LN3@SetState_P:
  027f6	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _n$236906[ebp]
  027fc	83 c0 01	 add	 eax, 1
  027ff	89 85 dc fe ff
	ff		 mov	 DWORD PTR _n$236906[ebp], eax
$LN4@SetState_P:
  02805	81 bd dc fe ff
	ff 98 3a 00 00	 cmp	 DWORD PTR _n$236906[ebp], 15000 ; 00003a98H
  0280f	7d 54		 jge	 SHORT $LN2@SetState_P

; 930  : 	{
; 931  : 		if ( gObj[n].MapNumber == this->GetBridgeMapNumber(iBridgeIndex) && gObj[n].Connected > PLAYER_LOGGED ) //season3 changed

  02811	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _n$236906[ebp]
  02817	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0281d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02823	0f b6 b4 01 49
	01 00 00	 movzx	 esi, BYTE PTR [ecx+eax+329]
  0282b	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  0282e	52		 push	 edx
  0282f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  02832	e8 00 00 00 00	 call	 ?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeMapNumber
  02837	3b f0		 cmp	 esi, eax
  02839	75 28		 jne	 SHORT $LN1@SetState_P
  0283b	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _n$236906[ebp]
  02841	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  02847	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0284d	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  02852	7e 0f		 jle	 SHORT $LN1@SetState_P

; 932  : 		{
; 933  : 			this->SearchUserDeleteQuestItem(n);

  02854	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _n$236906[ebp]
  0285a	50		 push	 eax
  0285b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0285e	e8 00 00 00 00	 call	 ?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDeleteQuestItem
$LN1@SetState_P:

; 934  : 		}
; 935  : 	}

  02863	eb 91		 jmp	 SHORT $LN3@SetState_P
$LN2@SetState_P:

; 936  : 
; 937  : 	LogAddTD("[Blood Castle] (%d) SetState PLAYING", iBridgeIndex+1);

  02865	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  02868	83 c0 01	 add	 eax, 1
  0286b	50		 push	 eax
  0286c	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@IOKOFOAG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@
  02871	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  02877	83 c4 08	 add	 esp, 8
$LN6@SetState_P:

; 938  : }

  0287a	5f		 pop	 edi
  0287b	5e		 pop	 esi
  0287c	5b		 pop	 ebx
  0287d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  02880	33 cd		 xor	 ecx, ebp
  02882	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02887	8b e5		 mov	 esp, ebp
  02889	5d		 pop	 ebp
  0288a	c2 04 00	 ret	 4
?SetState_Playing@CBloodCastle@@IAEXH@Z ENDP		; CBloodCastle::SetState_Playing
_TEXT	ENDS
PUBLIC	??_C@_0CF@OPFFLCHN@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@ ; `string'
;	COMDAT ??_C@_0CF@OPFFLCHN@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@
CONST	SEGMENT
??_C@_0CF@OPFFLCHN@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@ DB '['
	DB	'Blood Castle] (%d) SetState PLAYEND', 00H	; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv138 = -76						; size = 4
tv67 = -76						; size = 4
_n$236918 = -8						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?SetState_PlayEnd@CBloodCastle@@IAEXH@Z PROC		; CBloodCastle::SetState_PlayEnd
; _this$ = ecx

; 941  : {

  02890	55		 push	 ebp
  02891	8b ec		 mov	 ebp, esp
  02893	83 ec 4c	 sub	 esp, 76			; 0000004cH
  02896	53		 push	 ebx
  02897	56		 push	 esi
  02898	57		 push	 edi
  02899	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 942  : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  0289c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  028a0	7d 09		 jge	 SHORT $LN8@SetState_P@2
  028a2	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  028a9	eb 0c		 jmp	 SHORT $LN9@SetState_P@2
$LN8@SetState_P@2:
  028ab	33 c0		 xor	 eax, eax
  028ad	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  028b1	0f 9e c0	 setle	 al
  028b4	89 45 b4	 mov	 DWORD PTR tv67[ebp], eax
$LN9@SetState_P@2:
  028b7	83 7d b4 00	 cmp	 DWORD PTR tv67[ebp], 0
  028bb	75 05		 jne	 SHORT $LN5@SetState_P@2

; 943  : 	{
; 944  : 		return;

  028bd	e9 fc 00 00 00	 jmp	 $LN6@SetState_P@2
$LN5@SetState_P@2:

; 945  : 	}
; 946  : 
; 947  : 	this->SendNoticeState(iBridgeIndex, 2);

  028c2	6a 02		 push	 2
  028c4	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  028c7	50		 push	 eax
  028c8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  028cb	e8 00 00 00 00	 call	 ?SendNoticeState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SendNoticeState

; 948  : 	this->ClearMonster(iBridgeIndex, 0);

  028d0	6a 00		 push	 0
  028d2	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  028d5	50		 push	 eax
  028d6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  028d9	e8 00 00 00 00	 call	 ?ClearMonster@CBloodCastle@@QAEXH_N@Z ; CBloodCastle::ClearMonster

; 949  : 	this->m_BridgeData[iBridgeIndex].m_bBC_CAN_ENTER = false;

  028de	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  028e1	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  028e7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  028ea	c6 84 01 bb 03
	00 00 00	 mov	 BYTE PTR [ecx+eax+955], 0

; 950  : 	this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC = this->m_iBC_TIME_MIN_REST*60*1000;

  028f2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  028f5	8b 88 10 23 00
	00		 mov	 ecx, DWORD PTR [eax+8976]
  028fb	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  028fe	69 c9 e8 03 00
	00		 imul	 ecx, 1000		; 000003e8H
  02904	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  02907	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  0290d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02910	89 8c 10 ac 03
	00 00		 mov	 DWORD PTR [eax+edx+940], ecx

; 951  : 
; 952  : 	LogAddTD("[Blood Castle] (%d) SetState PLAYEND", iBridgeIndex+1);

  02917	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0291a	83 c0 01	 add	 eax, 1
  0291d	50		 push	 eax
  0291e	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@OPFFLCHN@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@
  02923	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  02929	83 c4 08	 add	 esp, 8

; 953  : 
; 954  : 	for (int n=0;n<MAX_BLOOD_CASTLE_SUB_BRIDGE;n++)

  0292c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$236918[ebp], 0
  02933	eb 09		 jmp	 SHORT $LN4@SetState_P@2
$LN3@SetState_P@2:
  02935	8b 45 f8	 mov	 eax, DWORD PTR _n$236918[ebp]
  02938	83 c0 01	 add	 eax, 1
  0293b	89 45 f8	 mov	 DWORD PTR _n$236918[ebp], eax
$LN4@SetState_P@2:
  0293e	83 7d f8 28	 cmp	 DWORD PTR _n$236918[ebp], 40 ; 00000028H
  02942	7d 7a		 jge	 SHORT $LN6@SetState_P@2

; 955  : 	{
; 956  : 		if ( OBJMAX_RANGE(this->m_BridgeData[iBridgeIndex].m_UserData[n].m_iIndex) != FALSE )

  02944	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  02947	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0294d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02950	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  02954	8b 45 f8	 mov	 eax, DWORD PTR _n$236918[ebp]
  02957	6b c0 14	 imul	 eax, 20			; 00000014H
  0295a	83 7c 02 18 00	 cmp	 DWORD PTR [edx+eax+24], 0
  0295f	7d 09		 jge	 SHORT $LN10@SetState_P@2
  02961	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv138[ebp], 0
  02968	eb 26		 jmp	 SHORT $LN11@SetState_P@2
$LN10@SetState_P@2:
  0296a	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  0296d	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  02973	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  02976	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  0297a	8b 4d f8	 mov	 ecx, DWORD PTR _n$236918[ebp]
  0297d	6b c9 14	 imul	 ecx, 20			; 00000014H
  02980	33 d2		 xor	 edx, edx
  02982	81 7c 08 18 97
	3a 00 00	 cmp	 DWORD PTR [eax+ecx+24], 14999 ; 00003a97H
  0298a	0f 9e c2	 setle	 dl
  0298d	89 55 b4	 mov	 DWORD PTR tv138[ebp], edx
$LN11@SetState_P@2:
  02990	83 7d b4 00	 cmp	 DWORD PTR tv138[ebp], 0
  02994	74 23		 je	 SHORT $LN1@SetState_P@2

; 957  : 		{
; 958  : 			this->SearchUserDeleteQuestItem(this->m_BridgeData[iBridgeIndex].m_UserData[n].m_iIndex);

  02996	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  02999	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0299f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  029a2	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  029a6	8b 45 f8	 mov	 eax, DWORD PTR _n$236918[ebp]
  029a9	6b c0 14	 imul	 eax, 20			; 00000014H
  029ac	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  029b0	51		 push	 ecx
  029b1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  029b4	e8 00 00 00 00	 call	 ?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDeleteQuestItem
$LN1@SetState_P@2:

; 959  : 		}
; 960  : 	}

  029b9	e9 77 ff ff ff	 jmp	 $LN3@SetState_P@2
$LN6@SetState_P@2:

; 961  : }

  029be	5f		 pop	 edi
  029bf	5e		 pop	 esi
  029c0	5b		 pop	 ebx
  029c1	8b e5		 mov	 esp, ebp
  029c3	5d		 pop	 ebp
  029c4	c2 04 00	 ret	 4
?SetState_PlayEnd@CBloodCastle@@IAEXH@Z ENDP		; CBloodCastle::SetState_PlayEnd
_TEXT	ENDS
PUBLIC	?GetCurrentState@CBloodCastle@@QAEHH@Z		; CBloodCastle::GetCurrentState
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv67 = -72						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?GetCurrentState@CBloodCastle@@QAEHH@Z PROC		; CBloodCastle::GetCurrentState
; _this$ = ecx

; 964  : {

  029d0	55		 push	 ebp
  029d1	8b ec		 mov	 ebp, esp
  029d3	83 ec 48	 sub	 esp, 72			; 00000048H
  029d6	53		 push	 ebx
  029d7	56		 push	 esi
  029d8	57		 push	 edi
  029d9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 965  : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  029dc	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  029e0	7d 09		 jge	 SHORT $LN4@GetCurrent
  029e2	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  029e9	eb 0c		 jmp	 SHORT $LN5@GetCurrent
$LN4@GetCurrent:
  029eb	33 c0		 xor	 eax, eax
  029ed	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  029f1	0f 9e c0	 setle	 al
  029f4	89 45 b8	 mov	 DWORD PTR tv67[ebp], eax
$LN5@GetCurrent:
  029f7	83 7d b8 00	 cmp	 DWORD PTR tv67[ebp], 0
  029fb	75 07		 jne	 SHORT $LN1@GetCurrent

; 966  : 	{
; 967  : 		return -1;

  029fd	b8 ff ff ff ff	 mov	 eax, -1
  02a02	eb 13		 jmp	 SHORT $LN2@GetCurrent
$LN1@GetCurrent:

; 968  : 	}
; 969  : 
; 970  : 	return this->m_BridgeData[iBridgeIndex].m_iBC_STATE;

  02a04	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  02a07	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  02a0d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02a10	8b 84 01 a8 03
	00 00		 mov	 eax, DWORD PTR [ecx+eax+936]
$LN2@GetCurrent:

; 971  : }

  02a17	5f		 pop	 edi
  02a18	5e		 pop	 esi
  02a19	5b		 pop	 ebx
  02a1a	8b e5		 mov	 esp, ebp
  02a1c	5d		 pop	 ebp
  02a1d	c2 04 00	 ret	 4
?GetCurrentState@CBloodCastle@@QAEHH@Z ENDP		; CBloodCastle::GetCurrentState
_TEXT	ENDS
PUBLIC	?GetCurrentRemainSec@CBloodCastle@@QAEHH@Z	; CBloodCastle::GetCurrentRemainSec
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?GetCurrentRemainSec@CBloodCastle@@QAEHH@Z PROC		; CBloodCastle::GetCurrentRemainSec
; _this$ = ecx

; 974  : {

  02a20	55		 push	 ebp
  02a21	8b ec		 mov	 ebp, esp
  02a23	83 ec 44	 sub	 esp, 68			; 00000044H
  02a26	53		 push	 ebx
  02a27	56		 push	 esi
  02a28	57		 push	 edi
  02a29	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 975  : 	return this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 1000;

  02a2c	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  02a2f	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  02a35	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02a38	8b 84 01 ac 03
	00 00		 mov	 eax, DWORD PTR [ecx+eax+940]
  02a3f	99		 cdq
  02a40	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  02a45	f7 f9		 idiv	 ecx

; 976  : }

  02a47	5f		 pop	 edi
  02a48	5e		 pop	 esi
  02a49	5b		 pop	 ebx
  02a4a	8b e5		 mov	 esp, ebp
  02a4c	5d		 pop	 ebp
  02a4d	c2 04 00	 ret	 4
?GetCurrentRemainSec@CBloodCastle@@QAEHH@Z ENDP		; CBloodCastle::GetCurrentRemainSec
_TEXT	ENDS
PUBLIC	?CheckEnterLevel@CBloodCastle@@QAEHHH@Z		; CBloodCastle::CheckEnterLevel
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv67 = -72						; size = 4
_this$ = -4						; size = 4
_iIndex$ = 8						; size = 4
_iLevel$ = 12						; size = 4
?CheckEnterLevel@CBloodCastle@@QAEHHH@Z PROC		; CBloodCastle::CheckEnterLevel
; _this$ = ecx

; 979  : {

  02a50	55		 push	 ebp
  02a51	8b ec		 mov	 ebp, esp
  02a53	83 ec 48	 sub	 esp, 72			; 00000048H
  02a56	53		 push	 ebx
  02a57	56		 push	 esi
  02a58	57		 push	 edi
  02a59	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 980  : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  02a5c	83 7d 08 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  02a60	7d 09		 jge	 SHORT $LN15@CheckEnter
  02a62	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  02a69	eb 0f		 jmp	 SHORT $LN16@CheckEnter
$LN15@CheckEnter:
  02a6b	33 c0		 xor	 eax, eax
  02a6d	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _iIndex$[ebp], 14999 ; 00003a97H
  02a74	0f 9e c0	 setle	 al
  02a77	89 45 b8	 mov	 DWORD PTR tv67[ebp], eax
$LN16@CheckEnter:
  02a7a	83 7d b8 00	 cmp	 DWORD PTR tv67[ebp], 0
  02a7e	75 0a		 jne	 SHORT $LN12@CheckEnter

; 981  : 	{
; 982  : 		return 2;

  02a80	b8 02 00 00 00	 mov	 eax, 2
  02a85	e9 04 02 00 00	 jmp	 $LN13@CheckEnter
$LN12@CheckEnter:

; 983  : 	}
; 984  : 
; 985  : 	if ( gObj[iIndex].Type != OBJ_USER || gObj[iIndex].Connected <= PLAYER_LOGGED )

  02a8a	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  02a8d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  02a93	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02a99	0f b7 54 01 68	 movzx	 edx, WORD PTR [ecx+eax+104]
  02a9e	83 fa 01	 cmp	 edx, 1
  02aa1	75 16		 jne	 SHORT $LN10@CheckEnter
  02aa3	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  02aa6	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  02aac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02ab2	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  02ab7	7f 0a		 jg	 SHORT $LN11@CheckEnter
$LN10@CheckEnter:

; 986  : 	{
; 987  : 		return 2;

  02ab9	b8 02 00 00 00	 mov	 eax, 2
  02abe	e9 cb 01 00 00	 jmp	 $LN13@CheckEnter
$LN11@CheckEnter:

; 988  : 	}
; 989  : 
; 990  : 	if ( gObj[iIndex].Class == CLASS_DARKLORD 
; 991  : #ifdef MONK
; 992  : 		|| gObj[iIndex].Class == CLASS_MONK
; 993  : #endif
; 994  : 		|| gObj[iIndex].Class == CLASS_MAGUMSA )

  02ac3	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  02ac6	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  02acc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02ad2	0f b7 94 01 b8
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+184]
  02ada	83 fa 04	 cmp	 edx, 4
  02add	74 3c		 je	 SHORT $LN8@CheckEnter
  02adf	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  02ae2	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  02ae8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02aee	0f b7 94 01 b8
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+184]
  02af6	83 fa 06	 cmp	 edx, 6
  02af9	74 20		 je	 SHORT $LN8@CheckEnter
  02afb	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  02afe	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  02b04	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02b0a	0f b7 94 01 b8
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+184]
  02b12	83 fa 03	 cmp	 edx, 3
  02b15	0f 85 be 00 00
	00		 jne	 $LN9@CheckEnter
$LN8@CheckEnter:

; 995  : 	{
; 996  : 		if ( gObj[iIndex].Level >= g_sttBLOODCASTLE_LEVEL[iLevel-1].iLOWER_BOUND_MAGUMSA && gObj[iIndex].Level <= g_sttBLOODCASTLE_LEVEL[iLevel-1].iUPPER_BOUND_MAGUMSA )

  02b1b	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  02b1e	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  02b24	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02b2a	0f bf 94 01 be
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+190]
  02b32	8b 45 0c	 mov	 eax, DWORD PTR _iLevel$[ebp]
  02b35	83 e8 01	 sub	 eax, 1
  02b38	c1 e0 04	 shl	 eax, 4
  02b3b	3b 90 08 00 00
	00		 cmp	 edx, DWORD PTR _g_sttBLOODCASTLE_LEVEL[eax+8]
  02b41	7c 2f		 jl	 SHORT $LN7@CheckEnter
  02b43	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  02b46	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  02b4c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02b52	0f bf 94 01 be
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+190]
  02b5a	8b 45 0c	 mov	 eax, DWORD PTR _iLevel$[ebp]
  02b5d	83 e8 01	 sub	 eax, 1
  02b60	c1 e0 04	 shl	 eax, 4
  02b63	3b 90 0c 00 00
	00		 cmp	 edx, DWORD PTR _g_sttBLOODCASTLE_LEVEL[eax+12]
  02b69	7f 07		 jg	 SHORT $LN7@CheckEnter

; 997  : 		{
; 998  : 			return 0;

  02b6b	33 c0		 xor	 eax, eax
  02b6d	e9 1c 01 00 00	 jmp	 $LN13@CheckEnter
$LN7@CheckEnter:

; 999  : 		}
; 1000 : 
; 1001 : 		if ( gObj[iIndex].Level < g_sttBLOODCASTLE_LEVEL[iLevel-1].iLOWER_BOUND_MAGUMSA )

  02b72	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  02b75	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  02b7b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02b81	0f bf 94 01 be
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+190]
  02b89	8b 45 0c	 mov	 eax, DWORD PTR _iLevel$[ebp]
  02b8c	83 e8 01	 sub	 eax, 1
  02b8f	c1 e0 04	 shl	 eax, 4
  02b92	3b 90 08 00 00
	00		 cmp	 edx, DWORD PTR _g_sttBLOODCASTLE_LEVEL[eax+8]
  02b98	7d 08		 jge	 SHORT $LN6@CheckEnter

; 1002 : 		{
; 1003 : 			return -1;

  02b9a	83 c8 ff	 or	 eax, -1
  02b9d	e9 ec 00 00 00	 jmp	 $LN13@CheckEnter
$LN6@CheckEnter:

; 1004 : 		}
; 1005 : 
; 1006 : 		if ( gObj[iIndex].Level > g_sttBLOODCASTLE_LEVEL[iLevel-1].iUPPER_BOUND_MAGUMSA )

  02ba2	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  02ba5	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  02bab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02bb1	0f bf 94 01 be
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+190]
  02bb9	8b 45 0c	 mov	 eax, DWORD PTR _iLevel$[ebp]
  02bbc	83 e8 01	 sub	 eax, 1
  02bbf	c1 e0 04	 shl	 eax, 4
  02bc2	3b 90 0c 00 00
	00		 cmp	 edx, DWORD PTR _g_sttBLOODCASTLE_LEVEL[eax+12]
  02bc8	7e 0a		 jle	 SHORT $LN5@CheckEnter

; 1007 : 		{
; 1008 : 			return 1;

  02bca	b8 01 00 00 00	 mov	 eax, 1
  02bcf	e9 ba 00 00 00	 jmp	 $LN13@CheckEnter
$LN5@CheckEnter:

; 1009 : 		}
; 1010 : 	}
; 1011 : 	else

  02bd4	e9 b0 00 00 00	 jmp	 $LN4@CheckEnter
$LN9@CheckEnter:

; 1012 : 	{
; 1013 : 		if ( gObj[iIndex].Level >= g_sttBLOODCASTLE_LEVEL[iLevel-1].iLOWER_BOUND && gObj[iIndex].Level <= g_sttBLOODCASTLE_LEVEL[iLevel-1].iUPPER_BOUND )

  02bd9	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  02bdc	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  02be2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02be8	0f bf 94 01 be
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+190]
  02bf0	8b 45 0c	 mov	 eax, DWORD PTR _iLevel$[ebp]
  02bf3	83 e8 01	 sub	 eax, 1
  02bf6	c1 e0 04	 shl	 eax, 4
  02bf9	3b 90 00 00 00
	00		 cmp	 edx, DWORD PTR _g_sttBLOODCASTLE_LEVEL[eax]
  02bff	7c 2c		 jl	 SHORT $LN3@CheckEnter
  02c01	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  02c04	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  02c0a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02c10	0f bf 94 01 be
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+190]
  02c18	8b 45 0c	 mov	 eax, DWORD PTR _iLevel$[ebp]
  02c1b	83 e8 01	 sub	 eax, 1
  02c1e	c1 e0 04	 shl	 eax, 4
  02c21	3b 90 04 00 00
	00		 cmp	 edx, DWORD PTR _g_sttBLOODCASTLE_LEVEL[eax+4]
  02c27	7f 04		 jg	 SHORT $LN3@CheckEnter

; 1014 : 		{
; 1015 : 			return 0;

  02c29	33 c0		 xor	 eax, eax
  02c2b	eb 61		 jmp	 SHORT $LN13@CheckEnter
$LN3@CheckEnter:

; 1016 : 		}
; 1017 : 
; 1018 : 		if ( gObj[iIndex].Level < g_sttBLOODCASTLE_LEVEL[iLevel-1].iLOWER_BOUND )

  02c2d	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  02c30	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  02c36	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02c3c	0f bf 94 01 be
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+190]
  02c44	8b 45 0c	 mov	 eax, DWORD PTR _iLevel$[ebp]
  02c47	83 e8 01	 sub	 eax, 1
  02c4a	c1 e0 04	 shl	 eax, 4
  02c4d	3b 90 00 00 00
	00		 cmp	 edx, DWORD PTR _g_sttBLOODCASTLE_LEVEL[eax]
  02c53	7d 05		 jge	 SHORT $LN2@CheckEnter

; 1019 : 		{
; 1020 : 			return -1;

  02c55	83 c8 ff	 or	 eax, -1
  02c58	eb 34		 jmp	 SHORT $LN13@CheckEnter
$LN2@CheckEnter:

; 1021 : 		}
; 1022 : 
; 1023 : 		if ( gObj[iIndex].Level > g_sttBLOODCASTLE_LEVEL[iLevel-1].iUPPER_BOUND )

  02c5a	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  02c5d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  02c63	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02c69	0f bf 94 01 be
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+190]
  02c71	8b 45 0c	 mov	 eax, DWORD PTR _iLevel$[ebp]
  02c74	83 e8 01	 sub	 eax, 1
  02c77	c1 e0 04	 shl	 eax, 4
  02c7a	3b 90 04 00 00
	00		 cmp	 edx, DWORD PTR _g_sttBLOODCASTLE_LEVEL[eax+4]
  02c80	7e 07		 jle	 SHORT $LN4@CheckEnter

; 1024 : 		{
; 1025 : 			return 1;

  02c82	b8 01 00 00 00	 mov	 eax, 1
  02c87	eb 05		 jmp	 SHORT $LN13@CheckEnter
$LN4@CheckEnter:

; 1026 : 		}
; 1027 : 	}
; 1028 : 
; 1029 : 	return 2;

  02c89	b8 02 00 00 00	 mov	 eax, 2
$LN13@CheckEnter:

; 1030 : }

  02c8e	5f		 pop	 edi
  02c8f	5e		 pop	 esi
  02c90	5b		 pop	 ebx
  02c91	8b e5		 mov	 esp, ebp
  02c93	5d		 pop	 ebp
  02c94	c2 08 00	 ret	 8
?CheckEnterLevel@CBloodCastle@@QAEHHH@Z ENDP		; CBloodCastle::CheckEnterLevel
_TEXT	ENDS
PUBLIC	?CheckEnterFreeTicket@CBloodCastle@@QAE_NH@Z	; CBloodCastle::CheckEnterFreeTicket
EXTRN	?IsItem@CItem@@QAEHXZ:PROC			; CItem::IsItem
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv67 = -76						; size = 4
_x$236972 = -8						; size = 4
_this$ = -4						; size = 4
_iIndex$ = 8						; size = 4
?CheckEnterFreeTicket@CBloodCastle@@QAE_NH@Z PROC	; CBloodCastle::CheckEnterFreeTicket
; _this$ = ecx

; 1033 : {

  02ca0	55		 push	 ebp
  02ca1	8b ec		 mov	 ebp, esp
  02ca3	83 ec 4c	 sub	 esp, 76			; 0000004cH
  02ca6	53		 push	 ebx
  02ca7	56		 push	 esi
  02ca8	57		 push	 edi
  02ca9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1034 : 	if ( !OBJMAX_RANGE(iIndex) )

  02cac	83 7d 08 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  02cb0	7d 09		 jge	 SHORT $LN11@CheckEnter@2
  02cb2	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  02cb9	eb 0f		 jmp	 SHORT $LN12@CheckEnter@2
$LN11@CheckEnter@2:
  02cbb	33 c0		 xor	 eax, eax
  02cbd	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _iIndex$[ebp], 14999 ; 00003a97H
  02cc4	0f 9e c0	 setle	 al
  02cc7	89 45 b4	 mov	 DWORD PTR tv67[ebp], eax
$LN12@CheckEnter@2:
  02cca	83 7d b4 00	 cmp	 DWORD PTR tv67[ebp], 0
  02cce	75 07		 jne	 SHORT $LN8@CheckEnter@2

; 1035 : 		return false;

  02cd0	32 c0		 xor	 al, al
  02cd2	e9 ab 00 00 00	 jmp	 $LN9@CheckEnter@2
$LN8@CheckEnter@2:

; 1036 : 
; 1037 : 	if ( gObj[iIndex].Type != OBJ_USER || gObj[iIndex].Connected <= PLAYER_LOGGED )

  02cd7	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  02cda	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  02ce0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02ce6	0f b7 54 01 68	 movzx	 edx, WORD PTR [ecx+eax+104]
  02ceb	83 fa 01	 cmp	 edx, 1
  02cee	75 16		 jne	 SHORT $LN6@CheckEnter@2
  02cf0	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  02cf3	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  02cf9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02cff	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  02d04	7f 04		 jg	 SHORT $LN7@CheckEnter@2
$LN6@CheckEnter@2:

; 1038 : 		return false;

  02d06	32 c0		 xor	 al, al
  02d08	eb 78		 jmp	 SHORT $LN9@CheckEnter@2
$LN7@CheckEnter@2:

; 1039 : 
; 1040 : 	for (int x=0;x<MAIN_INVENTORY_SIZE;x++)

  02d0a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _x$236972[ebp], 0
  02d11	eb 09		 jmp	 SHORT $LN5@CheckEnter@2
$LN4@CheckEnter@2:
  02d13	8b 45 f8	 mov	 eax, DWORD PTR _x$236972[ebp]
  02d16	83 c0 01	 add	 eax, 1
  02d19	89 45 f8	 mov	 DWORD PTR _x$236972[ebp], eax
$LN5@CheckEnter@2:
  02d1c	81 7d f8 cc 00
	00 00		 cmp	 DWORD PTR _x$236972[ebp], 204 ; 000000ccH
  02d23	7d 5b		 jge	 SHORT $LN3@CheckEnter@2

; 1041 : 	{
; 1042 : 		if ( gObj[iIndex].pInventory[x].IsItem() == TRUE )

  02d25	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  02d28	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  02d2e	8b 4d f8	 mov	 ecx, DWORD PTR _x$236972[ebp]
  02d31	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  02d37	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02d3d	03 8c 02 24 0e
	00 00		 add	 ecx, DWORD PTR [edx+eax+3620]
  02d44	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  02d49	83 f8 01	 cmp	 eax, 1
  02d4c	75 30		 jne	 SHORT $LN2@CheckEnter@2

; 1043 : 		{
; 1044 : 			if ( gObj[iIndex].pInventory [x].m_Type == ITEMGET(13,47) )

  02d4e	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  02d51	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  02d57	8b 4d f8	 mov	 ecx, DWORD PTR _x$236972[ebp]
  02d5a	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  02d60	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02d66	8b 84 02 24 0e
	00 00		 mov	 eax, DWORD PTR [edx+eax+3620]
  02d6d	0f bf 4c 08 06	 movsx	 ecx, WORD PTR [eax+ecx+6]
  02d72	81 f9 2f 1a 00
	00		 cmp	 ecx, 6703		; 00001a2fH
  02d78	75 04		 jne	 SHORT $LN2@CheckEnter@2

; 1045 : 			{
; 1046 : 				return true;

  02d7a	b0 01		 mov	 al, 1
  02d7c	eb 04		 jmp	 SHORT $LN9@CheckEnter@2
$LN2@CheckEnter@2:

; 1047 : 			}
; 1048 : 		}
; 1049 : 	}

  02d7e	eb 93		 jmp	 SHORT $LN4@CheckEnter@2
$LN3@CheckEnter@2:

; 1050 : 
; 1051 : 	return false;

  02d80	32 c0		 xor	 al, al
$LN9@CheckEnter@2:

; 1052 : }

  02d82	5f		 pop	 edi
  02d83	5e		 pop	 esi
  02d84	5b		 pop	 ebx
  02d85	8b e5		 mov	 esp, ebp
  02d87	5d		 pop	 ebp
  02d88	c2 04 00	 ret	 4
?CheckEnterFreeTicket@CBloodCastle@@QAE_NH@Z ENDP	; CBloodCastle::CheckEnterFreeTicket
_TEXT	ENDS
PUBLIC	??_C@_0DE@KMNEMIOE@?$FL?E?u?$LI?m?$LI?A?E?d?5Mix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Fa@ ; `string'
PUBLIC	??_C@_0DH@PODHMCM@?$FL?E?u?$LI?m?$LI?A?E?d?5Mix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Su@ ; `string'
PUBLIC	??_C@_0GA@CFALPHEA@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@ ; `string'
PUBLIC	??_C@_0FM@MNNOPKAN@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@ ; `string'
PUBLIC	??_C@_0GE@IPBOHNGB@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@ ; `string'
PUBLIC	??_C@_0BA@JGACLMIM@?E?u?$LI?m?$LI?A?E?d?5Mix?0?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0EM@CDAILJHC@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?BloodCastleChaosMix@CBloodCastle@@QAE_NHH@Z	; CBloodCastle::BloodCastleChaosMix
EXTRN	?gObjInventoryCommit@@YAHH@Z:PROC		; gObjInventoryCommit
EXTRN	?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z:PROC ; GCUserChaosBoxSend
EXTRN	?ChaosBoxInit@CMixSystem@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CMixSystem::ChaosBoxInit
EXTRN	?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z:PROC	; ItemSerialCreateSend
EXTRN	_rand:PROC
EXTRN	?GCMoneySend@@YAXHK@Z:PROC			; GCMoneySend
EXTRN	?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z:PROC	; CCastleSiegeSync::AddTributeMoney
EXTRN	?GetTaxRateChaos@CCastleSiegeSync@@QAEHH@Z:PROC	; CCastleSiegeSync::GetTaxRateChaos
EXTRN	?g_CastleSiegeSync@@3VCCastleSiegeSync@@A:BYTE	; g_CastleSiegeSync
EXTRN	?GetPlusChaosRate@CCrywolfSync@@QAEHXZ:PROC	; CCrywolfSync::GetPlusChaosRate
EXTRN	?g_iCrywolfApplyMvpBenefit@@3HA:DWORD		; g_iCrywolfApplyMvpBenefit
EXTRN	?GetOccupationState@CCrywolfSync@@QAEHXZ:PROC	; CCrywolfSync::GetOccupationState
EXTRN	?g_CrywolfSync@@3VCCrywolfSync@@A:BYTE		; g_CrywolfSync
EXTRN	?LogChaosItem@CMixSystem@@QAEXPAUOBJECTSTRUCT@@PAD@Z:PROC ; CMixSystem::LogChaosItem
EXTRN	?g_MixSystem@@3VCMixSystem@@A:BYTE		; g_MixSystem
EXTRN	__imp__wsprintfA:PROC
EXTRN	__alldiv:PROC
EXTRN	__allmul:PROC
;	COMDAT ??_C@_0DE@KMNEMIOE@?$FL?E?u?$LI?m?$LI?A?E?d?5Mix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Fa@
CONST	SEGMENT
??_C@_0DE@KMNEMIOE@?$FL?E?u?$LI?m?$LI?A?E?d?5Mix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Fa@ DB '['
	DB	0c5H, 0f5H, 0b8H, 0edH, 0b8H, 0c1H, 0c5H, 0e4H, ' Mix] [%s][%s'
	DB	'] CBMix Fail %d Money : %d-%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@PODHMCM@?$FL?E?u?$LI?m?$LI?A?E?d?5Mix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Su@
CONST	SEGMENT
??_C@_0DH@PODHMCM@?$FL?E?u?$LI?m?$LI?A?E?d?5Mix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Su@ DB '['
	DB	0c5H, 0f5H, 0b8H, 0edH, 0b8H, 0c1H, 0c5H, 0e4H, ' Mix] [%s][%s'
	DB	'] CBMix Success %d Money : %d-%d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@CFALPHEA@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@
CONST	SEGMENT
??_C@_0GA@CFALPHEA@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@ DB '['
	DB	'Blood Castle] ', 0c5H, 0f5H, 0b8H, 0edH, 0b8H, 0c1H, 0c5H, 0e4H
	DB	' Mix Chaos Mix Failed - Not Enough Money (Account:%s, Name:%s'
	DB	', Level:%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FM@MNNOPKAN@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@
CONST	SEGMENT
??_C@_0FM@MNNOPKAN@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@ DB '['
	DB	'Blood Castle] ', 0c5H, 0f5H, 0b8H, 0edH, 0b8H, 0c1H, 0c5H, 0e4H
	DB	' Mix Chaos Mix Failed - MixMoney < 0 (Account:%s, Name:%s, Le'
	DB	'vel:%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0GE@IPBOHNGB@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@
CONST	SEGMENT
??_C@_0GE@IPBOHNGB@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@ DB '['
	DB	'Blood Castle] ', 0c5H, 0f5H, 0b8H, 0edH, 0b8H, 0c1H, 0c5H, 0e4H
	DB	' Mix Chaos Mix Failed - MixRate Out of Bound (Account:%s, Nam'
	DB	'e:%s, Level:%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JGACLMIM@?E?u?$LI?m?$LI?A?E?d?5Mix?0?$CFd?$AA@
CONST	SEGMENT
??_C@_0BA@JGACLMIM@?E?u?$LI?m?$LI?A?E?d?5Mix?0?$CFd?$AA@ DB 0c5H, 0f5H, 0b8H
	DB	0edH, 0b8H, 0c1H, 0c5H, 0e4H, ' Mix,%d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@CDAILJHC@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@
CONST	SEGMENT
??_C@_0EM@CDAILJHC@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@ DB '['
	DB	'Blood Castle] ', 0c5H, 0f5H, 0b8H, 0edH, 0b8H, 0c1H, 0c5H, 0e4H
	DB	' Mix Chaos Mix Start (Account:%s, Name:%s, Level:%d)', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv77 = -140						; size = 4
tv78 = -136						; size = 4
tv67 = -136						; size = 4
_item_num$237018 = -68					; size = 4
_iChaosTaxMoney$ = -64					; size = 4
_iMIX_NEED_MONEY$ = -60					; size = 4
_iMIX_SUCCESS_RATE$ = -56				; size = 4
_szTemp$ = -52						; size = 17
_pMsg$ = -32						; size = 16
_bMIX_RESULT$ = -16					; size = 4
_iMapNumber$ = -12					; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iLEVEL$ = 12						; size = 4
?BloodCastleChaosMix@CBloodCastle@@QAE_NHH@Z PROC	; CBloodCastle::BloodCastleChaosMix
; _this$ = ecx

; 1059 : {

  02d90	55		 push	 ebp
  02d91	8b ec		 mov	 ebp, esp
  02d93	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  02d99	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  02d9e	33 c5		 xor	 eax, ebp
  02da0	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  02da3	53		 push	 ebx
  02da4	56		 push	 esi
  02da5	57		 push	 edi
  02da6	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1060 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  02da9	83 7d 08 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  02dad	7d 0c		 jge	 SHORT $LN15@BloodCastl
  02daf	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv67[ebp], 0
  02db9	eb 12		 jmp	 SHORT $LN16@BloodCastl
$LN15@BloodCastl:
  02dbb	33 c0		 xor	 eax, eax
  02dbd	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _iIndex$[ebp], 14999 ; 00003a97H
  02dc4	0f 9e c0	 setle	 al
  02dc7	89 85 78 ff ff
	ff		 mov	 DWORD PTR tv67[ebp], eax
$LN16@BloodCastl:
  02dcd	83 bd 78 ff ff
	ff 00		 cmp	 DWORD PTR tv67[ebp], 0
  02dd4	75 07		 jne	 SHORT $LN12@BloodCastl

; 1061 : 	{
; 1062 : 		return false;

  02dd6	32 c0		 xor	 al, al
  02dd8	e9 e2 04 00 00	 jmp	 $LN13@BloodCastl
$LN12@BloodCastl:

; 1063 : 	}
; 1064 : 
; 1065 : 	int iMapNumber = this->GetBridgeMapNumber(iLEVEL-1); //Season3 add-on

  02ddd	8b 45 0c	 mov	 eax, DWORD PTR _iLEVEL$[ebp]
  02de0	83 e8 01	 sub	 eax, 1
  02de3	50		 push	 eax
  02de4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  02de7	e8 00 00 00 00	 call	 ?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeMapNumber
  02dec	89 45 f4	 mov	 DWORD PTR _iMapNumber$[ebp], eax

; 1066 : 
; 1067 : 	if ( BC_MAP_RANGE(iMapNumber)  == FALSE ) //season3 changed

  02def	83 7d f4 34	 cmp	 DWORD PTR _iMapNumber$[ebp], 52 ; 00000034H
  02df3	75 0c		 jne	 SHORT $LN19@BloodCastl
  02df5	c7 85 78 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv78[ebp], 1
  02dff	eb 2d		 jmp	 SHORT $LN20@BloodCastl
$LN19@BloodCastl:
  02e01	83 7d f4 0b	 cmp	 DWORD PTR _iMapNumber$[ebp], 11 ; 0000000bH
  02e05	7d 0c		 jge	 SHORT $LN17@BloodCastl
  02e07	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv77[ebp], 0
  02e11	eb 0f		 jmp	 SHORT $LN18@BloodCastl
$LN17@BloodCastl:
  02e13	33 c0		 xor	 eax, eax
  02e15	83 7d f4 11	 cmp	 DWORD PTR _iMapNumber$[ebp], 17 ; 00000011H
  02e19	0f 9e c0	 setle	 al
  02e1c	89 85 74 ff ff
	ff		 mov	 DWORD PTR tv77[ebp], eax
$LN18@BloodCastl:
  02e22	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR tv77[ebp]
  02e28	89 8d 78 ff ff
	ff		 mov	 DWORD PTR tv78[ebp], ecx
$LN20@BloodCastl:
  02e2e	83 bd 78 ff ff
	ff 00		 cmp	 DWORD PTR tv78[ebp], 0
  02e35	75 07		 jne	 SHORT $LN11@BloodCastl

; 1068 : 	{
; 1069 : 		return false;

  02e37	32 c0		 xor	 al, al
  02e39	e9 81 04 00 00	 jmp	 $LN13@BloodCastl
$LN11@BloodCastl:

; 1070 : 	}
; 1071 : 
; 1072 : 	BOOL bMIX_RESULT = FALSE;

  02e3e	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _bMIX_RESULT$[ebp], 0

; 1073 : 
; 1074 : 	PMSG_CHAOSMIXRESULT pMsg;
; 1075 : 
; 1076 : 	PHeadSetB((LPBYTE)&pMsg.h, 0x86, sizeof(PMSG_CHAOSMIXRESULT));

  02e45	6a 10		 push	 16			; 00000010H
  02e47	68 86 00 00 00	 push	 134			; 00000086H
  02e4c	8d 45 e0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  02e4f	50		 push	 eax
  02e50	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  02e55	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1077 : 	pMsg.Result = CB_ERROR; //

  02e58	c6 45 e3 00	 mov	 BYTE PTR _pMsg$[ebp+3], 0

; 1078 : 	gObj[iIndex].ChaosLock = TRUE;

  02e5c	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  02e5f	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  02e65	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02e6b	c7 84 01 88 0e
	00 00 01 00 00
	00		 mov	 DWORD PTR [ecx+eax+3720], 1

; 1079 : 
; 1080 : 	LogAddTD("[Blood Castle]  Mix Chaos Mix Start (Account:%s, Name:%s, Level:%d)", gObj[iIndex].AccountID, gObj[iIndex].Name, iLEVEL);

  02e76	8b 45 0c	 mov	 eax, DWORD PTR _iLEVEL$[ebp]
  02e79	50		 push	 eax
  02e7a	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  02e7d	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  02e83	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02e89	8d 44 0a 77	 lea	 eax, DWORD PTR [edx+ecx+119]
  02e8d	50		 push	 eax
  02e8e	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  02e91	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  02e97	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02e9d	8d 44 0a 6c	 lea	 eax, DWORD PTR [edx+ecx+108]
  02ea1	50		 push	 eax
  02ea2	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@CDAILJHC@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@
  02ea7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  02ead	83 c4 10	 add	 esp, 16			; 00000010H

; 1081 : 
; 1082 : 	char szTemp[17];
; 1083 : 	wsprintf(szTemp, " Mix,%d", iLEVEL); //Season 2.5 add-on

  02eb0	8b 45 0c	 mov	 eax, DWORD PTR _iLEVEL$[ebp]
  02eb3	50		 push	 eax
  02eb4	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JGACLMIM@?E?u?$LI?m?$LI?A?E?d?5Mix?0?$CFd?$AA@
  02eb9	8d 4d cc	 lea	 ecx, DWORD PTR _szTemp$[ebp]
  02ebc	51		 push	 ecx
  02ebd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  02ec3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1084 : 
; 1085 : 	g_MixSystem.LogChaosItem(&gObj[iIndex], szTemp);

  02ec6	8d 45 cc	 lea	 eax, DWORD PTR _szTemp$[ebp]
  02ec9	50		 push	 eax
  02eca	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  02ecd	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  02ed3	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02ed9	51		 push	 ecx
  02eda	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  02edf	e8 00 00 00 00	 call	 ?LogChaosItem@CMixSystem@@QAEXPAUOBJECTSTRUCT@@PAD@Z ; CMixSystem::LogChaosItem

; 1086 : 
; 1087 : 	int iMIX_SUCCESS_RATE = g_iBC_ChoasMixSuccessRate[iLEVEL - 1];

  02ee4	8b 45 0c	 mov	 eax, DWORD PTR _iLEVEL$[ebp]
  02ee7	8b 0c 85 fc ff
	ff ff		 mov	 ecx, DWORD PTR _g_iBC_ChoasMixSuccessRate[eax*4-4]
  02eee	89 4d c8	 mov	 DWORD PTR _iMIX_SUCCESS_RATE$[ebp], ecx

; 1088 : 
; 1089 : 	if ( iMIX_SUCCESS_RATE < 0 || iMIX_SUCCESS_RATE > 100 )

  02ef1	83 7d c8 00	 cmp	 DWORD PTR _iMIX_SUCCESS_RATE$[ebp], 0
  02ef5	7c 06		 jl	 SHORT $LN9@BloodCastl
  02ef7	83 7d c8 64	 cmp	 DWORD PTR _iMIX_SUCCESS_RATE$[ebp], 100 ; 00000064H
  02efb	7e 56		 jle	 SHORT $LN10@BloodCastl
$LN9@BloodCastl:

; 1090 : 	{
; 1091 : 		DataSend(iIndex, (LPBYTE)&pMsg, pMsg.h.size);

  02efd	0f b6 45 e1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  02f01	50		 push	 eax
  02f02	8d 4d e0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  02f05	51		 push	 ecx
  02f06	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  02f09	52		 push	 edx
  02f0a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  02f0f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1092 : 		LogAddTD("[Blood Castle]  Mix Chaos Mix Failed - MixRate Out of Bound (Account:%s, Name:%s, Level:%d)", gObj[iIndex].AccountID, gObj[iIndex].Name, iLEVEL);

  02f12	8b 45 0c	 mov	 eax, DWORD PTR _iLEVEL$[ebp]
  02f15	50		 push	 eax
  02f16	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  02f19	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  02f1f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02f25	8d 44 0a 77	 lea	 eax, DWORD PTR [edx+ecx+119]
  02f29	50		 push	 eax
  02f2a	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  02f2d	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  02f33	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02f39	8d 44 0a 6c	 lea	 eax, DWORD PTR [edx+ecx+108]
  02f3d	50		 push	 eax
  02f3e	68 00 00 00 00	 push	 OFFSET ??_C@_0GE@IPBOHNGB@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@
  02f43	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  02f49	83 c4 10	 add	 esp, 16			; 00000010H

; 1093 : 		return false;

  02f4c	32 c0		 xor	 al, al
  02f4e	e9 6c 03 00 00	 jmp	 $LN13@BloodCastl
$LN10@BloodCastl:

; 1094 : 	}
; 1095 : 
; 1096 : 	if ( g_CrywolfSync.GetOccupationState() == 0 && g_iCrywolfApplyMvpBenefit )

  02f53	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CrywolfSync@@3VCCrywolfSync@@A ; g_CrywolfSync
  02f58	e8 00 00 00 00	 call	 ?GetOccupationState@CCrywolfSync@@QAEHXZ ; CCrywolfSync::GetOccupationState
  02f5d	85 c0		 test	 eax, eax
  02f5f	75 19		 jne	 SHORT $LN8@BloodCastl
  02f61	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_iCrywolfApplyMvpBenefit@@3HA, 0 ; g_iCrywolfApplyMvpBenefit
  02f68	74 10		 je	 SHORT $LN8@BloodCastl

; 1097 : 	{
; 1098 : 		iMIX_SUCCESS_RATE += g_CrywolfSync.GetPlusChaosRate();

  02f6a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CrywolfSync@@3VCCrywolfSync@@A ; g_CrywolfSync
  02f6f	e8 00 00 00 00	 call	 ?GetPlusChaosRate@CCrywolfSync@@QAEHXZ ; CCrywolfSync::GetPlusChaosRate
  02f74	03 45 c8	 add	 eax, DWORD PTR _iMIX_SUCCESS_RATE$[ebp]
  02f77	89 45 c8	 mov	 DWORD PTR _iMIX_SUCCESS_RATE$[ebp], eax
$LN8@BloodCastl:

; 1099 : 	}
; 1100 : 
; 1101 : 	if ( iMIX_SUCCESS_RATE > 80 )

  02f7a	83 7d c8 50	 cmp	 DWORD PTR _iMIX_SUCCESS_RATE$[ebp], 80 ; 00000050H
  02f7e	7e 07		 jle	 SHORT $LN7@BloodCastl

; 1102 : 	{
; 1103 : 		iMIX_SUCCESS_RATE = 80;

  02f80	c7 45 c8 50 00
	00 00		 mov	 DWORD PTR _iMIX_SUCCESS_RATE$[ebp], 80 ; 00000050H
$LN7@BloodCastl:

; 1104 : 	}
; 1105 : 
; 1106 : 	if ( gObj[iIndex].ChaosSuccessRate > 10 )

  02f87	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  02f8a	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  02f90	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02f96	83 bc 01 84 0e
	00 00 0a	 cmp	 DWORD PTR [ecx+eax+3716], 10 ; 0000000aH
  02f9e	7e 33		 jle	 SHORT $LN6@BloodCastl

; 1107 : 	{
; 1108 : 		pMsg.Result = 0xF0;

  02fa0	c6 45 e3 f0	 mov	 BYTE PTR _pMsg$[ebp+3], 240 ; 000000f0H

; 1109 : 		gObj[iIndex].ChaosLock = FALSE;

  02fa4	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  02fa7	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  02fad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02fb3	c7 84 01 88 0e
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+3720], 0

; 1110 : 
; 1111 : 		DataSend(iIndex, (LPBYTE)&pMsg, pMsg.h.size);

  02fbe	0f b6 45 e1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  02fc2	50		 push	 eax
  02fc3	8d 4d e0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  02fc6	51		 push	 ecx
  02fc7	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  02fca	52		 push	 edx
  02fcb	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  02fd0	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@BloodCastl:

; 1112 : 	}
; 1113 : 
; 1114 : 	iMIX_SUCCESS_RATE += gObj[iIndex].ChaosSuccessRate;

  02fd3	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  02fd6	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  02fdc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02fe2	8b 55 c8	 mov	 edx, DWORD PTR _iMIX_SUCCESS_RATE$[ebp]
  02fe5	03 94 01 84 0e
	00 00		 add	 edx, DWORD PTR [ecx+eax+3716]
  02fec	89 55 c8	 mov	 DWORD PTR _iMIX_SUCCESS_RATE$[ebp], edx

; 1115 : 	int iMIX_NEED_MONEY = g_iBC_ChoasMixMoney[iLEVEL - 1];

  02fef	8b 45 0c	 mov	 eax, DWORD PTR _iLEVEL$[ebp]
  02ff2	8b 0c 85 fc ff
	ff ff		 mov	 ecx, DWORD PTR _g_iBC_ChoasMixMoney[eax*4-4]
  02ff9	89 4d c4	 mov	 DWORD PTR _iMIX_NEED_MONEY$[ebp], ecx

; 1116 : 	int iChaosTaxMoney = (int)((__int64)(iMIX_NEED_MONEY) * (__int64)(g_CastleSiegeSync.GetTaxRateChaos(iIndex)) / (__int64)100);

  02ffc	8b 45 c4	 mov	 eax, DWORD PTR _iMIX_NEED_MONEY$[ebp]
  02fff	99		 cdq
  03000	8b f0		 mov	 esi, eax
  03002	8b fa		 mov	 edi, edx
  03004	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  03007	50		 push	 eax
  03008	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  0300d	e8 00 00 00 00	 call	 ?GetTaxRateChaos@CCastleSiegeSync@@QAEHH@Z ; CCastleSiegeSync::GetTaxRateChaos
  03012	99		 cdq
  03013	52		 push	 edx
  03014	50		 push	 eax
  03015	57		 push	 edi
  03016	56		 push	 esi
  03017	e8 00 00 00 00	 call	 __allmul
  0301c	6a 00		 push	 0
  0301e	6a 64		 push	 100			; 00000064H
  03020	52		 push	 edx
  03021	50		 push	 eax
  03022	e8 00 00 00 00	 call	 __alldiv
  03027	89 45 c0	 mov	 DWORD PTR _iChaosTaxMoney$[ebp], eax

; 1117 : 
; 1118 : 	if ( iChaosTaxMoney < 0 )

  0302a	83 7d c0 00	 cmp	 DWORD PTR _iChaosTaxMoney$[ebp], 0
  0302e	7d 07		 jge	 SHORT $LN5@BloodCastl

; 1119 : 	{
; 1120 : 		iChaosTaxMoney = 0;

  03030	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _iChaosTaxMoney$[ebp], 0
$LN5@BloodCastl:

; 1121 : 	}
; 1122 : 
; 1123 : 	iMIX_NEED_MONEY += iChaosTaxMoney;

  03037	8b 45 c4	 mov	 eax, DWORD PTR _iMIX_NEED_MONEY$[ebp]
  0303a	03 45 c0	 add	 eax, DWORD PTR _iChaosTaxMoney$[ebp]
  0303d	89 45 c4	 mov	 DWORD PTR _iMIX_NEED_MONEY$[ebp], eax

; 1124 : 
; 1125 : 	if ( iMIX_NEED_MONEY <  0 )

  03040	79 56		 jns	 SHORT $LN4@BloodCastl

; 1126 : 	{
; 1127 : 		DataSend(iIndex, (LPBYTE)&pMsg, pMsg.h.size);

  03042	0f b6 45 e1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  03046	50		 push	 eax
  03047	8d 4d e0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0304a	51		 push	 ecx
  0304b	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0304e	52		 push	 edx
  0304f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  03054	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1128 : 		LogAddTD("[Blood Castle]  Mix Chaos Mix Failed - MixMoney < 0 (Account:%s, Name:%s, Level:%d)", gObj[iIndex].AccountID, gObj[iIndex].Name, iLEVEL);

  03057	8b 45 0c	 mov	 eax, DWORD PTR _iLEVEL$[ebp]
  0305a	50		 push	 eax
  0305b	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0305e	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  03064	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0306a	8d 44 0a 77	 lea	 eax, DWORD PTR [edx+ecx+119]
  0306e	50		 push	 eax
  0306f	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  03072	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  03078	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0307e	8d 44 0a 6c	 lea	 eax, DWORD PTR [edx+ecx+108]
  03082	50		 push	 eax
  03083	68 00 00 00 00	 push	 OFFSET ??_C@_0FM@MNNOPKAN@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@
  03088	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0308e	83 c4 10	 add	 esp, 16			; 00000010H

; 1129 : 		return false;

  03091	32 c0		 xor	 al, al
  03093	e9 27 02 00 00	 jmp	 $LN13@BloodCastl
$LN4@BloodCastl:

; 1130 : 	}
; 1131 : 
; 1132 : 	if ( (gObj[iIndex].Money - iMIX_NEED_MONEY) < 0 )

  03098	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0309b	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  030a1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  030a7	8b 94 01 f0 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+240]
  030ae	2b 55 c4	 sub	 edx, DWORD PTR _iMIX_NEED_MONEY$[ebp]
  030b1	79 5a		 jns	 SHORT $LN3@BloodCastl

; 1133 : 	{
; 1134 : 		pMsg.Result = CB_BC_NOT_ENOUGH_ZEN;

  030b3	c6 45 e3 0b	 mov	 BYTE PTR _pMsg$[ebp+3], 11 ; 0000000bH

; 1135 : 		DataSend(iIndex, (LPBYTE)&pMsg, pMsg.h.size);

  030b7	0f b6 45 e1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  030bb	50		 push	 eax
  030bc	8d 4d e0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  030bf	51		 push	 ecx
  030c0	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  030c3	52		 push	 edx
  030c4	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  030c9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1136 : 		LogAddTD("[Blood Castle]  Mix Chaos Mix Failed - Not Enough Money (Account:%s, Name:%s, Level:%d)", gObj[iIndex].AccountID, gObj[iIndex].Name, iLEVEL);

  030cc	8b 45 0c	 mov	 eax, DWORD PTR _iLEVEL$[ebp]
  030cf	50		 push	 eax
  030d0	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  030d3	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  030d9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  030df	8d 44 0a 77	 lea	 eax, DWORD PTR [edx+ecx+119]
  030e3	50		 push	 eax
  030e4	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  030e7	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  030ed	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  030f3	8d 44 0a 6c	 lea	 eax, DWORD PTR [edx+ecx+108]
  030f7	50		 push	 eax
  030f8	68 00 00 00 00	 push	 OFFSET ??_C@_0GA@CFALPHEA@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@
  030fd	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  03103	83 c4 10	 add	 esp, 16			; 00000010H

; 1137 : 		return false;

  03106	32 c0		 xor	 al, al
  03108	e9 b2 01 00 00	 jmp	 $LN13@BloodCastl
$LN3@BloodCastl:

; 1138 : 	}
; 1139 : 
; 1140 : 	gObj[iIndex].Money -= iMIX_NEED_MONEY;

  0310d	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  03110	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  03116	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0311c	8b 94 01 f0 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+240]
  03123	2b 55 c4	 sub	 edx, DWORD PTR _iMIX_NEED_MONEY$[ebp]
  03126	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  03129	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0312f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  03135	89 94 01 f0 00
	00 00		 mov	 DWORD PTR [ecx+eax+240], edx

; 1141 : 	g_CastleSiegeSync.AddTributeMoney(iChaosTaxMoney);

  0313c	8b 45 c0	 mov	 eax, DWORD PTR _iChaosTaxMoney$[ebp]
  0313f	50		 push	 eax
  03140	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  03145	e8 00 00 00 00	 call	 ?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z ; CCastleSiegeSync::AddTributeMoney

; 1142 : 	GCMoneySend(iIndex, gObj[iIndex].Money);

  0314a	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0314d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  03153	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  03159	8b 94 01 f0 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+240]
  03160	52		 push	 edx
  03161	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  03164	50		 push	 eax
  03165	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  0316a	83 c4 08	 add	 esp, 8

; 1143 : 
; 1144 : 	if ( (rand()%100) < iMIX_SUCCESS_RATE )

  0316d	e8 00 00 00 00	 call	 _rand
  03172	99		 cdq
  03173	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  03178	f7 f9		 idiv	 ecx
  0317a	3b 55 c8	 cmp	 edx, DWORD PTR _iMIX_SUCCESS_RATE$[ebp]
  0317d	0f 8d 8e 00 00
	00		 jge	 $LN2@BloodCastl

; 1145 : 	{
; 1146 : 		int item_num = ITEMGET(13,18);

  03183	c7 45 bc 12 1a
	00 00		 mov	 DWORD PTR _item_num$237018[ebp], 6674 ; 00001a12H

; 1147 : 		ItemSerialCreateSend(iIndex, -1, 0, 0, item_num, (BYTE)iLEVEL, 255, 0, 0, 0, -1, 0, 0);

  0318a	6a 00		 push	 0
  0318c	6a 00		 push	 0
  0318e	6a ff		 push	 -1
  03190	6a 00		 push	 0
  03192	6a 00		 push	 0
  03194	6a 00		 push	 0
  03196	68 ff 00 00 00	 push	 255			; 000000ffH
  0319b	0f b6 45 0c	 movzx	 eax, BYTE PTR _iLEVEL$[ebp]
  0319f	50		 push	 eax
  031a0	8b 4d bc	 mov	 ecx, DWORD PTR _item_num$237018[ebp]
  031a3	51		 push	 ecx
  031a4	6a 00		 push	 0
  031a6	6a 00		 push	 0
  031a8	68 ff 00 00 00	 push	 255			; 000000ffH
  031ad	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  031b0	52		 push	 edx
  031b1	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  031b6	83 c4 34	 add	 esp, 52			; 00000034H

; 1148 : 		LogAddTD("[ Mix] [%s][%s] CBMix Success %d Money : %d-%d", gObj[iIndex].AccountID, gObj[iIndex].Name, iMIX_SUCCESS_RATE, gObj[iIndex].Money, iMIX_NEED_MONEY);

  031b9	8b 45 c4	 mov	 eax, DWORD PTR _iMIX_NEED_MONEY$[ebp]
  031bc	50		 push	 eax
  031bd	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  031c0	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  031c6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  031cc	8b 84 0a f0 00
	00 00		 mov	 eax, DWORD PTR [edx+ecx+240]
  031d3	50		 push	 eax
  031d4	8b 4d c8	 mov	 ecx, DWORD PTR _iMIX_SUCCESS_RATE$[ebp]
  031d7	51		 push	 ecx
  031d8	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  031db	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  031e1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  031e6	8d 4c 10 77	 lea	 ecx, DWORD PTR [eax+edx+119]
  031ea	51		 push	 ecx
  031eb	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  031ee	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  031f4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  031f9	8d 4c 10 6c	 lea	 ecx, DWORD PTR [eax+edx+108]
  031fd	51		 push	 ecx
  031fe	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@PODHMCM@?$FL?E?u?$LI?m?$LI?A?E?d?5Mix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Su@
  03203	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  03209	83 c4 18	 add	 esp, 24			; 00000018H

; 1149 : 	}
; 1150 : 	else

  0320c	e9 a0 00 00 00	 jmp	 $LN1@BloodCastl
$LN2@BloodCastl:

; 1151 : 	{
; 1152 : 		g_MixSystem.ChaosBoxInit(&gObj[iIndex]);

  03211	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  03214	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0321a	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  03220	50		 push	 eax
  03221	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  03226	e8 00 00 00 00	 call	 ?ChaosBoxInit@CMixSystem@@QAEHPAUOBJECTSTRUCT@@@Z ; CMixSystem::ChaosBoxInit

; 1153 : 		GCUserChaosBoxSend(&gObj[iIndex], 0);

  0322b	6a 00		 push	 0
  0322d	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  03230	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  03236	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0323c	50		 push	 eax
  0323d	e8 00 00 00 00	 call	 ?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z ; GCUserChaosBoxSend
  03242	83 c4 08	 add	 esp, 8

; 1154 : 		DataSend(iIndex, (LPBYTE)&pMsg, pMsg.h.size);

  03245	0f b6 45 e1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  03249	50		 push	 eax
  0324a	8d 4d e0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0324d	51		 push	 ecx
  0324e	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  03251	52		 push	 edx
  03252	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  03257	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1155 : 		LogAddTD("[ Mix] [%s][%s] CBMix Fail %d Money : %d-%d", gObj[iIndex].AccountID, gObj[iIndex].Name, iMIX_SUCCESS_RATE, gObj[iIndex].Money, iMIX_NEED_MONEY);

  0325a	8b 45 c4	 mov	 eax, DWORD PTR _iMIX_NEED_MONEY$[ebp]
  0325d	50		 push	 eax
  0325e	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  03261	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  03267	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0326d	8b 84 0a f0 00
	00 00		 mov	 eax, DWORD PTR [edx+ecx+240]
  03274	50		 push	 eax
  03275	8b 4d c8	 mov	 ecx, DWORD PTR _iMIX_SUCCESS_RATE$[ebp]
  03278	51		 push	 ecx
  03279	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0327c	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  03282	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  03287	8d 4c 10 77	 lea	 ecx, DWORD PTR [eax+edx+119]
  0328b	51		 push	 ecx
  0328c	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0328f	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  03295	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0329a	8d 4c 10 6c	 lea	 ecx, DWORD PTR [eax+edx+108]
  0329e	51		 push	 ecx
  0329f	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@KMNEMIOE@?$FL?E?u?$LI?m?$LI?A?E?d?5Mix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Fa@
  032a4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  032aa	83 c4 18	 add	 esp, 24			; 00000018H

; 1156 : 		return false;

  032ad	32 c0		 xor	 al, al
  032af	eb 0e		 jmp	 SHORT $LN13@BloodCastl
$LN1@BloodCastl:

; 1157 : 	}
; 1158 : 
; 1159 : 	::gObjInventoryCommit(iIndex);

  032b1	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  032b4	50		 push	 eax
  032b5	e8 00 00 00 00	 call	 ?gObjInventoryCommit@@YAHH@Z ; gObjInventoryCommit
  032ba	83 c4 04	 add	 esp, 4

; 1160 : 
; 1161 : 	return true;

  032bd	b0 01		 mov	 al, 1
$LN13@BloodCastl:

; 1162 : }

  032bf	5f		 pop	 edi
  032c0	5e		 pop	 esi
  032c1	5b		 pop	 ebx
  032c2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  032c5	33 cd		 xor	 ecx, ebp
  032c7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  032cc	8b e5		 mov	 esp, ebp
  032ce	5d		 pop	 ebp
  032cf	c2 08 00	 ret	 8
?BloodCastleChaosMix@CBloodCastle@@QAE_NHH@Z ENDP	; CBloodCastle::BloodCastleChaosMix
_TEXT	ENDS
PUBLIC	?CheckChoasMixItem@CBloodCastle@@QAEHH@Z	; CBloodCastle::CheckChoasMixItem
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv190 = -120						; size = 4
tv183 = -120						; size = 4
tv67 = -120						; size = 4
_iBLOOD_BONE_LEVEL$237077 = -52				; size = 4
_iSCROLL_LEVEL$237074 = -48				; size = 4
_i$237066 = -44						; size = 4
_iCharmOfLuckCount$ = -40				; size = 4
_iBloodBoneLevel$ = -36					; size = 4
_iAngelKingPaperLevel$ = -32				; size = 4
_iEventItemCount$ = -28					; size = 4
_bIsOtherItemExist$ = -24				; size = 4
_bIsBloodBoneExist$ = -20				; size = 4
_bIsAngelKingPaperExist$ = -16				; size = 4
_bIsChaosGemExist$ = -12				; size = 4
_iCHAOS_MIX_LEVEL$ = -8					; size = 4
_this$ = -4						; size = 4
_iIndex$ = 8						; size = 4
?CheckChoasMixItem@CBloodCastle@@QAEHH@Z PROC		; CBloodCastle::CheckChoasMixItem
; _this$ = ecx

; 1218 : {

  032e0	55		 push	 ebp
  032e1	8b ec		 mov	 ebp, esp
  032e3	83 ec 78	 sub	 esp, 120		; 00000078H
  032e6	53		 push	 ebx
  032e7	56		 push	 esi
  032e8	57		 push	 edi
  032e9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1219 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  032ec	83 7d 08 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  032f0	7d 09		 jge	 SHORT $LN32@CheckChoas
  032f2	c7 45 88 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  032f9	eb 0f		 jmp	 SHORT $LN33@CheckChoas
$LN32@CheckChoas:
  032fb	33 c0		 xor	 eax, eax
  032fd	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _iIndex$[ebp], 14999 ; 00003a97H
  03304	0f 9e c0	 setle	 al
  03307	89 45 88	 mov	 DWORD PTR tv67[ebp], eax
$LN33@CheckChoas:
  0330a	83 7d 88 00	 cmp	 DWORD PTR tv67[ebp], 0
  0330e	75 07		 jne	 SHORT $LN29@CheckChoas

; 1220 : 	{
; 1221 : 		return false;

  03310	33 c0		 xor	 eax, eax
  03312	e9 b4 03 00 00	 jmp	 $LN30@CheckChoas
$LN29@CheckChoas:

; 1222 : 	}
; 1223 : 
; 1224 : 	int iCHAOS_MIX_LEVEL = 0;

  03317	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iCHAOS_MIX_LEVEL$[ebp], 0

; 1225 : 	BOOL bIsChaosGemExist = FALSE;

  0331e	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _bIsChaosGemExist$[ebp], 0

; 1226 : 	BOOL bIsAngelKingPaperExist = FALSE;

  03325	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _bIsAngelKingPaperExist$[ebp], 0

; 1227 : 	BOOL bIsBloodBoneExist = FALSE;

  0332c	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _bIsBloodBoneExist$[ebp], 0

; 1228 : 	BOOL bIsOtherItemExist = FALSE;

  03333	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _bIsOtherItemExist$[ebp], 0

; 1229 : 	int iEventItemCount = 0;

  0333a	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _iEventItemCount$[ebp], 0

; 1230 : 	int iAngelKingPaperLevel = 0;

  03341	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _iAngelKingPaperLevel$[ebp], 0

; 1231 : 	int iBloodBoneLevel = 0;

  03348	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _iBloodBoneLevel$[ebp], 0

; 1232 : 	int iCharmOfLuckCount=0;

  0334f	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _iCharmOfLuckCount$[ebp], 0

; 1233 : 
; 1234 : 	for ( int i=0;i<CHAOS_BOX_SIZE;i++)

  03356	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _i$237066[ebp], 0
  0335d	eb 09		 jmp	 SHORT $LN28@CheckChoas
$LN27@CheckChoas:
  0335f	8b 45 d4	 mov	 eax, DWORD PTR _i$237066[ebp]
  03362	83 c0 01	 add	 eax, 1
  03365	89 45 d4	 mov	 DWORD PTR _i$237066[ebp], eax
$LN28@CheckChoas:
  03368	83 7d d4 20	 cmp	 DWORD PTR _i$237066[ebp], 32 ; 00000020H
  0336c	0f 8d a6 01 00
	00		 jge	 $LN26@CheckChoas

; 1235 : 	{
; 1236 : 		if ( gObj[iIndex].pChaosBox[i].IsItem() == TRUE )

  03372	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  03375	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0337b	8b 4d d4	 mov	 ecx, DWORD PTR _i$237066[ebp]
  0337e	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  03384	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0338a	03 8c 02 78 0e
	00 00		 add	 ecx, DWORD PTR [edx+eax+3704]
  03391	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  03396	83 f8 01	 cmp	 eax, 1
  03399	0f 85 74 01 00
	00		 jne	 $LN17@CheckChoas

; 1237 : 		{
; 1238 : 			if ( gObj[iIndex].pChaosBox[i].m_Type == ITEMGET(12,15) )

  0339f	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  033a2	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  033a8	8b 4d d4	 mov	 ecx, DWORD PTR _i$237066[ebp]
  033ab	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  033b1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  033b7	8b 84 02 78 0e
	00 00		 mov	 eax, DWORD PTR [edx+eax+3704]
  033be	0f bf 4c 08 06	 movsx	 ecx, WORD PTR [eax+ecx+6]
  033c3	81 f9 0f 18 00
	00		 cmp	 ecx, 6159		; 0000180fH
  033c9	75 0c		 jne	 SHORT $LN24@CheckChoas

; 1239 : 			{
; 1240 : 				bIsChaosGemExist = TRUE;

  033cb	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _bIsChaosGemExist$[ebp], 1
  033d2	e9 3c 01 00 00	 jmp	 $LN17@CheckChoas
$LN24@CheckChoas:

; 1241 : 			}
; 1242 : 			else if ( gObj[iIndex].pChaosBox[i].m_Type == ITEMGET(13,16) )

  033d7	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  033da	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  033e0	8b 4d d4	 mov	 ecx, DWORD PTR _i$237066[ebp]
  033e3	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  033e9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  033ef	8b 84 02 78 0e
	00 00		 mov	 eax, DWORD PTR [edx+eax+3704]
  033f6	0f bf 4c 08 06	 movsx	 ecx, WORD PTR [eax+ecx+6]
  033fb	81 f9 10 1a 00
	00		 cmp	 ecx, 6672		; 00001a10H
  03401	75 42		 jne	 SHORT $LN22@CheckChoas

; 1243 : 			{
; 1244 : 				int iSCROLL_LEVEL = gObj[iIndex].pChaosBox[i].m_Level;

  03403	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  03406	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0340c	8b 4d d4	 mov	 ecx, DWORD PTR _i$237066[ebp]
  0340f	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  03415	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0341b	8b 84 02 78 0e
	00 00		 mov	 eax, DWORD PTR [edx+eax+3704]
  03422	0f bf 4c 08 08	 movsx	 ecx, WORD PTR [eax+ecx+8]
  03427	89 4d d0	 mov	 DWORD PTR _iSCROLL_LEVEL$237074[ebp], ecx

; 1245 : 				iEventItemCount++;

  0342a	8b 45 e4	 mov	 eax, DWORD PTR _iEventItemCount$[ebp]
  0342d	83 c0 01	 add	 eax, 1
  03430	89 45 e4	 mov	 DWORD PTR _iEventItemCount$[ebp], eax

; 1246 : 				bIsAngelKingPaperExist = TRUE;

  03433	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _bIsAngelKingPaperExist$[ebp], 1

; 1247 : 				iAngelKingPaperLevel = iSCROLL_LEVEL;

  0343a	8b 45 d0	 mov	 eax, DWORD PTR _iSCROLL_LEVEL$237074[ebp]
  0343d	89 45 e0	 mov	 DWORD PTR _iAngelKingPaperLevel$[ebp], eax
  03440	e9 ce 00 00 00	 jmp	 $LN17@CheckChoas
$LN22@CheckChoas:

; 1248 : 			}
; 1249 : 			else if ( gObj[iIndex].pChaosBox[i].m_Type == ITEMGET(13,17) )

  03445	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  03448	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0344e	8b 4d d4	 mov	 ecx, DWORD PTR _i$237066[ebp]
  03451	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  03457	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0345d	8b 84 02 78 0e
	00 00		 mov	 eax, DWORD PTR [edx+eax+3704]
  03464	0f bf 4c 08 06	 movsx	 ecx, WORD PTR [eax+ecx+6]
  03469	81 f9 11 1a 00
	00		 cmp	 ecx, 6673		; 00001a11H
  0346f	75 3f		 jne	 SHORT $LN20@CheckChoas

; 1250 : 			{
; 1251 : 				int iBLOOD_BONE_LEVEL = gObj[iIndex].pChaosBox[i].m_Level;

  03471	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  03474	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0347a	8b 4d d4	 mov	 ecx, DWORD PTR _i$237066[ebp]
  0347d	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  03483	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  03489	8b 84 02 78 0e
	00 00		 mov	 eax, DWORD PTR [edx+eax+3704]
  03490	0f bf 4c 08 08	 movsx	 ecx, WORD PTR [eax+ecx+8]
  03495	89 4d cc	 mov	 DWORD PTR _iBLOOD_BONE_LEVEL$237077[ebp], ecx

; 1252 : 				iEventItemCount++;

  03498	8b 45 e4	 mov	 eax, DWORD PTR _iEventItemCount$[ebp]
  0349b	83 c0 01	 add	 eax, 1
  0349e	89 45 e4	 mov	 DWORD PTR _iEventItemCount$[ebp], eax

; 1253 : 				bIsBloodBoneExist = TRUE;

  034a1	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _bIsBloodBoneExist$[ebp], 1

; 1254 : 				iBloodBoneLevel = iBLOOD_BONE_LEVEL;

  034a8	8b 45 cc	 mov	 eax, DWORD PTR _iBLOOD_BONE_LEVEL$237077[ebp]
  034ab	89 45 dc	 mov	 DWORD PTR _iBloodBoneLevel$[ebp], eax
  034ae	eb 63		 jmp	 SHORT $LN17@CheckChoas
$LN20@CheckChoas:

; 1255 : 			}
; 1256 : 			else if ( gObj[iIndex].pChaosBox[i].m_Type == ITEMGET(14,53) )

  034b0	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  034b3	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  034b9	8b 4d d4	 mov	 ecx, DWORD PTR _i$237066[ebp]
  034bc	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  034c2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  034c8	8b 84 02 78 0e
	00 00		 mov	 eax, DWORD PTR [edx+eax+3704]
  034cf	0f bf 4c 08 06	 movsx	 ecx, WORD PTR [eax+ecx+6]
  034d4	81 f9 35 1c 00
	00		 cmp	 ecx, 7221		; 00001c35H
  034da	75 30		 jne	 SHORT $LN18@CheckChoas

; 1257 : 			{
; 1258 : 				iCharmOfLuckCount += (int)gObj[iIndex].pChaosBox[i].m_Durability;

  034dc	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  034df	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  034e5	8b 4d d4	 mov	 ecx, DWORD PTR _i$237066[ebp]
  034e8	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  034ee	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  034f4	8b 84 02 78 0e
	00 00		 mov	 eax, DWORD PTR [edx+eax+3704]
  034fb	d9 44 08 24	 fld	 DWORD PTR [eax+ecx+36]
  034ff	e8 00 00 00 00	 call	 __ftol2_sse
  03504	03 45 d8	 add	 eax, DWORD PTR _iCharmOfLuckCount$[ebp]
  03507	89 45 d8	 mov	 DWORD PTR _iCharmOfLuckCount$[ebp], eax

; 1259 : 			}
; 1260 : 			else

  0350a	eb 07		 jmp	 SHORT $LN17@CheckChoas
$LN18@CheckChoas:

; 1261 : 			{
; 1262 : 				bIsOtherItemExist = TRUE;

  0350c	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _bIsOtherItemExist$[ebp], 1
$LN17@CheckChoas:

; 1263 : 			}
; 1264 : 		}
; 1265 : 	}

  03513	e9 47 fe ff ff	 jmp	 $LN27@CheckChoas
$LN26@CheckChoas:

; 1266 : 
; 1267 : 	gObj[iIndex].ChaosSuccessRate = iCharmOfLuckCount;

  03518	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0351b	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  03521	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  03527	8b 55 d8	 mov	 edx, DWORD PTR _iCharmOfLuckCount$[ebp]
  0352a	89 94 01 84 0e
	00 00		 mov	 DWORD PTR [ecx+eax+3716], edx

; 1268 : 
; 1269 : 	if ( bIsOtherItemExist != FALSE )

  03531	83 7d e8 00	 cmp	 DWORD PTR _bIsOtherItemExist$[ebp], 0
  03535	74 0a		 je	 SHORT $LN16@CheckChoas

; 1270 : 	{
; 1271 : 		return 8;

  03537	b8 08 00 00 00	 mov	 eax, 8
  0353c	e9 8a 01 00 00	 jmp	 $LN30@CheckChoas
$LN16@CheckChoas:

; 1272 : 	}
; 1273 : 
; 1274 : 	if ( bIsAngelKingPaperExist == FALSE && bIsBloodBoneExist == FALSE )

  03541	83 7d f0 00	 cmp	 DWORD PTR _bIsAngelKingPaperExist$[ebp], 0
  03545	75 0d		 jne	 SHORT $LN15@CheckChoas
  03547	83 7d ec 00	 cmp	 DWORD PTR _bIsBloodBoneExist$[ebp], 0
  0354b	75 07		 jne	 SHORT $LN15@CheckChoas

; 1275 : 	{
; 1276 : 		return 0;

  0354d	33 c0		 xor	 eax, eax
  0354f	e9 77 01 00 00	 jmp	 $LN30@CheckChoas
$LN15@CheckChoas:

; 1277 : 	}
; 1278 : 
; 1279 : 	if ( bIsAngelKingPaperExist == FALSE || bIsBloodBoneExist == FALSE )

  03554	83 7d f0 00	 cmp	 DWORD PTR _bIsAngelKingPaperExist$[ebp], 0
  03558	74 06		 je	 SHORT $LN13@CheckChoas
  0355a	83 7d ec 00	 cmp	 DWORD PTR _bIsBloodBoneExist$[ebp], 0
  0355e	75 0a		 jne	 SHORT $LN14@CheckChoas
$LN13@CheckChoas:

; 1280 : 	{
; 1281 : 		return 11;

  03560	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  03565	e9 61 01 00 00	 jmp	 $LN30@CheckChoas
$LN14@CheckChoas:

; 1282 : 	}
; 1283 : 
; 1284 : 	if ( iEventItemCount > 2 )

  0356a	83 7d e4 02	 cmp	 DWORD PTR _iEventItemCount$[ebp], 2
  0356e	7e 0a		 jle	 SHORT $LN12@CheckChoas

; 1285 : 	{
; 1286 : 		return 12;

  03570	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  03575	e9 51 01 00 00	 jmp	 $LN30@CheckChoas
$LN12@CheckChoas:

; 1287 : 	}
; 1288 : 
; 1289 : 	if ( iCharmOfLuckCount > 10 )

  0357a	83 7d d8 0a	 cmp	 DWORD PTR _iCharmOfLuckCount$[ebp], 10 ; 0000000aH
  0357e	7e 0a		 jle	 SHORT $LN11@CheckChoas

; 1290 : 	{
; 1291 : 		return 15;

  03580	b8 0f 00 00 00	 mov	 eax, 15			; 0000000fH
  03585	e9 41 01 00 00	 jmp	 $LN30@CheckChoas
$LN11@CheckChoas:

; 1292 : 	}
; 1293 : 
; 1294 : 	if ( iAngelKingPaperLevel != iBloodBoneLevel )

  0358a	8b 45 e0	 mov	 eax, DWORD PTR _iAngelKingPaperLevel$[ebp]
  0358d	3b 45 dc	 cmp	 eax, DWORD PTR _iBloodBoneLevel$[ebp]
  03590	74 0a		 je	 SHORT $LN10@CheckChoas

; 1295 : 	{
; 1296 : 		return 9;

  03592	b8 09 00 00 00	 mov	 eax, 9
  03597	e9 2f 01 00 00	 jmp	 $LN30@CheckChoas
$LN10@CheckChoas:

; 1297 : 	}
; 1298 : 
; 1299 : 	if ( BC_BRIDGE_RANGE(iAngelKingPaperLevel-1) == FALSE )

  0359c	8b 45 e0	 mov	 eax, DWORD PTR _iAngelKingPaperLevel$[ebp]
  0359f	83 e8 01	 sub	 eax, 1
  035a2	79 09		 jns	 SHORT $LN34@CheckChoas
  035a4	c7 45 88 00 00
	00 00		 mov	 DWORD PTR tv183[ebp], 0
  035ab	eb 11		 jmp	 SHORT $LN35@CheckChoas
$LN34@CheckChoas:
  035ad	8b 4d e0	 mov	 ecx, DWORD PTR _iAngelKingPaperLevel$[ebp]
  035b0	83 e9 01	 sub	 ecx, 1
  035b3	33 d2		 xor	 edx, edx
  035b5	83 f9 07	 cmp	 ecx, 7
  035b8	0f 9e c2	 setle	 dl
  035bb	89 55 88	 mov	 DWORD PTR tv183[ebp], edx
$LN35@CheckChoas:
  035be	83 7d 88 00	 cmp	 DWORD PTR tv183[ebp], 0
  035c2	75 0a		 jne	 SHORT $LN9@CheckChoas

; 1300 : 	{
; 1301 : 		return 9;

  035c4	b8 09 00 00 00	 mov	 eax, 9
  035c9	e9 fd 00 00 00	 jmp	 $LN30@CheckChoas
$LN9@CheckChoas:

; 1302 : 	}
; 1303 : 
; 1304 : 	if ( BC_BRIDGE_RANGE(iBloodBoneLevel-1) == FALSE )

  035ce	8b 45 dc	 mov	 eax, DWORD PTR _iBloodBoneLevel$[ebp]
  035d1	83 e8 01	 sub	 eax, 1
  035d4	79 09		 jns	 SHORT $LN36@CheckChoas
  035d6	c7 45 88 00 00
	00 00		 mov	 DWORD PTR tv190[ebp], 0
  035dd	eb 11		 jmp	 SHORT $LN37@CheckChoas
$LN36@CheckChoas:
  035df	8b 4d dc	 mov	 ecx, DWORD PTR _iBloodBoneLevel$[ebp]
  035e2	83 e9 01	 sub	 ecx, 1
  035e5	33 d2		 xor	 edx, edx
  035e7	83 f9 07	 cmp	 ecx, 7
  035ea	0f 9e c2	 setle	 dl
  035ed	89 55 88	 mov	 DWORD PTR tv190[ebp], edx
$LN37@CheckChoas:
  035f0	83 7d 88 00	 cmp	 DWORD PTR tv190[ebp], 0
  035f4	75 0a		 jne	 SHORT $LN8@CheckChoas

; 1305 : 	{
; 1306 : 		return 9;

  035f6	b8 09 00 00 00	 mov	 eax, 9
  035fb	e9 cb 00 00 00	 jmp	 $LN30@CheckChoas
$LN8@CheckChoas:

; 1307 : 	}
; 1308 : 
; 1309 : 	if ( bIsChaosGemExist == FALSE )

  03600	83 7d f4 00	 cmp	 DWORD PTR _bIsChaosGemExist$[ebp], 0
  03604	75 0a		 jne	 SHORT $LN7@CheckChoas

; 1310 : 	{
; 1311 : 		return 10;

  03606	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  0360b	e9 bb 00 00 00	 jmp	 $LN30@CheckChoas
$LN7@CheckChoas:

; 1312 : 	}
; 1313 : 
; 1314 : 	if ( gObj[iIndex].Class == CLASS_DARKLORD 
; 1315 : #ifdef MONK
; 1316 : 		|| gObj[iIndex].Class == CLASS_MONK
; 1317 : #endif
; 1318 : 		|| gObj[iIndex].Class == CLASS_MAGUMSA )

  03610	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  03613	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  03619	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0361f	0f b7 94 01 b8
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+184]
  03627	83 fa 04	 cmp	 edx, 4
  0362a	74 38		 je	 SHORT $LN5@CheckChoas
  0362c	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0362f	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  03635	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0363b	0f b7 94 01 b8
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+184]
  03643	83 fa 06	 cmp	 edx, 6
  03646	74 1c		 je	 SHORT $LN5@CheckChoas
  03648	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0364b	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  03651	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  03657	0f b7 94 01 b8
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+184]
  0365f	83 fa 03	 cmp	 edx, 3
  03662	75 28		 jne	 SHORT $LN6@CheckChoas
$LN5@CheckChoas:

; 1319 : 	{
; 1320 : 		if ( gObj[iIndex].Level < g_sttBLOODCASTLE_LEVEL[0].iLOWER_BOUND_MAGUMSA )

  03664	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  03667	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0366d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  03673	0f bf 94 01 be
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+190]
  0367b	3b 15 08 00 00
	00		 cmp	 edx, DWORD PTR _g_sttBLOODCASTLE_LEVEL+8
  03681	7d 07		 jge	 SHORT $LN4@CheckChoas

; 1321 : 		{
; 1322 : 			return 14;

  03683	b8 0e 00 00 00	 mov	 eax, 14			; 0000000eH
  03688	eb 41		 jmp	 SHORT $LN30@CheckChoas
$LN4@CheckChoas:

; 1323 : 		}
; 1324 : 	}
; 1325 : 	else

  0368a	eb 26		 jmp	 SHORT $LN2@CheckChoas
$LN6@CheckChoas:

; 1326 : 	{
; 1327 : 		if ( gObj[iIndex].Level < g_sttBLOODCASTLE_LEVEL[0].iLOWER_BOUND )

  0368c	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0368f	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  03695	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0369b	0f bf 94 01 be
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+190]
  036a3	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _g_sttBLOODCASTLE_LEVEL
  036a9	7d 07		 jge	 SHORT $LN2@CheckChoas

; 1328 : 		{
; 1329 : 			return 14;

  036ab	b8 0e 00 00 00	 mov	 eax, 14			; 0000000eH
  036b0	eb 19		 jmp	 SHORT $LN30@CheckChoas
$LN2@CheckChoas:

; 1330 : 		}
; 1331 : 	}
; 1332 : 
; 1333 : 	if ( bIsChaosGemExist != FALSE && bIsAngelKingPaperExist != FALSE && bIsBloodBoneExist != FALSE )

  036b2	83 7d f4 00	 cmp	 DWORD PTR _bIsChaosGemExist$[ebp], 0
  036b6	74 11		 je	 SHORT $LN1@CheckChoas
  036b8	83 7d f0 00	 cmp	 DWORD PTR _bIsAngelKingPaperExist$[ebp], 0
  036bc	74 0b		 je	 SHORT $LN1@CheckChoas
  036be	83 7d ec 00	 cmp	 DWORD PTR _bIsBloodBoneExist$[ebp], 0
  036c2	74 05		 je	 SHORT $LN1@CheckChoas

; 1334 : 	{
; 1335 : 		return iAngelKingPaperLevel;

  036c4	8b 45 e0	 mov	 eax, DWORD PTR _iAngelKingPaperLevel$[ebp]
  036c7	eb 02		 jmp	 SHORT $LN30@CheckChoas
$LN1@CheckChoas:

; 1336 : 	}
; 1337 : 
; 1338 : 	return 0;

  036c9	33 c0		 xor	 eax, eax
$LN30@CheckChoas:

; 1339 : }

  036cb	5f		 pop	 edi
  036cc	5e		 pop	 esi
  036cd	5b		 pop	 ebx
  036ce	8b e5		 mov	 esp, ebp
  036d0	5d		 pop	 ebp
  036d1	c2 04 00	 ret	 4
?CheckChoasMixItem@CBloodCastle@@QAEHH@Z ENDP		; CBloodCastle::CheckChoasMixItem
_TEXT	ENDS
PUBLIC	?CheckEnterItem@CBloodCastle@@QAEHH@Z		; CBloodCastle::CheckEnterItem
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv138 = -80						; size = 4
tv67 = -80						; size = 4
_x$237106 = -12						; size = 4
_iITEM_LEVEL$ = -8					; size = 4
_this$ = -4						; size = 4
_iIndex$ = 8						; size = 4
?CheckEnterItem@CBloodCastle@@QAEHH@Z PROC		; CBloodCastle::CheckEnterItem
; _this$ = ecx

; 1342 : {

  036e0	55		 push	 ebp
  036e1	8b ec		 mov	 ebp, esp
  036e3	83 ec 50	 sub	 esp, 80			; 00000050H
  036e6	53		 push	 ebx
  036e7	56		 push	 esi
  036e8	57		 push	 edi
  036e9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1343 : 	int iITEM_LEVEL = 0;

  036ec	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iITEM_LEVEL$[ebp], 0

; 1344 : 
; 1345 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  036f3	83 7d 08 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  036f7	7d 09		 jge	 SHORT $LN14@CheckEnter@3
  036f9	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  03700	eb 0f		 jmp	 SHORT $LN15@CheckEnter@3
$LN14@CheckEnter@3:
  03702	33 c0		 xor	 eax, eax
  03704	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _iIndex$[ebp], 14999 ; 00003a97H
  0370b	0f 9e c0	 setle	 al
  0370e	89 45 b0	 mov	 DWORD PTR tv67[ebp], eax
$LN15@CheckEnter@3:
  03711	83 7d b0 00	 cmp	 DWORD PTR tv67[ebp], 0
  03715	75 07		 jne	 SHORT $LN11@CheckEnter@3

; 1346 : 	{
; 1347 : 		return 0;

  03717	33 c0		 xor	 eax, eax
  03719	e9 43 01 00 00	 jmp	 $LN12@CheckEnter@3
$LN11@CheckEnter@3:

; 1348 : 	}
; 1349 : 
; 1350 : 	if ( gObj[iIndex].Type != OBJ_USER || gObj[iIndex].Connected <= PLAYER_LOGGED )

  0371e	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  03721	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  03727	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0372d	0f b7 54 01 68	 movzx	 edx, WORD PTR [ecx+eax+104]
  03732	83 fa 01	 cmp	 edx, 1
  03735	75 16		 jne	 SHORT $LN9@CheckEnter@3
  03737	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0373a	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  03740	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  03746	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  0374b	7f 07		 jg	 SHORT $LN10@CheckEnter@3
$LN9@CheckEnter@3:

; 1351 : 	{
; 1352 : 		return 0;

  0374d	33 c0		 xor	 eax, eax
  0374f	e9 0d 01 00 00	 jmp	 $LN12@CheckEnter@3
$LN10@CheckEnter@3:

; 1353 : 	}
; 1354 : 
; 1355 : 	for ( int x=0;x<MAIN_INVENTORY_SIZE;x++)

  03754	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _x$237106[ebp], 0
  0375b	eb 09		 jmp	 SHORT $LN8@CheckEnter@3
$LN7@CheckEnter@3:
  0375d	8b 45 f4	 mov	 eax, DWORD PTR _x$237106[ebp]
  03760	83 c0 01	 add	 eax, 1
  03763	89 45 f4	 mov	 DWORD PTR _x$237106[ebp], eax
$LN8@CheckEnter@3:
  03766	81 7d f4 cc 00
	00 00		 cmp	 DWORD PTR _x$237106[ebp], 204 ; 000000ccH
  0376d	0f 8d eb 00 00
	00		 jge	 $LN6@CheckEnter@3

; 1356 : 	{
; 1357 : 		if ( gObj[iIndex].pInventory[x].IsItem() == TRUE )

  03773	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  03776	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0377c	8b 4d f4	 mov	 ecx, DWORD PTR _x$237106[ebp]
  0377f	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  03785	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0378b	03 8c 02 24 0e
	00 00		 add	 ecx, DWORD PTR [edx+eax+3620]
  03792	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  03797	83 f8 01	 cmp	 eax, 1
  0379a	0f 85 b9 00 00
	00		 jne	 $LN5@CheckEnter@3

; 1358 : 		{
; 1359 : 			if ( gObj[iIndex].pInventory[x].m_Type == ITEMGET(13,18) )

  037a0	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  037a3	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  037a9	8b 4d f4	 mov	 ecx, DWORD PTR _x$237106[ebp]
  037ac	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  037b2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  037b8	8b 84 02 24 0e
	00 00		 mov	 eax, DWORD PTR [edx+eax+3620]
  037bf	0f bf 4c 08 06	 movsx	 ecx, WORD PTR [eax+ecx+6]
  037c4	81 f9 12 1a 00
	00		 cmp	 ecx, 6674		; 00001a12H
  037ca	75 5a		 jne	 SHORT $LN4@CheckEnter@3

; 1360 : 			{
; 1361 : 				iITEM_LEVEL = gObj[iIndex].pInventory[x].m_Level;

  037cc	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  037cf	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  037d5	8b 4d f4	 mov	 ecx, DWORD PTR _x$237106[ebp]
  037d8	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  037de	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  037e4	8b 84 02 24 0e
	00 00		 mov	 eax, DWORD PTR [edx+eax+3620]
  037eb	0f bf 4c 08 08	 movsx	 ecx, WORD PTR [eax+ecx+8]
  037f0	89 4d f8	 mov	 DWORD PTR _iITEM_LEVEL$[ebp], ecx

; 1362 : 
; 1363 : 				if ( CHECK_LIMIT(iITEM_LEVEL, MAX_CLOACK_LEVEL) == FALSE )

  037f3	83 7d f8 00	 cmp	 DWORD PTR _iITEM_LEVEL$[ebp], 0
  037f7	7d 09		 jge	 SHORT $LN16@CheckEnter@3
  037f9	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv138[ebp], 0
  03800	eb 0c		 jmp	 SHORT $LN17@CheckEnter@3
$LN16@CheckEnter@3:
  03802	33 c0		 xor	 eax, eax
  03804	83 7d f8 08	 cmp	 DWORD PTR _iITEM_LEVEL$[ebp], 8
  03808	0f 9e c0	 setle	 al
  0380b	89 45 b0	 mov	 DWORD PTR tv138[ebp], eax
$LN17@CheckEnter@3:
  0380e	83 7d b0 00	 cmp	 DWORD PTR tv138[ebp], 0
  03812	75 07		 jne	 SHORT $LN3@CheckEnter@3

; 1364 : 				{
; 1365 : 					iITEM_LEVEL = 0;

  03814	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iITEM_LEVEL$[ebp], 0
$LN3@CheckEnter@3:

; 1366 : 
; 1367 : 				}
; 1368 : 
; 1369 : 				if ( iITEM_LEVEL != 0 )

  0381b	83 7d f8 00	 cmp	 DWORD PTR _iITEM_LEVEL$[ebp], 0
  0381f	74 05		 je	 SHORT $LN4@CheckEnter@3

; 1370 : 				{
; 1371 : 					return iITEM_LEVEL;

  03821	8b 45 f8	 mov	 eax, DWORD PTR _iITEM_LEVEL$[ebp]
  03824	eb 3b		 jmp	 SHORT $LN12@CheckEnter@3
$LN4@CheckEnter@3:

; 1372 : 				}
; 1373 : 			}
; 1374 : 			
; 1375 : 			if ( gObj[iIndex].pInventory[x].m_Type == ITEMGET(13,47) )

  03826	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  03829	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0382f	8b 4d f4	 mov	 ecx, DWORD PTR _x$237106[ebp]
  03832	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  03838	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0383e	8b 84 02 24 0e
	00 00		 mov	 eax, DWORD PTR [edx+eax+3620]
  03845	0f bf 4c 08 06	 movsx	 ecx, WORD PTR [eax+ecx+6]
  0384a	81 f9 2f 1a 00
	00		 cmp	 ecx, 6703		; 00001a2fH
  03850	75 07		 jne	 SHORT $LN5@CheckEnter@3

; 1376 : 			{
; 1377 : 				iITEM_LEVEL = 10;

  03852	c7 45 f8 0a 00
	00 00		 mov	 DWORD PTR _iITEM_LEVEL$[ebp], 10 ; 0000000aH
$LN5@CheckEnter@3:

; 1378 : 			}
; 1379 : 		}
; 1380 : 	}

  03859	e9 ff fe ff ff	 jmp	 $LN7@CheckEnter@3
$LN6@CheckEnter@3:

; 1381 : 
; 1382 : 	return iITEM_LEVEL;

  0385e	8b 45 f8	 mov	 eax, DWORD PTR _iITEM_LEVEL$[ebp]
$LN12@CheckEnter@3:

; 1383 : }

  03861	5f		 pop	 edi
  03862	5e		 pop	 esi
  03863	5b		 pop	 ebx
  03864	8b e5		 mov	 esp, ebp
  03866	5d		 pop	 ebp
  03867	c2 04 00	 ret	 4
?CheckEnterItem@CBloodCastle@@QAEHH@Z ENDP		; CBloodCastle::CheckEnterItem
_TEXT	ENDS
PUBLIC	?CheckQuestItem@CBloodCastle@@QAEHH@Z		; CBloodCastle::CheckQuestItem
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv85 = -88						; size = 4
tv86 = -84						; size = 4
tv67 = -84						; size = 4
_x$237126 = -16						; size = 4
_iBridgeIndex$ = -12					; size = 4
_iITEM_LEVEL$ = -8					; size = 4
_this$ = -4						; size = 4
_iIndex$ = 8						; size = 4
?CheckQuestItem@CBloodCastle@@QAEHH@Z PROC		; CBloodCastle::CheckQuestItem
; _this$ = ecx

; 1387 : {

  03870	55		 push	 ebp
  03871	8b ec		 mov	 ebp, esp
  03873	83 ec 58	 sub	 esp, 88			; 00000058H
  03876	53		 push	 ebx
  03877	56		 push	 esi
  03878	57		 push	 edi
  03879	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1388 : 	int iITEM_LEVEL = -1;

  0387c	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _iITEM_LEVEL$[ebp], -1

; 1389 : 
; 1390 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  03883	83 7d 08 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  03887	7d 09		 jge	 SHORT $LN16@CheckQuest
  03889	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  03890	eb 0f		 jmp	 SHORT $LN17@CheckQuest
$LN16@CheckQuest:
  03892	33 c0		 xor	 eax, eax
  03894	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _iIndex$[ebp], 14999 ; 00003a97H
  0389b	0f 9e c0	 setle	 al
  0389e	89 45 ac	 mov	 DWORD PTR tv67[ebp], eax
$LN17@CheckQuest:
  038a1	83 7d ac 00	 cmp	 DWORD PTR tv67[ebp], 0
  038a5	75 0a		 jne	 SHORT $LN13@CheckQuest

; 1391 : 	{
; 1392 : 		return -1;

  038a7	b8 ff ff ff ff	 mov	 eax, -1
  038ac	e9 ed 01 00 00	 jmp	 $LN14@CheckQuest
$LN13@CheckQuest:

; 1393 : 	}
; 1394 : 
; 1395 : 	if ( BC_MAP_RANGE(gObj[iIndex].MapNumber) == FALSE )

  038b1	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  038b4	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  038ba	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  038c0	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  038c8	83 fa 34	 cmp	 edx, 52			; 00000034H
  038cb	75 09		 jne	 SHORT $LN20@CheckQuest
  038cd	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv86[ebp], 1
  038d4	eb 4d		 jmp	 SHORT $LN21@CheckQuest
$LN20@CheckQuest:
  038d6	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  038d9	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  038df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  038e5	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  038ed	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  038f0	7d 09		 jge	 SHORT $LN18@CheckQuest
  038f2	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv85[ebp], 0
  038f9	eb 22		 jmp	 SHORT $LN19@CheckQuest
$LN18@CheckQuest:
  038fb	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  038fe	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  03904	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0390a	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  03912	33 c0		 xor	 eax, eax
  03914	83 fa 11	 cmp	 edx, 17			; 00000011H
  03917	0f 9e c0	 setle	 al
  0391a	89 45 a8	 mov	 DWORD PTR tv85[ebp], eax
$LN19@CheckQuest:
  0391d	8b 4d a8	 mov	 ecx, DWORD PTR tv85[ebp]
  03920	89 4d ac	 mov	 DWORD PTR tv86[ebp], ecx
$LN21@CheckQuest:
  03923	83 7d ac 00	 cmp	 DWORD PTR tv86[ebp], 0
  03927	75 0a		 jne	 SHORT $LN12@CheckQuest

; 1396 : 	{
; 1397 : 		return -1;

  03929	b8 ff ff ff ff	 mov	 eax, -1
  0392e	e9 6b 01 00 00	 jmp	 $LN14@CheckQuest
$LN12@CheckQuest:

; 1398 : 	}
; 1399 : 
; 1400 : 	int iBridgeIndex = this->GetBridgeIndex(gObj[iIndex].MapNumber); //season3 add-on

  03933	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  03936	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0393c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  03942	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  0394a	52		 push	 edx
  0394b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0394e	e8 00 00 00 00	 call	 ?GetBridgeIndex@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeIndex
  03953	89 45 f4	 mov	 DWORD PTR _iBridgeIndex$[ebp], eax

; 1401 : 
; 1402 : 	if ( this->m_BridgeData[iBridgeIndex].m_nBC_QUESTITEM_SERIAL == -1 )

  03956	8b 45 f4	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  03959	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0395f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03962	83 bc 01 e8 03
	00 00 ff	 cmp	 DWORD PTR [ecx+eax+1000], -1
  0396a	75 08		 jne	 SHORT $LN11@CheckQuest

; 1403 : 	{
; 1404 : 		return -1;

  0396c	83 c8 ff	 or	 eax, -1
  0396f	e9 2a 01 00 00	 jmp	 $LN14@CheckQuest
$LN11@CheckQuest:

; 1405 : 	}
; 1406 : 
; 1407 : 	if ( gObj[iIndex].Type != OBJ_USER || gObj[iIndex].Connected <= PLAYER_LOGGED )

  03974	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  03977	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0397d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  03983	0f b7 54 01 68	 movzx	 edx, WORD PTR [ecx+eax+104]
  03988	83 fa 01	 cmp	 edx, 1
  0398b	75 16		 jne	 SHORT $LN9@CheckQuest
  0398d	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  03990	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  03996	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0399c	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  039a1	7f 08		 jg	 SHORT $LN10@CheckQuest
$LN9@CheckQuest:

; 1408 : 	{
; 1409 : 		return -1;

  039a3	83 c8 ff	 or	 eax, -1
  039a6	e9 f3 00 00 00	 jmp	 $LN14@CheckQuest
$LN10@CheckQuest:

; 1410 : 	}
; 1411 : 
; 1412 : 	for ( int x=0;x<MAIN_INVENTORY_SIZE;x++)

  039ab	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _x$237126[ebp], 0
  039b2	eb 09		 jmp	 SHORT $LN8@CheckQuest
$LN7@CheckQuest:
  039b4	8b 45 f0	 mov	 eax, DWORD PTR _x$237126[ebp]
  039b7	83 c0 01	 add	 eax, 1
  039ba	89 45 f0	 mov	 DWORD PTR _x$237126[ebp], eax
$LN8@CheckQuest:
  039bd	81 7d f0 cc 00
	00 00		 cmp	 DWORD PTR _x$237126[ebp], 204 ; 000000ccH
  039c4	0f 8d d1 00 00
	00		 jge	 $LN6@CheckQuest

; 1413 : 	{
; 1414 : 		if ( gObj[iIndex].pInventory[x].IsItem() == TRUE )

  039ca	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  039cd	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  039d3	8b 4d f0	 mov	 ecx, DWORD PTR _x$237126[ebp]
  039d6	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  039dc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  039e2	03 8c 02 24 0e
	00 00		 add	 ecx, DWORD PTR [edx+eax+3620]
  039e9	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  039ee	83 f8 01	 cmp	 eax, 1
  039f1	0f 85 9f 00 00
	00		 jne	 $LN5@CheckQuest

; 1415 : 		{
; 1416 : 			if ( gObj[iIndex].pInventory[x].m_Type == ITEMGET(13,19) )

  039f7	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  039fa	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  03a00	8b 4d f0	 mov	 ecx, DWORD PTR _x$237126[ebp]
  03a03	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  03a09	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  03a0f	8b 84 02 24 0e
	00 00		 mov	 eax, DWORD PTR [edx+eax+3620]
  03a16	0f bf 4c 08 06	 movsx	 ecx, WORD PTR [eax+ecx+6]
  03a1b	81 f9 13 1a 00
	00		 cmp	 ecx, 6675		; 00001a13H
  03a21	75 73		 jne	 SHORT $LN5@CheckQuest

; 1417 : 			{
; 1418 : 				if ( gObj[iIndex].pInventory[x].m_Number == this->m_BridgeData[iBridgeIndex].m_nBC_QUESTITEM_SERIAL )

  03a23	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  03a26	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  03a2c	8b 4d f0	 mov	 ecx, DWORD PTR _x$237126[ebp]
  03a2f	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  03a35	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  03a3b	8b 84 02 24 0e
	00 00		 mov	 eax, DWORD PTR [edx+eax+3620]
  03a42	8b 55 f4	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  03a45	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  03a4b	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  03a4e	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  03a51	3b 84 16 e8 03
	00 00		 cmp	 eax, DWORD PTR [esi+edx+1000]
  03a58	75 3c		 jne	 SHORT $LN5@CheckQuest

; 1419 : 				{
; 1420 : 					iITEM_LEVEL = gObj[iIndex].pInventory[x].m_Level;

  03a5a	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  03a5d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  03a63	8b 4d f0	 mov	 ecx, DWORD PTR _x$237126[ebp]
  03a66	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  03a6c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  03a72	8b 84 02 24 0e
	00 00		 mov	 eax, DWORD PTR [edx+eax+3620]
  03a79	0f bf 4c 08 08	 movsx	 ecx, WORD PTR [eax+ecx+8]
  03a7e	89 4d f8	 mov	 DWORD PTR _iITEM_LEVEL$[ebp], ecx

; 1421 : 
; 1422 : 					if ( iITEM_LEVEL < 0 || iITEM_LEVEL > 2 )

  03a81	83 7d f8 00	 cmp	 DWORD PTR _iITEM_LEVEL$[ebp], 0
  03a85	7c 06		 jl	 SHORT $LN1@CheckQuest
  03a87	83 7d f8 02	 cmp	 DWORD PTR _iITEM_LEVEL$[ebp], 2
  03a8b	7e 07		 jle	 SHORT $LN2@CheckQuest
$LN1@CheckQuest:

; 1423 : 					{
; 1424 : 						iITEM_LEVEL = -1;

  03a8d	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _iITEM_LEVEL$[ebp], -1
$LN2@CheckQuest:

; 1425 : 						
; 1426 : 					}
; 1427 : 
; 1428 : 					break;

  03a94	eb 05		 jmp	 SHORT $LN6@CheckQuest
$LN5@CheckQuest:

; 1429 : 				}
; 1430 : 			}
; 1431 : 		}
; 1432 : 	}

  03a96	e9 19 ff ff ff	 jmp	 $LN7@CheckQuest
$LN6@CheckQuest:

; 1433 : 
; 1434 : 	return iITEM_LEVEL;

  03a9b	8b 45 f8	 mov	 eax, DWORD PTR _iITEM_LEVEL$[ebp]
$LN14@CheckQuest:

; 1435 : }

  03a9e	5f		 pop	 edi
  03a9f	5e		 pop	 esi
  03aa0	5b		 pop	 ebx
  03aa1	8b e5		 mov	 esp, ebp
  03aa3	5d		 pop	 ebp
  03aa4	c2 04 00	 ret	 4
?CheckQuestItem@CBloodCastle@@QAEHH@Z ENDP		; CBloodCastle::CheckQuestItem
_TEXT	ENDS
PUBLIC	?CheckWalk@CBloodCastle@@QAE_NHHH@Z		; CBloodCastle::CheckWalk
EXTRN	?GetAttr@MapClass@@QAEEHH@Z:PROC		; MapClass::GetAttr
EXTRN	?MapC@@3PAVMapClass@@A:BYTE			; MapC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv85 = -80						; size = 4
tv86 = -76						; size = 4
tv67 = -76						; size = 4
_btMapAttr$237146 = -5					; size = 1
_this$ = -4						; size = 4
_iIndex$ = 8						; size = 4
_iMoveX$ = 12						; size = 4
_iMoveY$ = 16						; size = 4
?CheckWalk@CBloodCastle@@QAE_NHHH@Z PROC		; CBloodCastle::CheckWalk
; _this$ = ecx

; 1438 : {

  03ab0	55		 push	 ebp
  03ab1	8b ec		 mov	 ebp, esp
  03ab3	83 ec 50	 sub	 esp, 80			; 00000050H
  03ab6	53		 push	 ebx
  03ab7	56		 push	 esi
  03ab8	57		 push	 edi
  03ab9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1439 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  03abc	83 7d 08 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  03ac0	7d 09		 jge	 SHORT $LN9@CheckWalk
  03ac2	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  03ac9	eb 0f		 jmp	 SHORT $LN10@CheckWalk
$LN9@CheckWalk:
  03acb	33 c0		 xor	 eax, eax
  03acd	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _iIndex$[ebp], 14999 ; 00003a97H
  03ad4	0f 9e c0	 setle	 al
  03ad7	89 45 b4	 mov	 DWORD PTR tv67[ebp], eax
$LN10@CheckWalk:
  03ada	83 7d b4 00	 cmp	 DWORD PTR tv67[ebp], 0
  03ade	75 07		 jne	 SHORT $LN6@CheckWalk

; 1440 : 	{
; 1441 : 		return false;

  03ae0	32 c0		 xor	 al, al
  03ae2	e9 18 01 00 00	 jmp	 $LN7@CheckWalk
$LN6@CheckWalk:

; 1442 : 	}
; 1443 : 	
; 1444 : 	if ( BC_MAP_RANGE(gObj[iIndex].MapNumber) == FALSE )

  03ae7	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  03aea	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  03af0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  03af6	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  03afe	83 fa 34	 cmp	 edx, 52			; 00000034H
  03b01	75 09		 jne	 SHORT $LN13@CheckWalk
  03b03	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv86[ebp], 1
  03b0a	eb 4d		 jmp	 SHORT $LN14@CheckWalk
$LN13@CheckWalk:
  03b0c	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  03b0f	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  03b15	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  03b1b	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  03b23	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  03b26	7d 09		 jge	 SHORT $LN11@CheckWalk
  03b28	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv85[ebp], 0
  03b2f	eb 22		 jmp	 SHORT $LN12@CheckWalk
$LN11@CheckWalk:
  03b31	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  03b34	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  03b3a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  03b40	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  03b48	33 c0		 xor	 eax, eax
  03b4a	83 fa 11	 cmp	 edx, 17			; 00000011H
  03b4d	0f 9e c0	 setle	 al
  03b50	89 45 b0	 mov	 DWORD PTR tv85[ebp], eax
$LN12@CheckWalk:
  03b53	8b 4d b0	 mov	 ecx, DWORD PTR tv85[ebp]
  03b56	89 4d b4	 mov	 DWORD PTR tv86[ebp], ecx
$LN14@CheckWalk:
  03b59	83 7d b4 00	 cmp	 DWORD PTR tv86[ebp], 0
  03b5d	75 07		 jne	 SHORT $LN5@CheckWalk

; 1445 : 	{
; 1446 : 		return false;

  03b5f	32 c0		 xor	 al, al
  03b61	e9 99 00 00 00	 jmp	 $LN7@CheckWalk
$LN5@CheckWalk:

; 1447 : 	}
; 1448 : 
; 1449 : 	if ( gObj[iIndex].Type != OBJ_USER || gObj[iIndex].Connected <= PLAYER_LOGGED )

  03b66	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  03b69	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  03b6f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  03b75	0f b7 54 01 68	 movzx	 edx, WORD PTR [ecx+eax+104]
  03b7a	83 fa 01	 cmp	 edx, 1
  03b7d	75 16		 jne	 SHORT $LN3@CheckWalk
  03b7f	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  03b82	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  03b88	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  03b8e	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  03b93	7f 04		 jg	 SHORT $LN4@CheckWalk
$LN3@CheckWalk:

; 1450 : 	{
; 1451 : 		return false;

  03b95	32 c0		 xor	 al, al
  03b97	eb 66		 jmp	 SHORT $LN7@CheckWalk
$LN4@CheckWalk:

; 1452 : 	}
; 1453 : 
; 1454 : 	if ( this->GetCurrentState(gObj[iIndex].MapNumber) == TRUE )

  03b99	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  03b9c	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  03ba2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  03ba8	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  03bb0	52		 push	 edx
  03bb1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03bb4	e8 00 00 00 00	 call	 ?GetCurrentState@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetCurrentState
  03bb9	83 f8 01	 cmp	 eax, 1
  03bbc	75 3f		 jne	 SHORT $LN2@CheckWalk

; 1455 : 	{
; 1456 : 		BYTE btMapAttr = MapC[gObj[iIndex].MapNumber].GetAttr(iMoveX, iMoveY);

  03bbe	8b 45 10	 mov	 eax, DWORD PTR _iMoveY$[ebp]
  03bc1	50		 push	 eax
  03bc2	8b 4d 0c	 mov	 ecx, DWORD PTR _iMoveX$[ebp]
  03bc5	51		 push	 ecx
  03bc6	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  03bc9	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  03bcf	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  03bd4	0f b6 8c 10 49
	01 00 00	 movzx	 ecx, BYTE PTR [eax+edx+329]
  03bdc	69 c9 b8 3d 05
	00		 imul	 ecx, 343480		; 00053db8H
  03be2	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  03be8	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  03bed	88 45 fb	 mov	 BYTE PTR _btMapAttr$237146[ebp], al

; 1457 : 
; 1458 : 		if ( (btMapAttr&1) != 1 )

  03bf0	0f b6 45 fb	 movzx	 eax, BYTE PTR _btMapAttr$237146[ebp]
  03bf4	83 e0 01	 and	 eax, 1
  03bf7	75 04		 jne	 SHORT $LN2@CheckWalk

; 1459 : 		{
; 1460 : 			return true;

  03bf9	b0 01		 mov	 al, 1
  03bfb	eb 02		 jmp	 SHORT $LN7@CheckWalk
$LN2@CheckWalk:

; 1461 : 		}
; 1462 : 	}
; 1463 : 
; 1464 : 	return false;

  03bfd	32 c0		 xor	 al, al
$LN7@CheckWalk:

; 1465 : }

  03bff	5f		 pop	 edi
  03c00	5e		 pop	 esi
  03c01	5b		 pop	 ebx
  03c02	8b e5		 mov	 esp, ebp
  03c04	5d		 pop	 ebp
  03c05	c2 0c 00	 ret	 12			; 0000000cH
?CheckWalk@CBloodCastle@@QAE_NHHH@Z ENDP		; CBloodCastle::CheckWalk
_TEXT	ENDS
PUBLIC	?CheckCanEnter@CBloodCastle@@QAE_NH@Z		; CBloodCastle::CheckCanEnter
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv67 = -72						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?CheckCanEnter@CBloodCastle@@QAE_NH@Z PROC		; CBloodCastle::CheckCanEnter
; _this$ = ecx

; 1468 : {

  03c10	55		 push	 ebp
  03c11	8b ec		 mov	 ebp, esp
  03c13	83 ec 48	 sub	 esp, 72			; 00000048H
  03c16	53		 push	 ebx
  03c17	56		 push	 esi
  03c18	57		 push	 edi
  03c19	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1469 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  03c1c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  03c20	7d 09		 jge	 SHORT $LN4@CheckCanEn
  03c22	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  03c29	eb 0c		 jmp	 SHORT $LN5@CheckCanEn
$LN4@CheckCanEn:
  03c2b	33 c0		 xor	 eax, eax
  03c2d	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  03c31	0f 9e c0	 setle	 al
  03c34	89 45 b8	 mov	 DWORD PTR tv67[ebp], eax
$LN5@CheckCanEn:
  03c37	83 7d b8 00	 cmp	 DWORD PTR tv67[ebp], 0
  03c3b	75 04		 jne	 SHORT $LN1@CheckCanEn

; 1470 : 	{
; 1471 : 		return false;

  03c3d	32 c0		 xor	 al, al
  03c3f	eb 13		 jmp	 SHORT $LN2@CheckCanEn
$LN1@CheckCanEn:

; 1472 : 	}
; 1473 : 
; 1474 : 	return this->m_BridgeData[iBridgeIndex].m_bBC_CAN_ENTER;

  03c41	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  03c44	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  03c4a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03c4d	8a 84 01 bb 03
	00 00		 mov	 al, BYTE PTR [ecx+eax+955]
$LN2@CheckCanEn:

; 1475 : }

  03c54	5f		 pop	 edi
  03c55	5e		 pop	 esi
  03c56	5b		 pop	 ebx
  03c57	8b e5		 mov	 esp, ebp
  03c59	5d		 pop	 ebp
  03c5a	c2 04 00	 ret	 4
?CheckCanEnter@CBloodCastle@@QAE_NH@Z ENDP		; CBloodCastle::CheckCanEnter
_TEXT	ENDS
PUBLIC	?CheckCanParty@CBloodCastle@@QAE_NH@Z		; CBloodCastle::CheckCanParty
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv67 = -72						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?CheckCanParty@CBloodCastle@@QAE_NH@Z PROC		; CBloodCastle::CheckCanParty
; _this$ = ecx

; 1478 : {

  03c60	55		 push	 ebp
  03c61	8b ec		 mov	 ebp, esp
  03c63	83 ec 48	 sub	 esp, 72			; 00000048H
  03c66	53		 push	 ebx
  03c67	56		 push	 esi
  03c68	57		 push	 edi
  03c69	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1479 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  03c6c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  03c70	7d 09		 jge	 SHORT $LN4@CheckCanPa
  03c72	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  03c79	eb 0c		 jmp	 SHORT $LN5@CheckCanPa
$LN4@CheckCanPa:
  03c7b	33 c0		 xor	 eax, eax
  03c7d	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  03c81	0f 9e c0	 setle	 al
  03c84	89 45 b8	 mov	 DWORD PTR tv67[ebp], eax
$LN5@CheckCanPa:
  03c87	83 7d b8 00	 cmp	 DWORD PTR tv67[ebp], 0
  03c8b	75 04		 jne	 SHORT $LN1@CheckCanPa

; 1480 : 	{
; 1481 : 		return false;

  03c8d	32 c0		 xor	 al, al
  03c8f	eb 13		 jmp	 SHORT $LN2@CheckCanPa
$LN1@CheckCanPa:

; 1482 : 	}
; 1483 : 
; 1484 : 	return this->m_BridgeData[iBridgeIndex].m_bBC_CAN_PARTY;

  03c91	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  03c94	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  03c9a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03c9d	8a 84 01 bc 03
	00 00		 mov	 al, BYTE PTR [ecx+eax+956]
$LN2@CheckCanPa:

; 1485 : }

  03ca4	5f		 pop	 edi
  03ca5	5e		 pop	 esi
  03ca6	5b		 pop	 ebx
  03ca7	8b e5		 mov	 esp, ebp
  03ca9	5d		 pop	 ebp
  03caa	c2 04 00	 ret	 4
?CheckCanParty@CBloodCastle@@QAE_NH@Z ENDP		; CBloodCastle::CheckCanParty
_TEXT	ENDS
PUBLIC	?CheckQuestItemSerial@CBloodCastle@@QAE_NHPAVCMapItem@@@Z ; CBloodCastle::CheckQuestItemSerial
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv129 = -76						; size = 4
tv67 = -76						; size = 4
_iLEVEL$237167 = -8					; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
_lpItem$ = 12						; size = 4
?CheckQuestItemSerial@CBloodCastle@@QAE_NHPAVCMapItem@@@Z PROC ; CBloodCastle::CheckQuestItemSerial
; _this$ = ecx

; 1488 : {

  03cb0	55		 push	 ebp
  03cb1	8b ec		 mov	 ebp, esp
  03cb3	83 ec 4c	 sub	 esp, 76			; 0000004cH
  03cb6	53		 push	 ebx
  03cb7	56		 push	 esi
  03cb8	57		 push	 edi
  03cb9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1489 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  03cbc	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  03cc0	7d 09		 jge	 SHORT $LN9@CheckQuest@2
  03cc2	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  03cc9	eb 0c		 jmp	 SHORT $LN10@CheckQuest@2
$LN9@CheckQuest@2:
  03ccb	33 c0		 xor	 eax, eax
  03ccd	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  03cd1	0f 9e c0	 setle	 al
  03cd4	89 45 b4	 mov	 DWORD PTR tv67[ebp], eax
$LN10@CheckQuest@2:
  03cd7	83 7d b4 00	 cmp	 DWORD PTR tv67[ebp], 0
  03cdb	75 07		 jne	 SHORT $LN6@CheckQuest@2

; 1490 : 	{
; 1491 : 		return false;

  03cdd	32 c0		 xor	 al, al
  03cdf	e9 85 00 00 00	 jmp	 $LN7@CheckQuest@2
$LN6@CheckQuest@2:

; 1492 : 	}
; 1493 : 
; 1494 : 	if ( this->m_BridgeData[iBridgeIndex].m_nBC_QUESTITEM_SERIAL == -1 )

  03ce4	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  03ce7	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  03ced	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03cf0	83 bc 01 e8 03
	00 00 ff	 cmp	 DWORD PTR [ecx+eax+1000], -1
  03cf8	75 04		 jne	 SHORT $LN5@CheckQuest@2

; 1495 : 	{
; 1496 : 		return false;

  03cfa	32 c0		 xor	 al, al
  03cfc	eb 6b		 jmp	 SHORT $LN7@CheckQuest@2
$LN5@CheckQuest@2:

; 1497 : 	}
; 1498 : 	
; 1499 : 	if ( lpItem->IsItem() == TRUE )

  03cfe	8b 4d 0c	 mov	 ecx, DWORD PTR _lpItem$[ebp]
  03d01	83 c1 04	 add	 ecx, 4
  03d04	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  03d09	83 f8 01	 cmp	 eax, 1
  03d0c	75 59		 jne	 SHORT $LN4@CheckQuest@2

; 1500 : 	{
; 1501 : 		if ( lpItem->m_Type == ITEMGET(13,19) )

  03d0e	8b 45 0c	 mov	 eax, DWORD PTR _lpItem$[ebp]
  03d11	0f bf 48 0a	 movsx	 ecx, WORD PTR [eax+10]
  03d15	81 f9 13 1a 00
	00		 cmp	 ecx, 6675		; 00001a13H
  03d1b	75 4a		 jne	 SHORT $LN4@CheckQuest@2

; 1502 : 		{
; 1503 : 			int iLEVEL = lpItem->m_Level;

  03d1d	8b 45 0c	 mov	 eax, DWORD PTR _lpItem$[ebp]
  03d20	0f bf 48 0c	 movsx	 ecx, WORD PTR [eax+12]
  03d24	89 4d f8	 mov	 DWORD PTR _iLEVEL$237167[ebp], ecx

; 1504 : 
; 1505 : 			if ( BC_WEAPON_LEVEL_RANGE(iLEVEL) != FALSE )

  03d27	83 7d f8 00	 cmp	 DWORD PTR _iLEVEL$237167[ebp], 0
  03d2b	7d 09		 jge	 SHORT $LN11@CheckQuest@2
  03d2d	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv129[ebp], 0
  03d34	eb 0c		 jmp	 SHORT $LN12@CheckQuest@2
$LN11@CheckQuest@2:
  03d36	33 c0		 xor	 eax, eax
  03d38	83 7d f8 02	 cmp	 DWORD PTR _iLEVEL$237167[ebp], 2
  03d3c	0f 9e c0	 setle	 al
  03d3f	89 45 b4	 mov	 DWORD PTR tv129[ebp], eax
$LN12@CheckQuest@2:
  03d42	83 7d b4 00	 cmp	 DWORD PTR tv129[ebp], 0
  03d46	74 1f		 je	 SHORT $LN4@CheckQuest@2

; 1506 : 			{
; 1507 : 				if ( this->m_BridgeData[iBridgeIndex].m_nBC_QUESTITEM_SERIAL == lpItem->m_Number )

  03d48	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  03d4b	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  03d51	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03d54	8b 55 0c	 mov	 edx, DWORD PTR _lpItem$[ebp]
  03d57	8b 84 01 e8 03
	00 00		 mov	 eax, DWORD PTR [ecx+eax+1000]
  03d5e	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  03d61	75 04		 jne	 SHORT $LN4@CheckQuest@2

; 1508 : 				{
; 1509 : 					return true;

  03d63	b0 01		 mov	 al, 1
  03d65	eb 02		 jmp	 SHORT $LN7@CheckQuest@2
$LN4@CheckQuest@2:

; 1510 : 				}
; 1511 : 			}
; 1512 : 		}
; 1513 : 	}
; 1514 : 	
; 1515 : 
; 1516 : 	return false;

  03d67	32 c0		 xor	 al, al
$LN7@CheckQuest@2:

; 1517 : 
; 1518 : }

  03d69	5f		 pop	 edi
  03d6a	5e		 pop	 esi
  03d6b	5b		 pop	 ebx
  03d6c	8b e5		 mov	 esp, ebp
  03d6e	5d		 pop	 ebp
  03d6f	c2 08 00	 ret	 8
?CheckQuestItemSerial@CBloodCastle@@QAE_NHPAVCMapItem@@@Z ENDP ; CBloodCastle::CheckQuestItemSerial
_TEXT	ENDS
PUBLIC	?CheckPlayStart@CBloodCastle@@QAE_NH@Z		; CBloodCastle::CheckPlayStart
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv67 = -72						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?CheckPlayStart@CBloodCastle@@QAE_NH@Z PROC		; CBloodCastle::CheckPlayStart
; _this$ = ecx

; 1521 : {

  03d80	55		 push	 ebp
  03d81	8b ec		 mov	 ebp, esp
  03d83	83 ec 48	 sub	 esp, 72			; 00000048H
  03d86	53		 push	 ebx
  03d87	56		 push	 esi
  03d88	57		 push	 edi
  03d89	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1522 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  03d8c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  03d90	7d 09		 jge	 SHORT $LN4@CheckPlayS
  03d92	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  03d99	eb 0c		 jmp	 SHORT $LN5@CheckPlayS
$LN4@CheckPlayS:
  03d9b	33 c0		 xor	 eax, eax
  03d9d	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  03da1	0f 9e c0	 setle	 al
  03da4	89 45 b8	 mov	 DWORD PTR tv67[ebp], eax
$LN5@CheckPlayS:
  03da7	83 7d b8 00	 cmp	 DWORD PTR tv67[ebp], 0
  03dab	75 04		 jne	 SHORT $LN1@CheckPlayS

; 1523 : 	{
; 1524 : 		return false;

  03dad	32 c0		 xor	 al, al
  03daf	eb 13		 jmp	 SHORT $LN2@CheckPlayS
$LN1@CheckPlayS:

; 1525 : 	}
; 1526 : 
; 1527 : 	return this->m_BridgeData[iBridgeIndex].m_bBC_PLAY_START;

  03db1	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  03db4	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  03dba	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03dbd	8a 84 01 bd 03
	00 00		 mov	 al, BYTE PTR [ecx+eax+957]
$LN2@CheckPlayS:

; 1528 : }

  03dc4	5f		 pop	 edi
  03dc5	5e		 pop	 esi
  03dc6	5b		 pop	 ebx
  03dc7	8b e5		 mov	 esp, ebp
  03dc9	5d		 pop	 ebp
  03dca	c2 04 00	 ret	 4
?CheckPlayStart@CBloodCastle@@QAE_NH@Z ENDP		; CBloodCastle::CheckPlayStart
_TEXT	ENDS
PUBLIC	?GetRemainTime@CBloodCastle@@QAEHH@Z		; CBloodCastle::GetRemainTime
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
$T239247 = -152						; size = 4
$T239248 = -148						; size = 4
$T239249 = -144						; size = 4
$T239250 = -140						; size = 4
$T239251 = -136						; size = 4
$T239252 = -132						; size = 4
$T239253 = -128						; size = 4
_loc14$237195 = -60					; size = 4
_loc13$237194 = -56					; size = 4
_ltime$237193 = -52					; size = 8
_today$237192 = -44					; size = 4
_CurrentTime$237191 = -40				; size = 4
_CheckTime$237190 = -36					; size = 4
_BaseTime$237189 = -32					; size = 4
_WebzenVar2$237188 = -28				; size = 8
_WebzenVar1$237187 = -20				; size = 8
_it$237186 = -12					; size = 4
_iREMAIN_MINUTE$ = -8					; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?GetRemainTime@CBloodCastle@@QAEHH@Z PROC		; CBloodCastle::GetRemainTime
; _this$ = ecx

; 1531 : {

  03dd0	55		 push	 ebp
  03dd1	8b ec		 mov	 ebp, esp
  03dd3	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H
  03dd9	53		 push	 ebx
  03dda	56		 push	 esi
  03ddb	57		 push	 edi
  03ddc	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1532 : 	int iREMAIN_MINUTE = 0;

  03ddf	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iREMAIN_MINUTE$[ebp], 0

; 1533 : 
; 1534 : 	if ( this->GetCurrentState(iBridgeIndex) == 1 )

  03de6	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  03de9	50		 push	 eax
  03dea	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03ded	e8 00 00 00 00	 call	 ?GetCurrentState@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetCurrentState
  03df2	83 f8 01	 cmp	 eax, 1
  03df5	75 2f		 jne	 SHORT $LN17@GetRemainT

; 1535 : 	{
; 1536 : 		iREMAIN_MINUTE = this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 60000 - this->m_iBC_TIME_MIN_OPEN + 1;

  03df7	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  03dfa	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  03e00	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03e03	8b 84 01 ac 03
	00 00		 mov	 eax, DWORD PTR [ecx+eax+940]
  03e0a	99		 cdq
  03e0b	b9 60 ea 00 00	 mov	 ecx, 60000		; 0000ea60H
  03e10	f7 f9		 idiv	 ecx
  03e12	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  03e15	2b 82 08 23 00
	00		 sub	 eax, DWORD PTR [edx+8968]
  03e1b	83 c0 01	 add	 eax, 1
  03e1e	89 45 f8	 mov	 DWORD PTR _iREMAIN_MINUTE$[ebp], eax

; 1537 : 	}
; 1538 : 	else

  03e21	e9 91 02 00 00	 jmp	 $LN16@GetRemainT
$LN17@GetRemainT:

; 1539 : 	{
; 1540 : 		std::list<BLOODCASTLE_START_TIME>::iterator it; //loc3 -> ebp C

  03e26	8d 4d f4	 lea	 ecx, DWORD PTR _it$237186[ebp]
  03e29	e8 00 00 00 00	 call	 ??0?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE@XZ ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >

; 1541 : 		BLOODCASTLE_START_TIME WebzenVar1; //loc 4-5 -> ebp 14
; 1542 : 		BLOODCASTLE_START_TIME WebzenVar2; //loc 6-7 -> epb 18
; 1543 : 		int BaseTime = 0; // loc8 -> ebp 1C

  03e2e	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _BaseTime$237189[ebp], 0

; 1544 : 		int CheckTime = 0; // loc9 -> ebp 20

  03e35	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _CheckTime$237190[ebp], 0

; 1545 : 		DWORD CurrentTime = 0;	// loc10-> ebp 24

  03e3c	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _CurrentTime$237191[ebp], 0

; 1546 : 		
; 1547 : 		tm * today; //loc11 -> ebp 28
; 1548 : 		time_t ltime; //loc12 -> ebp 2C
; 1549 : 
; 1550 : 		int loc13; //ebp 34
; 1551 : 		int loc14; //ebp 38
; 1552 : 
; 1553 : 		time(&ltime); //

  03e43	8d 45 cc	 lea	 eax, DWORD PTR _ltime$237193[ebp]
  03e46	50		 push	 eax
  03e47	e8 00 00 00 00	 call	 _time
  03e4c	83 c4 04	 add	 esp, 4

; 1554 : 		today = localtime(&ltime); //

  03e4f	8d 45 cc	 lea	 eax, DWORD PTR _ltime$237193[ebp]
  03e52	50		 push	 eax
  03e53	e8 00 00 00 00	 call	 _localtime
  03e58	83 c4 04	 add	 esp, 4
  03e5b	89 45 d4	 mov	 DWORD PTR _today$237192[ebp], eax

; 1555 : 		
; 1556 : 		CurrentTime = (today->tm_hour * 60) + today->tm_min;

  03e5e	8b 45 d4	 mov	 eax, DWORD PTR _today$237192[ebp]
  03e61	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  03e64	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  03e67	8b 55 d4	 mov	 edx, DWORD PTR _today$237192[ebp]
  03e6a	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  03e6d	89 4d d8	 mov	 DWORD PTR _CurrentTime$237191[ebp], ecx

; 1557 : 		WebzenVar1 = *this->m_listBloodCastleOpenTime.begin();

  03e70	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR $T239247[ebp]
  03e76	50		 push	 eax
  03e77	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03e7a	81 c1 20 23 00
	00		 add	 ecx, 8992		; 00002320H
  03e80	e8 00 00 00 00	 call	 ?begin@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@2@XZ ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::begin
  03e85	8b c8		 mov	 ecx, eax
  03e87	e8 00 00 00 00	 call	 ??D?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBEAAUBLOODCASTLE_START_TIME@@XZ ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator*
  03e8c	8b 08		 mov	 ecx, DWORD PTR [eax]
  03e8e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  03e91	89 4d ec	 mov	 DWORD PTR _WebzenVar1$237187[ebp], ecx
  03e94	89 55 f0	 mov	 DWORD PTR _WebzenVar1$237187[ebp+4], edx

; 1558 : 
; 1559 : 		for( it = this->m_listBloodCastleOpenTime.begin(); it != this->m_listBloodCastleOpenTime.end(); ++it ) //for identical

  03e97	8d 85 6c ff ff
	ff		 lea	 eax, DWORD PTR $T239248[ebp]
  03e9d	50		 push	 eax
  03e9e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03ea1	81 c1 20 23 00
	00		 add	 ecx, 8992		; 00002320H
  03ea7	e8 00 00 00 00	 call	 ?begin@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@2@XZ ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::begin
  03eac	8b 08		 mov	 ecx, DWORD PTR [eax]
  03eae	89 4d f4	 mov	 DWORD PTR _it$237186[ebp], ecx
  03eb1	eb 08		 jmp	 SHORT $LN15@GetRemainT
$LN14@GetRemainT:
  03eb3	8d 4d f4	 lea	 ecx, DWORD PTR _it$237186[ebp]
  03eb6	e8 00 00 00 00	 call	 ??E?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator++
$LN15@GetRemainT:
  03ebb	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR $T239249[ebp]
  03ec1	50		 push	 eax
  03ec2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03ec5	81 c1 20 23 00
	00		 add	 ecx, 8992		; 00002320H
  03ecb	e8 00 00 00 00	 call	 ?end@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@2@XZ ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::end
  03ed0	50		 push	 eax
  03ed1	8d 4d f4	 lea	 ecx, DWORD PTR _it$237186[ebp]
  03ed4	e8 00 00 00 00	 call	 ??9?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator!=
  03ed9	0f b6 c8	 movzx	 ecx, al
  03edc	85 c9		 test	 ecx, ecx
  03ede	74 7e		 je	 SHORT $LN13@GetRemainT

; 1560 : 		{
; 1561 : 			WebzenVar2 = *it; // loc5-6

  03ee0	8d 4d f4	 lea	 ecx, DWORD PTR _it$237186[ebp]
  03ee3	e8 00 00 00 00	 call	 ??D?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBEAAUBLOODCASTLE_START_TIME@@XZ ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator*
  03ee8	8b 08		 mov	 ecx, DWORD PTR [eax]
  03eea	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  03eed	89 4d e4	 mov	 DWORD PTR _WebzenVar2$237188[ebp], ecx
  03ef0	89 55 e8	 mov	 DWORD PTR _WebzenVar2$237188[ebp+4], edx

; 1562 : 			BaseTime = (WebzenVar1.m_iHour * 60) + WebzenVar1.m_iMinute;

  03ef3	8b 45 ec	 mov	 eax, DWORD PTR _WebzenVar1$237187[ebp]
  03ef6	6b c0 3c	 imul	 eax, 60			; 0000003cH
  03ef9	03 45 f0	 add	 eax, DWORD PTR _WebzenVar1$237187[ebp+4]
  03efc	89 45 e0	 mov	 DWORD PTR _BaseTime$237189[ebp], eax

; 1563 : 			CheckTime =	(WebzenVar2.m_iHour * 60) + WebzenVar2.m_iMinute;

  03eff	8b 45 e4	 mov	 eax, DWORD PTR _WebzenVar2$237188[ebp]
  03f02	6b c0 3c	 imul	 eax, 60			; 0000003cH
  03f05	03 45 e8	 add	 eax, DWORD PTR _WebzenVar2$237188[ebp+4]
  03f08	89 45 dc	 mov	 DWORD PTR _CheckTime$237190[ebp], eax

; 1564 : 
; 1565 : 			if( BaseTime == CheckTime )

  03f0b	8b 45 e0	 mov	 eax, DWORD PTR _BaseTime$237189[ebp]
  03f0e	3b 45 dc	 cmp	 eax, DWORD PTR _CheckTime$237190[ebp]
  03f11	75 1f		 jne	 SHORT $LN12@GetRemainT

; 1566 : 			{
; 1567 : 				if( CurrentTime < CheckTime )

  03f13	8b 45 d8	 mov	 eax, DWORD PTR _CurrentTime$237191[ebp]
  03f16	3b 45 dc	 cmp	 eax, DWORD PTR _CheckTime$237190[ebp]
  03f19	73 15		 jae	 SHORT $LN11@GetRemainT

; 1568 : 				{
; 1569 : 					WebzenVar2 = *it;

  03f1b	8d 4d f4	 lea	 ecx, DWORD PTR _it$237186[ebp]
  03f1e	e8 00 00 00 00	 call	 ??D?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBEAAUBLOODCASTLE_START_TIME@@XZ ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator*
  03f23	8b 08		 mov	 ecx, DWORD PTR [eax]
  03f25	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  03f28	89 4d e4	 mov	 DWORD PTR _WebzenVar2$237188[ebp], ecx
  03f2b	89 55 e8	 mov	 DWORD PTR _WebzenVar2$237188[ebp+4], edx

; 1570 : 					break;

  03f2e	eb 2e		 jmp	 SHORT $LN13@GetRemainT
$LN11@GetRemainT:

; 1571 : 				}
; 1572 : 				continue;

  03f30	eb 81		 jmp	 SHORT $LN14@GetRemainT
$LN12@GetRemainT:

; 1573 : 			}
; 1574 : 			
; 1575 : 			if( CurrentTime >= BaseTime && CurrentTime < CheckTime )

  03f32	8b 45 d8	 mov	 eax, DWORD PTR _CurrentTime$237191[ebp]
  03f35	3b 45 e0	 cmp	 eax, DWORD PTR _BaseTime$237189[ebp]
  03f38	72 0c		 jb	 SHORT $LN10@GetRemainT
  03f3a	8b 45 d8	 mov	 eax, DWORD PTR _CurrentTime$237191[ebp]
  03f3d	3b 45 dc	 cmp	 eax, DWORD PTR _CheckTime$237190[ebp]
  03f40	73 04		 jae	 SHORT $LN10@GetRemainT

; 1576 : 			{
; 1577 : 				break;

  03f42	eb 1a		 jmp	 SHORT $LN13@GetRemainT

; 1578 : 			}
; 1579 : 			else

  03f44	eb 13		 jmp	 SHORT $LN9@GetRemainT
$LN10@GetRemainT:

; 1580 : 			{
; 1581 : 				WebzenVar1 = *it;

  03f46	8d 4d f4	 lea	 ecx, DWORD PTR _it$237186[ebp]
  03f49	e8 00 00 00 00	 call	 ??D?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBEAAUBLOODCASTLE_START_TIME@@XZ ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator*
  03f4e	8b 08		 mov	 ecx, DWORD PTR [eax]
  03f50	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  03f53	89 4d ec	 mov	 DWORD PTR _WebzenVar1$237187[ebp], ecx
  03f56	89 55 f0	 mov	 DWORD PTR _WebzenVar1$237187[ebp+4], edx
$LN9@GetRemainT:

; 1582 : 			}
; 1583 : 		}

  03f59	e9 55 ff ff ff	 jmp	 $LN14@GetRemainT
$LN13@GetRemainT:

; 1584 : 
; 1585 : 		for(loc13 = 2;loc13--;) //good ->func identical so far

  03f5e	c7 45 c8 02 00
	00 00		 mov	 DWORD PTR _loc13$237194[ebp], 2
$LN8@GetRemainT:
  03f65	8b 45 c8	 mov	 eax, DWORD PTR _loc13$237194[ebp]
  03f68	8b 4d c8	 mov	 ecx, DWORD PTR _loc13$237194[ebp]
  03f6b	83 e9 01	 sub	 ecx, 1
  03f6e	89 4d c8	 mov	 DWORD PTR _loc13$237194[ebp], ecx
  03f71	85 c0		 test	 eax, eax
  03f73	0f 84 12 01 00
	00		 je	 $LN7@GetRemainT

; 1586 : 		{
; 1587 : 			if(it == this->m_listBloodCastleOpenTime.end())

  03f79	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR $T239250[ebp]
  03f7f	50		 push	 eax
  03f80	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03f83	81 c1 20 23 00
	00		 add	 ecx, 8992		; 00002320H
  03f89	e8 00 00 00 00	 call	 ?end@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@2@XZ ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::end
  03f8e	50		 push	 eax
  03f8f	8d 4d f4	 lea	 ecx, DWORD PTR _it$237186[ebp]
  03f92	e8 00 00 00 00	 call	 ??8?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator==
  03f97	0f b6 c8	 movzx	 ecx, al
  03f9a	85 c9		 test	 ecx, ecx
  03f9c	74 2d		 je	 SHORT $LN6@GetRemainT

; 1588 : 			{
; 1589 : 				it = this->m_listBloodCastleOpenTime.begin();

  03f9e	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR $T239251[ebp]
  03fa4	50		 push	 eax
  03fa5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  03fa8	81 c1 20 23 00
	00		 add	 ecx, 8992		; 00002320H
  03fae	e8 00 00 00 00	 call	 ?begin@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@2@XZ ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::begin
  03fb3	8b 08		 mov	 ecx, DWORD PTR [eax]
  03fb5	89 4d f4	 mov	 DWORD PTR _it$237186[ebp], ecx

; 1590 : 
; 1591 : 				WebzenVar2 = (*it);

  03fb8	8d 4d f4	 lea	 ecx, DWORD PTR _it$237186[ebp]
  03fbb	e8 00 00 00 00	 call	 ??D?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBEAAUBLOODCASTLE_START_TIME@@XZ ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator*
  03fc0	8b 08		 mov	 ecx, DWORD PTR [eax]
  03fc2	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  03fc5	89 4d e4	 mov	 DWORD PTR _WebzenVar2$237188[ebp], ecx
  03fc8	89 55 e8	 mov	 DWORD PTR _WebzenVar2$237188[ebp+4], edx
$LN6@GetRemainT:

; 1592 : 			}
; 1593 : 
; 1594 : 			CheckTime = WebzenVar2.m_iHour*60+WebzenVar2.m_iMinute;

  03fcb	8b 45 e4	 mov	 eax, DWORD PTR _WebzenVar2$237188[ebp]
  03fce	6b c0 3c	 imul	 eax, 60			; 0000003cH
  03fd1	03 45 e8	 add	 eax, DWORD PTR _WebzenVar2$237188[ebp+4]
  03fd4	89 45 dc	 mov	 DWORD PTR _CheckTime$237190[ebp], eax

; 1595 : 
; 1596 : 			if(today->tm_hour <= WebzenVar2.m_iHour && CheckTime > CurrentTime)

  03fd7	8b 45 d4	 mov	 eax, DWORD PTR _today$237192[ebp]
  03fda	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  03fdd	3b 4d e4	 cmp	 ecx, DWORD PTR _WebzenVar2$237188[ebp]
  03fe0	7f 1c		 jg	 SHORT $LN5@GetRemainT
  03fe2	8b 45 dc	 mov	 eax, DWORD PTR _CheckTime$237190[ebp]
  03fe5	3b 45 d8	 cmp	 eax, DWORD PTR _CurrentTime$237191[ebp]
  03fe8	76 14		 jbe	 SHORT $LN5@GetRemainT

; 1597 : 			{
; 1598 : 				iREMAIN_MINUTE = ((CheckTime - CurrentTime)*60)*1000;

  03fea	8b 45 dc	 mov	 eax, DWORD PTR _CheckTime$237190[ebp]
  03fed	2b 45 d8	 sub	 eax, DWORD PTR _CurrentTime$237191[ebp]
  03ff0	6b c0 3c	 imul	 eax, 60			; 0000003cH
  03ff3	69 c0 e8 03 00
	00		 imul	 eax, 1000		; 000003e8H
  03ff9	89 45 f8	 mov	 DWORD PTR _iREMAIN_MINUTE$[ebp], eax

; 1599 : 			}
; 1600 : 			else

  03ffc	eb 17		 jmp	 SHORT $LN4@GetRemainT
$LN5@GetRemainT:

; 1601 : 			{
; 1602 : 				iREMAIN_MINUTE = ((1440-CurrentTime+CheckTime)*60)*1000;

  03ffe	b8 a0 05 00 00	 mov	 eax, 1440		; 000005a0H
  04003	2b 45 d8	 sub	 eax, DWORD PTR _CurrentTime$237191[ebp]
  04006	03 45 dc	 add	 eax, DWORD PTR _CheckTime$237190[ebp]
  04009	6b c0 3c	 imul	 eax, 60			; 0000003cH
  0400c	69 c0 e8 03 00
	00		 imul	 eax, 1000		; 000003e8H
  04012	89 45 f8	 mov	 DWORD PTR _iREMAIN_MINUTE$[ebp], eax
$LN4@GetRemainT:

; 1603 : 			}
; 1604 : 
; 1605 : 			if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= ( this->m_iBC_TIME_MIN_OPEN * 60 * 1000 )) //should be if ( iREMAIN_MINUTE <= ( this->m_iBC_TIME_MIN_OPEN * 60 * 1000 ))

  04015	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  04018	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0401e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04021	8b 91 08 23 00
	00		 mov	 edx, DWORD PTR [ecx+8968]
  04027	6b d2 3c	 imul	 edx, 60			; 0000003cH
  0402a	69 d2 e8 03 00
	00		 imul	 edx, 1000		; 000003e8H
  04030	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04033	39 94 01 ac 03
	00 00		 cmp	 DWORD PTR [ecx+eax+940], edx
  0403a	7f 48		 jg	 SHORT $LN3@GetRemainT

; 1606 : 			{
; 1607 : 				it++;

  0403c	6a 00		 push	 0
  0403e	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR $T239252[ebp]
  04044	50		 push	 eax
  04045	8d 4d f4	 lea	 ecx, DWORD PTR _it$237186[ebp]
  04048	e8 00 00 00 00	 call	 ??E?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator++

; 1608 : 
; 1609 : 				if(it != this->m_listBloodCastleOpenTime.end())

  0404d	8d 45 80	 lea	 eax, DWORD PTR $T239253[ebp]
  04050	50		 push	 eax
  04051	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04054	81 c1 20 23 00
	00		 add	 ecx, 8992		; 00002320H
  0405a	e8 00 00 00 00	 call	 ?end@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@2@XZ ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::end
  0405f	50		 push	 eax
  04060	8d 4d f4	 lea	 ecx, DWORD PTR _it$237186[ebp]
  04063	e8 00 00 00 00	 call	 ??9?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator!=
  04068	0f b6 c8	 movzx	 ecx, al
  0406b	85 c9		 test	 ecx, ecx
  0406d	74 13		 je	 SHORT $LN2@GetRemainT

; 1610 : 				{
; 1611 : 					WebzenVar2 = (*it);

  0406f	8d 4d f4	 lea	 ecx, DWORD PTR _it$237186[ebp]
  04072	e8 00 00 00 00	 call	 ??D?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBEAAUBLOODCASTLE_START_TIME@@XZ ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator*
  04077	8b 08		 mov	 ecx, DWORD PTR [eax]
  04079	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0407c	89 4d e4	 mov	 DWORD PTR _WebzenVar2$237188[ebp], ecx
  0407f	89 55 e8	 mov	 DWORD PTR _WebzenVar2$237188[ebp+4], edx
$LN2@GetRemainT:

; 1612 : 				}
; 1613 : 			}
; 1614 : 			else

  04082	eb 02		 jmp	 SHORT $LN1@GetRemainT
$LN3@GetRemainT:

; 1615 : 			{
; 1616 : 				break;

  04084	eb 05		 jmp	 SHORT $LN7@GetRemainT
$LN1@GetRemainT:

; 1617 : 			}
; 1618 : 		}

  04086	e9 da fe ff ff	 jmp	 $LN8@GetRemainT
$LN7@GetRemainT:

; 1619 : 		loc14 = GetTickCount();

  0408b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  04091	89 45 c4	 mov	 DWORD PTR _loc14$237195[ebp], eax

; 1620 : 		iREMAIN_MINUTE = this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC - today->tm_sec * 1000;

  04094	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  04097	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0409d	8b 4d d4	 mov	 ecx, DWORD PTR _today$237192[ebp]
  040a0	8b 11		 mov	 edx, DWORD PTR [ecx]
  040a2	69 d2 e8 03 00
	00		 imul	 edx, 1000		; 000003e8H
  040a8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  040ab	8b 84 01 ac 03
	00 00		 mov	 eax, DWORD PTR [ecx+eax+940]
  040b2	2b c2		 sub	 eax, edx
  040b4	89 45 f8	 mov	 DWORD PTR _iREMAIN_MINUTE$[ebp], eax
$LN16@GetRemainT:

; 1621 : 	}
; 1622 : 
; 1623 : 	return iREMAIN_MINUTE;

  040b7	8b 45 f8	 mov	 eax, DWORD PTR _iREMAIN_MINUTE$[ebp]

; 1624 : }

  040ba	5f		 pop	 edi
  040bb	5e		 pop	 esi
  040bc	5b		 pop	 ebx
  040bd	8b e5		 mov	 esp, ebp
  040bf	5d		 pop	 ebp
  040c0	c2 04 00	 ret	 4
?GetRemainTime@CBloodCastle@@QAEHH@Z ENDP		; CBloodCastle::GetRemainTime
_TEXT	ENDS
EXTRN	?gObjDel@@YAFH@Z:PROC				; gObjDel
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv67 = -76						; size = 4
_n$237225 = -8						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
_bClearCastleDoor$ = 12					; size = 1
?ClearMonster@CBloodCastle@@QAEXH_N@Z PROC		; CBloodCastle::ClearMonster
; _this$ = ecx

; 1628 : {

  040d0	55		 push	 ebp
  040d1	8b ec		 mov	 ebp, esp
  040d3	83 ec 4c	 sub	 esp, 76			; 0000004cH
  040d6	53		 push	 ebx
  040d7	56		 push	 esi
  040d8	57		 push	 edi
  040d9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1629 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  040dc	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  040e0	7d 09		 jge	 SHORT $LN10@ClearMonst
  040e2	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  040e9	eb 0c		 jmp	 SHORT $LN11@ClearMonst
$LN10@ClearMonst:
  040eb	33 c0		 xor	 eax, eax
  040ed	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  040f1	0f 9e c0	 setle	 al
  040f4	89 45 b4	 mov	 DWORD PTR tv67[ebp], eax
$LN11@ClearMonst:
  040f7	83 7d b4 00	 cmp	 DWORD PTR tv67[ebp], 0
  040fb	75 05		 jne	 SHORT $LN7@ClearMonst

; 1630 : 	{
; 1631 : 		return;

  040fd	e9 a4 00 00 00	 jmp	 $LN8@ClearMonst
$LN7@ClearMonst:

; 1632 : 	}
; 1633 : 
; 1634 : 	for ( int n=0;n<OBJ_MAXMONSTER;n++)

  04102	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$237225[ebp], 0
  04109	eb 09		 jmp	 SHORT $LN6@ClearMonst
$LN5@ClearMonst:
  0410b	8b 45 f8	 mov	 eax, DWORD PTR _n$237225[ebp]
  0410e	83 c0 01	 add	 eax, 1
  04111	89 45 f8	 mov	 DWORD PTR _n$237225[ebp], eax
$LN6@ClearMonst:
  04114	81 7d f8 c8 32
	00 00		 cmp	 DWORD PTR _n$237225[ebp], 13000 ; 000032c8H
  0411b	0f 8d 85 00 00
	00		 jge	 $LN8@ClearMonst

; 1635 : 	{
; 1636 : 		if ( gObj[n].MapNumber == this->GetBridgeMapNumber(iBridgeIndex))

  04121	8b 45 f8	 mov	 eax, DWORD PTR _n$237225[ebp]
  04124	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0412a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  04130	0f b6 b4 01 49
	01 00 00	 movzx	 esi, BYTE PTR [ecx+eax+329]
  04138	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  0413b	52		 push	 edx
  0413c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0413f	e8 00 00 00 00	 call	 ?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeMapNumber
  04144	3b f0		 cmp	 esi, eax
  04146	75 59		 jne	 SHORT $LN3@ClearMonst

; 1637 : 		{
; 1638 : 			if ( bClearCastleDoor == false && gObj[n].Class == 131)

  04148	0f b6 45 0c	 movzx	 eax, BYTE PTR _bClearCastleDoor$[ebp]
  0414c	85 c0		 test	 eax, eax
  0414e	75 21		 jne	 SHORT $LN2@ClearMonst
  04150	8b 45 f8	 mov	 eax, DWORD PTR _n$237225[ebp]
  04153	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  04159	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0415f	0f b7 94 01 b8
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+184]
  04167	81 fa 83 00 00
	00		 cmp	 edx, 131		; 00000083H
  0416d	75 02		 jne	 SHORT $LN2@ClearMonst

; 1639 : 			{
; 1640 : 				continue;

  0416f	eb 9a		 jmp	 SHORT $LN5@ClearMonst
$LN2@ClearMonst:

; 1641 : 			}
; 1642 : 
; 1643 : 			if ( gObj[n].Class == 232 )

  04171	8b 45 f8	 mov	 eax, DWORD PTR _n$237225[ebp]
  04174	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0417a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  04180	0f b7 94 01 b8
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+184]
  04188	81 fa e8 00 00
	00		 cmp	 edx, 232		; 000000e8H
  0418e	75 05		 jne	 SHORT $LN1@ClearMonst

; 1644 : 			{
; 1645 : 				continue;

  04190	e9 76 ff ff ff	 jmp	 $LN5@ClearMonst
$LN1@ClearMonst:

; 1646 : 			}
; 1647 : 
; 1648 : 			gObjDel(n);

  04195	8b 45 f8	 mov	 eax, DWORD PTR _n$237225[ebp]
  04198	50		 push	 eax
  04199	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  0419e	83 c4 04	 add	 esp, 4
$LN3@ClearMonst:

; 1649 : 		}
; 1650 : 	}

  041a1	e9 65 ff ff ff	 jmp	 $LN5@ClearMonst
$LN8@ClearMonst:

; 1651 : }

  041a6	5f		 pop	 edi
  041a7	5e		 pop	 esi
  041a8	5b		 pop	 ebx
  041a9	8b e5		 mov	 esp, ebp
  041ab	5d		 pop	 ebp
  041ac	c2 08 00	 ret	 8
?ClearMonster@CBloodCastle@@QAEXH_N@Z ENDP		; CBloodCastle::ClearMonster
_TEXT	ENDS
PUBLIC	??_C@_0CM@LMONCAJK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5monster@ ; `string'
PUBLIC	??_C@_0CF@PEIIJNGA@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Create?5Door?5@ ; `string'
PUBLIC	??_C@_0DI@KKDEDDLA@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Create?5Door?5@ ; `string'
PUBLIC	?SetMonsterKillCount@CBloodCastle@@QAEXH@Z	; CBloodCastle::SetMonsterKillCount
EXTRN	?gObjSetMonster@@YAHHH@Z:PROC			; gObjSetMonster
EXTRN	?gObjSetPosMonster@@YAHHH@Z:PROC		; gObjSetPosMonster
EXTRN	?gObjAddMonster@@YAFH@Z:PROC			; gObjAddMonster
;	COMDAT ??_C@_0CM@LMONCAJK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5monster@
CONST	SEGMENT
??_C@_0CM@LMONCAJK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5monster@ DB '['
	DB	'Blood Castle] (%d) Door monster type Error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@PEIIJNGA@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Create?5Door?5@
CONST	SEGMENT
??_C@_0CF@PEIIJNGA@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Create?5Door?5@ DB '['
	DB	'Blood Castle] (%d) Create Door Fail', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@KKDEDDLA@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Create?5Door?5@
CONST	SEGMENT
??_C@_0DI@KKDEDDLA@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Create?5Door?5@ DB '['
	DB	'Blood Castle] (%d) Create Door Successfuly : Index(%d)', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv208 = -108						; size = 4
tv251 = -104						; size = 4
tv209 = -104						; size = 4
tv67 = -104						; size = 4
_btBridgeIndex$237258 = -34				; size = 1
_btMap$237257 = -33					; size = 1
_wIndex$237256 = -32					; size = 2
_n$237251 = -28						; size = 4
_result$ = -24						; size = 4
_iIndex$237243 = -20					; size = 4
_btBloodCastleIndex$ = -14				; size = 1
_btMapNumber$ = -13					; size = 1
_wMonsterType$ = -12					; size = 2
_nCastleDoorPosNum$ = -8				; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?SetMonster@CBloodCastle@@QAEXH@Z PROC			; CBloodCastle::SetMonster
; _this$ = ecx

; 1655 : {

  041b0	55		 push	 ebp
  041b1	8b ec		 mov	 ebp, esp
  041b3	83 ec 6c	 sub	 esp, 108		; 0000006cH
  041b6	53		 push	 ebx
  041b7	56		 push	 esi
  041b8	57		 push	 edi
  041b9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1656 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  041bc	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  041c0	7d 09		 jge	 SHORT $LN20@SetMonster
  041c2	c7 45 98 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  041c9	eb 0c		 jmp	 SHORT $LN21@SetMonster
$LN20@SetMonster:
  041cb	33 c0		 xor	 eax, eax
  041cd	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  041d1	0f 9e c0	 setle	 al
  041d4	89 45 98	 mov	 DWORD PTR tv67[ebp], eax
$LN21@SetMonster:
  041d7	83 7d 98 00	 cmp	 DWORD PTR tv67[ebp], 0
  041db	75 05		 jne	 SHORT $LN17@SetMonster

; 1657 : 	{
; 1658 : 		return;

  041dd	e9 de 05 00 00	 jmp	 $LN18@SetMonster
$LN17@SetMonster:

; 1659 : 	}
; 1660 : 
; 1661 : 	this->SetMonsterKillCount(iBridgeIndex);

  041e2	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  041e5	50		 push	 eax
  041e6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  041e9	e8 00 00 00 00	 call	 ?SetMonsterKillCount@CBloodCastle@@QAEXH@Z ; CBloodCastle::SetMonsterKillCount

; 1662 : 	int nCastleDoorPosNum = this->m_BridgeData[iBridgeIndex].m_nCastleDoorPosNum;

  041ee	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  041f1	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  041f7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  041fa	8b 94 01 90 03
	00 00		 mov	 edx, DWORD PTR [ecx+eax+912]
  04201	89 55 f8	 mov	 DWORD PTR _nCastleDoorPosNum$[ebp], edx

; 1663 : 
; 1664 : 	WORD wMonsterType = gMSetBase.m_Mp[nCastleDoorPosNum].m_Type; //season3 changed

  04204	8b 45 f8	 mov	 eax, DWORD PTR _nCastleDoorPosNum$[ebp]
  04207	c1 e0 04	 shl	 eax, 4
  0420a	66 8b 88 06 00
	00 00		 mov	 cx, WORD PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+6]
  04211	66 89 4d f4	 mov	 WORD PTR _wMonsterType$[ebp], cx

; 1665 : 	BYTE btMapNumber = gMSetBase.m_Mp[nCastleDoorPosNum].m_MapNumber;

  04215	8b 45 f8	 mov	 eax, DWORD PTR _nCastleDoorPosNum$[ebp]
  04218	c1 e0 04	 shl	 eax, 4
  0421b	8a 88 08 00 00
	00		 mov	 cl, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+8]
  04221	88 4d f3	 mov	 BYTE PTR _btMapNumber$[ebp], cl

; 1666 : 	BYTE btBloodCastleIndex = this->GetBridgeIndex(btMapNumber); //season3 changed

  04224	0f b6 45 f3	 movzx	 eax, BYTE PTR _btMapNumber$[ebp]
  04228	50		 push	 eax
  04229	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0422c	e8 00 00 00 00	 call	 ?GetBridgeIndex@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeIndex
  04231	88 45 f2	 mov	 BYTE PTR _btBloodCastleIndex$[ebp], al

; 1667 : 
; 1668 : 	if ( nCastleDoorPosNum != -1 )

  04234	83 7d f8 ff	 cmp	 DWORD PTR _nCastleDoorPosNum$[ebp], -1
  04238	0f 84 cc 01 00
	00		 je	 $LN12@SetMonster

; 1669 : 	{
; 1670 : 		if ( wMonsterType == 131 )

  0423e	0f b7 45 f4	 movzx	 eax, WORD PTR _wMonsterType$[ebp]
  04242	3d 83 00 00 00	 cmp	 eax, 131		; 00000083H
  04247	0f 85 a7 01 00
	00		 jne	 $LN15@SetMonster

; 1671 : 		{
; 1672 : 			int iIndex = ::gObjAddMonster(btMapNumber);

  0424d	0f b6 45 f3	 movzx	 eax, BYTE PTR _btMapNumber$[ebp]
  04251	50		 push	 eax
  04252	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  04257	83 c4 04	 add	 esp, 4
  0425a	0f bf c8	 movsx	 ecx, ax
  0425d	89 4d ec	 mov	 DWORD PTR _iIndex$237243[ebp], ecx

; 1673 : 
; 1674 : 			if ( iIndex >= 0 )

  04260	83 7d ec 00	 cmp	 DWORD PTR _iIndex$237243[ebp], 0
  04264	0f 8c 72 01 00
	00		 jl	 $LN14@SetMonster

; 1675 : 			{
; 1676 : 				::gObjSetPosMonster(iIndex, nCastleDoorPosNum);

  0426a	8b 45 f8	 mov	 eax, DWORD PTR _nCastleDoorPosNum$[ebp]
  0426d	50		 push	 eax
  0426e	8b 4d ec	 mov	 ecx, DWORD PTR _iIndex$237243[ebp]
  04271	51		 push	 ecx
  04272	e8 00 00 00 00	 call	 ?gObjSetPosMonster@@YAHHH@Z ; gObjSetPosMonster
  04277	83 c4 08	 add	 esp, 8

; 1677 : 				::gObjSetMonster(iIndex, wMonsterType);

  0427a	0f b7 45 f4	 movzx	 eax, WORD PTR _wMonsterType$[ebp]
  0427e	50		 push	 eax
  0427f	8b 4d ec	 mov	 ecx, DWORD PTR _iIndex$237243[ebp]
  04282	51		 push	 ecx
  04283	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster
  04288	83 c4 08	 add	 esp, 8

; 1678 : 
; 1679 : 				gObj[iIndex].m_cBloodCastleIndex = btBloodCastleIndex;

  0428b	8b 45 ec	 mov	 eax, DWORD PTR _iIndex$237243[ebp]
  0428e	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  04294	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0429a	8a 55 f2	 mov	 dl, BYTE PTR _btBloodCastleIndex$[ebp]
  0429d	88 94 01 9e 0e
	00 00		 mov	 BYTE PTR [ecx+eax+3742], dl

; 1680 : 				gObj[iIndex].m_ItemRate = this->m_iBC_NORMAL_ITEM_DROP;

  042a4	8b 45 ec	 mov	 eax, DWORD PTR _iIndex$237243[ebp]
  042a7	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  042ad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  042b3	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  042b6	66 8b 92 14 23
	00 00		 mov	 dx, WORD PTR [edx+8980]
  042bd	66 89 94 01 b8
	04 00 00	 mov	 WORD PTR [ecx+eax+1208], dx

; 1681 : 				gObj[iIndex].Dir = 1;

  042c5	8b 45 ec	 mov	 eax, DWORD PTR _iIndex$237243[ebp]
  042c8	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  042ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  042d4	c6 84 01 48 01
	00 00 01	 mov	 BYTE PTR [ecx+eax+328], 1

; 1682 : 				gObj[iIndex].m_PosNum = -1;

  042dc	8b 45 ec	 mov	 eax, DWORD PTR _iIndex$237243[ebp]
  042df	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  042e5	83 c9 ff	 or	 ecx, -1
  042e8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  042ee	66 89 8c 02 b0
	03 00 00	 mov	 WORD PTR [edx+eax+944], cx

; 1683 : 				gObj[iIndex].Live = TRUE;

  042f6	8b 45 ec	 mov	 eax, DWORD PTR _iIndex$237243[ebp]
  042f9	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  042ff	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  04305	c6 44 01 6a 01	 mov	 BYTE PTR [ecx+eax+106], 1

; 1684 : 				gObj[iIndex].DieRegen = FALSE;

  0430a	8b 45 ec	 mov	 eax, DWORD PTR _iIndex$237243[ebp]
  0430d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  04313	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  04319	c6 84 01 a2 03
	00 00 00	 mov	 BYTE PTR [ecx+eax+930], 0

; 1685 : 				gObj[iIndex].m_State = 1;

  04321	8b 45 ec	 mov	 eax, DWORD PTR _iIndex$237243[ebp]
  04324	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0432a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  04330	c7 84 01 20 02
	00 00 01 00 00
	00		 mov	 DWORD PTR [ecx+eax+544], 1

; 1686 : 				gObj[iIndex].MaxRegenTime = 0;

  0433b	8b 45 ec	 mov	 eax, DWORD PTR _iIndex$237243[ebp]
  0433e	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  04344	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0434a	c7 84 01 ac 03
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+940], 0

; 1687 : 				gObj[iIndex].MaxLife = this->m_BridgeData[btBloodCastleIndex].m_iCastleStatueHealth;

  04355	0f b6 45 f2	 movzx	 eax, BYTE PTR _btBloodCastleIndex$[ebp]
  04359	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0435f	8b 4d ec	 mov	 ecx, DWORD PTR _iIndex$237243[ebp]
  04362	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  04368	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0436e	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  04371	d9 84 06 c4 03
	00 00		 fld	 DWORD PTR [esi+eax+964]
  04378	d9 9c 0a 00 01
	00 00		 fstp	 DWORD PTR [edx+ecx+256]

; 1688 : 				gObj[iIndex].Life = this->m_BridgeData[btBloodCastleIndex].m_iCastleStatueHealth;

  0437f	0f b6 45 f2	 movzx	 eax, BYTE PTR _btBloodCastleIndex$[ebp]
  04383	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  04389	8b 4d ec	 mov	 ecx, DWORD PTR _iIndex$237243[ebp]
  0438c	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  04392	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  04398	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  0439b	d9 84 06 c4 03
	00 00		 fld	 DWORD PTR [esi+eax+964]
  043a2	d9 9c 0a fc 00
	00 00		 fstp	 DWORD PTR [edx+ecx+252]

; 1689 : 
; 1690 : 				LogAddTD("[Blood Castle] (%d) Create Door Successfuly : Index(%d)", btBloodCastleIndex+1, this->m_BridgeData[btBloodCastleIndex].m_iBC_DOOR_MONSTER_INDEX = iIndex); //season 2.5 add-on

  043a9	0f b6 45 f2	 movzx	 eax, BYTE PTR _btBloodCastleIndex$[ebp]
  043ad	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  043b3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  043b6	8b 55 ec	 mov	 edx, DWORD PTR _iIndex$237243[ebp]
  043b9	89 94 01 5c 04
	00 00		 mov	 DWORD PTR [ecx+eax+1116], edx
  043c0	8b 45 ec	 mov	 eax, DWORD PTR _iIndex$237243[ebp]
  043c3	50		 push	 eax
  043c4	0f b6 4d f2	 movzx	 ecx, BYTE PTR _btBloodCastleIndex$[ebp]
  043c8	83 c1 01	 add	 ecx, 1
  043cb	51		 push	 ecx
  043cc	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@KKDEDDLA@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Create?5Door?5@
  043d1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  043d7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1691 : 			}
; 1692 : 			else

  043da	eb 16		 jmp	 SHORT $LN13@SetMonster
$LN14@SetMonster:

; 1693 : 			{
; 1694 : 				LogAddTD("[Blood Castle] (%d) Create Door Fail", btBloodCastleIndex+1); //season 2.5 add-on

  043dc	0f b6 45 f2	 movzx	 eax, BYTE PTR _btBloodCastleIndex$[ebp]
  043e0	83 c0 01	 add	 eax, 1
  043e3	50		 push	 eax
  043e4	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@PEIIJNGA@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Create?5Door?5@
  043e9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  043ef	83 c4 08	 add	 esp, 8
$LN13@SetMonster:

; 1695 : 			}
; 1696 : 		}
; 1697 : 		else

  043f2	eb 16		 jmp	 SHORT $LN12@SetMonster
$LN15@SetMonster:

; 1698 : 		{
; 1699 : 			LogAddTD("[Blood Castle] (%d) Door monster type Error", btBloodCastleIndex+1); //season 2.5 add-on

  043f4	0f b6 45 f2	 movzx	 eax, BYTE PTR _btBloodCastleIndex$[ebp]
  043f8	83 c0 01	 add	 eax, 1
  043fb	50		 push	 eax
  043fc	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@LMONCAJK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5monster@
  04401	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  04407	83 c4 08	 add	 esp, 8
$LN12@SetMonster:

; 1700 : 		}
; 1701 : 	}
; 1702 : 
; 1703 : 	int result;
; 1704 : 	for ( int n=0;n<gMSetBase.m_Count;n++)

  0440a	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _n$237251[ebp], 0
  04411	eb 09		 jmp	 SHORT $LN11@SetMonster
$LN10@SetMonster:
  04413	8b 45 e4	 mov	 eax, DWORD PTR _n$237251[ebp]
  04416	83 c0 01	 add	 eax, 1
  04419	89 45 e4	 mov	 DWORD PTR _n$237251[ebp], eax
$LN11@SetMonster:
  0441c	8b 45 e4	 mov	 eax, DWORD PTR _n$237251[ebp]
  0441f	3b 05 84 2c 03
	00		 cmp	 eax, DWORD PTR ?gMSetBase@@3VCMonsterSetBase@@A+208004
  04425	0f 8d 95 03 00
	00		 jge	 $LN9@SetMonster

; 1705 : 	{
; 1706 : 		if ( BC_MAP_RANGE(gMSetBase.m_Mp[n].m_MapNumber) != FALSE  )

  0442b	8b 45 e4	 mov	 eax, DWORD PTR _n$237251[ebp]
  0442e	c1 e0 04	 shl	 eax, 4
  04431	0f b6 88 08 00
	00 00		 movzx	 ecx, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+8]
  04438	83 f9 34	 cmp	 ecx, 52			; 00000034H
  0443b	75 09		 jne	 SHORT $LN24@SetMonster
  0443d	c7 45 98 01 00
	00 00		 mov	 DWORD PTR tv209[ebp], 1
  04444	eb 39		 jmp	 SHORT $LN25@SetMonster
$LN24@SetMonster:
  04446	8b 55 e4	 mov	 edx, DWORD PTR _n$237251[ebp]
  04449	c1 e2 04	 shl	 edx, 4
  0444c	0f b6 82 08 00
	00 00		 movzx	 eax, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[edx+8]
  04453	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  04456	7d 09		 jge	 SHORT $LN22@SetMonster
  04458	c7 45 94 00 00
	00 00		 mov	 DWORD PTR tv208[ebp], 0
  0445f	eb 18		 jmp	 SHORT $LN23@SetMonster
$LN22@SetMonster:
  04461	8b 4d e4	 mov	 ecx, DWORD PTR _n$237251[ebp]
  04464	c1 e1 04	 shl	 ecx, 4
  04467	0f b6 91 08 00
	00 00		 movzx	 edx, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[ecx+8]
  0446e	33 c0		 xor	 eax, eax
  04470	83 fa 11	 cmp	 edx, 17			; 00000011H
  04473	0f 9e c0	 setle	 al
  04476	89 45 94	 mov	 DWORD PTR tv208[ebp], eax
$LN23@SetMonster:
  04479	8b 4d 94	 mov	 ecx, DWORD PTR tv208[ebp]
  0447c	89 4d 98	 mov	 DWORD PTR tv209[ebp], ecx
$LN25@SetMonster:
  0447f	83 7d 98 00	 cmp	 DWORD PTR tv209[ebp], 0
  04483	0f 84 32 03 00
	00		 je	 $LN1@SetMonster

; 1707 : 		{
; 1708 : 			WORD wIndex = gMSetBase.m_Mp[n].m_Type;

  04489	8b 45 e4	 mov	 eax, DWORD PTR _n$237251[ebp]
  0448c	c1 e0 04	 shl	 eax, 4
  0448f	66 8b 88 06 00
	00 00		 mov	 cx, WORD PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+6]
  04496	66 89 4d e0	 mov	 WORD PTR _wIndex$237256[ebp], cx

; 1709 : 			BYTE btMap   = gMSetBase.m_Mp[n].m_MapNumber;

  0449a	8b 45 e4	 mov	 eax, DWORD PTR _n$237251[ebp]
  0449d	c1 e0 04	 shl	 eax, 4
  044a0	8a 88 08 00 00
	00		 mov	 cl, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+8]
  044a6	88 4d df	 mov	 BYTE PTR _btMap$237257[ebp], cl

; 1710 : 			BYTE btBridgeIndex = this->GetBridgeIndex(btMap); //season3 changed

  044a9	0f b6 45 df	 movzx	 eax, BYTE PTR _btMap$237257[ebp]
  044ad	50		 push	 eax
  044ae	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  044b1	e8 00 00 00 00	 call	 ?GetBridgeIndex@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeIndex
  044b6	88 45 de	 mov	 BYTE PTR _btBridgeIndex$237258[ebp], al

; 1711 : 			
; 1712 : 			if ( btBridgeIndex != iBridgeIndex )

  044b9	0f b6 45 de	 movzx	 eax, BYTE PTR _btBridgeIndex$237258[ebp]
  044bd	3b 45 08	 cmp	 eax, DWORD PTR _iBridgeIndex$[ebp]
  044c0	74 05		 je	 SHORT $LN7@SetMonster

; 1713 : 			{
; 1714 : 				continue;

  044c2	e9 4c ff ff ff	 jmp	 $LN10@SetMonster
$LN7@SetMonster:

; 1715 : 			}
; 1716 : 
; 1717 : 			if ( wIndex == 232 )

  044c7	0f b7 45 e0	 movzx	 eax, WORD PTR _wIndex$237256[ebp]
  044cb	3d e8 00 00 00	 cmp	 eax, 232		; 000000e8H
  044d0	75 05		 jne	 SHORT $LN6@SetMonster

; 1718 : 			{
; 1719 : 				continue;

  044d2	e9 3c ff ff ff	 jmp	 $LN10@SetMonster
$LN6@SetMonster:

; 1720 : 			}
; 1721 : 
; 1722 : 			if ( wIndex == 131 )

  044d7	0f b7 45 e0	 movzx	 eax, WORD PTR _wIndex$237256[ebp]
  044db	3d 83 00 00 00	 cmp	 eax, 131		; 00000083H
  044e0	75 05		 jne	 SHORT $LN5@SetMonster

; 1723 : 			{
; 1724 : 				continue;

  044e2	e9 2c ff ff ff	 jmp	 $LN10@SetMonster
$LN5@SetMonster:

; 1725 : 			}
; 1726 : 
; 1727 : 			if ( wIndex == 89 || wIndex == 95 || wIndex == 112  || wIndex == 118 || wIndex == 124 || wIndex == 130 || wIndex == 143 || wIndex == 433 ) //season3 changed

  044e7	0f b7 45 e0	 movzx	 eax, WORD PTR _wIndex$237256[ebp]
  044eb	83 f8 59	 cmp	 eax, 89			; 00000059H
  044ee	74 45		 je	 SHORT $LN3@SetMonster
  044f0	0f b7 45 e0	 movzx	 eax, WORD PTR _wIndex$237256[ebp]
  044f4	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  044f7	74 3c		 je	 SHORT $LN3@SetMonster
  044f9	0f b7 45 e0	 movzx	 eax, WORD PTR _wIndex$237256[ebp]
  044fd	83 f8 70	 cmp	 eax, 112		; 00000070H
  04500	74 33		 je	 SHORT $LN3@SetMonster
  04502	0f b7 45 e0	 movzx	 eax, WORD PTR _wIndex$237256[ebp]
  04506	83 f8 76	 cmp	 eax, 118		; 00000076H
  04509	74 2a		 je	 SHORT $LN3@SetMonster
  0450b	0f b7 45 e0	 movzx	 eax, WORD PTR _wIndex$237256[ebp]
  0450f	83 f8 7c	 cmp	 eax, 124		; 0000007cH
  04512	74 21		 je	 SHORT $LN3@SetMonster
  04514	0f b7 45 e0	 movzx	 eax, WORD PTR _wIndex$237256[ebp]
  04518	3d 82 00 00 00	 cmp	 eax, 130		; 00000082H
  0451d	74 16		 je	 SHORT $LN3@SetMonster
  0451f	0f b7 45 e0	 movzx	 eax, WORD PTR _wIndex$237256[ebp]
  04523	3d 8f 00 00 00	 cmp	 eax, 143		; 0000008fH
  04528	74 0b		 je	 SHORT $LN3@SetMonster
  0452a	0f b7 45 e0	 movzx	 eax, WORD PTR _wIndex$237256[ebp]
  0452e	3d b1 01 00 00	 cmp	 eax, 433		; 000001b1H
  04533	75 05		 jne	 SHORT $LN4@SetMonster
$LN3@SetMonster:

; 1728 : 			{
; 1729 : 				continue;

  04535	e9 d9 fe ff ff	 jmp	 $LN10@SetMonster
$LN4@SetMonster:

; 1730 : 			}
; 1731 : 
; 1732 : 			if ( BC_STATUE_RANGE(wIndex-132) != FALSE )

  0453a	0f b7 45 e0	 movzx	 eax, WORD PTR _wIndex$237256[ebp]
  0453e	2d 84 00 00 00	 sub	 eax, 132		; 00000084H
  04543	79 09		 jns	 SHORT $LN26@SetMonster
  04545	c7 45 98 00 00
	00 00		 mov	 DWORD PTR tv251[ebp], 0
  0454c	eb 15		 jmp	 SHORT $LN27@SetMonster
$LN26@SetMonster:
  0454e	0f b7 4d e0	 movzx	 ecx, WORD PTR _wIndex$237256[ebp]
  04552	81 e9 84 00 00
	00		 sub	 ecx, 132		; 00000084H
  04558	33 d2		 xor	 edx, edx
  0455a	83 f9 02	 cmp	 ecx, 2
  0455d	0f 9e c2	 setle	 dl
  04560	89 55 98	 mov	 DWORD PTR tv251[ebp], edx
$LN27@SetMonster:
  04563	83 7d 98 00	 cmp	 DWORD PTR tv251[ebp], 0
  04567	74 05		 je	 SHORT $LN2@SetMonster

; 1733 : 			{
; 1734 : 				continue;

  04569	e9 a5 fe ff ff	 jmp	 $LN10@SetMonster
$LN2@SetMonster:

; 1735 : 			}
; 1736 : 
; 1737 : 			result = gObjAddMonster(gMSetBase.m_Mp[n].m_MapNumber);

  0456e	8b 45 e4	 mov	 eax, DWORD PTR _n$237251[ebp]
  04571	c1 e0 04	 shl	 eax, 4
  04574	0f b6 88 08 00
	00 00		 movzx	 ecx, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+8]
  0457b	51		 push	 ecx
  0457c	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  04581	83 c4 04	 add	 esp, 4
  04584	0f bf d0	 movsx	 edx, ax
  04587	89 55 e8	 mov	 DWORD PTR _result$[ebp], edx

; 1738 : 
; 1739 : 			if ( result >= 0 )

  0458a	83 7d e8 00	 cmp	 DWORD PTR _result$[ebp], 0
  0458e	0f 8c 27 02 00
	00		 jl	 $LN1@SetMonster

; 1740 : 			{
; 1741 : 				gObj[result].m_PosNum = n;

  04594	8b 45 e8	 mov	 eax, DWORD PTR _result$[ebp]
  04597	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0459d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  045a3	66 8b 55 e4	 mov	 dx, WORD PTR _n$237251[ebp]
  045a7	66 89 94 01 b0
	03 00 00	 mov	 WORD PTR [ecx+eax+944], dx

; 1742 : 				gObj[result].X = gMSetBase.m_Mp[n].m_X;

  045af	8b 45 e4	 mov	 eax, DWORD PTR _n$237251[ebp]
  045b2	c1 e0 04	 shl	 eax, 4
  045b5	66 0f b6 88 0a
	00 00 00	 movzx	 cx, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+10]
  045bd	8b 55 e8	 mov	 edx, DWORD PTR _result$[ebp]
  045c0	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  045c6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  045cb	66 89 8c 10 44
	01 00 00	 mov	 WORD PTR [eax+edx+324], cx

; 1743 : 				gObj[result].Y = gMSetBase.m_Mp[n].m_Y;

  045d3	8b 45 e4	 mov	 eax, DWORD PTR _n$237251[ebp]
  045d6	c1 e0 04	 shl	 eax, 4
  045d9	66 0f b6 88 0b
	00 00 00	 movzx	 cx, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+11]
  045e1	8b 55 e8	 mov	 edx, DWORD PTR _result$[ebp]
  045e4	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  045ea	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  045ef	66 89 8c 10 46
	01 00 00	 mov	 WORD PTR [eax+edx+326], cx

; 1744 : 				gObj[result].MapNumber = gMSetBase.m_Mp[n].m_MapNumber;

  045f7	8b 45 e4	 mov	 eax, DWORD PTR _n$237251[ebp]
  045fa	c1 e0 04	 shl	 eax, 4
  045fd	8b 4d e8	 mov	 ecx, DWORD PTR _result$[ebp]
  04600	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  04606	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0460c	8a 80 08 00 00
	00		 mov	 al, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+8]
  04612	88 84 0a 49 01
	00 00		 mov	 BYTE PTR [edx+ecx+329], al

; 1745 : 				gObj[result].TX = gObj[result].X;

  04619	8b 45 e8	 mov	 eax, DWORD PTR _result$[ebp]
  0461c	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  04622	8b 4d e8	 mov	 ecx, DWORD PTR _result$[ebp]
  04625	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0462b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  04631	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  04637	66 8b 84 06 44
	01 00 00	 mov	 ax, WORD PTR [esi+eax+324]
  0463f	66 89 84 0a 7c
	01 00 00	 mov	 WORD PTR [edx+ecx+380], ax

; 1746 : 				gObj[result].TY = gObj[result].Y;

  04647	8b 45 e8	 mov	 eax, DWORD PTR _result$[ebp]
  0464a	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  04650	8b 4d e8	 mov	 ecx, DWORD PTR _result$[ebp]
  04653	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  04659	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0465f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  04665	66 8b 84 06 46
	01 00 00	 mov	 ax, WORD PTR [esi+eax+326]
  0466d	66 89 84 0a 7e
	01 00 00	 mov	 WORD PTR [edx+ecx+382], ax

; 1747 : 				gObj[result].m_OldX = gObj[result].X;

  04675	8b 45 e8	 mov	 eax, DWORD PTR _result$[ebp]
  04678	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0467e	8b 4d e8	 mov	 ecx, DWORD PTR _result$[ebp]
  04681	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  04687	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0468d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  04693	66 8b 84 06 44
	01 00 00	 mov	 ax, WORD PTR [esi+eax+324]
  0469b	66 89 84 0a 78
	01 00 00	 mov	 WORD PTR [edx+ecx+376], ax

; 1748 : 				gObj[result].m_OldY = gObj[result].Y;

  046a3	8b 45 e8	 mov	 eax, DWORD PTR _result$[ebp]
  046a6	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  046ac	8b 4d e8	 mov	 ecx, DWORD PTR _result$[ebp]
  046af	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  046b5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  046bb	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  046c1	66 8b 84 06 46
	01 00 00	 mov	 ax, WORD PTR [esi+eax+326]
  046c9	66 89 84 0a 7a
	01 00 00	 mov	 WORD PTR [edx+ecx+378], ax

; 1749 : 				gObj[result].Dir = gMSetBase.m_Mp[n].m_Dir;

  046d1	8b 45 e4	 mov	 eax, DWORD PTR _n$237251[ebp]
  046d4	c1 e0 04	 shl	 eax, 4
  046d7	8b 4d e8	 mov	 ecx, DWORD PTR _result$[ebp]
  046da	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  046e0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  046e6	8a 80 0c 00 00
	00		 mov	 al, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+12]
  046ec	88 84 0a 48 01
	00 00		 mov	 BYTE PTR [edx+ecx+328], al

; 1750 : 				gObj[result].StartX = gObj[result].X;

  046f3	8b 45 e8	 mov	 eax, DWORD PTR _result$[ebp]
  046f6	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  046fc	8b 4d e8	 mov	 ecx, DWORD PTR _result$[ebp]
  046ff	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  04705	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0470b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  04711	8a 84 06 44 01
	00 00		 mov	 al, BYTE PTR [esi+eax+324]
  04718	88 84 0a 76 01
	00 00		 mov	 BYTE PTR [edx+ecx+374], al

; 1751 : 				gObj[result].StartY = gObj[result].Y;

  0471f	8b 45 e8	 mov	 eax, DWORD PTR _result$[ebp]
  04722	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  04728	8b 4d e8	 mov	 ecx, DWORD PTR _result$[ebp]
  0472b	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  04731	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  04737	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0473d	8a 84 06 46 01
	00 00		 mov	 al, BYTE PTR [esi+eax+326]
  04744	88 84 0a 77 01
	00 00		 mov	 BYTE PTR [edx+ecx+375], al

; 1752 : 				gObjSetMonster(result, wIndex);

  0474b	0f b7 45 e0	 movzx	 eax, WORD PTR _wIndex$237256[ebp]
  0474f	50		 push	 eax
  04750	8b 4d e8	 mov	 ecx, DWORD PTR _result$[ebp]
  04753	51		 push	 ecx
  04754	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster
  04759	83 c4 08	 add	 esp, 8

; 1753 : 				gObj[result].MaxRegenTime = this->m_iBC_MONSTER_REGEN;

  0475c	8b 45 e8	 mov	 eax, DWORD PTR _result$[ebp]
  0475f	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  04765	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0476b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0476e	8b 92 1c 23 00
	00		 mov	 edx, DWORD PTR [edx+8988]
  04774	89 94 01 ac 03
	00 00		 mov	 DWORD PTR [ecx+eax+940], edx

; 1754 : 				gObj[result].m_cBloodCastleIndex = btBridgeIndex;

  0477b	8b 45 e8	 mov	 eax, DWORD PTR _result$[ebp]
  0477e	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  04784	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0478a	8a 55 de	 mov	 dl, BYTE PTR _btBridgeIndex$237258[ebp]
  0478d	88 94 01 9e 0e
	00 00		 mov	 BYTE PTR [ecx+eax+3742], dl

; 1755 : 				gObj[result].Dir = rand() % 8;

  04794	e8 00 00 00 00	 call	 _rand
  04799	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  0479e	79 05		 jns	 SHORT $LN28@SetMonster
  047a0	48		 dec	 eax
  047a1	83 c8 f8	 or	 eax, -8			; fffffff8H
  047a4	40		 inc	 eax
$LN28@SetMonster:
  047a5	8b 4d e8	 mov	 ecx, DWORD PTR _result$[ebp]
  047a8	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  047ae	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  047b4	88 84 0a 48 01
	00 00		 mov	 BYTE PTR [edx+ecx+328], al
$LN1@SetMonster:

; 1756 : 			}
; 1757 : 		}
; 1758 : 	}

  047bb	e9 53 fc ff ff	 jmp	 $LN10@SetMonster
$LN9@SetMonster:
$LN18@SetMonster:

; 1759 : 	
; 1760 : }

  047c0	5f		 pop	 edi
  047c1	5e		 pop	 esi
  047c2	5b		 pop	 ebx
  047c3	8b e5		 mov	 esp, ebp
  047c5	5d		 pop	 ebp
  047c6	c2 04 00	 ret	 4
?SetMonster@CBloodCastle@@QAEXH@Z ENDP			; CBloodCastle::SetMonster
_TEXT	ENDS
PUBLIC	?SetBossMonster@CBloodCastle@@QAEXH@Z		; CBloodCastle::SetBossMonster
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv67 = -92						; size = 4
_btBloodCastleIndex$237280 = -22			; size = 1
_btMapNumber$237279 = -21				; size = 1
_wMonsterType$237278 = -20				; size = 2
_nBossMonsterPosNum$237277 = -16			; size = 4
_x$237272 = -12						; size = 4
_result$ = -8						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?SetBossMonster@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::SetBossMonster
; _this$ = ecx

; 1764 : {

  047d0	55		 push	 ebp
  047d1	8b ec		 mov	 ebp, esp
  047d3	83 ec 5c	 sub	 esp, 92			; 0000005cH
  047d6	53		 push	 ebx
  047d7	56		 push	 esi
  047d8	57		 push	 edi
  047d9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1765 : 	int result;
; 1766 : 
; 1767 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  047dc	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  047e0	7d 09		 jge	 SHORT $LN12@SetBossMon
  047e2	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  047e9	eb 0c		 jmp	 SHORT $LN13@SetBossMon
$LN12@SetBossMon:
  047eb	33 c0		 xor	 eax, eax
  047ed	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  047f1	0f 9e c0	 setle	 al
  047f4	89 45 a4	 mov	 DWORD PTR tv67[ebp], eax
$LN13@SetBossMon:
  047f7	83 7d a4 00	 cmp	 DWORD PTR tv67[ebp], 0
  047fb	75 05		 jne	 SHORT $LN9@SetBossMon

; 1768 : 	{
; 1769 : 		return;

  047fd	e9 ad 01 00 00	 jmp	 $LN10@SetBossMon
$LN9@SetBossMon:

; 1770 : 	}
; 1771 : 
; 1772 : 	for ( int x=0;x<MAX_BLOOD_CASTLE_BOSS_MONSTER;x++)

  04802	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _x$237272[ebp], 0
  04809	eb 09		 jmp	 SHORT $LN8@SetBossMon
$LN7@SetBossMon:
  0480b	8b 45 f4	 mov	 eax, DWORD PTR _x$237272[ebp]
  0480e	83 c0 01	 add	 eax, 1
  04811	89 45 f4	 mov	 DWORD PTR _x$237272[ebp], eax
$LN8@SetBossMon:
  04814	83 7d f4 14	 cmp	 DWORD PTR _x$237272[ebp], 20 ; 00000014H
  04818	0f 8d 91 01 00
	00		 jge	 $LN10@SetBossMon

; 1773 : 	{
; 1774 : 		if ( this->m_BridgeData[iBridgeIndex].m_nBossMonsterPosNum[x] != -1 )

  0481e	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  04821	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  04827	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0482a	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0482e	8b 45 f4	 mov	 eax, DWORD PTR _x$237272[ebp]
  04831	83 bc 82 38 03
	00 00 ff	 cmp	 DWORD PTR [edx+eax*4+824], -1
  04839	0f 84 6b 01 00
	00		 je	 $LN5@SetBossMon

; 1775 : 		{
; 1776 : 			int nBossMonsterPosNum = this->m_BridgeData[iBridgeIndex].m_nBossMonsterPosNum[x];

  0483f	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  04842	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  04848	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0484b	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0484f	8b 45 f4	 mov	 eax, DWORD PTR _x$237272[ebp]
  04852	8b 8c 82 38 03
	00 00		 mov	 ecx, DWORD PTR [edx+eax*4+824]
  04859	89 4d f0	 mov	 DWORD PTR _nBossMonsterPosNum$237277[ebp], ecx

; 1777 : 
; 1778 : 			WORD wMonsterType = gMSetBase.m_Mp[nBossMonsterPosNum].m_Type; //season3 changed

  0485c	8b 45 f0	 mov	 eax, DWORD PTR _nBossMonsterPosNum$237277[ebp]
  0485f	c1 e0 04	 shl	 eax, 4
  04862	66 8b 88 06 00
	00 00		 mov	 cx, WORD PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+6]
  04869	66 89 4d ec	 mov	 WORD PTR _wMonsterType$237278[ebp], cx

; 1779 : 			BYTE btMapNumber = gMSetBase.m_Mp[nBossMonsterPosNum].m_MapNumber;

  0486d	8b 45 f0	 mov	 eax, DWORD PTR _nBossMonsterPosNum$237277[ebp]
  04870	c1 e0 04	 shl	 eax, 4
  04873	8a 88 08 00 00
	00		 mov	 cl, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+8]
  04879	88 4d eb	 mov	 BYTE PTR _btMapNumber$237279[ebp], cl

; 1780 : 			BYTE btBloodCastleIndex = this->GetBridgeIndex(btMapNumber); //season3 changed

  0487c	0f b6 45 eb	 movzx	 eax, BYTE PTR _btMapNumber$237279[ebp]
  04880	50		 push	 eax
  04881	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04884	e8 00 00 00 00	 call	 ?GetBridgeIndex@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeIndex
  04889	88 45 ea	 mov	 BYTE PTR _btBloodCastleIndex$237280[ebp], al

; 1781 : 
; 1782 : 			if ( btBloodCastleIndex != iBridgeIndex )

  0488c	0f b6 45 ea	 movzx	 eax, BYTE PTR _btBloodCastleIndex$237280[ebp]
  04890	3b 45 08	 cmp	 eax, DWORD PTR _iBridgeIndex$[ebp]
  04893	74 05		 je	 SHORT $LN4@SetBossMon

; 1783 : 			{
; 1784 : 				continue;

  04895	e9 71 ff ff ff	 jmp	 $LN7@SetBossMon
$LN4@SetBossMon:

; 1785 : 			}
; 1786 : 
; 1787 : 			if ( wMonsterType == 89 || wMonsterType == 95 || wMonsterType == 112 || wMonsterType == 118 || wMonsterType == 124 || wMonsterType == 130 || wMonsterType == 143 || wMonsterType == 433)

  0489a	0f b7 45 ec	 movzx	 eax, WORD PTR _wMonsterType$237278[ebp]
  0489e	83 f8 59	 cmp	 eax, 89			; 00000059H
  048a1	74 49		 je	 SHORT $LN2@SetBossMon
  048a3	0f b7 45 ec	 movzx	 eax, WORD PTR _wMonsterType$237278[ebp]
  048a7	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  048aa	74 40		 je	 SHORT $LN2@SetBossMon
  048ac	0f b7 45 ec	 movzx	 eax, WORD PTR _wMonsterType$237278[ebp]
  048b0	83 f8 70	 cmp	 eax, 112		; 00000070H
  048b3	74 37		 je	 SHORT $LN2@SetBossMon
  048b5	0f b7 45 ec	 movzx	 eax, WORD PTR _wMonsterType$237278[ebp]
  048b9	83 f8 76	 cmp	 eax, 118		; 00000076H
  048bc	74 2e		 je	 SHORT $LN2@SetBossMon
  048be	0f b7 45 ec	 movzx	 eax, WORD PTR _wMonsterType$237278[ebp]
  048c2	83 f8 7c	 cmp	 eax, 124		; 0000007cH
  048c5	74 25		 je	 SHORT $LN2@SetBossMon
  048c7	0f b7 45 ec	 movzx	 eax, WORD PTR _wMonsterType$237278[ebp]
  048cb	3d 82 00 00 00	 cmp	 eax, 130		; 00000082H
  048d0	74 1a		 je	 SHORT $LN2@SetBossMon
  048d2	0f b7 45 ec	 movzx	 eax, WORD PTR _wMonsterType$237278[ebp]
  048d6	3d 8f 00 00 00	 cmp	 eax, 143		; 0000008fH
  048db	74 0f		 je	 SHORT $LN2@SetBossMon
  048dd	0f b7 45 ec	 movzx	 eax, WORD PTR _wMonsterType$237278[ebp]
  048e1	3d b1 01 00 00	 cmp	 eax, 433		; 000001b1H
  048e6	0f 85 be 00 00
	00		 jne	 $LN5@SetBossMon
$LN2@SetBossMon:

; 1788 : 			{
; 1789 : 				result = ::gObjAddMonster(btMapNumber);

  048ec	0f b6 45 eb	 movzx	 eax, BYTE PTR _btMapNumber$237279[ebp]
  048f0	50		 push	 eax
  048f1	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  048f6	83 c4 04	 add	 esp, 4
  048f9	0f bf c8	 movsx	 ecx, ax
  048fc	89 4d f8	 mov	 DWORD PTR _result$[ebp], ecx

; 1790 : 
; 1791 : 				if ( result >= 0 )

  048ff	83 7d f8 00	 cmp	 DWORD PTR _result$[ebp], 0
  04903	0f 8c a1 00 00
	00		 jl	 $LN5@SetBossMon

; 1792 : 				{
; 1793 : 					::gObjSetPosMonster(result, nBossMonsterPosNum);

  04909	8b 45 f0	 mov	 eax, DWORD PTR _nBossMonsterPosNum$237277[ebp]
  0490c	50		 push	 eax
  0490d	8b 4d f8	 mov	 ecx, DWORD PTR _result$[ebp]
  04910	51		 push	 ecx
  04911	e8 00 00 00 00	 call	 ?gObjSetPosMonster@@YAHHH@Z ; gObjSetPosMonster
  04916	83 c4 08	 add	 esp, 8

; 1794 : 					::gObjSetMonster(result, wMonsterType);

  04919	0f b7 45 ec	 movzx	 eax, WORD PTR _wMonsterType$237278[ebp]
  0491d	50		 push	 eax
  0491e	8b 4d f8	 mov	 ecx, DWORD PTR _result$[ebp]
  04921	51		 push	 ecx
  04922	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster
  04927	83 c4 08	 add	 esp, 8

; 1795 : 					gObj[result].MaxRegenTime = this->m_iBC_MONSTER_REGEN;

  0492a	8b 45 f8	 mov	 eax, DWORD PTR _result$[ebp]
  0492d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  04933	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  04939	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0493c	8b 92 1c 23 00
	00		 mov	 edx, DWORD PTR [edx+8988]
  04942	89 94 01 ac 03
	00 00		 mov	 DWORD PTR [ecx+eax+940], edx

; 1796 : 					gObj[result].m_cBloodCastleIndex = btBloodCastleIndex;

  04949	8b 45 f8	 mov	 eax, DWORD PTR _result$[ebp]
  0494c	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  04952	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  04958	8a 55 ea	 mov	 dl, BYTE PTR _btBloodCastleIndex$237280[ebp]
  0495b	88 94 01 9e 0e
	00 00		 mov	 BYTE PTR [ecx+eax+3742], dl

; 1797 : 					gObj[result].m_ItemRate = this->m_iBC_NORMAL_ITEM_DROP;

  04962	8b 45 f8	 mov	 eax, DWORD PTR _result$[ebp]
  04965	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0496b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  04971	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  04974	66 8b 92 14 23
	00 00		 mov	 dx, WORD PTR [edx+8980]
  0497b	66 89 94 01 b8
	04 00 00	 mov	 WORD PTR [ecx+eax+1208], dx

; 1798 : 					gObj[result].Dir = rand() % 8;

  04983	e8 00 00 00 00	 call	 _rand
  04988	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  0498d	79 05		 jns	 SHORT $LN14@SetBossMon
  0498f	48		 dec	 eax
  04990	83 c8 f8	 or	 eax, -8			; fffffff8H
  04993	40		 inc	 eax
$LN14@SetBossMon:
  04994	8b 4d f8	 mov	 ecx, DWORD PTR _result$[ebp]
  04997	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0499d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  049a3	88 84 0a 48 01
	00 00		 mov	 BYTE PTR [edx+ecx+328], al
$LN5@SetBossMon:

; 1799 : 				}
; 1800 : 			}
; 1801 : 		}
; 1802 : 	}

  049aa	e9 5c fe ff ff	 jmp	 $LN7@SetBossMon
$LN10@SetBossMon:

; 1803 : }

  049af	5f		 pop	 edi
  049b0	5e		 pop	 esi
  049b1	5b		 pop	 ebx
  049b2	8b e5		 mov	 esp, ebp
  049b4	5d		 pop	 ebp
  049b5	c2 04 00	 ret	 4
?SetBossMonster@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::SetBossMonster
_TEXT	ENDS
PUBLIC	??_C@_0FO@DLJLMMJB@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@ ; `string'
PUBLIC	??_C@_0CN@LLNIHOPD@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Saint?5Status@ ; `string'
PUBLIC	?SetSaintStatue@CBloodCastle@@QAEXH@Z		; CBloodCastle::SetSaintStatue
;	COMDAT ??_C@_0FO@DLJLMMJB@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@
CONST	SEGMENT
??_C@_0FO@DLJLMMJB@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@ DB '['
	DB	'Blood Castle][Bug Tracer] (%d) It''s not Saint Statue( Map:%d'
	DB	', BloodCastleIndex:%d, Type:%d )', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@LLNIHOPD@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Saint?5Status@
CONST	SEGMENT
??_C@_0CN@LLNIHOPD@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Saint?5Status@ DB '['
	DB	'Blood Castle] (%d) Saint Status be created.', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv92 = -88						; size = 4
tv67 = -88						; size = 4
_result$237296 = -20					; size = 4
_btBloodCastleIndex$ = -14				; size = 1
_btMapNumber$ = -13					; size = 1
_wMonsterType$ = -12					; size = 2
_nSaintStatuePosNum$ = -8				; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?SetSaintStatue@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::SetSaintStatue
; _this$ = ecx

; 1807 : {

  049c0	55		 push	 ebp
  049c1	8b ec		 mov	 ebp, esp
  049c3	83 ec 58	 sub	 esp, 88			; 00000058H
  049c6	53		 push	 ebx
  049c7	56		 push	 esi
  049c8	57		 push	 edi
  049c9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1808 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  049cc	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  049d0	7d 09		 jge	 SHORT $LN8@SetSaintSt
  049d2	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  049d9	eb 0c		 jmp	 SHORT $LN9@SetSaintSt
$LN8@SetSaintSt:
  049db	33 c0		 xor	 eax, eax
  049dd	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  049e1	0f 9e c0	 setle	 al
  049e4	89 45 a8	 mov	 DWORD PTR tv67[ebp], eax
$LN9@SetSaintSt:
  049e7	83 7d a8 00	 cmp	 DWORD PTR tv67[ebp], 0
  049eb	75 05		 jne	 SHORT $LN5@SetSaintSt

; 1809 : 	{
; 1810 : 		return;

  049ed	e9 4d 02 00 00	 jmp	 $LN6@SetSaintSt
$LN5@SetSaintSt:

; 1811 : 	}
; 1812 : 
; 1813 : 	int nSaintStatuePosNum = this->m_BridgeData[iBridgeIndex].m_nSaintStatuePosNum;

  049f2	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  049f5	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  049fb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  049fe	8b 94 01 8c 03
	00 00		 mov	 edx, DWORD PTR [ecx+eax+908]
  04a05	89 55 f8	 mov	 DWORD PTR _nSaintStatuePosNum$[ebp], edx

; 1814 : 
; 1815 : 	WORD wMonsterType = gMSetBase.m_Mp[nSaintStatuePosNum].m_Type; //season3 changed

  04a08	8b 45 f8	 mov	 eax, DWORD PTR _nSaintStatuePosNum$[ebp]
  04a0b	c1 e0 04	 shl	 eax, 4
  04a0e	66 8b 88 06 00
	00 00		 mov	 cx, WORD PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+6]
  04a15	66 89 4d f4	 mov	 WORD PTR _wMonsterType$[ebp], cx

; 1816 : 	BYTE btMapNumber = gMSetBase.m_Mp[nSaintStatuePosNum].m_MapNumber;

  04a19	8b 45 f8	 mov	 eax, DWORD PTR _nSaintStatuePosNum$[ebp]
  04a1c	c1 e0 04	 shl	 eax, 4
  04a1f	8a 88 08 00 00
	00		 mov	 cl, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+8]
  04a25	88 4d f3	 mov	 BYTE PTR _btMapNumber$[ebp], cl

; 1817 : 	BYTE btBloodCastleIndex = this->GetBridgeIndex(btMapNumber); //season3 changed

  04a28	0f b6 45 f3	 movzx	 eax, BYTE PTR _btMapNumber$[ebp]
  04a2c	50		 push	 eax
  04a2d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04a30	e8 00 00 00 00	 call	 ?GetBridgeIndex@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeIndex
  04a35	88 45 f2	 mov	 BYTE PTR _btBloodCastleIndex$[ebp], al

; 1818 : 
; 1819 : 	if ( nSaintStatuePosNum != -1 )

  04a38	83 7d f8 ff	 cmp	 DWORD PTR _nSaintStatuePosNum$[ebp], -1
  04a3c	0f 84 fd 01 00
	00		 je	 $LN1@SetSaintSt

; 1820 : 	{
; 1821 : 		if ( BC_STATUE_RANGE(wMonsterType-132) != FALSE )

  04a42	0f b7 45 f4	 movzx	 eax, WORD PTR _wMonsterType$[ebp]
  04a46	2d 84 00 00 00	 sub	 eax, 132		; 00000084H
  04a4b	79 09		 jns	 SHORT $LN10@SetSaintSt
  04a4d	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv92[ebp], 0
  04a54	eb 15		 jmp	 SHORT $LN11@SetSaintSt
$LN10@SetSaintSt:
  04a56	0f b7 4d f4	 movzx	 ecx, WORD PTR _wMonsterType$[ebp]
  04a5a	81 e9 84 00 00
	00		 sub	 ecx, 132		; 00000084H
  04a60	33 d2		 xor	 edx, edx
  04a62	83 f9 02	 cmp	 ecx, 2
  04a65	0f 9e c2	 setle	 dl
  04a68	89 55 a8	 mov	 DWORD PTR tv92[ebp], edx
$LN11@SetSaintSt:
  04a6b	83 7d a8 00	 cmp	 DWORD PTR tv92[ebp], 0
  04a6f	0f 84 9d 01 00
	00		 je	 $LN3@SetSaintSt

; 1822 : 		{
; 1823 : 			int result = gObjAddMonster(btMapNumber);

  04a75	0f b6 45 f3	 movzx	 eax, BYTE PTR _btMapNumber$[ebp]
  04a79	50		 push	 eax
  04a7a	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  04a7f	83 c4 04	 add	 esp, 4
  04a82	0f bf c8	 movsx	 ecx, ax
  04a85	89 4d ec	 mov	 DWORD PTR _result$237296[ebp], ecx

; 1824 : 
; 1825 : 			if ( result >= 0 )

  04a88	83 7d ec 00	 cmp	 DWORD PTR _result$237296[ebp], 0
  04a8c	0f 8c 7e 01 00
	00		 jl	 $LN2@SetSaintSt

; 1826 : 			{
; 1827 : 				::gObjSetPosMonster(result, nSaintStatuePosNum);

  04a92	8b 45 f8	 mov	 eax, DWORD PTR _nSaintStatuePosNum$[ebp]
  04a95	50		 push	 eax
  04a96	8b 4d ec	 mov	 ecx, DWORD PTR _result$237296[ebp]
  04a99	51		 push	 ecx
  04a9a	e8 00 00 00 00	 call	 ?gObjSetPosMonster@@YAHHH@Z ; gObjSetPosMonster
  04a9f	83 c4 08	 add	 esp, 8

; 1828 : 				::gObjSetMonster(result, wMonsterType);

  04aa2	0f b7 45 f4	 movzx	 eax, WORD PTR _wMonsterType$[ebp]
  04aa6	50		 push	 eax
  04aa7	8b 4d ec	 mov	 ecx, DWORD PTR _result$237296[ebp]
  04aaa	51		 push	 ecx
  04aab	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster
  04ab0	83 c4 08	 add	 esp, 8

; 1829 : 				gObj[result].Class = rand() % 3 + 132;

  04ab3	e8 00 00 00 00	 call	 _rand
  04ab8	99		 cdq
  04ab9	b9 03 00 00 00	 mov	 ecx, 3
  04abe	f7 f9		 idiv	 ecx
  04ac0	81 c2 84 00 00
	00		 add	 edx, 132		; 00000084H
  04ac6	8b 45 ec	 mov	 eax, DWORD PTR _result$237296[ebp]
  04ac9	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  04acf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  04ad5	66 89 94 01 b8
	00 00 00	 mov	 WORD PTR [ecx+eax+184], dx

; 1830 : 				gObj[result].m_cBloodCastleIndex = btBloodCastleIndex;

  04add	8b 45 ec	 mov	 eax, DWORD PTR _result$237296[ebp]
  04ae0	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  04ae6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  04aec	8a 55 f2	 mov	 dl, BYTE PTR _btBloodCastleIndex$[ebp]
  04aef	88 94 01 9e 0e
	00 00		 mov	 BYTE PTR [ecx+eax+3742], dl

; 1831 : 				gObj[result].m_ItemRate = this->m_iBC_NORMAL_ITEM_DROP;

  04af6	8b 45 ec	 mov	 eax, DWORD PTR _result$237296[ebp]
  04af9	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  04aff	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  04b05	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  04b08	66 8b 92 14 23
	00 00		 mov	 dx, WORD PTR [edx+8980]
  04b0f	66 89 94 01 b8
	04 00 00	 mov	 WORD PTR [ecx+eax+1208], dx

; 1832 : 				gObj[result].Dir = 1;

  04b17	8b 45 ec	 mov	 eax, DWORD PTR _result$237296[ebp]
  04b1a	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  04b20	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  04b26	c6 84 01 48 01
	00 00 01	 mov	 BYTE PTR [ecx+eax+328], 1

; 1833 : 				gObj[result].m_PosNum = -1;

  04b2e	8b 45 ec	 mov	 eax, DWORD PTR _result$237296[ebp]
  04b31	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  04b37	83 c9 ff	 or	 ecx, -1
  04b3a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  04b40	66 89 8c 02 b0
	03 00 00	 mov	 WORD PTR [edx+eax+944], cx

; 1834 : 				gObj[result].Live = TRUE;

  04b48	8b 45 ec	 mov	 eax, DWORD PTR _result$237296[ebp]
  04b4b	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  04b51	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  04b57	c6 44 01 6a 01	 mov	 BYTE PTR [ecx+eax+106], 1

; 1835 : 				gObj[result].DieRegen = 0;

  04b5c	8b 45 ec	 mov	 eax, DWORD PTR _result$237296[ebp]
  04b5f	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  04b65	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  04b6b	c6 84 01 a2 03
	00 00 00	 mov	 BYTE PTR [ecx+eax+930], 0

; 1836 : 				gObj[result].m_State = 1;

  04b73	8b 45 ec	 mov	 eax, DWORD PTR _result$237296[ebp]
  04b76	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  04b7c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  04b82	c7 84 01 20 02
	00 00 01 00 00
	00		 mov	 DWORD PTR [ecx+eax+544], 1

; 1837 : 				gObj[result].MaxRegenTime = 0;

  04b8d	8b 45 ec	 mov	 eax, DWORD PTR _result$237296[ebp]
  04b90	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  04b96	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  04b9c	c7 84 01 ac 03
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+940], 0

; 1838 : 				gObj[result].MaxLife = this->m_BridgeData[btBloodCastleIndex].m_iCastleStatueHealth;

  04ba7	0f b6 45 f2	 movzx	 eax, BYTE PTR _btBloodCastleIndex$[ebp]
  04bab	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  04bb1	8b 4d ec	 mov	 ecx, DWORD PTR _result$237296[ebp]
  04bb4	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  04bba	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  04bc0	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  04bc3	d9 84 06 c4 03
	00 00		 fld	 DWORD PTR [esi+eax+964]
  04bca	d9 9c 0a 00 01
	00 00		 fstp	 DWORD PTR [edx+ecx+256]

; 1839 : 				gObj[result].Life = this->m_BridgeData[btBloodCastleIndex].m_iCastleStatueHealth;

  04bd1	0f b6 45 f2	 movzx	 eax, BYTE PTR _btBloodCastleIndex$[ebp]
  04bd5	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  04bdb	8b 4d ec	 mov	 ecx, DWORD PTR _result$237296[ebp]
  04bde	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  04be4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  04bea	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  04bed	d9 84 06 c4 03
	00 00		 fld	 DWORD PTR [esi+eax+964]
  04bf4	d9 9c 0a fc 00
	00 00		 fstp	 DWORD PTR [edx+ecx+252]

; 1840 : 
; 1841 : 				LogAddTD("[Blood Castle] (%d) Saint Status be created.", iBridgeIndex+1); //season 2.5 add-on

  04bfb	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  04bfe	83 c0 01	 add	 eax, 1
  04c01	50		 push	 eax
  04c02	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@LLNIHOPD@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Saint?5Status@
  04c07	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  04c0d	83 c4 08	 add	 esp, 8
$LN2@SetSaintSt:

; 1842 : 			}
; 1843 : 		}
; 1844 : 		else

  04c10	eb 2d		 jmp	 SHORT $LN1@SetSaintSt
$LN3@SetSaintSt:

; 1845 : 		{
; 1846 : 			LogAddTD("[Blood Castle][Bug Tracer] (%d) It's not Saint Statue( Map:%d, BloodCastleIndex:%d, Type:%d )", iBridgeIndex+1, btMapNumber, this->GetBridgeIndex(btMapNumber), wMonsterType); //season3 changed

  04c12	0f b7 45 f4	 movzx	 eax, WORD PTR _wMonsterType$[ebp]
  04c16	50		 push	 eax
  04c17	0f b6 4d f3	 movzx	 ecx, BYTE PTR _btMapNumber$[ebp]
  04c1b	51		 push	 ecx
  04c1c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04c1f	e8 00 00 00 00	 call	 ?GetBridgeIndex@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeIndex
  04c24	50		 push	 eax
  04c25	0f b6 55 f3	 movzx	 edx, BYTE PTR _btMapNumber$[ebp]
  04c29	52		 push	 edx
  04c2a	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  04c2d	83 c0 01	 add	 eax, 1
  04c30	50		 push	 eax
  04c31	68 00 00 00 00	 push	 OFFSET ??_C@_0FO@DLJLMMJB@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@
  04c36	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  04c3c	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@SetSaintSt:
$LN6@SetSaintSt:

; 1847 : 		}
; 1848 : 	}
; 1849 : 
; 1850 : }

  04c3f	5f		 pop	 edi
  04c40	5e		 pop	 esi
  04c41	5b		 pop	 ebx
  04c42	8b e5		 mov	 esp, ebp
  04c44	5d		 pop	 ebp
  04c45	c2 04 00	 ret	 4
?SetSaintStatue@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::SetSaintStatue
_TEXT	ENDS
PUBLIC	?LeaveUserBridge@CBloodCastle@@QAEHHHH@Z	; CBloodCastle::LeaveUserBridge
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv72 = -76						; size = 4
tv67 = -76						; size = 4
_iRET_VAL$ = -8						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
_iBridgeSubIndex$ = 12					; size = 4
_iUserIndex$ = 16					; size = 4
?LeaveUserBridge@CBloodCastle@@QAEHHHH@Z PROC		; CBloodCastle::LeaveUserBridge
; _this$ = ecx

; 1853 : {

  04c50	55		 push	 ebp
  04c51	8b ec		 mov	 ebp, esp
  04c53	83 ec 4c	 sub	 esp, 76			; 0000004cH
  04c56	53		 push	 ebx
  04c57	56		 push	 esi
  04c58	57		 push	 edi
  04c59	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1854 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  04c5c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  04c60	7d 09		 jge	 SHORT $LN6@LeaveUserB
  04c62	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  04c69	eb 0c		 jmp	 SHORT $LN7@LeaveUserB
$LN6@LeaveUserB:
  04c6b	33 c0		 xor	 eax, eax
  04c6d	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  04c71	0f 9e c0	 setle	 al
  04c74	89 45 b4	 mov	 DWORD PTR tv67[ebp], eax
$LN7@LeaveUserB:
  04c77	83 7d b4 00	 cmp	 DWORD PTR tv67[ebp], 0
  04c7b	75 0a		 jne	 SHORT $LN3@LeaveUserB

; 1855 : 	{
; 1856 : 		return -1;

  04c7d	b8 ff ff ff ff	 mov	 eax, -1
  04c82	e9 00 01 00 00	 jmp	 $LN4@LeaveUserB
$LN3@LeaveUserB:

; 1857 : 	}
; 1858 : 
; 1859 : 	if ( BC_SUB_BRIDGE_RANGE(iBridgeSubIndex) == FALSE )

  04c87	83 7d 0c 00	 cmp	 DWORD PTR _iBridgeSubIndex$[ebp], 0
  04c8b	7d 09		 jge	 SHORT $LN8@LeaveUserB
  04c8d	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], 0
  04c94	eb 0c		 jmp	 SHORT $LN9@LeaveUserB
$LN8@LeaveUserB:
  04c96	33 c0		 xor	 eax, eax
  04c98	83 7d 0c 27	 cmp	 DWORD PTR _iBridgeSubIndex$[ebp], 39 ; 00000027H
  04c9c	0f 9e c0	 setle	 al
  04c9f	89 45 b4	 mov	 DWORD PTR tv72[ebp], eax
$LN9@LeaveUserB:
  04ca2	83 7d b4 00	 cmp	 DWORD PTR tv72[ebp], 0
  04ca6	75 0a		 jne	 SHORT $LN2@LeaveUserB

; 1860 : 	{
; 1861 : 		return -1;

  04ca8	b8 ff ff ff ff	 mov	 eax, -1
  04cad	e9 d5 00 00 00	 jmp	 $LN4@LeaveUserB
$LN2@LeaveUserB:

; 1862 : 	}
; 1863 : 
; 1864 : 	int iRET_VAL = -1;

  04cb2	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _iRET_VAL$[ebp], -1

; 1865 : 
; 1866 : 	::EnterCriticalSection(&this->m_BridgeData[iBridgeIndex].m_critUserData);

  04cb9	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  04cbc	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  04cc2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04cc5	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  04cc9	52		 push	 edx
  04cca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 1867 : 
; 1868 : 	if ( this->m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iIndex == iUserIndex )

  04cd0	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  04cd3	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  04cd9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04cdc	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  04ce0	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeSubIndex$[ebp]
  04ce3	6b c0 14	 imul	 eax, 20			; 00000014H
  04ce6	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  04cea	3b 4d 10	 cmp	 ecx, DWORD PTR _iUserIndex$[ebp]
  04ced	75 7e		 jne	 SHORT $LN1@LeaveUserB

; 1869 : 	{
; 1870 : 		iRET_VAL = iUserIndex;

  04cef	8b 45 10	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  04cf2	89 45 f8	 mov	 DWORD PTR _iRET_VAL$[ebp], eax

; 1871 : 		this->m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iIndex = -1;

  04cf5	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  04cf8	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  04cfe	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04d01	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  04d05	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeSubIndex$[ebp]
  04d08	6b c0 14	 imul	 eax, 20			; 00000014H
  04d0b	c7 44 02 18 ff
	ff ff ff	 mov	 DWORD PTR [edx+eax+24], -1

; 1872 : 		this->m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iEXP = 0;

  04d13	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  04d16	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  04d1c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04d1f	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  04d23	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeSubIndex$[ebp]
  04d26	6b c0 14	 imul	 eax, 20			; 00000014H
  04d29	c7 44 02 1c 00
	00 00 00	 mov	 DWORD PTR [edx+eax+28], 0

; 1873 : 		this->m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iScore = 0;

  04d31	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  04d34	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  04d3a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04d3d	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  04d41	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeSubIndex$[ebp]
  04d44	6b c0 14	 imul	 eax, 20			; 00000014H
  04d47	c7 44 02 20 00
	00 00 00	 mov	 DWORD PTR [edx+eax+32], 0

; 1874 : 		this->m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iUserState = 0;

  04d4f	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  04d52	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  04d58	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04d5b	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  04d5f	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeSubIndex$[ebp]
  04d62	6b c0 14	 imul	 eax, 20			; 00000014H
  04d65	c7 44 02 24 00
	00 00 00	 mov	 DWORD PTR [edx+eax+36], 0
$LN1@LeaveUserB:

; 1875 : 	}
; 1876 : 
; 1877 : 	::LeaveCriticalSection(&this->m_BridgeData[iBridgeIndex].m_critUserData);

  04d6d	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  04d70	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  04d76	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04d79	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  04d7d	52		 push	 edx
  04d7e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 1878 : 
; 1879 : 	return iRET_VAL;

  04d84	8b 45 f8	 mov	 eax, DWORD PTR _iRET_VAL$[ebp]
$LN4@LeaveUserB:

; 1880 : }

  04d87	5f		 pop	 edi
  04d88	5e		 pop	 esi
  04d89	5b		 pop	 ebx
  04d8a	8b e5		 mov	 esp, ebp
  04d8c	5d		 pop	 ebp
  04d8d	c2 0c 00	 ret	 12			; 0000000cH
?LeaveUserBridge@CBloodCastle@@QAEHHHH@Z ENDP		; CBloodCastle::LeaveUserBridge
_TEXT	ENDS
PUBLIC	?EnterUserBridge@CBloodCastle@@QAEHHH@Z		; CBloodCastle::EnterUserBridge
EXTRN	?ExConfig@@3VcExConfigs@@A:BYTE			; ExConfig
EXTRN	?CheckUser@CExLicense@@QAE_NH@Z:PROC		; CExLicense::CheckUser
EXTRN	?g_ExLicense@@3VCExLicense@@A:BYTE		; g_ExLicense
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv67 = -80						; size = 4
_i$237318 = -12						; size = 4
_iRET_VAL$ = -8						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
_iUserIndex$ = 12					; size = 4
?EnterUserBridge@CBloodCastle@@QAEHHH@Z PROC		; CBloodCastle::EnterUserBridge
; _this$ = ecx

; 1883 : {

  04d90	55		 push	 ebp
  04d91	8b ec		 mov	 ebp, esp
  04d93	83 ec 50	 sub	 esp, 80			; 00000050H
  04d96	53		 push	 ebx
  04d97	56		 push	 esi
  04d98	57		 push	 edi
  04d99	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1884 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  04d9c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  04da0	7d 09		 jge	 SHORT $LN15@EnterUserB
  04da2	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  04da9	eb 0c		 jmp	 SHORT $LN16@EnterUserB
$LN15@EnterUserB:
  04dab	33 c0		 xor	 eax, eax
  04dad	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  04db1	0f 9e c0	 setle	 al
  04db4	89 45 b0	 mov	 DWORD PTR tv67[ebp], eax
$LN16@EnterUserB:
  04db7	83 7d b0 00	 cmp	 DWORD PTR tv67[ebp], 0
  04dbb	75 0a		 jne	 SHORT $LN12@EnterUserB

; 1885 : 	{
; 1886 : 		return -1;

  04dbd	b8 ff ff ff ff	 mov	 eax, -1
  04dc2	e9 ad 01 00 00	 jmp	 $LN13@EnterUserB
$LN12@EnterUserB:

; 1887 : 	}
; 1888 : 
; 1889 : 	int iRET_VAL = -1;

  04dc7	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _iRET_VAL$[ebp], -1

; 1890 : 
; 1891 : 	::EnterCriticalSection(&this->m_BridgeData[iBridgeIndex].m_critUserData);

  04dce	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  04dd1	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  04dd7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04dda	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  04dde	52		 push	 edx
  04ddf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 1892 : 
; 1893 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  04de5	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$237318[ebp], 0
  04dec	eb 09		 jmp	 SHORT $LN11@EnterUserB
$LN10@EnterUserB:
  04dee	8b 45 f4	 mov	 eax, DWORD PTR _i$237318[ebp]
  04df1	83 c0 01	 add	 eax, 1
  04df4	89 45 f4	 mov	 DWORD PTR _i$237318[ebp], eax
$LN11@EnterUserB:
  04df7	83 7d f4 28	 cmp	 DWORD PTR _i$237318[ebp], 40 ; 00000028H
  04dfb	0f 8d 59 01 00
	00		 jge	 $LN9@EnterUserB

; 1894 : 	{
; 1895 : 		if(g_ExLicense.CheckUser(Gredy) || g_ExLicense.CheckUser(Gredy2) || g_ExLicense.CheckUser(GredyLocal))

  04e01	6a 20		 push	 32			; 00000020H
  04e03	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  04e08	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  04e0d	0f b6 c0	 movzx	 eax, al
  04e10	85 c0		 test	 eax, eax
  04e12	75 26		 jne	 SHORT $LN7@EnterUserB
  04e14	6a 22		 push	 34			; 00000022H
  04e16	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  04e1b	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  04e20	0f b6 c0	 movzx	 eax, al
  04e23	85 c0		 test	 eax, eax
  04e25	75 13		 jne	 SHORT $LN7@EnterUserB
  04e27	6a 21		 push	 33			; 00000021H
  04e29	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ExLicense@@3VCExLicense@@A ; g_ExLicense
  04e2e	e8 00 00 00 00	 call	 ?CheckUser@CExLicense@@QAE_NH@Z ; CExLicense::CheckUser
  04e33	0f b6 c0	 movzx	 eax, al
  04e36	85 c0		 test	 eax, eax
  04e38	74 12		 je	 SHORT $LN8@EnterUserB
$LN7@EnterUserB:

; 1896 : 		{
; 1897 : 			if( i > ExConfig.m_iBloodCastleMaxUser)

  04e3a	8b 45 f4	 mov	 eax, DWORD PTR _i$237318[ebp]
  04e3d	3b 05 3c 0d 00
	00		 cmp	 eax, DWORD PTR ?ExConfig@@3VcExConfigs@@A+3388
  04e43	7e 05		 jle	 SHORT $LN6@EnterUserB

; 1898 : 			{
; 1899 : 				break;

  04e45	e9 10 01 00 00	 jmp	 $LN9@EnterUserB
$LN6@EnterUserB:

; 1900 : 			}
; 1901 : 		}
; 1902 : 		else

  04e4a	eb 0b		 jmp	 SHORT $LN5@EnterUserB
$LN8@EnterUserB:

; 1903 : 		{
; 1904 : 			if( i > 20)

  04e4c	83 7d f4 14	 cmp	 DWORD PTR _i$237318[ebp], 20 ; 00000014H
  04e50	7e 05		 jle	 SHORT $LN5@EnterUserB

; 1905 : 			{
; 1906 : 				break;

  04e52	e9 03 01 00 00	 jmp	 $LN9@EnterUserB
$LN5@EnterUserB:

; 1907 : 			}
; 1908 : 		}
; 1909 : 
; 1910 : 
; 1911 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  04e57	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  04e5a	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  04e60	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04e63	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  04e67	8b 45 f4	 mov	 eax, DWORD PTR _i$237318[ebp]
  04e6a	6b c0 14	 imul	 eax, 20			; 00000014H
  04e6d	83 7c 02 18 ff	 cmp	 DWORD PTR [edx+eax+24], -1
  04e72	74 2a		 je	 SHORT $LN3@EnterUserB

; 1912 : 		{
; 1913 : 			if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == iUserIndex )

  04e74	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  04e77	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  04e7d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04e80	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  04e84	8b 45 f4	 mov	 eax, DWORD PTR _i$237318[ebp]
  04e87	6b c0 14	 imul	 eax, 20			; 00000014H
  04e8a	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  04e8e	3b 4d 0c	 cmp	 ecx, DWORD PTR _iUserIndex$[ebp]
  04e91	75 0b		 jne	 SHORT $LN3@EnterUserB

; 1914 : 			{
; 1915 : 				iRET_VAL = i;

  04e93	8b 45 f4	 mov	 eax, DWORD PTR _i$237318[ebp]
  04e96	89 45 f8	 mov	 DWORD PTR _iRET_VAL$[ebp], eax

; 1916 : 				break;

  04e99	e9 bc 00 00 00	 jmp	 $LN9@EnterUserB
$LN3@EnterUserB:

; 1917 : 			}
; 1918 : 		}
; 1919 : 
; 1920 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == -1 )

  04e9e	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  04ea1	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  04ea7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04eaa	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  04eae	8b 45 f4	 mov	 eax, DWORD PTR _i$237318[ebp]
  04eb1	6b c0 14	 imul	 eax, 20			; 00000014H
  04eb4	83 7c 02 18 ff	 cmp	 DWORD PTR [edx+eax+24], -1
  04eb9	0f 85 96 00 00
	00		 jne	 $LN1@EnterUserB

; 1921 : 		{
; 1922 : 			iRET_VAL = i;

  04ebf	8b 45 f4	 mov	 eax, DWORD PTR _i$237318[ebp]
  04ec2	89 45 f8	 mov	 DWORD PTR _iRET_VAL$[ebp], eax

; 1923 : 			this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex = iUserIndex;

  04ec5	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  04ec8	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  04ece	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04ed1	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  04ed5	8b 45 f4	 mov	 eax, DWORD PTR _i$237318[ebp]
  04ed8	6b c0 14	 imul	 eax, 20			; 00000014H
  04edb	8b 4d 0c	 mov	 ecx, DWORD PTR _iUserIndex$[ebp]
  04ede	89 4c 02 18	 mov	 DWORD PTR [edx+eax+24], ecx

; 1924 : 			this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iEXP = 0;

  04ee2	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  04ee5	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  04eeb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04eee	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  04ef2	8b 45 f4	 mov	 eax, DWORD PTR _i$237318[ebp]
  04ef5	6b c0 14	 imul	 eax, 20			; 00000014H
  04ef8	c7 44 02 1c 00
	00 00 00	 mov	 DWORD PTR [edx+eax+28], 0

; 1925 : 			this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iScore = 0;

  04f00	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  04f03	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  04f09	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04f0c	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  04f10	8b 45 f4	 mov	 eax, DWORD PTR _i$237318[ebp]
  04f13	6b c0 14	 imul	 eax, 20			; 00000014H
  04f16	c7 44 02 20 00
	00 00 00	 mov	 DWORD PTR [edx+eax+32], 0

; 1926 : 			this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 0;

  04f1e	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  04f21	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  04f27	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04f2a	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  04f2e	8b 45 f4	 mov	 eax, DWORD PTR _i$237318[ebp]
  04f31	6b c0 14	 imul	 eax, 20			; 00000014H
  04f34	c7 44 02 24 00
	00 00 00	 mov	 DWORD PTR [edx+eax+36], 0

; 1927 : 			gObj[iUserIndex].m_bBloodCastleComplete = false;

  04f3c	8b 45 0c	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  04f3f	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  04f45	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  04f4b	c6 84 01 a4 0e
	00 00 00	 mov	 BYTE PTR [ecx+eax+3748], 0

; 1928 : 			break;

  04f53	eb 05		 jmp	 SHORT $LN9@EnterUserB
$LN1@EnterUserB:

; 1929 : 		}
; 1930 : 	}

  04f55	e9 94 fe ff ff	 jmp	 $LN10@EnterUserB
$LN9@EnterUserB:

; 1931 : 
; 1932 : 	::LeaveCriticalSection(&this->m_BridgeData[iBridgeIndex].m_critUserData);

  04f5a	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  04f5d	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  04f63	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  04f66	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  04f6a	52		 push	 edx
  04f6b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 1933 : 
; 1934 : 	return iRET_VAL;

  04f71	8b 45 f8	 mov	 eax, DWORD PTR _iRET_VAL$[ebp]
$LN13@EnterUserB:

; 1935 : }

  04f74	5f		 pop	 edi
  04f75	5e		 pop	 esi
  04f76	5b		 pop	 ebx
  04f77	8b e5		 mov	 esp, ebp
  04f79	5d		 pop	 ebp
  04f7a	c2 08 00	 ret	 8
?EnterUserBridge@CBloodCastle@@QAEHHH@Z ENDP		; CBloodCastle::EnterUserBridge
_TEXT	ENDS
PUBLIC	??_C@_0L@MNKEEMGH@?0?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5?$AA@ ; `string'
PUBLIC	??_C@_0BM@DJAOLMAF@400?5LevelUp?5?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Party?5?$AA@ ; `string'
PUBLIC	??_C@_0DA@KDBPKGIM@?$FL?$CFs?$FN?$FL?$CFs?$FN?5LevelUp?5PlusStatQuest?5C@ ; `string'
PUBLIC	??_C@_0FC@MCCJHJPM@Experience?5?3?5Map?$FL?$CFd?$FN?9?$CI?$CFd?0?$CFd?$CJ?5?$FL?$CFs@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?LevelUp@CBloodCastle@@QAEHHHH@Z		; CBloodCastle::LevelUp
EXTRN	?LevelUp@CAchievements@@QAEXH@Z:PROC		; CAchievements::LevelUp
EXTRN	?g_Achievements@@3VCAchievements@@A:BYTE	; g_Achievements
EXTRN	_strlen:PROC
EXTRN	?gParty@@3VPartyClass@@A:BYTE			; gParty
EXTRN	_sprintf:PROC
EXTRN	?gObjCalcMaxLifePower@@YAXH@Z:PROC		; gObjCalcMaxLifePower
EXTRN	?GCLevelUpMsgSend@@YAXHH@Z:PROC			; GCLevelUpMsgSend
EXTRN	?gObjSetBP@@YAXH@Z:PROC				; gObjSetBP
EXTRN	?gObjNextExpCal@@YAXPAUOBJECTSTRUCT@@@Z:PROC	; gObjNextExpCal
EXTRN	?DCInfo@@3Vclassdef@@A:BYTE			; DCInfo
EXTRN	?GCServerMsgStringSend@@YAXPADHE@Z:PROC		; GCServerMsgStringSend
EXTRN	?gObjSetExpPetItem@@YAXHH@Z:PROC		; gObjSetExpPetItem
EXTRN	?MasterLevelUp@CMasterLevelSystem@@QAEHPAUOBJECTSTRUCT@@AA_J_NH@Z:PROC ; CMasterLevelSystem::MasterLevelUp
EXTRN	?g_MasterLevelSystem@@3VCMasterLevelSystem@@A:BYTE ; g_MasterLevelSystem
;	COMDAT ??_C@_0L@MNKEEMGH@?0?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5?$AA@
CONST	SEGMENT
??_C@_0L@MNKEEMGH@?0?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5?$AA@ DB ',(%s)(%s) ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@DJAOLMAF@400?5LevelUp?5?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Party?5?$AA@
CONST	SEGMENT
??_C@_0BM@DJAOLMAF@400?5LevelUp?5?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Party?5?$AA@ DB '4'
	DB	'00 LevelUp (%s)(%s) Party ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@KDBPKGIM@?$FL?$CFs?$FN?$FL?$CFs?$FN?5LevelUp?5PlusStatQuest?5C@
CONST	SEGMENT
??_C@_0DA@KDBPKGIM@?$FL?$CFs?$FN?$FL?$CFs?$FN?5LevelUp?5PlusStatQuest?5C@ DB '['
	DB	'%s][%s] LevelUp PlusStatQuest Clear AddStat %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@MCCJHJPM@Experience?5?3?5Map?$FL?$CFd?$FN?9?$CI?$CFd?0?$CFd?$CJ?5?$FL?$CFs@
CONST	SEGMENT
??_C@_0FC@MCCJHJPM@Experience?5?3?5Map?$FL?$CFd?$FN?9?$CI?$CFd?0?$CFd?$CJ?5?$FL?$CFs@ DB 'E'
	DB	'xperience : Map[%d]-(%d,%d) [%s][%s](%d) %u %d MonsterIndex :'
	DB	' %d, EventType : %d', 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv67 = -352						; size = 4
_iSize$237359 = -284					; size = 4
_i$237354 = -280					; size = 4
_iPartyNumIndex$237353 = -276				; size = 4
_szMsg$237351 = -272					; size = 256
_iPartyNumber$237350 = -16				; size = 4
_iLEFT_EXP$ = -12					; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iAddExp$ = 12						; size = 4
_iEventType$ = 16					; size = 4
?LevelUp@CBloodCastle@@QAEHHHH@Z PROC			; CBloodCastle::LevelUp
; _this$ = ecx

; 1938 : {

  04f80	55		 push	 ebp
  04f81	8b ec		 mov	 ebp, esp
  04f83	81 ec 60 01 00
	00		 sub	 esp, 352		; 00000160H
  04f89	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  04f8e	33 c5		 xor	 eax, ebp
  04f90	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  04f93	53		 push	 ebx
  04f94	56		 push	 esi
  04f95	57		 push	 edi
  04f96	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1939 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  04f99	83 7d 08 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  04f9d	7d 0c		 jge	 SHORT $LN17@LevelUp
  04f9f	c7 85 a0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv67[ebp], 0
  04fa9	eb 12		 jmp	 SHORT $LN18@LevelUp
$LN17@LevelUp:
  04fab	33 c0		 xor	 eax, eax
  04fad	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _iIndex$[ebp], 14999 ; 00003a97H
  04fb4	0f 9e c0	 setle	 al
  04fb7	89 85 a0 fe ff
	ff		 mov	 DWORD PTR tv67[ebp], eax
$LN18@LevelUp:
  04fbd	83 bd a0 fe ff
	ff 00		 cmp	 DWORD PTR tv67[ebp], 0
  04fc4	75 07		 jne	 SHORT $LN14@LevelUp

; 1940 : 	{
; 1941 : 		return 0;

  04fc6	33 c0		 xor	 eax, eax
  04fc8	e9 a4 06 00 00	 jmp	 $LN15@LevelUp
$LN14@LevelUp:

; 1942 : 	}
; 1943 : 
; 1944 : 	int iLEFT_EXP = 0;

  04fcd	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iLEFT_EXP$[ebp], 0

; 1945 : 
; 1946 : 	if(g_MasterLevelSystem.MasterLevelUp(&gObj[iIndex], (__int64&)iAddExp,1,0) != 0) //season3 add-on

  04fd4	6a 00		 push	 0
  04fd6	6a 01		 push	 1
  04fd8	8d 45 0c	 lea	 eax, DWORD PTR _iAddExp$[ebp]
  04fdb	50		 push	 eax
  04fdc	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  04fdf	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  04fe5	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  04feb	51		 push	 ecx
  04fec	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterLevelSystem@@3VCMasterLevelSystem@@A ; g_MasterLevelSystem
  04ff1	e8 00 00 00 00	 call	 ?MasterLevelUp@CMasterLevelSystem@@QAEHPAUOBJECTSTRUCT@@AA_J_NH@Z ; CMasterLevelSystem::MasterLevelUp
  04ff6	85 c0		 test	 eax, eax
  04ff8	74 07		 je	 SHORT $LN13@LevelUp

; 1947 : 	{
; 1948 : 		return 0;

  04ffa	33 c0		 xor	 eax, eax
  04ffc	e9 70 06 00 00	 jmp	 $LN15@LevelUp
$LN13@LevelUp:

; 1949 : 	}
; 1950 : 
; 1951 : 
; 1952 : 	::gObjSetExpPetItem(iIndex, iAddExp);

  05001	8b 45 0c	 mov	 eax, DWORD PTR _iAddExp$[ebp]
  05004	50		 push	 eax
  05005	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  05008	51		 push	 ecx
  05009	e8 00 00 00 00	 call	 ?gObjSetExpPetItem@@YAXHH@Z ; gObjSetExpPetItem
  0500e	83 c4 08	 add	 esp, 8

; 1953 : 
; 1954 : 	LogAddTD("Experience : Map[%d]-(%d,%d) [%s][%s](%d) %u %d MonsterIndex : %d, EventType : %d", gObj[iIndex].MapNumber, gObj[iIndex].X, gObj[iIndex].X, gObj[iIndex].AccountID, gObj[iIndex].Name, gObj[iIndex].Level, gObj[iIndex].Experience, iAddExp, 0, iEventType);

  05011	8b 45 10	 mov	 eax, DWORD PTR _iEventType$[ebp]
  05014	50		 push	 eax
  05015	6a 00		 push	 0
  05017	8b 4d 0c	 mov	 ecx, DWORD PTR _iAddExp$[ebp]
  0501a	51		 push	 ecx
  0501b	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0501e	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  05024	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05029	8b 8c 10 c8 00
	00 00		 mov	 ecx, DWORD PTR [eax+edx+200]
  05030	51		 push	 ecx
  05031	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  05034	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  0503a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0503f	0f bf 8c 10 be
	00 00 00	 movsx	 ecx, WORD PTR [eax+edx+190]
  05047	51		 push	 ecx
  05048	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0504b	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  05051	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05056	8d 4c 10 77	 lea	 ecx, DWORD PTR [eax+edx+119]
  0505a	51		 push	 ecx
  0505b	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0505e	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  05064	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05069	8d 4c 10 6c	 lea	 ecx, DWORD PTR [eax+edx+108]
  0506d	51		 push	 ecx
  0506e	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  05071	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  05077	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0507c	0f bf 8c 10 44
	01 00 00	 movsx	 ecx, WORD PTR [eax+edx+324]
  05084	51		 push	 ecx
  05085	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  05088	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  0508e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05093	0f bf 8c 10 44
	01 00 00	 movsx	 ecx, WORD PTR [eax+edx+324]
  0509b	51		 push	 ecx
  0509c	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0509f	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  050a5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  050aa	0f b6 8c 10 49
	01 00 00	 movzx	 ecx, BYTE PTR [eax+edx+329]
  050b2	51		 push	 ecx
  050b3	68 00 00 00 00	 push	 OFFSET ??_C@_0FC@MCCJHJPM@Experience?5?3?5Map?$FL?$CFd?$FN?9?$CI?$CFd?0?$CFd?$CJ?5?$FL?$CFs@
  050b8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  050be	83 c4 2c	 add	 esp, 44			; 0000002cH

; 1955 : 
; 1956 : 	if ( gObj[iIndex].Level >= MAX_CHAR_LEVEL )

  050c1	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  050c4	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  050ca	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  050d0	0f bf 94 01 be
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+190]
  050d8	81 fa 90 01 00
	00		 cmp	 edx, 400		; 00000190H
  050de	7c 34		 jl	 SHORT $LN12@LevelUp

; 1957 : 	{
; 1958 : 		::GCServerMsgStringSend(lMsg.Get(MSGGET(4, 112)), gObj[iIndex].m_Index, 1);

  050e0	6a 01		 push	 1
  050e2	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  050e5	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  050eb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  050f1	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  050f4	52		 push	 edx
  050f5	68 70 04 00 00	 push	 1136			; 00000470H
  050fa	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  050ff	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  05104	50		 push	 eax
  05105	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0510a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1959 : 		return 0;

  0510d	33 c0		 xor	 eax, eax
  0510f	e9 5d 05 00 00	 jmp	 $LN15@LevelUp
$LN12@LevelUp:

; 1960 : 	}
; 1961 : 
; 1962 : 	if ( (gObj[iIndex].Experience + iAddExp) < gObj[iIndex].NextExp )

  05114	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  05117	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0511d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05123	8b 94 01 c8 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+200]
  0512a	03 55 0c	 add	 edx, DWORD PTR _iAddExp$[ebp]
  0512d	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  05130	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05136	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0513c	3b 94 01 cc 00
	00 00		 cmp	 edx, DWORD PTR [ecx+eax+204]
  05143	73 34		 jae	 SHORT $LN11@LevelUp

; 1963 : 	{
; 1964 : 		gObj[iIndex].Experience += iAddExp;

  05145	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  05148	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0514e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05154	8b 94 01 c8 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+200]
  0515b	03 55 0c	 add	 edx, DWORD PTR _iAddExp$[ebp]
  0515e	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  05161	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05167	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0516d	89 94 01 c8 00
	00 00		 mov	 DWORD PTR [ecx+eax+200], edx

; 1965 : 	}
; 1966 : 	else

  05174	e9 e7 04 00 00	 jmp	 $LN5@LevelUp
$LN11@LevelUp:

; 1967 : 	{
; 1968 : 		iLEFT_EXP = gObj[iIndex].Experience + iAddExp - gObj[iIndex].NextExp;

  05179	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0517c	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05182	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05188	8b 94 01 c8 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+200]
  0518f	03 55 0c	 add	 edx, DWORD PTR _iAddExp$[ebp]
  05192	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  05195	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0519b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  051a1	2b 94 01 cc 00
	00 00		 sub	 edx, DWORD PTR [ecx+eax+204]
  051a8	89 55 f4	 mov	 DWORD PTR _iLEFT_EXP$[ebp], edx

; 1969 : 		gObj[iIndex].Experience = gObj[iIndex].NextExp;

  051ab	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  051ae	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  051b4	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  051b7	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  051bd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  051c3	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  051c9	8b 84 06 cc 00
	00 00		 mov	 eax, DWORD PTR [esi+eax+204]
  051d0	89 84 0a c8 00
	00 00		 mov	 DWORD PTR [edx+ecx+200], eax

; 1970 : 		gObj[iIndex].Level++;

  051d7	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  051da	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  051e0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  051e6	66 8b 94 01 be
	00 00 00	 mov	 dx, WORD PTR [ecx+eax+190]
  051ee	66 83 c2 01	 add	 dx, 1
  051f2	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  051f5	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  051fb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05201	66 89 94 01 be
	00 00 00	 mov	 WORD PTR [ecx+eax+190], dx

; 1971 : 
; 1972 : 		if ( gObj[iIndex].Class == CLASS_DARKLORD 
; 1973 : #ifdef MONK
; 1974 : 			|| gObj[iIndex].Class == CLASS_MONK
; 1975 : #endif
; 1976 : 			|| gObj[iIndex].Class == CLASS_MAGUMSA )

  05209	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0520c	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05212	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05218	0f b7 94 01 b8
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+184]
  05220	83 fa 04	 cmp	 edx, 4
  05223	74 38		 je	 SHORT $LN8@LevelUp
  05225	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  05228	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0522e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05234	0f b7 94 01 b8
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+184]
  0523c	83 fa 06	 cmp	 edx, 6
  0523f	74 1c		 je	 SHORT $LN8@LevelUp
  05241	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  05244	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0524a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05250	0f b7 94 01 b8
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+184]
  05258	83 fa 03	 cmp	 edx, 3
  0525b	75 31		 jne	 SHORT $LN9@LevelUp
$LN8@LevelUp:

; 1977 : 		{
; 1978 : 			gObj[iIndex].LevelUpPoint += 7;

  0525d	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  05260	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05266	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0526c	8b 94 01 c0 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+192]
  05273	83 c2 07	 add	 edx, 7
  05276	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  05279	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0527f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05285	89 94 01 c0 00
	00 00		 mov	 DWORD PTR [ecx+eax+192], edx

; 1979 : 		}
; 1980 : 		else

  0528c	eb 2f		 jmp	 SHORT $LN7@LevelUp
$LN9@LevelUp:

; 1981 : 		{
; 1982 : 			gObj[iIndex].LevelUpPoint += 5;

  0528e	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  05291	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05297	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0529d	8b 94 01 c0 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+192]
  052a4	83 c2 05	 add	 edx, 5
  052a7	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  052aa	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  052b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  052b6	89 94 01 c0 00
	00 00		 mov	 DWORD PTR [ecx+eax+192], edx
$LN7@LevelUp:

; 1983 : 		}
; 1984 : 
; 1985 : 		if ( gObj[iIndex].PlusStatQuestClear != false )

  052bd	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  052c0	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  052c6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  052cc	0f b6 94 01 a5
	00 00 00	 movzx	 edx, BYTE PTR [ecx+eax+165]
  052d4	85 d2		 test	 edx, edx
  052d6	74 7c		 je	 SHORT $LN6@LevelUp

; 1986 : 		{
; 1987 : 			gObj[iIndex].LevelUpPoint++;

  052d8	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  052db	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  052e1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  052e7	8b 94 01 c0 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+192]
  052ee	83 c2 01	 add	 edx, 1
  052f1	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  052f4	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  052fa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05300	89 94 01 c0 00
	00 00		 mov	 DWORD PTR [ecx+eax+192], edx

; 1988 : 
; 1989 : 			LogAddTD("[%s][%s] LevelUp PlusStatQuest Clear AddStat %d",
; 1990 : 				gObj[iIndex].AccountID, gObj[iIndex].Name, gObj[iIndex].LevelUpPoint);

  05307	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0530a	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05310	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05316	8b 94 01 c0 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+192]
  0531d	52		 push	 edx
  0531e	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  05321	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05327	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0532d	8d 54 01 77	 lea	 edx, DWORD PTR [ecx+eax+119]
  05331	52		 push	 edx
  05332	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  05335	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0533b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05341	8d 54 01 6c	 lea	 edx, DWORD PTR [ecx+eax+108]
  05345	52		 push	 edx
  05346	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@KDBPKGIM@?$FL?$CFs?$FN?$FL?$CFs?$FN?5LevelUp?5PlusStatQuest?5C@
  0534b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  05351	83 c4 10	 add	 esp, 16			; 00000010H
$LN6@LevelUp:

; 1991 : 		}
; 1992 : 
; 1993 : 		gObj[iIndex].MaxLife += DCInfo.DefClass[gObj[iIndex].Class].LevelLife;

  05354	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  05357	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0535d	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  05360	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  05366	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0536c	0f b7 8c 0a b8
	00 00 00	 movzx	 ecx, WORD PTR [edx+ecx+184]
  05374	69 c9 c8 0b 00
	00		 imul	 ecx, 3016		; 00000bc8H
  0537a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05380	d9 84 02 00 01
	00 00		 fld	 DWORD PTR [edx+eax+256]
  05387	d8 81 10 00 00
	00		 fadd	 DWORD PTR ?DCInfo@@3Vclassdef@@A[ecx+16]
  0538d	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  05390	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05396	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0539c	d9 9c 01 00 01
	00 00		 fstp	 DWORD PTR [ecx+eax+256]

; 1994 : 		gObj[iIndex].MaxMana += DCInfo.DefClass[gObj[iIndex].Class].LevelMana;

  053a3	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  053a6	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  053ac	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  053af	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  053b5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  053bb	0f b7 8c 0a b8
	00 00 00	 movzx	 ecx, WORD PTR [edx+ecx+184]
  053c3	69 c9 c8 0b 00
	00		 imul	 ecx, 3016		; 00000bc8H
  053c9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  053cf	d9 84 02 14 01
	00 00		 fld	 DWORD PTR [edx+eax+276]
  053d6	d8 81 1c 00 00
	00		 fadd	 DWORD PTR ?DCInfo@@3Vclassdef@@A[ecx+28]
  053dc	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  053df	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  053e5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  053eb	d9 9c 01 14 01
	00 00		 fstp	 DWORD PTR [ecx+eax+276]

; 1995 : 		gObj[iIndex].Life = gObj[iIndex].MaxLife;

  053f2	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  053f5	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  053fb	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  053fe	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  05404	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0540a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05410	d9 84 06 00 01
	00 00		 fld	 DWORD PTR [esi+eax+256]
  05417	d9 9c 0a fc 00
	00 00		 fstp	 DWORD PTR [edx+ecx+252]

; 1996 : 		gObj[iIndex].Mana = gObj[iIndex].MaxMana;

  0541e	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  05421	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05427	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0542a	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  05430	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05436	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0543c	d9 84 06 14 01
	00 00		 fld	 DWORD PTR [esi+eax+276]
  05443	d9 9c 0a 10 01
	00 00		 fstp	 DWORD PTR [edx+ecx+272]

; 1997 : 		gObjNextExpCal(&gObj[iIndex]);

  0544a	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0544d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05453	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05459	50		 push	 eax
  0545a	e8 00 00 00 00	 call	 ?gObjNextExpCal@@YAXPAUOBJECTSTRUCT@@@Z ; gObjNextExpCal
  0545f	83 c4 04	 add	 esp, 4

; 1998 : 		gObjSetBP(gObj[iIndex].m_Index);

  05462	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  05465	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0546b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05471	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  05474	52		 push	 edx
  05475	e8 00 00 00 00	 call	 ?gObjSetBP@@YAXH@Z	; gObjSetBP
  0547a	83 c4 04	 add	 esp, 4

; 1999 : 
; 2000 : 		GCLevelUpMsgSend(gObj[iIndex].m_Index, 1);

  0547d	6a 01		 push	 1
  0547f	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  05482	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05488	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0548e	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  05491	52		 push	 edx
  05492	e8 00 00 00 00	 call	 ?GCLevelUpMsgSend@@YAXHH@Z ; GCLevelUpMsgSend
  05497	83 c4 08	 add	 esp, 8

; 2001 : 
; 2002 : 		gObjCalcMaxLifePower(gObj[iIndex].m_Index);

  0549a	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0549d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  054a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  054a9	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  054ac	52		 push	 edx
  054ad	e8 00 00 00 00	 call	 ?gObjCalcMaxLifePower@@YAXH@Z ; gObjCalcMaxLifePower
  054b2	83 c4 04	 add	 esp, 4

; 2003 : 		LogAddTD(lMsg.Get(MSGGET(2, 8)), gObj[iIndex].AccountID, gObj[iIndex].Name, gObj[iIndex].Level);

  054b5	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  054b8	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  054be	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  054c4	0f bf 94 01 be
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+190]
  054cc	52		 push	 edx
  054cd	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  054d0	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  054d6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  054dc	8d 54 01 77	 lea	 edx, DWORD PTR [ecx+eax+119]
  054e0	52		 push	 edx
  054e1	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  054e4	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  054ea	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  054f0	8d 54 01 6c	 lea	 edx, DWORD PTR [ecx+eax+108]
  054f4	52		 push	 edx
  054f5	68 08 02 00 00	 push	 520			; 00000208H
  054fa	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  054ff	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  05504	50		 push	 eax
  05505	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0550b	83 c4 10	 add	 esp, 16			; 00000010H

; 2004 : 
; 2005 : 		//----------------------------------------------------------------------------------------------
; 2006 : 
; 2007 : 		if( gObj[iIndex].Level == 400 && gObj[iIndex].PartyNumber >= 0 ) //Season 2.5 add-on (Party Level 400 Display)

  0550e	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  05511	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05517	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0551d	0f bf 94 01 be
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+190]
  05525	81 fa 90 01 00
	00		 cmp	 edx, 400		; 00000190H
  0552b	0f 85 2f 01 00
	00		 jne	 $LN5@LevelUp
  05531	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  05534	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0553a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05540	83 bc 01 2c 04
	00 00 00	 cmp	 DWORD PTR [ecx+eax+1068], 0
  05548	0f 8c 12 01 00
	00		 jl	 $LN5@LevelUp

; 2008 : 		{
; 2009 : 			int iPartyNumber = gObj[iIndex].PartyNumber;

  0554e	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  05551	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05557	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0555d	8b 94 01 2c 04
	00 00		 mov	 edx, DWORD PTR [ecx+eax+1068]
  05564	89 55 f0	 mov	 DWORD PTR _iPartyNumber$237350[ebp], edx

; 2010 : 			char szMsg[256];
; 2011 : 			sprintf(szMsg,"400 LevelUp (%s)(%s) Party ",gObj[iIndex].AccountID,gObj[iIndex].Name);

  05567	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0556a	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05570	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05576	8d 54 01 77	 lea	 edx, DWORD PTR [ecx+eax+119]
  0557a	52		 push	 edx
  0557b	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0557e	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05584	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0558a	8d 54 01 6c	 lea	 edx, DWORD PTR [ecx+eax+108]
  0558e	52		 push	 edx
  0558f	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@DJAOLMAF@400?5LevelUp?5?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Party?5?$AA@
  05594	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _szMsg$237351[ebp]
  0559a	50		 push	 eax
  0559b	e8 00 00 00 00	 call	 _sprintf
  055a0	83 c4 10	 add	 esp, 16			; 00000010H

; 2012 : 			int iPartyNumIndex;
; 2013 : 
; 2014 : 			for( int i = 0; i<MAX_USER_IN_PARTY; i++ )

  055a3	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$237354[ebp], 0
  055ad	eb 0f		 jmp	 SHORT $LN4@LevelUp
$LN3@LevelUp:
  055af	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _i$237354[ebp]
  055b5	83 c0 01	 add	 eax, 1
  055b8	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _i$237354[ebp], eax
$LN4@LevelUp:
  055be	83 bd e8 fe ff
	ff 0a		 cmp	 DWORD PTR _i$237354[ebp], 10 ; 0000000aH
  055c5	0f 8d 85 00 00
	00		 jge	 $LN2@LevelUp

; 2015 : 			{
; 2016 : 				iPartyNumIndex = gParty.m_PartyS[iPartyNumber].Number[i];

  055cb	8b 45 f0	 mov	 eax, DWORD PTR _iPartyNumber$237350[ebp]
  055ce	6b c0 6c	 imul	 eax, 108		; 0000006cH
  055d1	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _i$237354[ebp]
  055d7	8b 94 88 0c 00
	00 00		 mov	 edx, DWORD PTR ?gParty@@3VPartyClass@@A[eax+ecx*4+12]
  055de	89 95 ec fe ff
	ff		 mov	 DWORD PTR _iPartyNumIndex$237353[ebp], edx

; 2017 : 
; 2018 : 				if( iPartyNumIndex >= 0  )

  055e4	83 bd ec fe ff
	ff 00		 cmp	 DWORD PTR _iPartyNumIndex$237353[ebp], 0
  055eb	7c 5e		 jl	 SHORT $LN1@LevelUp

; 2019 : 				{
; 2020 : 					int iSize = strlen(szMsg);

  055ed	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _szMsg$237351[ebp]
  055f3	50		 push	 eax
  055f4	e8 00 00 00 00	 call	 _strlen
  055f9	83 c4 04	 add	 esp, 4
  055fc	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _iSize$237359[ebp], eax

; 2021 : 					sprintf(&szMsg[iSize],",(%s)(%s) ",gObj[iPartyNumIndex].AccountID,gObj[iPartyNumIndex].Name);

  05602	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _iPartyNumIndex$237353[ebp]
  05608	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0560e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05614	8d 54 01 77	 lea	 edx, DWORD PTR [ecx+eax+119]
  05618	52		 push	 edx
  05619	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _iPartyNumIndex$237353[ebp]
  0561f	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05625	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0562b	8d 54 01 6c	 lea	 edx, DWORD PTR [ecx+eax+108]
  0562f	52		 push	 edx
  05630	68 00 00 00 00	 push	 OFFSET ??_C@_0L@MNKEEMGH@?0?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5?$AA@
  05635	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _iSize$237359[ebp]
  0563b	8d 8c 05 f0 fe
	ff ff		 lea	 ecx, DWORD PTR _szMsg$237351[ebp+eax]
  05642	51		 push	 ecx
  05643	e8 00 00 00 00	 call	 _sprintf
  05648	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@LevelUp:

; 2022 : 				}
; 2023 : 			}

  0564b	e9 5f ff ff ff	 jmp	 $LN3@LevelUp
$LN2@LevelUp:

; 2024 : 			LogAddTD(szMsg);

  05650	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _szMsg$237351[ebp]
  05656	50		 push	 eax
  05657	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0565d	83 c4 04	 add	 esp, 4
$LN5@LevelUp:

; 2025 : 		}
; 2026 : 	}
; 2027 : #ifndef FIX_DS_CRASH
; 2028 : 	GJSetCharacterInfo(&gObj[iIndex], gObj[iIndex].m_Index, 0);
; 2029 : #endif	
; 2030 : #if(SYSTEM_ACHIEVEMENTS)
; 2031 : 	g_Achievements.LevelUp(iIndex);

  05660	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  05663	50		 push	 eax
  05664	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Achievements@@3VCAchievements@@A ; g_Achievements
  05669	e8 00 00 00 00	 call	 ?LevelUp@CAchievements@@QAEXH@Z ; CAchievements::LevelUp

; 2032 : #endif
; 2033 : 	return iLEFT_EXP;

  0566e	8b 45 f4	 mov	 eax, DWORD PTR _iLEFT_EXP$[ebp]
$LN15@LevelUp:

; 2034 : }

  05671	5f		 pop	 edi
  05672	5e		 pop	 esi
  05673	5b		 pop	 ebx
  05674	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  05677	33 cd		 xor	 ecx, ebp
  05679	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0567e	8b e5		 mov	 esp, ebp
  05680	5d		 pop	 ebp
  05681	c2 0c 00	 ret	 12			; 0000000cH
?LevelUp@CBloodCastle@@QAEHHHH@Z ENDP			; CBloodCastle::LevelUp
_TEXT	ENDS
EXTRN	?gObjIsConnected@@YAHH@Z:PROC			; gObjIsConnected
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv67 = -76						; size = 4
_i$237366 = -8						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?CheckUsersOnConnect@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::CheckUsersOnConnect
; _this$ = ecx

; 2038 : {

  05690	55		 push	 ebp
  05691	8b ec		 mov	 ebp, esp
  05693	83 ec 4c	 sub	 esp, 76			; 0000004cH
  05696	53		 push	 ebx
  05697	56		 push	 esi
  05698	57		 push	 edi
  05699	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2039 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  0569c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  056a0	7d 09		 jge	 SHORT $LN11@CheckUsers
  056a2	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  056a9	eb 0c		 jmp	 SHORT $LN12@CheckUsers
$LN11@CheckUsers:
  056ab	33 c0		 xor	 eax, eax
  056ad	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  056b1	0f 9e c0	 setle	 al
  056b4	89 45 b4	 mov	 DWORD PTR tv67[ebp], eax
$LN12@CheckUsers:
  056b7	83 7d b4 00	 cmp	 DWORD PTR tv67[ebp], 0
  056bb	75 05		 jne	 SHORT $LN8@CheckUsers

; 2040 : 	{
; 2041 : 		return;

  056bd	e9 13 01 00 00	 jmp	 $LN9@CheckUsers
$LN8@CheckUsers:

; 2042 : 	}
; 2043 : 
; 2044 : 	::EnterCriticalSection(&this->m_BridgeData[iBridgeIndex].m_critUserData);

  056c2	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  056c5	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  056cb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  056ce	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  056d2	52		 push	 edx
  056d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 2045 : 
; 2046 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  056d9	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$237366[ebp], 0
  056e0	eb 09		 jmp	 SHORT $LN7@CheckUsers
$LN6@CheckUsers:
  056e2	8b 45 f8	 mov	 eax, DWORD PTR _i$237366[ebp]
  056e5	83 c0 01	 add	 eax, 1
  056e8	89 45 f8	 mov	 DWORD PTR _i$237366[ebp], eax
$LN7@CheckUsers:
  056eb	83 7d f8 28	 cmp	 DWORD PTR _i$237366[ebp], 40 ; 00000028H
  056ef	0f 8d c9 00 00
	00		 jge	 $LN5@CheckUsers

; 2047 : 	{
; 2048 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  056f5	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  056f8	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  056fe	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  05701	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  05705	8b 45 f8	 mov	 eax, DWORD PTR _i$237366[ebp]
  05708	6b c0 14	 imul	 eax, 20			; 00000014H
  0570b	83 7c 02 18 ff	 cmp	 DWORD PTR [edx+eax+24], -1
  05710	0f 84 a3 00 00
	00		 je	 $LN4@CheckUsers

; 2049 : 		{
; 2050 : 			if ( gObjIsConnected(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex) == FALSE )

  05716	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  05719	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0571f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  05722	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  05726	8b 45 f8	 mov	 eax, DWORD PTR _i$237366[ebp]
  05729	6b c0 14	 imul	 eax, 20			; 00000014H
  0572c	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  05730	51		 push	 ecx
  05731	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  05736	83 c4 04	 add	 esp, 4
  05739	85 c0		 test	 eax, eax
  0573b	75 20		 jne	 SHORT $LN3@CheckUsers

; 2051 : 			{
; 2052 : 				this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex = -1;

  0573d	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  05740	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  05746	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  05749	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0574d	8b 45 f8	 mov	 eax, DWORD PTR _i$237366[ebp]
  05750	6b c0 14	 imul	 eax, 20			; 00000014H
  05753	c7 44 02 18 ff
	ff ff ff	 mov	 DWORD PTR [edx+eax+24], -1

; 2053 : 			}
; 2054 : 			else

  0575b	eb 5c		 jmp	 SHORT $LN4@CheckUsers
$LN3@CheckUsers:

; 2055 : 			{
; 2056 : 				if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber != this->GetBridgeMapNumber(iBridgeIndex) ) //season3 changed

  0575d	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  05760	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  05766	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  05769	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0576d	8b 45 f8	 mov	 eax, DWORD PTR _i$237366[ebp]
  05770	6b c0 14	 imul	 eax, 20			; 00000014H
  05773	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  05777	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0577d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05783	0f b6 b4 0a 49
	01 00 00	 movzx	 esi, BYTE PTR [edx+ecx+329]
  0578b	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0578e	50		 push	 eax
  0578f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  05792	e8 00 00 00 00	 call	 ?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeMapNumber
  05797	3b f0		 cmp	 esi, eax
  05799	74 1e		 je	 SHORT $LN4@CheckUsers

; 2057 : 				{
; 2058 : 					this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex = -1;

  0579b	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0579e	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  057a4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  057a7	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  057ab	8b 45 f8	 mov	 eax, DWORD PTR _i$237366[ebp]
  057ae	6b c0 14	 imul	 eax, 20			; 00000014H
  057b1	c7 44 02 18 ff
	ff ff ff	 mov	 DWORD PTR [edx+eax+24], -1
$LN4@CheckUsers:

; 2059 : 				}
; 2060 : 			}
; 2061 : 		}
; 2062 : 	}

  057b9	e9 24 ff ff ff	 jmp	 $LN6@CheckUsers
$LN5@CheckUsers:

; 2063 : 
; 2064 : 	::LeaveCriticalSection(&this->m_BridgeData[iBridgeIndex].m_critUserData);

  057be	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  057c1	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  057c7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  057ca	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  057ce	52		 push	 edx
  057cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
$LN9@CheckUsers:

; 2065 : 
; 2066 : }

  057d5	5f		 pop	 edi
  057d6	5e		 pop	 esi
  057d7	5b		 pop	 ebx
  057d8	8b e5		 mov	 esp, ebp
  057da	5d		 pop	 ebp
  057db	c2 04 00	 ret	 4
?CheckUsersOnConnect@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::CheckUsersOnConnect
_TEXT	ENDS
PUBLIC	?AddExperience@CBloodCastle@@QAE_NHH@Z		; CBloodCastle::AddExperience
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv93 = -72						; size = 4
tv80 = -72						; size = 4
tv67 = -72						; size = 4
_this$ = -4						; size = 4
_iIndex$ = 8						; size = 4
_iEXP$ = 12						; size = 4
?AddExperience@CBloodCastle@@QAE_NHH@Z PROC		; CBloodCastle::AddExperience
; _this$ = ecx

; 2069 : {

  057e0	55		 push	 ebp
  057e1	8b ec		 mov	 ebp, esp
  057e3	83 ec 48	 sub	 esp, 72			; 00000048H
  057e6	53		 push	 ebx
  057e7	56		 push	 esi
  057e8	57		 push	 edi
  057e9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2070 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  057ec	83 7d 08 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  057f0	7d 09		 jge	 SHORT $LN7@AddExperie
  057f2	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  057f9	eb 0f		 jmp	 SHORT $LN8@AddExperie
$LN7@AddExperie:
  057fb	33 c0		 xor	 eax, eax
  057fd	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _iIndex$[ebp], 14999 ; 00003a97H
  05804	0f 9e c0	 setle	 al
  05807	89 45 b8	 mov	 DWORD PTR tv67[ebp], eax
$LN8@AddExperie:
  0580a	83 7d b8 00	 cmp	 DWORD PTR tv67[ebp], 0
  0580e	75 07		 jne	 SHORT $LN4@AddExperie

; 2071 : 	{
; 2072 : 		return false;

  05810	32 c0		 xor	 al, al
  05812	e9 67 01 00 00	 jmp	 $LN5@AddExperie
$LN4@AddExperie:

; 2073 : 	}
; 2074 : 
; 2075 : 	if ( BC_BRIDGE_RANGE(gObj[iIndex].m_cBloodCastleIndex) == FALSE )

  05817	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0581a	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05820	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05826	0f be 94 01 9e
	0e 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3742]
  0582e	85 d2		 test	 edx, edx
  05830	7d 09		 jge	 SHORT $LN9@AddExperie
  05832	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv80[ebp], 0
  05839	eb 22		 jmp	 SHORT $LN10@AddExperie
$LN9@AddExperie:
  0583b	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0583e	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05844	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0584a	0f be 94 01 9e
	0e 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3742]
  05852	33 c0		 xor	 eax, eax
  05854	83 fa 07	 cmp	 edx, 7
  05857	0f 9e c0	 setle	 al
  0585a	89 45 b8	 mov	 DWORD PTR tv80[ebp], eax
$LN10@AddExperie:
  0585d	83 7d b8 00	 cmp	 DWORD PTR tv80[ebp], 0
  05861	75 07		 jne	 SHORT $LN3@AddExperie

; 2076 : 	{
; 2077 : 		return false;

  05863	32 c0		 xor	 al, al
  05865	e9 14 01 00 00	 jmp	 $LN5@AddExperie
$LN3@AddExperie:

; 2078 : 	}
; 2079 : 
; 2080 : 	if ( BC_SUB_BRIDGE_RANGE(gObj[iIndex].m_cBloodCastleSubIndex) == FALSE )

  0586a	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0586d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05873	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05879	0f be 94 01 9f
	0e 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3743]
  05881	85 d2		 test	 edx, edx
  05883	7d 09		 jge	 SHORT $LN11@AddExperie
  05885	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv93[ebp], 0
  0588c	eb 22		 jmp	 SHORT $LN12@AddExperie
$LN11@AddExperie:
  0588e	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  05891	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05897	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0589d	0f be 94 01 9f
	0e 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3743]
  058a5	33 c0		 xor	 eax, eax
  058a7	83 fa 27	 cmp	 edx, 39			; 00000027H
  058aa	0f 9e c0	 setle	 al
  058ad	89 45 b8	 mov	 DWORD PTR tv93[ebp], eax
$LN12@AddExperie:
  058b0	83 7d b8 00	 cmp	 DWORD PTR tv93[ebp], 0
  058b4	75 07		 jne	 SHORT $LN2@AddExperie

; 2081 : 	{
; 2082 : 		return false;

  058b6	32 c0		 xor	 al, al
  058b8	e9 c1 00 00 00	 jmp	 $LN5@AddExperie
$LN2@AddExperie:

; 2083 : 	}
; 2084 : 
; 2085 : 	if ( iEXP > 0 )

  058bd	83 7d 0c 00	 cmp	 DWORD PTR _iEXP$[ebp], 0
  058c1	0f 8e b5 00 00
	00		 jle	 $LN1@AddExperie

; 2086 : 	{
; 2087 : 		this->m_BridgeData[gObj[iIndex].m_cBloodCastleIndex].m_UserData[gObj[iIndex].m_cBloodCastleSubIndex].m_iEXP += iEXP;

  058c7	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  058ca	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  058d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  058d6	0f be 94 01 9e
	0e 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3742]
  058de	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  058e4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  058e7	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  058eb	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  058ee	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  058f4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  058f9	0f be 94 10 9f
	0e 00 00	 movsx	 edx, BYTE PTR [eax+edx+3743]
  05901	6b d2 14	 imul	 edx, 20			; 00000014H
  05904	8b 44 11 1c	 mov	 eax, DWORD PTR [ecx+edx+28]
  05908	03 45 0c	 add	 eax, DWORD PTR _iEXP$[ebp]
  0590b	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0590e	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  05914	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0591a	0f be 8c 0a 9f
	0e 00 00	 movsx	 ecx, BYTE PTR [edx+ecx+3743]
  05922	6b c9 14	 imul	 ecx, 20			; 00000014H
  05925	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  05928	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  0592e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05934	0f be 94 16 9e
	0e 00 00	 movsx	 edx, BYTE PTR [esi+edx+3742]
  0593c	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  05942	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  05945	8d 54 16 04	 lea	 edx, DWORD PTR [esi+edx+4]
  05949	89 44 0a 1c	 mov	 DWORD PTR [edx+ecx+28], eax

; 2088 : 		gObj[iIndex].m_iBloodCastleEXP += iEXP;

  0594d	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  05950	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  05956	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0595c	8b 94 01 a0 0e
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3744]
  05963	03 55 0c	 add	 edx, DWORD PTR _iEXP$[ebp]
  05966	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  05969	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0596f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  05975	89 94 01 a0 0e
	00 00		 mov	 DWORD PTR [ecx+eax+3744], edx
$LN1@AddExperie:

; 2089 : 	}
; 2090 : 
; 2091 : 	return true;

  0597c	b0 01		 mov	 al, 1
$LN5@AddExperie:

; 2092 : }

  0597e	5f		 pop	 edi
  0597f	5e		 pop	 esi
  05980	5b		 pop	 ebx
  05981	8b e5		 mov	 esp, ebp
  05983	5d		 pop	 ebp
  05984	c2 08 00	 ret	 8
?AddExperience@CBloodCastle@@QAE_NHH@Z ENDP		; CBloodCastle::AddExperience
; Function compile flags: /Odtp /ZI
tv67 = -84						; size = 4
_iMapNumber$237396 = -16				; size = 4
_j$237392 = -12						; size = 4
_i$237388 = -8						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?BlockCastleEntrance@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::BlockCastleEntrance
; _this$ = ecx

; 2096 : {

  05990	55		 push	 ebp
  05991	8b ec		 mov	 ebp, esp
  05993	83 ec 54	 sub	 esp, 84			; 00000054H
  05996	53		 push	 ebx
  05997	56		 push	 esi
  05998	57		 push	 edi
  05999	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2097 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  0599c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  059a0	7d 09		 jge	 SHORT $LN10@BlockCastl
  059a2	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  059a9	eb 0c		 jmp	 SHORT $LN11@BlockCastl
$LN10@BlockCastl:
  059ab	33 c0		 xor	 eax, eax
  059ad	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  059b1	0f 9e c0	 setle	 al
  059b4	89 45 ac	 mov	 DWORD PTR tv67[ebp], eax
$LN11@BlockCastl:
  059b7	83 7d ac 00	 cmp	 DWORD PTR tv67[ebp], 0
  059bb	75 05		 jne	 SHORT $LN7@BlockCastl

; 2098 : 	{
; 2099 : 		return;

  059bd	e9 a2 00 00 00	 jmp	 $LN8@BlockCastl
$LN7@BlockCastl:

; 2100 : 	}
; 2101 : 
; 2102 : 	for ( int i= ::g_btCastleEntranceMapXY[iBridgeIndex].btStartX;i<= ::g_btCastleEntranceMapXY[iBridgeIndex].btEndX;i++)

  059c2	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  059c5	0f b6 0c 85 00
	00 00 00	 movzx	 ecx, BYTE PTR _g_btCastleEntranceMapXY[eax*4]
  059cd	89 4d f8	 mov	 DWORD PTR _i$237388[ebp], ecx
  059d0	eb 09		 jmp	 SHORT $LN6@BlockCastl
$LN5@BlockCastl:
  059d2	8b 45 f8	 mov	 eax, DWORD PTR _i$237388[ebp]
  059d5	83 c0 01	 add	 eax, 1
  059d8	89 45 f8	 mov	 DWORD PTR _i$237388[ebp], eax
$LN6@BlockCastl:
  059db	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  059de	0f b6 0c 85 02
	00 00 00	 movzx	 ecx, BYTE PTR _g_btCastleEntranceMapXY[eax*4+2]
  059e6	39 4d f8	 cmp	 DWORD PTR _i$237388[ebp], ecx
  059e9	7f 79		 jg	 SHORT $LN8@BlockCastl

; 2103 : 	{
; 2104 : 		for ( int j= ::g_btCastleEntranceMapXY[iBridgeIndex].btStartY;j<= ::g_btCastleEntranceMapXY[iBridgeIndex].btEndY;j++)

  059eb	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  059ee	0f b6 0c 85 01
	00 00 00	 movzx	 ecx, BYTE PTR _g_btCastleEntranceMapXY[eax*4+1]
  059f6	89 4d f4	 mov	 DWORD PTR _j$237392[ebp], ecx
  059f9	eb 09		 jmp	 SHORT $LN3@BlockCastl
$LN2@BlockCastl:
  059fb	8b 45 f4	 mov	 eax, DWORD PTR _j$237392[ebp]
  059fe	83 c0 01	 add	 eax, 1
  05a01	89 45 f4	 mov	 DWORD PTR _j$237392[ebp], eax
$LN3@BlockCastl:
  05a04	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  05a07	0f b6 0c 85 03
	00 00 00	 movzx	 ecx, BYTE PTR _g_btCastleEntranceMapXY[eax*4+3]
  05a0f	39 4d f4	 cmp	 DWORD PTR _j$237392[ebp], ecx
  05a12	7f 4b		 jg	 SHORT $LN1@BlockCastl

; 2105 : 		{
; 2106 : 			int iMapNumber = this->GetBridgeMapNumber(iBridgeIndex); //season3 add-on

  05a14	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  05a17	50		 push	 eax
  05a18	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  05a1b	e8 00 00 00 00	 call	 ?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeMapNumber
  05a20	89 45 f0	 mov	 DWORD PTR _iMapNumber$237396[ebp], eax

; 2107 : 
; 2108 : 			MapC[iMapNumber].m_attrbuf[j * 256 + i] |= 4; //season3 changed

  05a23	8b 45 f0	 mov	 eax, DWORD PTR _iMapNumber$237396[ebp]
  05a26	69 c0 b8 3d 05
	00		 imul	 eax, 343480		; 00053db8H
  05a2c	8b 4d f4	 mov	 ecx, DWORD PTR _j$237392[ebp]
  05a2f	c1 e1 08	 shl	 ecx, 8
  05a32	03 4d f8	 add	 ecx, DWORD PTR _i$237388[ebp]
  05a35	8b 90 10 00 00
	00		 mov	 edx, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+16]
  05a3b	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  05a3f	83 c8 04	 or	 eax, 4
  05a42	8b 4d f0	 mov	 ecx, DWORD PTR _iMapNumber$237396[ebp]
  05a45	69 c9 b8 3d 05
	00		 imul	 ecx, 343480		; 00053db8H
  05a4b	8b 55 f4	 mov	 edx, DWORD PTR _j$237392[ebp]
  05a4e	c1 e2 08	 shl	 edx, 8
  05a51	03 55 f8	 add	 edx, DWORD PTR _i$237388[ebp]
  05a54	8b 89 10 00 00
	00		 mov	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx+16]
  05a5a	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 2109 : 		}

  05a5d	eb 9c		 jmp	 SHORT $LN2@BlockCastl
$LN1@BlockCastl:

; 2110 : 	}

  05a5f	e9 6e ff ff ff	 jmp	 $LN5@BlockCastl
$LN8@BlockCastl:

; 2111 : }

  05a64	5f		 pop	 edi
  05a65	5e		 pop	 esi
  05a66	5b		 pop	 ebx
  05a67	8b e5		 mov	 esp, ebp
  05a69	5d		 pop	 ebp
  05a6a	c2 04 00	 ret	 4
?BlockCastleEntrance@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::BlockCastleEntrance
; Function compile flags: /Odtp /ZI
tv67 = -84						; size = 4
_iMapNumber$237410 = -16				; size = 4
_j$237406 = -12						; size = 4
_i$237402 = -8						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?ReleaseCastleEntrance@CBloodCastle@@QAEXH@Z PROC	; CBloodCastle::ReleaseCastleEntrance
; _this$ = ecx

; 2115 : {

  05a70	55		 push	 ebp
  05a71	8b ec		 mov	 ebp, esp
  05a73	83 ec 54	 sub	 esp, 84			; 00000054H
  05a76	53		 push	 ebx
  05a77	56		 push	 esi
  05a78	57		 push	 edi
  05a79	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2116 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  05a7c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  05a80	7d 09		 jge	 SHORT $LN10@ReleaseCas
  05a82	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  05a89	eb 0c		 jmp	 SHORT $LN11@ReleaseCas
$LN10@ReleaseCas:
  05a8b	33 c0		 xor	 eax, eax
  05a8d	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  05a91	0f 9e c0	 setle	 al
  05a94	89 45 ac	 mov	 DWORD PTR tv67[ebp], eax
$LN11@ReleaseCas:
  05a97	83 7d ac 00	 cmp	 DWORD PTR tv67[ebp], 0
  05a9b	75 05		 jne	 SHORT $LN7@ReleaseCas

; 2117 : 	{
; 2118 : 		return;

  05a9d	e9 a2 00 00 00	 jmp	 $LN8@ReleaseCas
$LN7@ReleaseCas:

; 2119 : 	}
; 2120 : 
; 2121 : 	for ( int i= ::g_btCastleEntranceMapXY[iBridgeIndex].btStartX;i<= ::g_btCastleEntranceMapXY[iBridgeIndex].btEndX;i++)

  05aa2	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  05aa5	0f b6 0c 85 00
	00 00 00	 movzx	 ecx, BYTE PTR _g_btCastleEntranceMapXY[eax*4]
  05aad	89 4d f8	 mov	 DWORD PTR _i$237402[ebp], ecx
  05ab0	eb 09		 jmp	 SHORT $LN6@ReleaseCas
$LN5@ReleaseCas:
  05ab2	8b 45 f8	 mov	 eax, DWORD PTR _i$237402[ebp]
  05ab5	83 c0 01	 add	 eax, 1
  05ab8	89 45 f8	 mov	 DWORD PTR _i$237402[ebp], eax
$LN6@ReleaseCas:
  05abb	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  05abe	0f b6 0c 85 02
	00 00 00	 movzx	 ecx, BYTE PTR _g_btCastleEntranceMapXY[eax*4+2]
  05ac6	39 4d f8	 cmp	 DWORD PTR _i$237402[ebp], ecx
  05ac9	7f 79		 jg	 SHORT $LN8@ReleaseCas

; 2122 : 	{
; 2123 : 		for ( int j= ::g_btCastleEntranceMapXY[iBridgeIndex].btStartY;j<= ::g_btCastleEntranceMapXY[iBridgeIndex].btEndY;j++)

  05acb	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  05ace	0f b6 0c 85 01
	00 00 00	 movzx	 ecx, BYTE PTR _g_btCastleEntranceMapXY[eax*4+1]
  05ad6	89 4d f4	 mov	 DWORD PTR _j$237406[ebp], ecx
  05ad9	eb 09		 jmp	 SHORT $LN3@ReleaseCas
$LN2@ReleaseCas:
  05adb	8b 45 f4	 mov	 eax, DWORD PTR _j$237406[ebp]
  05ade	83 c0 01	 add	 eax, 1
  05ae1	89 45 f4	 mov	 DWORD PTR _j$237406[ebp], eax
$LN3@ReleaseCas:
  05ae4	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  05ae7	0f b6 0c 85 03
	00 00 00	 movzx	 ecx, BYTE PTR _g_btCastleEntranceMapXY[eax*4+3]
  05aef	39 4d f4	 cmp	 DWORD PTR _j$237406[ebp], ecx
  05af2	7f 4b		 jg	 SHORT $LN1@ReleaseCas

; 2124 : 		{
; 2125 : 			int iMapNumber = this->GetBridgeMapNumber(iBridgeIndex); //season3 add-on

  05af4	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  05af7	50		 push	 eax
  05af8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  05afb	e8 00 00 00 00	 call	 ?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeMapNumber
  05b00	89 45 f0	 mov	 DWORD PTR _iMapNumber$237410[ebp], eax

; 2126 : 
; 2127 : 			MapC[iMapNumber].m_attrbuf[j * 256 + i] &= ~4; //season3 changed

  05b03	8b 45 f0	 mov	 eax, DWORD PTR _iMapNumber$237410[ebp]
  05b06	69 c0 b8 3d 05
	00		 imul	 eax, 343480		; 00053db8H
  05b0c	8b 4d f4	 mov	 ecx, DWORD PTR _j$237406[ebp]
  05b0f	c1 e1 08	 shl	 ecx, 8
  05b12	03 4d f8	 add	 ecx, DWORD PTR _i$237402[ebp]
  05b15	8b 90 10 00 00
	00		 mov	 edx, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+16]
  05b1b	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  05b1f	83 e0 fb	 and	 eax, -5			; fffffffbH
  05b22	8b 4d f0	 mov	 ecx, DWORD PTR _iMapNumber$237410[ebp]
  05b25	69 c9 b8 3d 05
	00		 imul	 ecx, 343480		; 00053db8H
  05b2b	8b 55 f4	 mov	 edx, DWORD PTR _j$237406[ebp]
  05b2e	c1 e2 08	 shl	 edx, 8
  05b31	03 55 f8	 add	 edx, DWORD PTR _i$237402[ebp]
  05b34	8b 89 10 00 00
	00		 mov	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx+16]
  05b3a	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 2128 : 		}

  05b3d	eb 9c		 jmp	 SHORT $LN2@ReleaseCas
$LN1@ReleaseCas:

; 2129 : 	}

  05b3f	e9 6e ff ff ff	 jmp	 $LN5@ReleaseCas
$LN8@ReleaseCas:

; 2130 : }

  05b44	5f		 pop	 edi
  05b45	5e		 pop	 esi
  05b46	5b		 pop	 ebx
  05b47	8b e5		 mov	 esp, ebp
  05b49	5d		 pop	 ebp
  05b4a	c2 04 00	 ret	 4
?ReleaseCastleEntrance@CBloodCastle@@QAEXH@Z ENDP	; CBloodCastle::ReleaseCastleEntrance
; Function compile flags: /Odtp /ZI
tv67 = -84						; size = 4
_iMapNumber$237424 = -16				; size = 4
_j$237420 = -12						; size = 4
_i$237416 = -8						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?BlockCastleBridge@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::BlockCastleBridge
; _this$ = ecx

; 2134 : {

  05b50	55		 push	 ebp
  05b51	8b ec		 mov	 ebp, esp
  05b53	83 ec 54	 sub	 esp, 84			; 00000054H
  05b56	53		 push	 ebx
  05b57	56		 push	 esi
  05b58	57		 push	 edi
  05b59	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2135 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  05b5c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  05b60	7d 09		 jge	 SHORT $LN10@BlockCastl@2
  05b62	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  05b69	eb 0c		 jmp	 SHORT $LN11@BlockCastl@2
$LN10@BlockCastl@2:
  05b6b	33 c0		 xor	 eax, eax
  05b6d	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  05b71	0f 9e c0	 setle	 al
  05b74	89 45 ac	 mov	 DWORD PTR tv67[ebp], eax
$LN11@BlockCastl@2:
  05b77	83 7d ac 00	 cmp	 DWORD PTR tv67[ebp], 0
  05b7b	75 05		 jne	 SHORT $LN7@BlockCastl@2

; 2136 : 	{
; 2137 : 		return;

  05b7d	e9 a2 00 00 00	 jmp	 $LN8@BlockCastl@2
$LN7@BlockCastl@2:

; 2138 : 	}
; 2139 : 
; 2140 : 	for ( int i= ::g_btCastleBridgeMapXY[iBridgeIndex].btStartX;i<= ::g_btCastleBridgeMapXY[iBridgeIndex].btEndX;i++)

  05b82	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  05b85	0f b6 0c 85 00
	00 00 00	 movzx	 ecx, BYTE PTR _g_btCastleBridgeMapXY[eax*4]
  05b8d	89 4d f8	 mov	 DWORD PTR _i$237416[ebp], ecx
  05b90	eb 09		 jmp	 SHORT $LN6@BlockCastl@2
$LN5@BlockCastl@2:
  05b92	8b 45 f8	 mov	 eax, DWORD PTR _i$237416[ebp]
  05b95	83 c0 01	 add	 eax, 1
  05b98	89 45 f8	 mov	 DWORD PTR _i$237416[ebp], eax
$LN6@BlockCastl@2:
  05b9b	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  05b9e	0f b6 0c 85 02
	00 00 00	 movzx	 ecx, BYTE PTR _g_btCastleBridgeMapXY[eax*4+2]
  05ba6	39 4d f8	 cmp	 DWORD PTR _i$237416[ebp], ecx
  05ba9	7f 79		 jg	 SHORT $LN8@BlockCastl@2

; 2141 : 	{
; 2142 : 		for ( int j= ::g_btCastleBridgeMapXY[iBridgeIndex].btStartY;j<= ::g_btCastleBridgeMapXY[iBridgeIndex].btEndY;j++)

  05bab	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  05bae	0f b6 0c 85 01
	00 00 00	 movzx	 ecx, BYTE PTR _g_btCastleBridgeMapXY[eax*4+1]
  05bb6	89 4d f4	 mov	 DWORD PTR _j$237420[ebp], ecx
  05bb9	eb 09		 jmp	 SHORT $LN3@BlockCastl@2
$LN2@BlockCastl@2:
  05bbb	8b 45 f4	 mov	 eax, DWORD PTR _j$237420[ebp]
  05bbe	83 c0 01	 add	 eax, 1
  05bc1	89 45 f4	 mov	 DWORD PTR _j$237420[ebp], eax
$LN3@BlockCastl@2:
  05bc4	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  05bc7	0f b6 0c 85 03
	00 00 00	 movzx	 ecx, BYTE PTR _g_btCastleBridgeMapXY[eax*4+3]
  05bcf	39 4d f4	 cmp	 DWORD PTR _j$237420[ebp], ecx
  05bd2	7f 4b		 jg	 SHORT $LN1@BlockCastl@2

; 2143 : 		{
; 2144 : 			int iMapNumber = this->GetBridgeMapNumber(iBridgeIndex); //season3 add-on

  05bd4	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  05bd7	50		 push	 eax
  05bd8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  05bdb	e8 00 00 00 00	 call	 ?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeMapNumber
  05be0	89 45 f0	 mov	 DWORD PTR _iMapNumber$237424[ebp], eax

; 2145 : 
; 2146 : 			MapC[iMapNumber].m_attrbuf[j * 256 + i] |= 8; //season3 changed

  05be3	8b 45 f0	 mov	 eax, DWORD PTR _iMapNumber$237424[ebp]
  05be6	69 c0 b8 3d 05
	00		 imul	 eax, 343480		; 00053db8H
  05bec	8b 4d f4	 mov	 ecx, DWORD PTR _j$237420[ebp]
  05bef	c1 e1 08	 shl	 ecx, 8
  05bf2	03 4d f8	 add	 ecx, DWORD PTR _i$237416[ebp]
  05bf5	8b 90 10 00 00
	00		 mov	 edx, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+16]
  05bfb	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  05bff	83 c8 08	 or	 eax, 8
  05c02	8b 4d f0	 mov	 ecx, DWORD PTR _iMapNumber$237424[ebp]
  05c05	69 c9 b8 3d 05
	00		 imul	 ecx, 343480		; 00053db8H
  05c0b	8b 55 f4	 mov	 edx, DWORD PTR _j$237420[ebp]
  05c0e	c1 e2 08	 shl	 edx, 8
  05c11	03 55 f8	 add	 edx, DWORD PTR _i$237416[ebp]
  05c14	8b 89 10 00 00
	00		 mov	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx+16]
  05c1a	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 2147 : 		}

  05c1d	eb 9c		 jmp	 SHORT $LN2@BlockCastl@2
$LN1@BlockCastl@2:

; 2148 : 	}

  05c1f	e9 6e ff ff ff	 jmp	 $LN5@BlockCastl@2
$LN8@BlockCastl@2:

; 2149 : }

  05c24	5f		 pop	 edi
  05c25	5e		 pop	 esi
  05c26	5b		 pop	 ebx
  05c27	8b e5		 mov	 esp, ebp
  05c29	5d		 pop	 ebp
  05c2a	c2 04 00	 ret	 4
?BlockCastleBridge@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::BlockCastleBridge
_TEXT	ENDS
PUBLIC	??_C@_0DE@LNBDIFNP@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5Relea@ ; `string'
PUBLIC	??_C@_0CI@PNCMBIPP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Castle?5Door?5@ ; `string'
;	COMDAT ??_C@_0DE@LNBDIFNP@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5Relea@
CONST	SEGMENT
??_C@_0DE@LNBDIFNP@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5Relea@ DB '['
	DB	'Blood Castle][Bug Tracer] ReleaseCastleBridge-> %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@PNCMBIPP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Castle?5Door?5@
CONST	SEGMENT
??_C@_0CI@PNCMBIPP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Castle?5Door?5@ DB '['
	DB	'Blood Castle] (%d) Castle Door Subsist', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv67 = -84						; size = 4
_iMapNumber$237438 = -16				; size = 4
_j$237434 = -12						; size = 4
_i$237430 = -8						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?ReleaseCastleBridge@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::ReleaseCastleBridge
; _this$ = ecx

; 2153 : {

  05c30	55		 push	 ebp
  05c31	8b ec		 mov	 ebp, esp
  05c33	83 ec 54	 sub	 esp, 84			; 00000054H
  05c36	53		 push	 ebx
  05c37	56		 push	 esi
  05c38	57		 push	 edi
  05c39	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2154 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  05c3c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  05c40	7d 09		 jge	 SHORT $LN10@ReleaseCas@2
  05c42	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  05c49	eb 0c		 jmp	 SHORT $LN11@ReleaseCas@2
$LN10@ReleaseCas@2:
  05c4b	33 c0		 xor	 eax, eax
  05c4d	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  05c51	0f 9e c0	 setle	 al
  05c54	89 45 ac	 mov	 DWORD PTR tv67[ebp], eax
$LN11@ReleaseCas@2:
  05c57	83 7d ac 00	 cmp	 DWORD PTR tv67[ebp], 0
  05c5b	75 05		 jne	 SHORT $LN7@ReleaseCas@2

; 2155 : 	{
; 2156 : 		return;

  05c5d	e9 d3 00 00 00	 jmp	 $LN8@ReleaseCas@2
$LN7@ReleaseCas@2:

; 2157 : 	}
; 2158 : 
; 2159 : 	for ( int i= ::g_btCastleBridgeMapXY[iBridgeIndex].btStartX;i<= ::g_btCastleBridgeMapXY[iBridgeIndex].btEndX;i++)

  05c62	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  05c65	0f b6 0c 85 00
	00 00 00	 movzx	 ecx, BYTE PTR _g_btCastleBridgeMapXY[eax*4]
  05c6d	89 4d f8	 mov	 DWORD PTR _i$237430[ebp], ecx
  05c70	eb 09		 jmp	 SHORT $LN6@ReleaseCas@2
$LN5@ReleaseCas@2:
  05c72	8b 45 f8	 mov	 eax, DWORD PTR _i$237430[ebp]
  05c75	83 c0 01	 add	 eax, 1
  05c78	89 45 f8	 mov	 DWORD PTR _i$237430[ebp], eax
$LN6@ReleaseCas@2:
  05c7b	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  05c7e	0f b6 0c 85 02
	00 00 00	 movzx	 ecx, BYTE PTR _g_btCastleBridgeMapXY[eax*4+2]
  05c86	39 4d f8	 cmp	 DWORD PTR _i$237430[ebp], ecx
  05c89	0f 8f a6 00 00
	00		 jg	 $LN8@ReleaseCas@2

; 2160 : 	{
; 2161 : 		for ( int j= ::g_btCastleBridgeMapXY[iBridgeIndex].btStartY;j<= ::g_btCastleBridgeMapXY[iBridgeIndex].btEndY;j++)

  05c8f	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  05c92	0f b6 0c 85 01
	00 00 00	 movzx	 ecx, BYTE PTR _g_btCastleBridgeMapXY[eax*4+1]
  05c9a	89 4d f4	 mov	 DWORD PTR _j$237434[ebp], ecx
  05c9d	eb 09		 jmp	 SHORT $LN3@ReleaseCas@2
$LN2@ReleaseCas@2:
  05c9f	8b 45 f4	 mov	 eax, DWORD PTR _j$237434[ebp]
  05ca2	83 c0 01	 add	 eax, 1
  05ca5	89 45 f4	 mov	 DWORD PTR _j$237434[ebp], eax
$LN3@ReleaseCas@2:
  05ca8	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  05cab	0f b6 0c 85 03
	00 00 00	 movzx	 ecx, BYTE PTR _g_btCastleBridgeMapXY[eax*4+3]
  05cb3	39 4d f4	 cmp	 DWORD PTR _j$237434[ebp], ecx
  05cb6	7f 78		 jg	 SHORT $LN1@ReleaseCas@2

; 2162 : 		{
; 2163 : 			int iMapNumber = this->GetBridgeMapNumber(iBridgeIndex); //season3 add-on

  05cb8	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  05cbb	50		 push	 eax
  05cbc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  05cbf	e8 00 00 00 00	 call	 ?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeMapNumber
  05cc4	89 45 f0	 mov	 DWORD PTR _iMapNumber$237438[ebp], eax

; 2164 : 
; 2165 : 			MapC[iMapNumber].m_attrbuf[j * 256 + i] &= ~8; //season3 changed

  05cc7	8b 45 f0	 mov	 eax, DWORD PTR _iMapNumber$237438[ebp]
  05cca	69 c0 b8 3d 05
	00		 imul	 eax, 343480		; 00053db8H
  05cd0	8b 4d f4	 mov	 ecx, DWORD PTR _j$237434[ebp]
  05cd3	c1 e1 08	 shl	 ecx, 8
  05cd6	03 4d f8	 add	 ecx, DWORD PTR _i$237430[ebp]
  05cd9	8b 90 10 00 00
	00		 mov	 edx, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+16]
  05cdf	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  05ce3	83 e0 f7	 and	 eax, -9			; fffffff7H
  05ce6	8b 4d f0	 mov	 ecx, DWORD PTR _iMapNumber$237438[ebp]
  05ce9	69 c9 b8 3d 05
	00		 imul	 ecx, 343480		; 00053db8H
  05cef	8b 55 f4	 mov	 edx, DWORD PTR _j$237434[ebp]
  05cf2	c1 e2 08	 shl	 edx, 8
  05cf5	03 55 f8	 add	 edx, DWORD PTR _i$237430[ebp]
  05cf8	8b 89 10 00 00
	00		 mov	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx+16]
  05cfe	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 2166 : 
; 2167 : 			LogAddTD("[Blood Castle] (%d) Castle Door Subsist", iBridgeIndex+1); //season 2.5 add-on

  05d01	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  05d04	83 c0 01	 add	 eax, 1
  05d07	50		 push	 eax
  05d08	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@PNCMBIPP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Castle?5Door?5@
  05d0d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  05d13	83 c4 08	 add	 esp, 8

; 2168 : 
; 2169 : 			LogAddTD("[Blood Castle][Bug Tracer] ReleaseCastleBridge-> %d", iBridgeIndex+1);

  05d16	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  05d19	83 c0 01	 add	 eax, 1
  05d1c	50		 push	 eax
  05d1d	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@LNBDIFNP@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5Relea@
  05d22	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  05d28	83 c4 08	 add	 esp, 8

; 2170 : 		}

  05d2b	e9 6f ff ff ff	 jmp	 $LN2@ReleaseCas@2
$LN1@ReleaseCas@2:

; 2171 : 	}

  05d30	e9 3d ff ff ff	 jmp	 $LN5@ReleaseCas@2
$LN8@ReleaseCas@2:

; 2172 : }

  05d35	5f		 pop	 edi
  05d36	5e		 pop	 esi
  05d37	5b		 pop	 ebx
  05d38	8b e5		 mov	 esp, ebp
  05d3a	5d		 pop	 ebp
  05d3b	c2 04 00	 ret	 4
?ReleaseCastleBridge@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::ReleaseCastleBridge
; Function compile flags: /Odtp /ZI
tv67 = -88						; size = 4
_iMapNumber$237458 = -20				; size = 4
_z$237454 = -16						; size = 4
_y$237450 = -12						; size = 4
_x$237446 = -8						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?BlockCastleDoor@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::BlockCastleDoor
; _this$ = ecx

; 2176 : {

  05d40	55		 push	 ebp
  05d41	8b ec		 mov	 ebp, esp
  05d43	83 ec 58	 sub	 esp, 88			; 00000058H
  05d46	53		 push	 ebx
  05d47	56		 push	 esi
  05d48	57		 push	 edi
  05d49	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2177 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  05d4c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  05d50	7d 09		 jge	 SHORT $LN13@BlockCastl@3
  05d52	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  05d59	eb 0c		 jmp	 SHORT $LN14@BlockCastl@3
$LN13@BlockCastl@3:
  05d5b	33 c0		 xor	 eax, eax
  05d5d	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  05d61	0f 9e c0	 setle	 al
  05d64	89 45 a8	 mov	 DWORD PTR tv67[ebp], eax
$LN14@BlockCastl@3:
  05d67	83 7d a8 00	 cmp	 DWORD PTR tv67[ebp], 0
  05d6b	75 05		 jne	 SHORT $LN10@BlockCastl@3

; 2178 : 	{
; 2179 : 		return;

  05d6d	e9 df 00 00 00	 jmp	 $LN11@BlockCastl@3
$LN10@BlockCastl@3:

; 2180 : 	}
; 2181 : 
; 2182 : 	for ( int x=0;x<3;x++)

  05d72	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _x$237446[ebp], 0
  05d79	eb 09		 jmp	 SHORT $LN9@BlockCastl@3
$LN8@BlockCastl@3:
  05d7b	8b 45 f8	 mov	 eax, DWORD PTR _x$237446[ebp]
  05d7e	83 c0 01	 add	 eax, 1
  05d81	89 45 f8	 mov	 DWORD PTR _x$237446[ebp], eax
$LN9@BlockCastl@3:
  05d84	83 7d f8 03	 cmp	 DWORD PTR _x$237446[ebp], 3
  05d88	0f 8d c3 00 00
	00		 jge	 $LN11@BlockCastl@3

; 2183 : 	{
; 2184 : 		for ( int y=::g_btCastleDoorMapXY[iBridgeIndex][x].btStartX; y <= ::g_btCastleDoorMapXY[iBridgeIndex][x].btEndX ;y++)

  05d8e	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  05d91	6b c0 0c	 imul	 eax, 12			; 0000000cH
  05d94	8b 4d f8	 mov	 ecx, DWORD PTR _x$237446[ebp]
  05d97	0f b6 94 88 00
	00 00 00	 movzx	 edx, BYTE PTR _g_btCastleDoorMapXY[eax+ecx*4]
  05d9f	89 55 f4	 mov	 DWORD PTR _y$237450[ebp], edx
  05da2	eb 09		 jmp	 SHORT $LN6@BlockCastl@3
$LN5@BlockCastl@3:
  05da4	8b 45 f4	 mov	 eax, DWORD PTR _y$237450[ebp]
  05da7	83 c0 01	 add	 eax, 1
  05daa	89 45 f4	 mov	 DWORD PTR _y$237450[ebp], eax
$LN6@BlockCastl@3:
  05dad	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  05db0	6b c0 0c	 imul	 eax, 12			; 0000000cH
  05db3	8b 4d f8	 mov	 ecx, DWORD PTR _x$237446[ebp]
  05db6	0f b6 94 88 02
	00 00 00	 movzx	 edx, BYTE PTR _g_btCastleDoorMapXY[eax+ecx*4+2]
  05dbe	39 55 f4	 cmp	 DWORD PTR _y$237450[ebp], edx
  05dc1	0f 8f 85 00 00
	00		 jg	 $LN4@BlockCastl@3

; 2185 : 		{
; 2186 : 			for ( int z = ::g_btCastleDoorMapXY[iBridgeIndex][x].btStartY; z <= ::g_btCastleDoorMapXY[iBridgeIndex][x].btEndY ; z++)

  05dc7	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  05dca	6b c0 0c	 imul	 eax, 12			; 0000000cH
  05dcd	8b 4d f8	 mov	 ecx, DWORD PTR _x$237446[ebp]
  05dd0	0f b6 94 88 01
	00 00 00	 movzx	 edx, BYTE PTR _g_btCastleDoorMapXY[eax+ecx*4+1]
  05dd8	89 55 f0	 mov	 DWORD PTR _z$237454[ebp], edx
  05ddb	eb 09		 jmp	 SHORT $LN3@BlockCastl@3
$LN2@BlockCastl@3:
  05ddd	8b 45 f0	 mov	 eax, DWORD PTR _z$237454[ebp]
  05de0	83 c0 01	 add	 eax, 1
  05de3	89 45 f0	 mov	 DWORD PTR _z$237454[ebp], eax
$LN3@BlockCastl@3:
  05de6	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  05de9	6b c0 0c	 imul	 eax, 12			; 0000000cH
  05dec	8b 4d f8	 mov	 ecx, DWORD PTR _x$237446[ebp]
  05def	0f b6 94 88 03
	00 00 00	 movzx	 edx, BYTE PTR _g_btCastleDoorMapXY[eax+ecx*4+3]
  05df7	39 55 f0	 cmp	 DWORD PTR _z$237454[ebp], edx
  05dfa	7f 4b		 jg	 SHORT $LN1@BlockCastl@3

; 2187 : 			{
; 2188 : 				int iMapNumber = this->GetBridgeMapNumber(iBridgeIndex); //season3 add-on

  05dfc	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  05dff	50		 push	 eax
  05e00	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  05e03	e8 00 00 00 00	 call	 ?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeMapNumber
  05e08	89 45 ec	 mov	 DWORD PTR _iMapNumber$237458[ebp], eax

; 2189 : 
; 2190 : 				MapC[iMapNumber].m_attrbuf[z * 256 + y] |= 4; //season3 changed

  05e0b	8b 45 ec	 mov	 eax, DWORD PTR _iMapNumber$237458[ebp]
  05e0e	69 c0 b8 3d 05
	00		 imul	 eax, 343480		; 00053db8H
  05e14	8b 4d f0	 mov	 ecx, DWORD PTR _z$237454[ebp]
  05e17	c1 e1 08	 shl	 ecx, 8
  05e1a	03 4d f4	 add	 ecx, DWORD PTR _y$237450[ebp]
  05e1d	8b 90 10 00 00
	00		 mov	 edx, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+16]
  05e23	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  05e27	83 c8 04	 or	 eax, 4
  05e2a	8b 4d ec	 mov	 ecx, DWORD PTR _iMapNumber$237458[ebp]
  05e2d	69 c9 b8 3d 05
	00		 imul	 ecx, 343480		; 00053db8H
  05e33	8b 55 f0	 mov	 edx, DWORD PTR _z$237454[ebp]
  05e36	c1 e2 08	 shl	 edx, 8
  05e39	03 55 f4	 add	 edx, DWORD PTR _y$237450[ebp]
  05e3c	8b 89 10 00 00
	00		 mov	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx+16]
  05e42	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 2191 : 			}

  05e45	eb 96		 jmp	 SHORT $LN2@BlockCastl@3
$LN1@BlockCastl@3:

; 2192 : 		}

  05e47	e9 58 ff ff ff	 jmp	 $LN5@BlockCastl@3
$LN4@BlockCastl@3:

; 2193 : 	}

  05e4c	e9 2a ff ff ff	 jmp	 $LN8@BlockCastl@3
$LN11@BlockCastl@3:

; 2194 : }

  05e51	5f		 pop	 edi
  05e52	5e		 pop	 esi
  05e53	5b		 pop	 ebx
  05e54	8b e5		 mov	 esp, ebp
  05e56	5d		 pop	 ebp
  05e57	c2 04 00	 ret	 4
?BlockCastleDoor@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::BlockCastleDoor
_TEXT	ENDS
PUBLIC	?ReleaseCastleDoor@CBloodCastle@@QAEXH@Z	; CBloodCastle::ReleaseCastleDoor
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv67 = -88						; size = 4
_iMapNumber$237476 = -20				; size = 4
_z$237472 = -16						; size = 4
_y$237468 = -12						; size = 4
_x$237464 = -8						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?ReleaseCastleDoor@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::ReleaseCastleDoor
; _this$ = ecx

; 2198 : {

  05e60	55		 push	 ebp
  05e61	8b ec		 mov	 ebp, esp
  05e63	83 ec 58	 sub	 esp, 88			; 00000058H
  05e66	53		 push	 ebx
  05e67	56		 push	 esi
  05e68	57		 push	 edi
  05e69	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2199 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  05e6c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  05e70	7d 09		 jge	 SHORT $LN13@ReleaseCas@3
  05e72	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  05e79	eb 0c		 jmp	 SHORT $LN14@ReleaseCas@3
$LN13@ReleaseCas@3:
  05e7b	33 c0		 xor	 eax, eax
  05e7d	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  05e81	0f 9e c0	 setle	 al
  05e84	89 45 a8	 mov	 DWORD PTR tv67[ebp], eax
$LN14@ReleaseCas@3:
  05e87	83 7d a8 00	 cmp	 DWORD PTR tv67[ebp], 0
  05e8b	75 05		 jne	 SHORT $LN10@ReleaseCas@3

; 2200 : 	{
; 2201 : 		return;

  05e8d	e9 df 00 00 00	 jmp	 $LN11@ReleaseCas@3
$LN10@ReleaseCas@3:

; 2202 : 	}
; 2203 : 
; 2204 : 	for ( int x=0;x<3;x++)

  05e92	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _x$237464[ebp], 0
  05e99	eb 09		 jmp	 SHORT $LN9@ReleaseCas@3
$LN8@ReleaseCas@3:
  05e9b	8b 45 f8	 mov	 eax, DWORD PTR _x$237464[ebp]
  05e9e	83 c0 01	 add	 eax, 1
  05ea1	89 45 f8	 mov	 DWORD PTR _x$237464[ebp], eax
$LN9@ReleaseCas@3:
  05ea4	83 7d f8 03	 cmp	 DWORD PTR _x$237464[ebp], 3
  05ea8	0f 8d c3 00 00
	00		 jge	 $LN11@ReleaseCas@3

; 2205 : 	{
; 2206 : 		for ( int y=::g_btCastleDoorMapXY[iBridgeIndex][x].btStartX; y <= ::g_btCastleDoorMapXY[iBridgeIndex][x].btEndX ;y++)

  05eae	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  05eb1	6b c0 0c	 imul	 eax, 12			; 0000000cH
  05eb4	8b 4d f8	 mov	 ecx, DWORD PTR _x$237464[ebp]
  05eb7	0f b6 94 88 00
	00 00 00	 movzx	 edx, BYTE PTR _g_btCastleDoorMapXY[eax+ecx*4]
  05ebf	89 55 f4	 mov	 DWORD PTR _y$237468[ebp], edx
  05ec2	eb 09		 jmp	 SHORT $LN6@ReleaseCas@3
$LN5@ReleaseCas@3:
  05ec4	8b 45 f4	 mov	 eax, DWORD PTR _y$237468[ebp]
  05ec7	83 c0 01	 add	 eax, 1
  05eca	89 45 f4	 mov	 DWORD PTR _y$237468[ebp], eax
$LN6@ReleaseCas@3:
  05ecd	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  05ed0	6b c0 0c	 imul	 eax, 12			; 0000000cH
  05ed3	8b 4d f8	 mov	 ecx, DWORD PTR _x$237464[ebp]
  05ed6	0f b6 94 88 02
	00 00 00	 movzx	 edx, BYTE PTR _g_btCastleDoorMapXY[eax+ecx*4+2]
  05ede	39 55 f4	 cmp	 DWORD PTR _y$237468[ebp], edx
  05ee1	0f 8f 85 00 00
	00		 jg	 $LN4@ReleaseCas@3

; 2207 : 		{
; 2208 : 			for ( int z = ::g_btCastleDoorMapXY[iBridgeIndex][x].btStartY; z <= ::g_btCastleDoorMapXY[iBridgeIndex][x].btEndY ; z++)

  05ee7	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  05eea	6b c0 0c	 imul	 eax, 12			; 0000000cH
  05eed	8b 4d f8	 mov	 ecx, DWORD PTR _x$237464[ebp]
  05ef0	0f b6 94 88 01
	00 00 00	 movzx	 edx, BYTE PTR _g_btCastleDoorMapXY[eax+ecx*4+1]
  05ef8	89 55 f0	 mov	 DWORD PTR _z$237472[ebp], edx
  05efb	eb 09		 jmp	 SHORT $LN3@ReleaseCas@3
$LN2@ReleaseCas@3:
  05efd	8b 45 f0	 mov	 eax, DWORD PTR _z$237472[ebp]
  05f00	83 c0 01	 add	 eax, 1
  05f03	89 45 f0	 mov	 DWORD PTR _z$237472[ebp], eax
$LN3@ReleaseCas@3:
  05f06	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  05f09	6b c0 0c	 imul	 eax, 12			; 0000000cH
  05f0c	8b 4d f8	 mov	 ecx, DWORD PTR _x$237464[ebp]
  05f0f	0f b6 94 88 03
	00 00 00	 movzx	 edx, BYTE PTR _g_btCastleDoorMapXY[eax+ecx*4+3]
  05f17	39 55 f0	 cmp	 DWORD PTR _z$237472[ebp], edx
  05f1a	7f 4b		 jg	 SHORT $LN1@ReleaseCas@3

; 2209 : 			{
; 2210 : 				int iMapNumber = this->GetBridgeMapNumber(iBridgeIndex); //season3 add-on

  05f1c	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  05f1f	50		 push	 eax
  05f20	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  05f23	e8 00 00 00 00	 call	 ?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeMapNumber
  05f28	89 45 ec	 mov	 DWORD PTR _iMapNumber$237476[ebp], eax

; 2211 : 
; 2212 : 				MapC[iMapNumber].m_attrbuf[z * 256 + y] &= ~4; //season3 changed

  05f2b	8b 45 ec	 mov	 eax, DWORD PTR _iMapNumber$237476[ebp]
  05f2e	69 c0 b8 3d 05
	00		 imul	 eax, 343480		; 00053db8H
  05f34	8b 4d f0	 mov	 ecx, DWORD PTR _z$237472[ebp]
  05f37	c1 e1 08	 shl	 ecx, 8
  05f3a	03 4d f4	 add	 ecx, DWORD PTR _y$237468[ebp]
  05f3d	8b 90 10 00 00
	00		 mov	 edx, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+16]
  05f43	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  05f47	83 e0 fb	 and	 eax, -5			; fffffffbH
  05f4a	8b 4d ec	 mov	 ecx, DWORD PTR _iMapNumber$237476[ebp]
  05f4d	69 c9 b8 3d 05
	00		 imul	 ecx, 343480		; 00053db8H
  05f53	8b 55 f0	 mov	 edx, DWORD PTR _z$237472[ebp]
  05f56	c1 e2 08	 shl	 edx, 8
  05f59	03 55 f4	 add	 edx, DWORD PTR _y$237468[ebp]
  05f5c	8b 89 10 00 00
	00		 mov	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx+16]
  05f62	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 2213 : 			}

  05f65	eb 96		 jmp	 SHORT $LN2@ReleaseCas@3
$LN1@ReleaseCas@3:

; 2214 : 		}

  05f67	e9 58 ff ff ff	 jmp	 $LN5@ReleaseCas@3
$LN4@ReleaseCas@3:

; 2215 : 	}

  05f6c	e9 2a ff ff ff	 jmp	 $LN8@ReleaseCas@3
$LN11@ReleaseCas@3:

; 2216 : }

  05f71	5f		 pop	 edi
  05f72	5e		 pop	 esi
  05f73	5b		 pop	 ebx
  05f74	8b e5		 mov	 esp, ebp
  05f76	5d		 pop	 ebp
  05f77	c2 04 00	 ret	 4
?ReleaseCastleDoor@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::ReleaseCastleDoor
_TEXT	ENDS
PUBLIC	?BlockSector@CBloodCastle@@IAEXHHHHH@Z		; CBloodCastle::BlockSector
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv68 = -84						; size = 4
tv69 = -80						; size = 4
_j$237490 = -12						; size = 4
_i$237486 = -8						; size = 4
_this$ = -4						; size = 4
_iMAP_NUM$ = 8						; size = 4
_iSTART_X$ = 12						; size = 4
_iSTART_Y$ = 16						; size = 4
_iEND_X$ = 20						; size = 4
_iEND_Y$ = 24						; size = 4
?BlockSector@CBloodCastle@@IAEXHHHHH@Z PROC		; CBloodCastle::BlockSector
; _this$ = ecx

; 2219 : {

  05f80	55		 push	 ebp
  05f81	8b ec		 mov	 ebp, esp
  05f83	83 ec 54	 sub	 esp, 84			; 00000054H
  05f86	53		 push	 ebx
  05f87	56		 push	 esi
  05f88	57		 push	 edi
  05f89	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2220 : 	if ( BC_MAP_RANGE(iMAP_NUM) == FALSE )

  05f8c	83 7d 08 34	 cmp	 DWORD PTR _iMAP_NUM$[ebp], 52 ; 00000034H
  05f90	75 09		 jne	 SHORT $LN12@BlockSecto
  05f92	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  05f99	eb 21		 jmp	 SHORT $LN13@BlockSecto
$LN12@BlockSecto:
  05f9b	83 7d 08 0b	 cmp	 DWORD PTR _iMAP_NUM$[ebp], 11 ; 0000000bH
  05f9f	7d 09		 jge	 SHORT $LN10@BlockSecto
  05fa1	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
  05fa8	eb 0c		 jmp	 SHORT $LN11@BlockSecto
$LN10@BlockSecto:
  05faa	33 c0		 xor	 eax, eax
  05fac	83 7d 08 11	 cmp	 DWORD PTR _iMAP_NUM$[ebp], 17 ; 00000011H
  05fb0	0f 9e c0	 setle	 al
  05fb3	89 45 ac	 mov	 DWORD PTR tv68[ebp], eax
$LN11@BlockSecto:
  05fb6	8b 4d ac	 mov	 ecx, DWORD PTR tv68[ebp]
  05fb9	89 4d b0	 mov	 DWORD PTR tv69[ebp], ecx
$LN13@BlockSecto:
  05fbc	83 7d b0 00	 cmp	 DWORD PTR tv69[ebp], 0
  05fc0	75 02		 jne	 SHORT $LN7@BlockSecto

; 2221 : 	{
; 2222 : 		return;

  05fc2	eb 70		 jmp	 SHORT $LN8@BlockSecto
$LN7@BlockSecto:

; 2223 : 	}
; 2224 : 
; 2225 : 	for ( int i=iSTART_X;i<=iEND_X;i++)

  05fc4	8b 45 0c	 mov	 eax, DWORD PTR _iSTART_X$[ebp]
  05fc7	89 45 f8	 mov	 DWORD PTR _i$237486[ebp], eax
  05fca	eb 09		 jmp	 SHORT $LN6@BlockSecto
$LN5@BlockSecto:
  05fcc	8b 45 f8	 mov	 eax, DWORD PTR _i$237486[ebp]
  05fcf	83 c0 01	 add	 eax, 1
  05fd2	89 45 f8	 mov	 DWORD PTR _i$237486[ebp], eax
$LN6@BlockSecto:
  05fd5	8b 45 f8	 mov	 eax, DWORD PTR _i$237486[ebp]
  05fd8	3b 45 14	 cmp	 eax, DWORD PTR _iEND_X$[ebp]
  05fdb	7f 57		 jg	 SHORT $LN8@BlockSecto

; 2226 : 	{
; 2227 : 		for ( int j=iSTART_Y;j<=iEND_Y;j++ )

  05fdd	8b 45 10	 mov	 eax, DWORD PTR _iSTART_Y$[ebp]
  05fe0	89 45 f4	 mov	 DWORD PTR _j$237490[ebp], eax
  05fe3	eb 09		 jmp	 SHORT $LN3@BlockSecto
$LN2@BlockSecto:
  05fe5	8b 45 f4	 mov	 eax, DWORD PTR _j$237490[ebp]
  05fe8	83 c0 01	 add	 eax, 1
  05feb	89 45 f4	 mov	 DWORD PTR _j$237490[ebp], eax
$LN3@BlockSecto:
  05fee	8b 45 f4	 mov	 eax, DWORD PTR _j$237490[ebp]
  05ff1	3b 45 18	 cmp	 eax, DWORD PTR _iEND_Y$[ebp]
  05ff4	7f 3c		 jg	 SHORT $LN1@BlockSecto

; 2228 : 		{
; 2229 : 			MapC[iMAP_NUM].m_attrbuf[j * 256 + i] |= 4;

  05ff6	8b 45 08	 mov	 eax, DWORD PTR _iMAP_NUM$[ebp]
  05ff9	69 c0 b8 3d 05
	00		 imul	 eax, 343480		; 00053db8H
  05fff	8b 4d f4	 mov	 ecx, DWORD PTR _j$237490[ebp]
  06002	c1 e1 08	 shl	 ecx, 8
  06005	03 4d f8	 add	 ecx, DWORD PTR _i$237486[ebp]
  06008	8b 90 10 00 00
	00		 mov	 edx, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+16]
  0600e	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  06012	83 c8 04	 or	 eax, 4
  06015	8b 4d 08	 mov	 ecx, DWORD PTR _iMAP_NUM$[ebp]
  06018	69 c9 b8 3d 05
	00		 imul	 ecx, 343480		; 00053db8H
  0601e	8b 55 f4	 mov	 edx, DWORD PTR _j$237490[ebp]
  06021	c1 e2 08	 shl	 edx, 8
  06024	03 55 f8	 add	 edx, DWORD PTR _i$237486[ebp]
  06027	8b 89 10 00 00
	00		 mov	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx+16]
  0602d	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 2230 : 		}

  06030	eb b3		 jmp	 SHORT $LN2@BlockSecto
$LN1@BlockSecto:

; 2231 : 	}

  06032	eb 98		 jmp	 SHORT $LN5@BlockSecto
$LN8@BlockSecto:

; 2232 : }

  06034	5f		 pop	 edi
  06035	5e		 pop	 esi
  06036	5b		 pop	 ebx
  06037	8b e5		 mov	 esp, ebp
  06039	5d		 pop	 ebp
  0603a	c2 14 00	 ret	 20			; 00000014H
?BlockSector@CBloodCastle@@IAEXHHHHH@Z ENDP		; CBloodCastle::BlockSector
_TEXT	ENDS
PUBLIC	?ReleaseSector@CBloodCastle@@IAEXHHHHH@Z	; CBloodCastle::ReleaseSector
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv68 = -84						; size = 4
tv69 = -80						; size = 4
_j$237507 = -12						; size = 4
_i$237503 = -8						; size = 4
_this$ = -4						; size = 4
_iMAP_NUM$ = 8						; size = 4
_iSTART_X$ = 12						; size = 4
_iSTART_Y$ = 16						; size = 4
_iEND_X$ = 20						; size = 4
_iEND_Y$ = 24						; size = 4
?ReleaseSector@CBloodCastle@@IAEXHHHHH@Z PROC		; CBloodCastle::ReleaseSector
; _this$ = ecx

; 2235 : {

  06040	55		 push	 ebp
  06041	8b ec		 mov	 ebp, esp
  06043	83 ec 54	 sub	 esp, 84			; 00000054H
  06046	53		 push	 ebx
  06047	56		 push	 esi
  06048	57		 push	 edi
  06049	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2236 : 	if ( BC_MAP_RANGE(iMAP_NUM) == FALSE )

  0604c	83 7d 08 34	 cmp	 DWORD PTR _iMAP_NUM$[ebp], 52 ; 00000034H
  06050	75 09		 jne	 SHORT $LN12@ReleaseSec
  06052	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  06059	eb 21		 jmp	 SHORT $LN13@ReleaseSec
$LN12@ReleaseSec:
  0605b	83 7d 08 0b	 cmp	 DWORD PTR _iMAP_NUM$[ebp], 11 ; 0000000bH
  0605f	7d 09		 jge	 SHORT $LN10@ReleaseSec
  06061	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
  06068	eb 0c		 jmp	 SHORT $LN11@ReleaseSec
$LN10@ReleaseSec:
  0606a	33 c0		 xor	 eax, eax
  0606c	83 7d 08 11	 cmp	 DWORD PTR _iMAP_NUM$[ebp], 17 ; 00000011H
  06070	0f 9e c0	 setle	 al
  06073	89 45 ac	 mov	 DWORD PTR tv68[ebp], eax
$LN11@ReleaseSec:
  06076	8b 4d ac	 mov	 ecx, DWORD PTR tv68[ebp]
  06079	89 4d b0	 mov	 DWORD PTR tv69[ebp], ecx
$LN13@ReleaseSec:
  0607c	83 7d b0 00	 cmp	 DWORD PTR tv69[ebp], 0
  06080	75 02		 jne	 SHORT $LN7@ReleaseSec

; 2237 : 	{
; 2238 : 		return;

  06082	eb 70		 jmp	 SHORT $LN8@ReleaseSec
$LN7@ReleaseSec:

; 2239 : 	}
; 2240 : 
; 2241 : 	for ( int i=iSTART_X;i<=iEND_X;i++)

  06084	8b 45 0c	 mov	 eax, DWORD PTR _iSTART_X$[ebp]
  06087	89 45 f8	 mov	 DWORD PTR _i$237503[ebp], eax
  0608a	eb 09		 jmp	 SHORT $LN6@ReleaseSec
$LN5@ReleaseSec:
  0608c	8b 45 f8	 mov	 eax, DWORD PTR _i$237503[ebp]
  0608f	83 c0 01	 add	 eax, 1
  06092	89 45 f8	 mov	 DWORD PTR _i$237503[ebp], eax
$LN6@ReleaseSec:
  06095	8b 45 f8	 mov	 eax, DWORD PTR _i$237503[ebp]
  06098	3b 45 14	 cmp	 eax, DWORD PTR _iEND_X$[ebp]
  0609b	7f 57		 jg	 SHORT $LN8@ReleaseSec

; 2242 : 	{
; 2243 : 		for ( int j=iSTART_Y;j<=iEND_Y;j++ )

  0609d	8b 45 10	 mov	 eax, DWORD PTR _iSTART_Y$[ebp]
  060a0	89 45 f4	 mov	 DWORD PTR _j$237507[ebp], eax
  060a3	eb 09		 jmp	 SHORT $LN3@ReleaseSec
$LN2@ReleaseSec:
  060a5	8b 45 f4	 mov	 eax, DWORD PTR _j$237507[ebp]
  060a8	83 c0 01	 add	 eax, 1
  060ab	89 45 f4	 mov	 DWORD PTR _j$237507[ebp], eax
$LN3@ReleaseSec:
  060ae	8b 45 f4	 mov	 eax, DWORD PTR _j$237507[ebp]
  060b1	3b 45 18	 cmp	 eax, DWORD PTR _iEND_Y$[ebp]
  060b4	7f 3c		 jg	 SHORT $LN1@ReleaseSec

; 2244 : 		{
; 2245 : 			MapC[iMAP_NUM].m_attrbuf[j * 256 + i] &= ~4;

  060b6	8b 45 08	 mov	 eax, DWORD PTR _iMAP_NUM$[ebp]
  060b9	69 c0 b8 3d 05
	00		 imul	 eax, 343480		; 00053db8H
  060bf	8b 4d f4	 mov	 ecx, DWORD PTR _j$237507[ebp]
  060c2	c1 e1 08	 shl	 ecx, 8
  060c5	03 4d f8	 add	 ecx, DWORD PTR _i$237503[ebp]
  060c8	8b 90 10 00 00
	00		 mov	 edx, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+16]
  060ce	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  060d2	83 e0 fb	 and	 eax, -5			; fffffffbH
  060d5	8b 4d 08	 mov	 ecx, DWORD PTR _iMAP_NUM$[ebp]
  060d8	69 c9 b8 3d 05
	00		 imul	 ecx, 343480		; 00053db8H
  060de	8b 55 f4	 mov	 edx, DWORD PTR _j$237507[ebp]
  060e1	c1 e2 08	 shl	 edx, 8
  060e4	03 55 f8	 add	 edx, DWORD PTR _i$237503[ebp]
  060e7	8b 89 10 00 00
	00		 mov	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx+16]
  060ed	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 2246 : 		}

  060f0	eb b3		 jmp	 SHORT $LN2@ReleaseSec
$LN1@ReleaseSec:

; 2247 : 	}

  060f2	eb 98		 jmp	 SHORT $LN5@ReleaseSec
$LN8@ReleaseSec:

; 2248 : }

  060f4	5f		 pop	 edi
  060f5	5e		 pop	 esi
  060f6	5b		 pop	 ebx
  060f7	8b e5		 mov	 esp, ebp
  060f9	5d		 pop	 ebp
  060fa	c2 14 00	 ret	 20			; 00000014H
?ReleaseSector@CBloodCastle@@IAEXHHHHH@Z ENDP		; CBloodCastle::ReleaseSector
_TEXT	ENDS
PUBLIC	__$ArrayPad$
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv67 = -348						; size = 4
tv80 = -345						; size = 1
_iMapNumber$237529 = -280				; size = 4
_i$237525 = -276					; size = 4
_lpMsgBody$ = -272					; size = 4
_lpMsg$ = -268						; size = 4
_cTEMP_BUF$ = -264					; size = 256
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
_bLive$ = 12						; size = 1
?SendCastleEntranceBlockInfo@CBloodCastle@@QAEXH_N@Z PROC ; CBloodCastle::SendCastleEntranceBlockInfo
; _this$ = ecx

; 2252 : {

  06100	55		 push	 ebp
  06101	8b ec		 mov	 ebp, esp
  06103	81 ec 5c 01 00
	00		 sub	 esp, 348		; 0000015cH
  06109	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0610e	33 c5		 xor	 eax, ebp
  06110	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  06113	53		 push	 ebx
  06114	56		 push	 esi
  06115	57		 push	 edi
  06116	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2253 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  06119	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  0611d	7d 0c		 jge	 SHORT $LN9@SendCastle
  0611f	c7 85 a4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv67[ebp], 0
  06129	eb 0f		 jmp	 SHORT $LN10@SendCastle
$LN9@SendCastle:
  0612b	33 c0		 xor	 eax, eax
  0612d	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  06131	0f 9e c0	 setle	 al
  06134	89 85 a4 fe ff
	ff		 mov	 DWORD PTR tv67[ebp], eax
$LN10@SendCastle:
  0613a	83 bd a4 fe ff
	ff 00		 cmp	 DWORD PTR tv67[ebp], 0
  06141	75 05		 jne	 SHORT $LN6@SendCastle

; 2254 : 	{
; 2255 : 		return;

  06143	e9 5a 01 00 00	 jmp	 $LN7@SendCastle
$LN6@SendCastle:

; 2256 : 	}
; 2257 : 
; 2258 : 	char cTEMP_BUF[256];
; 2259 : 	PMSG_SETMAPATTR_COUNT * lpMsg = (PMSG_SETMAPATTR_COUNT *)cTEMP_BUF;

  06148	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _cTEMP_BUF$[ebp]
  0614e	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _lpMsg$[ebp], eax

; 2260 : 
; 2261 : 	PHeadSetB((LPBYTE)lpMsg, 0x46, sizeof(PMSG_SETMAPATTR_COUNT)+sizeof(PMSG_SETMAPATTR)*6);

  06154	6a 13		 push	 19			; 00000013H
  06156	6a 46		 push	 70			; 00000046H
  06158	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0615e	50		 push	 eax
  0615f	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  06164	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2262 : 	PMSG_SETMAPATTR * lpMsgBody = (PMSG_SETMAPATTR *)&cTEMP_BUF[7];

  06167	8d 85 ff fe ff
	ff		 lea	 eax, DWORD PTR _cTEMP_BUF$[ebp+7]
  0616d	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _lpMsgBody$[ebp], eax

; 2263 : 	lpMsg->btType = 0;

  06173	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06179	c6 40 03 00	 mov	 BYTE PTR [eax+3], 0

; 2264 : 	lpMsg->btCount = 1;

  0617d	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06183	c6 40 06 01	 mov	 BYTE PTR [eax+6], 1

; 2265 : 	lpMsg->btMapAttr = 4;

  06187	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0618d	c6 40 04 04	 mov	 BYTE PTR [eax+4], 4

; 2266 : 	(bLive)?(lpMsg->btMapSetType=0) :( lpMsg->btMapSetType=1);

  06191	0f b6 45 0c	 movzx	 eax, BYTE PTR _bLive$[ebp]
  06195	85 c0		 test	 eax, eax
  06197	74 13		 je	 SHORT $LN11@SendCastle
  06199	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0619f	c6 41 05 00	 mov	 BYTE PTR [ecx+5], 0
  061a3	c6 85 a7 fe ff
	ff 00		 mov	 BYTE PTR tv80[ebp], 0
  061aa	eb 11		 jmp	 SHORT $LN12@SendCastle
$LN11@SendCastle:
  061ac	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _lpMsg$[ebp]
  061b2	c6 42 05 01	 mov	 BYTE PTR [edx+5], 1
  061b6	c6 85 a7 fe ff
	ff 01		 mov	 BYTE PTR tv80[ebp], 1
$LN12@SendCastle:

; 2267 : 
; 2268 : 	lpMsgBody[0].btX = ::g_btCastleEntranceMapXY[iBridgeIndex].btStartX;

  061bd	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsgBody$[ebp]
  061c3	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  061c6	8a 14 8d 00 00
	00 00		 mov	 dl, BYTE PTR _g_btCastleEntranceMapXY[ecx*4]
  061cd	88 10		 mov	 BYTE PTR [eax], dl

; 2269 : 	lpMsgBody[0].btY = ::g_btCastleEntranceMapXY[iBridgeIndex].btStartY;

  061cf	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsgBody$[ebp]
  061d5	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  061d8	8a 14 8d 01 00
	00 00		 mov	 dl, BYTE PTR _g_btCastleEntranceMapXY[ecx*4+1]
  061df	88 50 01	 mov	 BYTE PTR [eax+1], dl

; 2270 : 	lpMsgBody[1].btX   = ::g_btCastleEntranceMapXY[iBridgeIndex].btEndX;

  061e2	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsgBody$[ebp]
  061e8	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  061eb	8a 14 8d 02 00
	00 00		 mov	 dl, BYTE PTR _g_btCastleEntranceMapXY[ecx*4+2]
  061f2	88 50 02	 mov	 BYTE PTR [eax+2], dl

; 2271 : 	lpMsgBody[1].btY   = ::g_btCastleEntranceMapXY[iBridgeIndex].btEndY;

  061f5	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsgBody$[ebp]
  061fb	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  061fe	8a 14 8d 03 00
	00 00		 mov	 dl, BYTE PTR _g_btCastleEntranceMapXY[ecx*4+3]
  06205	88 50 03	 mov	 BYTE PTR [eax+3], dl

; 2272 : 
; 2273 : 	for (int i=OBJ_MAXMONSTER;i<OBJMAX;i++)

  06208	c7 85 ec fe ff
	ff c8 32 00 00	 mov	 DWORD PTR _i$237525[ebp], 13000 ; 000032c8H
  06212	eb 0f		 jmp	 SHORT $LN5@SendCastle
$LN4@SendCastle:
  06214	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _i$237525[ebp]
  0621a	83 c0 01	 add	 eax, 1
  0621d	89 85 ec fe ff
	ff		 mov	 DWORD PTR _i$237525[ebp], eax
$LN5@SendCastle:
  06223	81 bd ec fe ff
	ff 98 3a 00 00	 cmp	 DWORD PTR _i$237525[ebp], 15000 ; 00003a98H
  0622d	7d 73		 jge	 SHORT $LN7@SendCastle

; 2274 : 	{
; 2275 : 		int iMapNumber = this->GetBridgeMapNumber(iBridgeIndex); //season3 add-on

  0622f	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  06232	50		 push	 eax
  06233	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  06236	e8 00 00 00 00	 call	 ?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeMapNumber
  0623b	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _iMapNumber$237529[ebp], eax

; 2276 : 
; 2277 : 		if ( gObj[i].MapNumber == iMapNumber ) //season3 changed

  06241	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _i$237525[ebp]
  06247	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0624d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  06253	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  0625b	3b 95 e8 fe ff
	ff		 cmp	 edx, DWORD PTR _iMapNumber$237529[ebp]
  06261	75 3a		 jne	 SHORT $LN2@SendCastle

; 2278 : 		{
; 2279 : 			if ( gObj[i].Connected > PLAYER_LOGGED )

  06263	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _i$237525[ebp]
  06269	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0626f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  06275	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  0627a	7e 21		 jle	 SHORT $LN2@SendCastle

; 2280 : 			{
; 2281 : 				DataSend(i,(LPBYTE)lpMsg, lpMsg->h.size);

  0627c	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06282	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  06286	51		 push	 ecx
  06287	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _lpMsg$[ebp]
  0628d	52		 push	 edx
  0628e	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _i$237525[ebp]
  06294	50		 push	 eax
  06295	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0629a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@SendCastle:

; 2282 : 			}
; 2283 : 		}
; 2284 : 	}

  0629d	e9 72 ff ff ff	 jmp	 $LN4@SendCastle
$LN7@SendCastle:

; 2285 : 
; 2286 : }

  062a2	5f		 pop	 edi
  062a3	5e		 pop	 esi
  062a4	5b		 pop	 ebx
  062a5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  062a8	33 cd		 xor	 ecx, ebp
  062aa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  062af	8b e5		 mov	 esp, ebp
  062b1	5d		 pop	 ebp
  062b2	c2 08 00	 ret	 8
?SendCastleEntranceBlockInfo@CBloodCastle@@QAEXH_N@Z ENDP ; CBloodCastle::SendCastleEntranceBlockInfo
_TEXT	ENDS
PUBLIC	??_C@_0FI@NGHAEIOD@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5SendC@ ; `string'
PUBLIC	__$ArrayPad$
;	COMDAT ??_C@_0FI@NGHAEIOD@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5SendC@
CONST	SEGMENT
??_C@_0FI@NGHAEIOD@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5SendC@ DB '['
	DB	'Blood Castle][Bug Tracer] SendCastleBridgeBlockInfo-> Bridge:'
	DB	'%d/Live:%d, (%d,%d,%d,%d)', 00H		; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv67 = -348						; size = 4
tv80 = -345						; size = 1
_iMapNumber$237551 = -280				; size = 4
_i$237547 = -276					; size = 4
_lpMsgBody$ = -272					; size = 4
_lpMsg$ = -268						; size = 4
_cTEMP_BUF$ = -264					; size = 256
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
_bLive$ = 12						; size = 1
?SendCastleBridgeBlockInfo@CBloodCastle@@QAEXH_N@Z PROC	; CBloodCastle::SendCastleBridgeBlockInfo
; _this$ = ecx

; 2290 : {

  062c0	55		 push	 ebp
  062c1	8b ec		 mov	 ebp, esp
  062c3	81 ec 5c 01 00
	00		 sub	 esp, 348		; 0000015cH
  062c9	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  062ce	33 c5		 xor	 eax, ebp
  062d0	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  062d3	53		 push	 ebx
  062d4	56		 push	 esi
  062d5	57		 push	 edi
  062d6	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2291 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  062d9	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  062dd	7d 0c		 jge	 SHORT $LN9@SendCastle@2
  062df	c7 85 a4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv67[ebp], 0
  062e9	eb 0f		 jmp	 SHORT $LN10@SendCastle@2
$LN9@SendCastle@2:
  062eb	33 c0		 xor	 eax, eax
  062ed	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  062f1	0f 9e c0	 setle	 al
  062f4	89 85 a4 fe ff
	ff		 mov	 DWORD PTR tv67[ebp], eax
$LN10@SendCastle@2:
  062fa	83 bd a4 fe ff
	ff 00		 cmp	 DWORD PTR tv67[ebp], 0
  06301	75 05		 jne	 SHORT $LN6@SendCastle@2

; 2292 : 	{
; 2293 : 		return;

  06303	e9 a3 01 00 00	 jmp	 $LN7@SendCastle@2
$LN6@SendCastle@2:

; 2294 : 	}
; 2295 : 
; 2296 : 	char cTEMP_BUF[256];
; 2297 : 	PMSG_SETMAPATTR_COUNT * lpMsg = (PMSG_SETMAPATTR_COUNT *)cTEMP_BUF;

  06308	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _cTEMP_BUF$[ebp]
  0630e	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _lpMsg$[ebp], eax

; 2298 : 
; 2299 : 	PHeadSetB((LPBYTE)lpMsg, 0x46, sizeof(PMSG_SETMAPATTR_COUNT)+sizeof(PMSG_SETMAPATTR)*6);

  06314	6a 13		 push	 19			; 00000013H
  06316	6a 46		 push	 70			; 00000046H
  06318	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0631e	50		 push	 eax
  0631f	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  06324	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2300 : 	PMSG_SETMAPATTR * lpMsgBody = (PMSG_SETMAPATTR *)&cTEMP_BUF[7];

  06327	8d 85 ff fe ff
	ff		 lea	 eax, DWORD PTR _cTEMP_BUF$[ebp+7]
  0632d	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _lpMsgBody$[ebp], eax

; 2301 : 	lpMsg->btType = 0;

  06333	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06339	c6 40 03 00	 mov	 BYTE PTR [eax+3], 0

; 2302 : 	lpMsg->btCount = 1;

  0633d	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06343	c6 40 06 01	 mov	 BYTE PTR [eax+6], 1

; 2303 : 	lpMsg->btMapAttr = 8;

  06347	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0634d	c6 40 04 08	 mov	 BYTE PTR [eax+4], 8

; 2304 : 	(bLive)?lpMsg->btMapSetType=0:lpMsg->btMapSetType=1;

  06351	0f b6 45 0c	 movzx	 eax, BYTE PTR _bLive$[ebp]
  06355	85 c0		 test	 eax, eax
  06357	74 13		 je	 SHORT $LN11@SendCastle@2
  06359	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0635f	c6 41 05 00	 mov	 BYTE PTR [ecx+5], 0
  06363	c6 85 a7 fe ff
	ff 00		 mov	 BYTE PTR tv80[ebp], 0
  0636a	eb 11		 jmp	 SHORT $LN12@SendCastle@2
$LN11@SendCastle@2:
  0636c	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _lpMsg$[ebp]
  06372	c6 42 05 01	 mov	 BYTE PTR [edx+5], 1
  06376	c6 85 a7 fe ff
	ff 01		 mov	 BYTE PTR tv80[ebp], 1
$LN12@SendCastle@2:

; 2305 : 
; 2306 : 	lpMsgBody[0].btX = ::g_btCastleEntranceMapXY[iBridgeIndex].btStartX;

  0637d	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsgBody$[ebp]
  06383	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  06386	8a 14 8d 00 00
	00 00		 mov	 dl, BYTE PTR _g_btCastleEntranceMapXY[ecx*4]
  0638d	88 10		 mov	 BYTE PTR [eax], dl

; 2307 : 	lpMsgBody[0].btY = ::g_btCastleEntranceMapXY[iBridgeIndex].btStartY;

  0638f	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsgBody$[ebp]
  06395	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  06398	8a 14 8d 01 00
	00 00		 mov	 dl, BYTE PTR _g_btCastleEntranceMapXY[ecx*4+1]
  0639f	88 50 01	 mov	 BYTE PTR [eax+1], dl

; 2308 : 	lpMsgBody[1].btX   = ::g_btCastleEntranceMapXY[iBridgeIndex].btEndX;

  063a2	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsgBody$[ebp]
  063a8	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  063ab	8a 14 8d 02 00
	00 00		 mov	 dl, BYTE PTR _g_btCastleEntranceMapXY[ecx*4+2]
  063b2	88 50 02	 mov	 BYTE PTR [eax+2], dl

; 2309 : 	lpMsgBody[1].btY   = ::g_btCastleEntranceMapXY[iBridgeIndex].btEndY;

  063b5	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsgBody$[ebp]
  063bb	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  063be	8a 14 8d 03 00
	00 00		 mov	 dl, BYTE PTR _g_btCastleEntranceMapXY[ecx*4+3]
  063c5	88 50 03	 mov	 BYTE PTR [eax+3], dl

; 2310 : 
; 2311 : 	for ( int i=OBJ_MAXMONSTER;i<OBJMAX;i++)

  063c8	c7 85 ec fe ff
	ff c8 32 00 00	 mov	 DWORD PTR _i$237547[ebp], 13000 ; 000032c8H
  063d2	eb 0f		 jmp	 SHORT $LN5@SendCastle@2
$LN4@SendCastle@2:
  063d4	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _i$237547[ebp]
  063da	83 c0 01	 add	 eax, 1
  063dd	89 85 ec fe ff
	ff		 mov	 DWORD PTR _i$237547[ebp], eax
$LN5@SendCastle@2:
  063e3	81 bd ec fe ff
	ff 98 3a 00 00	 cmp	 DWORD PTR _i$237547[ebp], 15000 ; 00003a98H
  063ed	0f 8d b8 00 00
	00		 jge	 $LN7@SendCastle@2

; 2312 : 	{
; 2313 : 		int iMapNumber = this->GetBridgeMapNumber(iBridgeIndex); //season3 add-on

  063f3	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  063f6	50		 push	 eax
  063f7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  063fa	e8 00 00 00 00	 call	 ?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeMapNumber
  063ff	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _iMapNumber$237551[ebp], eax

; 2314 : 
; 2315 : 		if ( gObj[i].MapNumber == iMapNumber ) //season3 changed

  06405	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _i$237547[ebp]
  0640b	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  06411	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  06417	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  0641f	3b 95 e8 fe ff
	ff		 cmp	 edx, DWORD PTR _iMapNumber$237551[ebp]
  06425	75 7f		 jne	 SHORT $LN2@SendCastle@2

; 2316 : 		{
; 2317 : 			if ( gObj[i].Connected > PLAYER_LOGGED )

  06427	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _i$237547[ebp]
  0642d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  06433	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  06439	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  0643e	7e 66		 jle	 SHORT $LN2@SendCastle@2

; 2318 : 			{
; 2319 : 				DataSend(i, (LPBYTE)lpMsg, lpMsg->h.size);

  06440	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06446	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  0644a	51		 push	 ecx
  0644b	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _lpMsg$[ebp]
  06451	52		 push	 edx
  06452	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _i$237547[ebp]
  06458	50		 push	 eax
  06459	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0645e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2320 : 
; 2321 : 				LogAddTD("[Blood Castle][Bug Tracer] SendCastleBridgeBlockInfo-> Bridge:%d/Live:%d, (%d,%d,%d,%d)", iBridgeIndex+1, bLive, lpMsgBody[0].btX, lpMsgBody[0].btY, lpMsgBody[1].btX, lpMsgBody[1].btY);

  06461	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsgBody$[ebp]
  06467	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0646b	51		 push	 ecx
  0646c	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR _lpMsgBody$[ebp]
  06472	0f b6 42 02	 movzx	 eax, BYTE PTR [edx+2]
  06476	50		 push	 eax
  06477	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR _lpMsgBody$[ebp]
  0647d	0f b6 51 01	 movzx	 edx, BYTE PTR [ecx+1]
  06481	52		 push	 edx
  06482	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsgBody$[ebp]
  06488	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0648b	51		 push	 ecx
  0648c	0f b6 55 0c	 movzx	 edx, BYTE PTR _bLive$[ebp]
  06490	52		 push	 edx
  06491	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  06494	83 c0 01	 add	 eax, 1
  06497	50		 push	 eax
  06498	68 00 00 00 00	 push	 OFFSET ??_C@_0FI@NGHAEIOD@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5SendC@
  0649d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  064a3	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN2@SendCastle@2:

; 2322 : 			}
; 2323 : 		}
; 2324 : 	}

  064a6	e9 29 ff ff ff	 jmp	 $LN4@SendCastle@2
$LN7@SendCastle@2:

; 2325 : }

  064ab	5f		 pop	 edi
  064ac	5e		 pop	 esi
  064ad	5b		 pop	 ebx
  064ae	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  064b1	33 cd		 xor	 ecx, ebp
  064b3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  064b8	8b e5		 mov	 esp, ebp
  064ba	5d		 pop	 ebp
  064bb	c2 08 00	 ret	 8
?SendCastleBridgeBlockInfo@CBloodCastle@@QAEXH_N@Z ENDP	; CBloodCastle::SendCastleBridgeBlockInfo
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?SendCastleDoorBlockInfo@CBloodCastle@@QAEXH_N@Z ; CBloodCastle::SendCastleDoorBlockInfo
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv67 = -348						; size = 4
tv80 = -345						; size = 1
_iMapNumber$237574 = -280				; size = 4
_i$237570 = -276					; size = 4
_lpMsgBody$ = -272					; size = 4
_lpMsg$ = -268						; size = 4
_cTEMP_BUF$ = -264					; size = 256
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
_bLive$ = 12						; size = 1
?SendCastleDoorBlockInfo@CBloodCastle@@QAEXH_N@Z PROC	; CBloodCastle::SendCastleDoorBlockInfo
; _this$ = ecx

; 2329 : {

  064c0	55		 push	 ebp
  064c1	8b ec		 mov	 ebp, esp
  064c3	81 ec 5c 01 00
	00		 sub	 esp, 348		; 0000015cH
  064c9	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  064ce	33 c5		 xor	 eax, ebp
  064d0	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  064d3	53		 push	 ebx
  064d4	56		 push	 esi
  064d5	57		 push	 edi
  064d6	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2330 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  064d9	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  064dd	7d 0c		 jge	 SHORT $LN9@SendCastle@3
  064df	c7 85 a4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv67[ebp], 0
  064e9	eb 0f		 jmp	 SHORT $LN10@SendCastle@3
$LN9@SendCastle@3:
  064eb	33 c0		 xor	 eax, eax
  064ed	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  064f1	0f 9e c0	 setle	 al
  064f4	89 85 a4 fe ff
	ff		 mov	 DWORD PTR tv67[ebp], eax
$LN10@SendCastle@3:
  064fa	83 bd a4 fe ff
	ff 00		 cmp	 DWORD PTR tv67[ebp], 0
  06501	75 05		 jne	 SHORT $LN6@SendCastle@3

; 2331 : 	{
; 2332 : 		return;

  06503	e9 0a 02 00 00	 jmp	 $LN7@SendCastle@3
$LN6@SendCastle@3:

; 2333 : 	}
; 2334 : 
; 2335 : 	char cTEMP_BUF[256];
; 2336 : 	PMSG_SETMAPATTR_COUNT * lpMsg = (PMSG_SETMAPATTR_COUNT *)cTEMP_BUF;

  06508	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _cTEMP_BUF$[ebp]
  0650e	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _lpMsg$[ebp], eax

; 2337 : 
; 2338 : 	PHeadSetB((LPBYTE)lpMsg, 0x46, sizeof(PMSG_SETMAPATTR_COUNT)+sizeof(PMSG_SETMAPATTR)*6);

  06514	6a 13		 push	 19			; 00000013H
  06516	6a 46		 push	 70			; 00000046H
  06518	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0651e	50		 push	 eax
  0651f	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  06524	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2339 : 	PMSG_SETMAPATTR * lpMsgBody = (PMSG_SETMAPATTR *)&cTEMP_BUF[7];

  06527	8d 85 ff fe ff
	ff		 lea	 eax, DWORD PTR _cTEMP_BUF$[ebp+7]
  0652d	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _lpMsgBody$[ebp], eax

; 2340 : 	lpMsg->btType = 0;

  06533	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06539	c6 40 03 00	 mov	 BYTE PTR [eax+3], 0

; 2341 : 	lpMsg->btCount = 3;

  0653d	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$[ebp]
  06543	c6 40 06 03	 mov	 BYTE PTR [eax+6], 3

; 2342 : 	lpMsg->btMapAttr = 4;

  06547	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0654d	c6 40 04 04	 mov	 BYTE PTR [eax+4], 4

; 2343 : 	(bLive)?lpMsg->btMapSetType=0:lpMsg->btMapSetType=1;

  06551	0f b6 45 0c	 movzx	 eax, BYTE PTR _bLive$[ebp]
  06555	85 c0		 test	 eax, eax
  06557	74 13		 je	 SHORT $LN11@SendCastle@3
  06559	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0655f	c6 41 05 00	 mov	 BYTE PTR [ecx+5], 0
  06563	c6 85 a7 fe ff
	ff 00		 mov	 BYTE PTR tv80[ebp], 0
  0656a	eb 11		 jmp	 SHORT $LN12@SendCastle@3
$LN11@SendCastle@3:
  0656c	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _lpMsg$[ebp]
  06572	c6 42 05 01	 mov	 BYTE PTR [edx+5], 1
  06576	c6 85 a7 fe ff
	ff 01		 mov	 BYTE PTR tv80[ebp], 1
$LN12@SendCastle@3:

; 2344 : 
; 2345 : 	lpMsgBody[0].btX = ::g_btCastleDoorMapXY[iBridgeIndex][0].btStartX;

  0657d	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  06580	6b c0 0c	 imul	 eax, 12			; 0000000cH
  06583	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR _lpMsgBody$[ebp]
  06589	8a 90 00 00 00
	00		 mov	 dl, BYTE PTR _g_btCastleDoorMapXY[eax]
  0658f	88 11		 mov	 BYTE PTR [ecx], dl

; 2346 : 	lpMsgBody[0].btY = ::g_btCastleDoorMapXY[iBridgeIndex][0].btStartY;

  06591	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  06594	6b c0 0c	 imul	 eax, 12			; 0000000cH
  06597	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR _lpMsgBody$[ebp]
  0659d	8a 90 01 00 00
	00		 mov	 dl, BYTE PTR _g_btCastleDoorMapXY[eax+1]
  065a3	88 51 01	 mov	 BYTE PTR [ecx+1], dl

; 2347 : 	lpMsgBody[1].btX   = ::g_btCastleDoorMapXY[iBridgeIndex][0].btEndX;

  065a6	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  065a9	6b c0 0c	 imul	 eax, 12			; 0000000cH
  065ac	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR _lpMsgBody$[ebp]
  065b2	8a 90 02 00 00
	00		 mov	 dl, BYTE PTR _g_btCastleDoorMapXY[eax+2]
  065b8	88 51 02	 mov	 BYTE PTR [ecx+2], dl

; 2348 : 	lpMsgBody[1].btY   = ::g_btCastleDoorMapXY[iBridgeIndex][0].btEndY;

  065bb	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  065be	6b c0 0c	 imul	 eax, 12			; 0000000cH
  065c1	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR _lpMsgBody$[ebp]
  065c7	8a 90 03 00 00
	00		 mov	 dl, BYTE PTR _g_btCastleDoorMapXY[eax+3]
  065cd	88 51 03	 mov	 BYTE PTR [ecx+3], dl

; 2349 : 
; 2350 : 	lpMsgBody[2].btX = ::g_btCastleDoorMapXY[iBridgeIndex][1].btStartX;

  065d0	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  065d3	6b c0 0c	 imul	 eax, 12			; 0000000cH
  065d6	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR _lpMsgBody$[ebp]
  065dc	8a 90 04 00 00
	00		 mov	 dl, BYTE PTR _g_btCastleDoorMapXY[eax+4]
  065e2	88 51 04	 mov	 BYTE PTR [ecx+4], dl

; 2351 : 	lpMsgBody[2].btY = ::g_btCastleDoorMapXY[iBridgeIndex][1].btStartY;

  065e5	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  065e8	6b c0 0c	 imul	 eax, 12			; 0000000cH
  065eb	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR _lpMsgBody$[ebp]
  065f1	8a 90 05 00 00
	00		 mov	 dl, BYTE PTR _g_btCastleDoorMapXY[eax+5]
  065f7	88 51 05	 mov	 BYTE PTR [ecx+5], dl

; 2352 : 	lpMsgBody[3].btX   = ::g_btCastleDoorMapXY[iBridgeIndex][1].btEndX;

  065fa	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  065fd	6b c0 0c	 imul	 eax, 12			; 0000000cH
  06600	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR _lpMsgBody$[ebp]
  06606	8a 90 06 00 00
	00		 mov	 dl, BYTE PTR _g_btCastleDoorMapXY[eax+6]
  0660c	88 51 06	 mov	 BYTE PTR [ecx+6], dl

; 2353 : 	lpMsgBody[3].btY   = ::g_btCastleDoorMapXY[iBridgeIndex][1].btEndY;

  0660f	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  06612	6b c0 0c	 imul	 eax, 12			; 0000000cH
  06615	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR _lpMsgBody$[ebp]
  0661b	8a 90 07 00 00
	00		 mov	 dl, BYTE PTR _g_btCastleDoorMapXY[eax+7]
  06621	88 51 07	 mov	 BYTE PTR [ecx+7], dl

; 2354 : 
; 2355 : 	lpMsgBody[4].btX = ::g_btCastleDoorMapXY[iBridgeIndex][2].btStartX;

  06624	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  06627	6b c0 0c	 imul	 eax, 12			; 0000000cH
  0662a	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR _lpMsgBody$[ebp]
  06630	8a 90 08 00 00
	00		 mov	 dl, BYTE PTR _g_btCastleDoorMapXY[eax+8]
  06636	88 51 08	 mov	 BYTE PTR [ecx+8], dl

; 2356 : 	lpMsgBody[4].btY = ::g_btCastleDoorMapXY[iBridgeIndex][2].btStartY;

  06639	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0663c	6b c0 0c	 imul	 eax, 12			; 0000000cH
  0663f	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR _lpMsgBody$[ebp]
  06645	8a 90 09 00 00
	00		 mov	 dl, BYTE PTR _g_btCastleDoorMapXY[eax+9]
  0664b	88 51 09	 mov	 BYTE PTR [ecx+9], dl

; 2357 : 	lpMsgBody[5].btX   = ::g_btCastleDoorMapXY[iBridgeIndex][2].btEndX;

  0664e	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  06651	6b c0 0c	 imul	 eax, 12			; 0000000cH
  06654	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR _lpMsgBody$[ebp]
  0665a	8a 90 0a 00 00
	00		 mov	 dl, BYTE PTR _g_btCastleDoorMapXY[eax+10]
  06660	88 51 0a	 mov	 BYTE PTR [ecx+10], dl

; 2358 : 	lpMsgBody[5].btY   = ::g_btCastleDoorMapXY[iBridgeIndex][2].btEndY;

  06663	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  06666	6b c0 0c	 imul	 eax, 12			; 0000000cH
  06669	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR _lpMsgBody$[ebp]
  0666f	8a 90 0b 00 00
	00		 mov	 dl, BYTE PTR _g_btCastleDoorMapXY[eax+11]
  06675	88 51 0b	 mov	 BYTE PTR [ecx+11], dl

; 2359 : 
; 2360 : 	for ( int i=OBJ_MAXMONSTER;i<OBJMAX;i++)

  06678	c7 85 ec fe ff
	ff c8 32 00 00	 mov	 DWORD PTR _i$237570[ebp], 13000 ; 000032c8H
  06682	eb 0f		 jmp	 SHORT $LN5@SendCastle@3
$LN4@SendCastle@3:
  06684	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _i$237570[ebp]
  0668a	83 c0 01	 add	 eax, 1
  0668d	89 85 ec fe ff
	ff		 mov	 DWORD PTR _i$237570[ebp], eax
$LN5@SendCastle@3:
  06693	81 bd ec fe ff
	ff 98 3a 00 00	 cmp	 DWORD PTR _i$237570[ebp], 15000 ; 00003a98H
  0669d	7d 73		 jge	 SHORT $LN7@SendCastle@3

; 2361 : 	{
; 2362 : 		int iMapNumber = this->GetBridgeMapNumber(iBridgeIndex); //season3 add-on

  0669f	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  066a2	50		 push	 eax
  066a3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  066a6	e8 00 00 00 00	 call	 ?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeMapNumber
  066ab	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _iMapNumber$237574[ebp], eax

; 2363 : 
; 2364 : 		if ( gObj[i].MapNumber == iMapNumber ) //season3 changed

  066b1	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _i$237570[ebp]
  066b7	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  066bd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  066c3	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  066cb	3b 95 e8 fe ff
	ff		 cmp	 edx, DWORD PTR _iMapNumber$237574[ebp]
  066d1	75 3a		 jne	 SHORT $LN2@SendCastle@3

; 2365 : 		{
; 2366 : 			if ( gObj[i].Connected > PLAYER_LOGGED )

  066d3	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _i$237570[ebp]
  066d9	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  066df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  066e5	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  066ea	7e 21		 jle	 SHORT $LN2@SendCastle@3

; 2367 : 			{
; 2368 : 				DataSend(i, (LPBYTE)lpMsg, lpMsg->h.size);

  066ec	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$[ebp]
  066f2	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  066f6	51		 push	 ecx
  066f7	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _lpMsg$[ebp]
  066fd	52		 push	 edx
  066fe	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _i$237570[ebp]
  06704	50		 push	 eax
  06705	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0670a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@SendCastle@3:

; 2369 : 			}
; 2370 : 		}
; 2371 : 	}

  0670d	e9 72 ff ff ff	 jmp	 $LN4@SendCastle@3
$LN7@SendCastle@3:

; 2372 : }

  06712	5f		 pop	 edi
  06713	5e		 pop	 esi
  06714	5b		 pop	 ebx
  06715	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  06718	33 cd		 xor	 ecx, ebp
  0671a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0671f	8b e5		 mov	 esp, ebp
  06721	5d		 pop	 ebp
  06722	c2 08 00	 ret	 8
?SendCastleDoorBlockInfo@CBloodCastle@@QAEXH_N@Z ENDP	; CBloodCastle::SendCastleDoorBlockInfo
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?SendNoticeMessage@CBloodCastle@@QAEXHPAD@Z	; CBloodCastle::SendNoticeMessage
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv67 = -352						; size = 4
_i$237585 = -284					; size = 4
_pNotice$ = -280					; size = 272
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
_lpszMSG$ = 12						; size = 4
?SendNoticeMessage@CBloodCastle@@QAEXHPAD@Z PROC	; CBloodCastle::SendNoticeMessage
; _this$ = ecx

; 2375 : {

  06730	55		 push	 ebp
  06731	8b ec		 mov	 ebp, esp
  06733	81 ec 60 01 00
	00		 sub	 esp, 352		; 00000160H
  06739	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0673e	33 c5		 xor	 eax, ebp
  06740	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  06743	53		 push	 ebx
  06744	56		 push	 esi
  06745	57		 push	 edi
  06746	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2376 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  06749	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  0674d	7d 0c		 jge	 SHORT $LN11@SendNotice
  0674f	c7 85 a0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv67[ebp], 0
  06759	eb 0f		 jmp	 SHORT $LN12@SendNotice
$LN11@SendNotice:
  0675b	33 c0		 xor	 eax, eax
  0675d	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  06761	0f 9e c0	 setle	 al
  06764	89 85 a0 fe ff
	ff		 mov	 DWORD PTR tv67[ebp], eax
$LN12@SendNotice:
  0676a	83 bd a0 fe ff
	ff 00		 cmp	 DWORD PTR tv67[ebp], 0
  06771	75 05		 jne	 SHORT $LN8@SendNotice

; 2377 : 	{
; 2378 : 		return;

  06773	e9 3b 01 00 00	 jmp	 $LN9@SendNotice
$LN8@SendNotice:

; 2379 : 	}
; 2380 : 
; 2381 : 	PMSG_NOTICE pNotice;
; 2382 : 
; 2383 : 	TNotice::MakeNoticeMsg( &pNotice, 0, lpszMSG);

  06778	8b 45 0c	 mov	 eax, DWORD PTR _lpszMSG$[ebp]
  0677b	50		 push	 eax
  0677c	6a 00		 push	 0
  0677e	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$[ebp]
  06784	51		 push	 ecx
  06785	e8 00 00 00 00	 call	 ?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z ; TNotice::MakeNoticeMsg
  0678a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2384 : 
; 2385 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  0678d	c7 85 e4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$237585[ebp], 0
  06797	eb 0f		 jmp	 SHORT $LN7@SendNotice
$LN6@SendNotice:
  06799	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _i$237585[ebp]
  0679f	83 c0 01	 add	 eax, 1
  067a2	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _i$237585[ebp], eax
$LN7@SendNotice:
  067a8	83 bd e4 fe ff
	ff 28		 cmp	 DWORD PTR _i$237585[ebp], 40 ; 00000028H
  067af	0f 8d fe 00 00
	00		 jge	 $LN9@SendNotice

; 2386 : 	{
; 2387 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  067b5	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  067b8	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  067be	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  067c1	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  067c5	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _i$237585[ebp]
  067cb	6b c0 14	 imul	 eax, 20			; 00000014H
  067ce	83 7c 02 18 ff	 cmp	 DWORD PTR [edx+eax+24], -1
  067d3	0f 84 d5 00 00
	00		 je	 $LN4@SendNotice

; 2388 : 		{
; 2389 : 			if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected > PLAYER_LOGGED )

  067d9	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  067dc	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  067e2	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  067e5	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  067e9	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _i$237585[ebp]
  067ef	6b c0 14	 imul	 eax, 20			; 00000014H
  067f2	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  067f6	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  067fc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  06802	83 7c 0a 04 02	 cmp	 DWORD PTR [edx+ecx+4], 2
  06807	0f 8e a1 00 00
	00		 jle	 $LN4@SendNotice

; 2390 : 			{
; 2391 : 				if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex != -1 )

  0680d	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  06810	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  06816	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  06819	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0681d	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _i$237585[ebp]
  06823	6b c0 14	 imul	 eax, 20			; 00000014H
  06826	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  0682a	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  06830	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  06836	0f be 84 0a 9e
	0e 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3742]
  0683e	83 f8 ff	 cmp	 eax, -1
  06841	74 6b		 je	 SHORT $LN4@SendNotice

; 2392 : 				{
; 2393 : 					if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex != -1 )

  06843	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  06846	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0684c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0684f	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  06853	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _i$237585[ebp]
  06859	6b c0 14	 imul	 eax, 20			; 00000014H
  0685c	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  06860	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  06866	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0686c	0f be 84 0a 9f
	0e 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3743]
  06874	83 f8 ff	 cmp	 eax, -1
  06877	74 35		 je	 SHORT $LN4@SendNotice

; 2394 : 					{
; 2395 : 						DataSend(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, (LPBYTE)&pNotice, pNotice.h.size);

  06879	0f b6 85 e9 fe
	ff ff		 movzx	 eax, BYTE PTR _pNotice$[ebp+1]
  06880	50		 push	 eax
  06881	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$[ebp]
  06887	51		 push	 ecx
  06888	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  0688b	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  06891	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  06894	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  06898	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR _i$237585[ebp]
  0689e	6b d2 14	 imul	 edx, 20			; 00000014H
  068a1	8b 44 11 18	 mov	 eax, DWORD PTR [ecx+edx+24]
  068a5	50		 push	 eax
  068a6	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  068ab	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@SendNotice:

; 2396 : 					}
; 2397 : 				}
; 2398 : 			}
; 2399 : 		}
; 2400 : 	}

  068ae	e9 e6 fe ff ff	 jmp	 $LN6@SendNotice
$LN9@SendNotice:

; 2401 : }

  068b3	5f		 pop	 edi
  068b4	5e		 pop	 esi
  068b5	5b		 pop	 ebx
  068b6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  068b9	33 cd		 xor	 ecx, ebp
  068bb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  068c0	8b e5		 mov	 esp, ebp
  068c2	5d		 pop	 ebp
  068c3	c2 08 00	 ret	 8
?SendNoticeMessage@CBloodCastle@@QAEXHPAD@Z ENDP	; CBloodCastle::SendNoticeMessage
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?SendNoticeScore@CBloodCastle@@QAEXH@Z		; CBloodCastle::SendNoticeScore
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv67 = -352						; size = 4
_i$237600 = -284					; size = 4
_pNotice$ = -280					; size = 272
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
?SendNoticeScore@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::SendNoticeScore
; _this$ = ecx

; 2404 : {

  068d0	55		 push	 ebp
  068d1	8b ec		 mov	 ebp, esp
  068d3	81 ec 60 01 00
	00		 sub	 esp, 352		; 00000160H
  068d9	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  068de	33 c5		 xor	 eax, ebp
  068e0	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  068e3	53		 push	 ebx
  068e4	56		 push	 esi
  068e5	57		 push	 edi
  068e6	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2405 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  068e9	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  068ed	7d 0c		 jge	 SHORT $LN11@SendNotice@2
  068ef	c7 85 a0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv67[ebp], 0
  068f9	eb 0f		 jmp	 SHORT $LN12@SendNotice@2
$LN11@SendNotice@2:
  068fb	33 c0		 xor	 eax, eax
  068fd	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  06901	0f 9e c0	 setle	 al
  06904	89 85 a0 fe ff
	ff		 mov	 DWORD PTR tv67[ebp], eax
$LN12@SendNotice@2:
  0690a	83 bd a0 fe ff
	ff 00		 cmp	 DWORD PTR tv67[ebp], 0
  06911	75 05		 jne	 SHORT $LN8@SendNotice@2

; 2406 : 	{
; 2407 : 		return;

  06913	e9 77 01 00 00	 jmp	 $LN9@SendNotice@2
$LN8@SendNotice@2:

; 2408 : 	}
; 2409 : 
; 2410 : 	PMSG_NOTICE pNotice;
; 2411 : 	pNotice.type = 0;

  06918	c6 85 eb fe ff
	ff 00		 mov	 BYTE PTR _pNotice$[ebp+3], 0

; 2412 : 
; 2413 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  0691f	c7 85 e4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$237600[ebp], 0
  06929	eb 0f		 jmp	 SHORT $LN7@SendNotice@2
$LN6@SendNotice@2:
  0692b	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _i$237600[ebp]
  06931	83 c0 01	 add	 eax, 1
  06934	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _i$237600[ebp], eax
$LN7@SendNotice@2:
  0693a	83 bd e4 fe ff
	ff 28		 cmp	 DWORD PTR _i$237600[ebp], 40 ; 00000028H
  06941	0f 8d 48 01 00
	00		 jge	 $LN9@SendNotice@2

; 2414 : 	{
; 2415 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  06947	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0694a	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  06950	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  06953	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  06957	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _i$237600[ebp]
  0695d	6b c0 14	 imul	 eax, 20			; 00000014H
  06960	83 7c 02 18 ff	 cmp	 DWORD PTR [edx+eax+24], -1
  06965	0f 84 1f 01 00
	00		 je	 $LN4@SendNotice@2

; 2416 : 		{
; 2417 : 			if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected > PLAYER_LOGGED )

  0696b	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0696e	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  06974	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  06977	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0697b	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _i$237600[ebp]
  06981	6b c0 14	 imul	 eax, 20			; 00000014H
  06984	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  06988	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0698e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  06994	83 7c 0a 04 02	 cmp	 DWORD PTR [edx+ecx+4], 2
  06999	0f 8e eb 00 00
	00		 jle	 $LN4@SendNotice@2

; 2418 : 			{
; 2419 : 				if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex != -1 )

  0699f	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  069a2	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  069a8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  069ab	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  069af	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _i$237600[ebp]
  069b5	6b c0 14	 imul	 eax, 20			; 00000014H
  069b8	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  069bc	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  069c2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  069c8	0f be 84 0a 9e
	0e 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3742]
  069d0	83 f8 ff	 cmp	 eax, -1
  069d3	0f 84 b1 00 00
	00		 je	 $LN4@SendNotice@2

; 2420 : 				{
; 2421 : 					if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex != -1 )

  069d9	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  069dc	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  069e2	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  069e5	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  069e9	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _i$237600[ebp]
  069ef	6b c0 14	 imul	 eax, 20			; 00000014H
  069f2	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  069f6	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  069fc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  06a02	0f be 84 0a 9f
	0e 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3743]
  06a0a	83 f8 ff	 cmp	 eax, -1
  06a0d	74 7b		 je	 SHORT $LN4@SendNotice@2

; 2422 : 					{
; 2423 : 						TNotice::MakeNoticeMsgEx(&pNotice, 0, lMsg.Get(MSGGET(4, 140)), iBridgeIndex+1, this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iEXP);

  06a0f	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  06a12	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  06a18	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  06a1b	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  06a1f	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _i$237600[ebp]
  06a25	6b c0 14	 imul	 eax, 20			; 00000014H
  06a28	8b 4c 02 1c	 mov	 ecx, DWORD PTR [edx+eax+28]
  06a2c	51		 push	 ecx
  06a2d	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  06a30	83 c2 01	 add	 edx, 1
  06a33	52		 push	 edx
  06a34	68 8c 04 00 00	 push	 1164			; 0000048cH
  06a39	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  06a3e	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  06a43	50		 push	 eax
  06a44	6a 00		 push	 0
  06a46	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$[ebp]
  06a4c	50		 push	 eax
  06a4d	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx
  06a52	83 c4 14	 add	 esp, 20			; 00000014H

; 2424 : 						DataSend(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, (LPBYTE)&pNotice, pNotice.h.size);

  06a55	0f b6 85 e9 fe
	ff ff		 movzx	 eax, BYTE PTR _pNotice$[ebp+1]
  06a5c	50		 push	 eax
  06a5d	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$[ebp]
  06a63	51		 push	 ecx
  06a64	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  06a67	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  06a6d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  06a70	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  06a74	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR _i$237600[ebp]
  06a7a	6b d2 14	 imul	 edx, 20			; 00000014H
  06a7d	8b 44 11 18	 mov	 eax, DWORD PTR [ecx+edx+24]
  06a81	50		 push	 eax
  06a82	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  06a87	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@SendNotice@2:

; 2425 : 					}
; 2426 : 				}
; 2427 : 			}
; 2428 : 		}
; 2429 : 	}

  06a8a	e9 9c fe ff ff	 jmp	 $LN6@SendNotice@2
$LN9@SendNotice@2:

; 2430 : }

  06a8f	5f		 pop	 edi
  06a90	5e		 pop	 esi
  06a91	5b		 pop	 ebx
  06a92	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  06a95	33 cd		 xor	 ecx, ebp
  06a97	e8 00 00 00 00	 call	 @__security_check_cookie@4
  06a9c	8b e5		 mov	 esp, ebp
  06a9e	5d		 pop	 ebp
  06a9f	c2 04 00	 ret	 4
?SendNoticeScore@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::SendNoticeScore
_TEXT	ENDS
PUBLIC	__$ArrayPad$
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv67 = -96						; size = 4
_i$237620 = -28						; size = 4
_pMsg$ = -24						; size = 14
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
_iPlayState$ = 12					; size = 4
?SendNoticeState@CBloodCastle@@QAEXHH@Z PROC		; CBloodCastle::SendNoticeState
; _this$ = ecx

; 2433 : {

  06ab0	55		 push	 ebp
  06ab1	8b ec		 mov	 ebp, esp
  06ab3	83 ec 60	 sub	 esp, 96			; 00000060H
  06ab6	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  06abb	33 c5		 xor	 eax, ebp
  06abd	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  06ac0	53		 push	 ebx
  06ac1	56		 push	 esi
  06ac2	57		 push	 edi
  06ac3	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2434 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  06ac6	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  06aca	7d 09		 jge	 SHORT $LN13@SendNotice@3
  06acc	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  06ad3	eb 0c		 jmp	 SHORT $LN14@SendNotice@3
$LN13@SendNotice@3:
  06ad5	33 c0		 xor	 eax, eax
  06ad7	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  06adb	0f 9e c0	 setle	 al
  06ade	89 45 a0	 mov	 DWORD PTR tv67[ebp], eax
$LN14@SendNotice@3:
  06ae1	83 7d a0 00	 cmp	 DWORD PTR tv67[ebp], 0
  06ae5	75 05		 jne	 SHORT $LN10@SendNotice@3

; 2435 : 	{
; 2436 : 		return;

  06ae7	e9 d7 01 00 00	 jmp	 $LN11@SendNotice@3
$LN10@SendNotice@3:

; 2437 : 	}
; 2438 : 
; 2439 : 	PMSG_STATEBLOODCASTLE pMsg;
; 2440 : 
; 2441 : 	PHeadSetB((LPBYTE)&pMsg, 0x9B, sizeof(PMSG_STATEBLOODCASTLE));

  06aec	6a 0e		 push	 14			; 0000000eH
  06aee	68 9b 00 00 00	 push	 155			; 0000009bH
  06af3	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  06af6	50		 push	 eax
  06af7	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  06afc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2442 : 	pMsg.btPlayState = iPlayState;

  06aff	8a 45 0c	 mov	 al, BYTE PTR _iPlayState$[ebp]
  06b02	88 45 eb	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 2443 : 	pMsg.wRemainSec = this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 1000;

  06b05	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  06b08	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  06b0e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  06b11	8b 84 01 ac 03
	00 00		 mov	 eax, DWORD PTR [ecx+eax+940]
  06b18	99		 cdq
  06b19	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  06b1e	f7 f9		 idiv	 ecx
  06b20	66 89 45 ec	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 2444 : 
; 2445 : 	if ( iPlayState == 4 )

  06b24	83 7d 0c 04	 cmp	 DWORD PTR _iPlayState$[ebp], 4
  06b28	75 32		 jne	 SHORT $LN9@SendNotice@3

; 2446 : 	{
; 2447 : 		pMsg.wMaxKillMonster = this->m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_MAX_COUNT;

  06b2a	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  06b2d	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  06b33	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  06b36	66 8b 94 01 dc
	03 00 00	 mov	 dx, WORD PTR [ecx+eax+988]
  06b3e	66 89 55 ee	 mov	 WORD PTR _pMsg$[ebp+6], dx

; 2448 : 		pMsg.wCurKillMonster = this->m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_KILL_COUNT;

  06b42	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  06b45	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  06b4b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  06b4e	66 8b 94 01 e0
	03 00 00	 mov	 dx, WORD PTR [ecx+eax+992]
  06b56	66 89 55 f0	 mov	 WORD PTR _pMsg$[ebp+8], dx

; 2449 : 	}
; 2450 : 	else

  06b5a	eb 30		 jmp	 SHORT $LN8@SendNotice@3
$LN9@SendNotice@3:

; 2451 : 	{
; 2452 : 		pMsg.wMaxKillMonster = this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_MAX_COUNT;

  06b5c	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  06b5f	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  06b65	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  06b68	66 8b 94 01 cc
	03 00 00	 mov	 dx, WORD PTR [ecx+eax+972]
  06b70	66 89 55 ee	 mov	 WORD PTR _pMsg$[ebp+6], dx

; 2453 : 		pMsg.wCurKillMonster = this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_KILL_COUNT;

  06b74	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  06b77	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  06b7d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  06b80	66 8b 94 01 d0
	03 00 00	 mov	 dx, WORD PTR [ecx+eax+976]
  06b88	66 89 55 f0	 mov	 WORD PTR _pMsg$[ebp+8], dx
$LN8@SendNotice@3:

; 2454 : 	}
; 2455 : 
; 2456 : 	pMsg.wUserHaveWeapon = this->m_BridgeData[iBridgeIndex].m_iBC_QUEST_ITEM_USER_INDEX;

  06b8c	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  06b8f	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  06b95	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  06b98	66 8b 94 01 ec
	03 00 00	 mov	 dx, WORD PTR [ecx+eax+1004]
  06ba0	66 89 55 f2	 mov	 WORD PTR _pMsg$[ebp+10], dx

; 2457 : 	pMsg.btWeaponNum = this->m_BridgeData[iBridgeIndex].m_btBC_QUEST_ITEM_NUMBER + 1;

  06ba4	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  06ba7	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  06bad	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  06bb0	0f b6 94 01 f0
	03 00 00	 movzx	 edx, BYTE PTR [ecx+eax+1008]
  06bb8	83 c2 01	 add	 edx, 1
  06bbb	88 55 f4	 mov	 BYTE PTR _pMsg$[ebp+12], dl

; 2458 : 
; 2459 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  06bbe	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _i$237620[ebp], 0
  06bc5	eb 09		 jmp	 SHORT $LN7@SendNotice@3
$LN6@SendNotice@3:
  06bc7	8b 45 e4	 mov	 eax, DWORD PTR _i$237620[ebp]
  06bca	83 c0 01	 add	 eax, 1
  06bcd	89 45 e4	 mov	 DWORD PTR _i$237620[ebp], eax
$LN7@SendNotice@3:
  06bd0	83 7d e4 28	 cmp	 DWORD PTR _i$237620[ebp], 40 ; 00000028H
  06bd4	0f 8d e9 00 00
	00		 jge	 $LN11@SendNotice@3

; 2460 : 	{
; 2461 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  06bda	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  06bdd	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  06be3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  06be6	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  06bea	8b 45 e4	 mov	 eax, DWORD PTR _i$237620[ebp]
  06bed	6b c0 14	 imul	 eax, 20			; 00000014H
  06bf0	83 7c 02 18 ff	 cmp	 DWORD PTR [edx+eax+24], -1
  06bf5	0f 84 c3 00 00
	00		 je	 $LN4@SendNotice@3

; 2462 : 		{
; 2463 : 			if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected > PLAYER_LOGGED )

  06bfb	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  06bfe	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  06c04	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  06c07	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  06c0b	8b 45 e4	 mov	 eax, DWORD PTR _i$237620[ebp]
  06c0e	6b c0 14	 imul	 eax, 20			; 00000014H
  06c11	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  06c15	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  06c1b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  06c21	83 7c 0a 04 02	 cmp	 DWORD PTR [edx+ecx+4], 2
  06c26	0f 8e 92 00 00
	00		 jle	 $LN4@SendNotice@3

; 2464 : 			{
; 2465 : 				if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex != -1 )

  06c2c	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  06c2f	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  06c35	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  06c38	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  06c3c	8b 45 e4	 mov	 eax, DWORD PTR _i$237620[ebp]
  06c3f	6b c0 14	 imul	 eax, 20			; 00000014H
  06c42	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  06c46	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  06c4c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  06c52	0f be 84 0a 9e
	0e 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3742]
  06c5a	83 f8 ff	 cmp	 eax, -1
  06c5d	74 5f		 je	 SHORT $LN4@SendNotice@3

; 2466 : 				{
; 2467 : 					if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex != -1 )

  06c5f	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  06c62	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  06c68	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  06c6b	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  06c6f	8b 45 e4	 mov	 eax, DWORD PTR _i$237620[ebp]
  06c72	6b c0 14	 imul	 eax, 20			; 00000014H
  06c75	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  06c79	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  06c7f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  06c85	0f be 84 0a 9f
	0e 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3743]
  06c8d	83 f8 ff	 cmp	 eax, -1
  06c90	74 2c		 je	 SHORT $LN4@SendNotice@3

; 2468 : 					{
; 2469 : 						DataSend(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, (LPBYTE)&pMsg, pMsg.h.size);

  06c92	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  06c96	50		 push	 eax
  06c97	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  06c9a	51		 push	 ecx
  06c9b	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  06c9e	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  06ca4	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  06ca7	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  06cab	8b 55 e4	 mov	 edx, DWORD PTR _i$237620[ebp]
  06cae	6b d2 14	 imul	 edx, 20			; 00000014H
  06cb1	8b 44 11 18	 mov	 eax, DWORD PTR [ecx+edx+24]
  06cb5	50		 push	 eax
  06cb6	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  06cbb	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@SendNotice@3:

; 2470 : 					}
; 2471 : 				}
; 2472 : 			}
; 2473 : 		}
; 2474 : 	}

  06cbe	e9 04 ff ff ff	 jmp	 $LN6@SendNotice@3
$LN11@SendNotice@3:

; 2475 : }

  06cc3	5f		 pop	 edi
  06cc4	5e		 pop	 esi
  06cc5	5b		 pop	 ebx
  06cc6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  06cc9	33 cd		 xor	 ecx, ebp
  06ccb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  06cd0	8b e5		 mov	 esp, ebp
  06cd2	5d		 pop	 ebp
  06cd3	c2 08 00	 ret	 8
?SendNoticeState@CBloodCastle@@QAEXHH@Z ENDP		; CBloodCastle::SendNoticeState
_TEXT	ENDS
PUBLIC	?CheckUserBridgeMember@CBloodCastle@@QAE_NHH@Z	; CBloodCastle::CheckUserBridgeMember
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv72 = -76						; size = 4
tv67 = -76						; size = 4
_i$237636 = -8						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
_iIndex$ = 12						; size = 4
?CheckUserBridgeMember@CBloodCastle@@QAE_NHH@Z PROC	; CBloodCastle::CheckUserBridgeMember
; _this$ = ecx

; 2478 : {

  06ce0	55		 push	 ebp
  06ce1	8b ec		 mov	 ebp, esp
  06ce3	83 ec 4c	 sub	 esp, 76			; 0000004cH
  06ce6	53		 push	 ebx
  06ce7	56		 push	 esi
  06ce8	57		 push	 edi
  06ce9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2479 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  06cec	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  06cf0	7d 09		 jge	 SHORT $LN9@CheckUserB
  06cf2	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  06cf9	eb 0c		 jmp	 SHORT $LN10@CheckUserB
$LN9@CheckUserB:
  06cfb	33 c0		 xor	 eax, eax
  06cfd	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  06d01	0f 9e c0	 setle	 al
  06d04	89 45 b4	 mov	 DWORD PTR tv67[ebp], eax
$LN10@CheckUserB:
  06d07	83 7d b4 00	 cmp	 DWORD PTR tv67[ebp], 0
  06d0b	75 04		 jne	 SHORT $LN6@CheckUserB

; 2480 : 	{
; 2481 : 		return false;

  06d0d	32 c0		 xor	 al, al
  06d0f	eb 67		 jmp	 SHORT $LN7@CheckUserB
$LN6@CheckUserB:

; 2482 : 	}
; 2483 : 
; 2484 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  06d11	83 7d 0c 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  06d15	7d 09		 jge	 SHORT $LN11@CheckUserB
  06d17	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], 0
  06d1e	eb 0f		 jmp	 SHORT $LN12@CheckUserB
$LN11@CheckUserB:
  06d20	33 c0		 xor	 eax, eax
  06d22	81 7d 0c 97 3a
	00 00		 cmp	 DWORD PTR _iIndex$[ebp], 14999 ; 00003a97H
  06d29	0f 9e c0	 setle	 al
  06d2c	89 45 b4	 mov	 DWORD PTR tv72[ebp], eax
$LN12@CheckUserB:
  06d2f	83 7d b4 00	 cmp	 DWORD PTR tv72[ebp], 0
  06d33	75 04		 jne	 SHORT $LN5@CheckUserB

; 2485 : 	{
; 2486 : 		return false;

  06d35	32 c0		 xor	 al, al
  06d37	eb 3f		 jmp	 SHORT $LN7@CheckUserB
$LN5@CheckUserB:

; 2487 : 	}
; 2488 : 
; 2489 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  06d39	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$237636[ebp], 0
  06d40	eb 09		 jmp	 SHORT $LN4@CheckUserB
$LN3@CheckUserB:
  06d42	8b 45 f8	 mov	 eax, DWORD PTR _i$237636[ebp]
  06d45	83 c0 01	 add	 eax, 1
  06d48	89 45 f8	 mov	 DWORD PTR _i$237636[ebp], eax
$LN4@CheckUserB:
  06d4b	83 7d f8 28	 cmp	 DWORD PTR _i$237636[ebp], 40 ; 00000028H
  06d4f	7d 25		 jge	 SHORT $LN2@CheckUserB

; 2490 : 	{
; 2491 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == iIndex )

  06d51	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  06d54	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  06d5a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  06d5d	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  06d61	8b 45 f8	 mov	 eax, DWORD PTR _i$237636[ebp]
  06d64	6b c0 14	 imul	 eax, 20			; 00000014H
  06d67	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  06d6b	3b 4d 0c	 cmp	 ecx, DWORD PTR _iIndex$[ebp]
  06d6e	75 04		 jne	 SHORT $LN1@CheckUserB

; 2492 : 		{
; 2493 : 			return true;

  06d70	b0 01		 mov	 al, 1
  06d72	eb 04		 jmp	 SHORT $LN7@CheckUserB
$LN1@CheckUserB:

; 2494 : 		}
; 2495 : 	}

  06d74	eb cc		 jmp	 SHORT $LN3@CheckUserB
$LN2@CheckUserB:

; 2496 : 
; 2497 : 	return false;

  06d76	32 c0		 xor	 al, al
$LN7@CheckUserB:

; 2498 : }

  06d78	5f		 pop	 edi
  06d79	5e		 pop	 esi
  06d7a	5b		 pop	 ebx
  06d7b	8b e5		 mov	 esp, ebp
  06d7d	5d		 pop	 ebp
  06d7e	c2 08 00	 ret	 8
?CheckUserBridgeMember@CBloodCastle@@QAE_NHH@Z ENDP	; CBloodCastle::CheckUserBridgeMember
_TEXT	ENDS
PUBLIC	?GetAliveUserTotalEXP@CBloodCastle@@IAEHH@Z	; CBloodCastle::GetAliveUserTotalEXP
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv154 = -84						; size = 4
tv155 = -80						; size = 4
tv67 = -80						; size = 4
_i$237647 = -12						; size = 4
_iRET_EXP$ = -8						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?GetAliveUserTotalEXP@CBloodCastle@@IAEHH@Z PROC	; CBloodCastle::GetAliveUserTotalEXP
; _this$ = ecx

; 2501 : {

  06d90	55		 push	 ebp
  06d91	8b ec		 mov	 ebp, esp
  06d93	83 ec 54	 sub	 esp, 84			; 00000054H
  06d96	53		 push	 ebx
  06d97	56		 push	 esi
  06d98	57		 push	 edi
  06d99	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2502 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  06d9c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  06da0	7d 09		 jge	 SHORT $LN10@GetAliveUs
  06da2	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  06da9	eb 0c		 jmp	 SHORT $LN11@GetAliveUs
$LN10@GetAliveUs:
  06dab	33 c0		 xor	 eax, eax
  06dad	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  06db1	0f 9e c0	 setle	 al
  06db4	89 45 b0	 mov	 DWORD PTR tv67[ebp], eax
$LN11@GetAliveUs:
  06db7	83 7d b0 00	 cmp	 DWORD PTR tv67[ebp], 0
  06dbb	75 07		 jne	 SHORT $LN7@GetAliveUs

; 2503 : 	{
; 2504 : 		return 0;

  06dbd	33 c0		 xor	 eax, eax
  06dbf	e9 59 01 00 00	 jmp	 $LN8@GetAliveUs
$LN7@GetAliveUs:

; 2505 : 	}
; 2506 : 
; 2507 : 	int iRET_EXP = 0;

  06dc4	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iRET_EXP$[ebp], 0

; 2508 : 
; 2509 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  06dcb	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$237647[ebp], 0
  06dd2	eb 09		 jmp	 SHORT $LN6@GetAliveUs
$LN5@GetAliveUs:
  06dd4	8b 45 f4	 mov	 eax, DWORD PTR _i$237647[ebp]
  06dd7	83 c0 01	 add	 eax, 1
  06dda	89 45 f4	 mov	 DWORD PTR _i$237647[ebp], eax
$LN6@GetAliveUs:
  06ddd	83 7d f4 28	 cmp	 DWORD PTR _i$237647[ebp], 40 ; 00000028H
  06de1	0f 8d 33 01 00
	00		 jge	 $LN4@GetAliveUs

; 2510 : 	{
; 2511 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  06de7	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  06dea	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  06df0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  06df3	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  06df7	8b 45 f4	 mov	 eax, DWORD PTR _i$237647[ebp]
  06dfa	6b c0 14	 imul	 eax, 20			; 00000014H
  06dfd	83 7c 02 18 ff	 cmp	 DWORD PTR [edx+eax+24], -1
  06e02	0f 84 0d 01 00
	00		 je	 $LN3@GetAliveUs

; 2512 : 		{
; 2513 : 			if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected > PLAYER_LOGGED )

  06e08	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  06e0b	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  06e11	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  06e14	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  06e18	8b 45 f4	 mov	 eax, DWORD PTR _i$237647[ebp]
  06e1b	6b c0 14	 imul	 eax, 20			; 00000014H
  06e1e	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  06e22	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  06e28	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  06e2e	83 7c 0a 04 02	 cmp	 DWORD PTR [edx+ecx+4], 2
  06e33	0f 8e dc 00 00
	00		 jle	 $LN3@GetAliveUs

; 2514 : 			{
; 2515 : 				if ( BC_MAP_RANGE(gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber) != FALSE )

  06e39	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  06e3c	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  06e42	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  06e45	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  06e49	8b 45 f4	 mov	 eax, DWORD PTR _i$237647[ebp]
  06e4c	6b c0 14	 imul	 eax, 20			; 00000014H
  06e4f	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  06e53	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  06e59	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  06e5f	0f b6 84 0a 49
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+329]
  06e67	83 f8 34	 cmp	 eax, 52			; 00000034H
  06e6a	75 09		 jne	 SHORT $LN14@GetAliveUs
  06e6c	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv155[ebp], 1
  06e73	eb 7a		 jmp	 SHORT $LN15@GetAliveUs
$LN14@GetAliveUs:
  06e75	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  06e78	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  06e7e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  06e81	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  06e85	8b 4d f4	 mov	 ecx, DWORD PTR _i$237647[ebp]
  06e88	6b c9 14	 imul	 ecx, 20			; 00000014H
  06e8b	8b 54 08 18	 mov	 edx, DWORD PTR [eax+ecx+24]
  06e8f	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  06e95	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  06e9a	0f b6 8c 10 49
	01 00 00	 movzx	 ecx, BYTE PTR [eax+edx+329]
  06ea2	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  06ea5	7d 09		 jge	 SHORT $LN12@GetAliveUs
  06ea7	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv154[ebp], 0
  06eae	eb 39		 jmp	 SHORT $LN13@GetAliveUs
$LN12@GetAliveUs:
  06eb0	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  06eb3	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  06eb9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  06ebc	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  06ec0	8b 55 f4	 mov	 edx, DWORD PTR _i$237647[ebp]
  06ec3	6b d2 14	 imul	 edx, 20			; 00000014H
  06ec6	8b 44 11 18	 mov	 eax, DWORD PTR [ecx+edx+24]
  06eca	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  06ed0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  06ed6	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  06ede	33 c0		 xor	 eax, eax
  06ee0	83 fa 11	 cmp	 edx, 17			; 00000011H
  06ee3	0f 9e c0	 setle	 al
  06ee6	89 45 ac	 mov	 DWORD PTR tv154[ebp], eax
$LN13@GetAliveUs:
  06ee9	8b 4d ac	 mov	 ecx, DWORD PTR tv154[ebp]
  06eec	89 4d b0	 mov	 DWORD PTR tv155[ebp], ecx
$LN15@GetAliveUs:
  06eef	83 7d b0 00	 cmp	 DWORD PTR tv155[ebp], 0
  06ef3	74 20		 je	 SHORT $LN3@GetAliveUs

; 2516 : 				{
; 2517 : 					iRET_EXP += this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iEXP;

  06ef5	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  06ef8	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  06efe	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  06f01	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  06f05	8b 45 f4	 mov	 eax, DWORD PTR _i$237647[ebp]
  06f08	6b c0 14	 imul	 eax, 20			; 00000014H
  06f0b	8b 4d f8	 mov	 ecx, DWORD PTR _iRET_EXP$[ebp]
  06f0e	03 4c 02 1c	 add	 ecx, DWORD PTR [edx+eax+28]
  06f12	89 4d f8	 mov	 DWORD PTR _iRET_EXP$[ebp], ecx
$LN3@GetAliveUs:

; 2518 : 				}
; 2519 : 			}
; 2520 : 		}
; 2521 : 	}

  06f15	e9 ba fe ff ff	 jmp	 $LN5@GetAliveUs
$LN4@GetAliveUs:

; 2522 : 
; 2523 : 	return iRET_EXP;

  06f1a	8b 45 f8	 mov	 eax, DWORD PTR _iRET_EXP$[ebp]
$LN8@GetAliveUs:

; 2524 : }

  06f1d	5f		 pop	 edi
  06f1e	5e		 pop	 esi
  06f1f	5b		 pop	 ebx
  06f20	8b e5		 mov	 esp, ebp
  06f22	5d		 pop	 ebp
  06f23	c2 04 00	 ret	 4
?GetAliveUserTotalEXP@CBloodCastle@@IAEHH@Z ENDP	; CBloodCastle::GetAliveUserTotalEXP
_TEXT	ENDS
PUBLIC	??_C@_0FK@KGCEHODG@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CFs@ ; `string'
EXTRN	?GCInventoryItemDeleteSend@@YAXHEE@Z:PROC	; GCInventoryItemDeleteSend
EXTRN	?gObjInventoryDeleteItem@@YAEHH@Z:PROC		; gObjInventoryDeleteItem
EXTRN	?gObjInventoryItemSet@@YAXHHE@Z:PROC		; gObjInventoryItemSet
;	COMDAT ??_C@_0FK@KGCEHODG@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CFs@
CONST	SEGMENT
??_C@_0FK@KGCEHODG@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CFs@ DB '['
	DB	'Blood Castle] Force (Account:%s, Name:%s) to Delete Angel Kin'
	DB	'g''s Weapon (%d) [Serial:%u]', 00H		; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv95 = -80						; size = 4
_iLEVEL$237665 = -12					; size = 4
_x$237659 = -8						; size = 4
_this$ = -4						; size = 4
_iIndex$ = 8						; size = 4
?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z PROC	; CBloodCastle::SearchUserDeleteQuestItem
; _this$ = ecx

; 2527 : {

  06f30	55		 push	 ebp
  06f31	8b ec		 mov	 ebp, esp
  06f33	83 ec 50	 sub	 esp, 80			; 00000050H
  06f36	53		 push	 ebx
  06f37	56		 push	 esi
  06f38	57		 push	 edi
  06f39	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2528 : 	if ( gObjIsConnected(iIndex) == FALSE )

  06f3c	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  06f3f	50		 push	 eax
  06f40	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  06f45	83 c4 04	 add	 esp, 4
  06f48	85 c0		 test	 eax, eax
  06f4a	75 05		 jne	 SHORT $LN7@SearchUser

; 2529 : 	{
; 2530 : 		return;

  06f4c	e9 62 01 00 00	 jmp	 $LN8@SearchUser
$LN7@SearchUser:

; 2531 : 	}
; 2532 : 
; 2533 : 	for ( int x=0;x<INVENTORY_SIZE;x++)

  06f51	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _x$237659[ebp], 0
  06f58	eb 09		 jmp	 SHORT $LN6@SearchUser
$LN5@SearchUser:
  06f5a	8b 45 f8	 mov	 eax, DWORD PTR _x$237659[ebp]
  06f5d	83 c0 01	 add	 eax, 1
  06f60	89 45 f8	 mov	 DWORD PTR _x$237659[ebp], eax
$LN6@SearchUser:
  06f63	81 7d f8 ec 00
	00 00		 cmp	 DWORD PTR _x$237659[ebp], 236 ; 000000ecH
  06f6a	0f 8d 43 01 00
	00		 jge	 $LN8@SearchUser

; 2534 : 	{
; 2535 : 		if ( gObj[iIndex].pInventory[x].IsItem() == TRUE )

  06f70	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  06f73	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  06f79	8b 4d f8	 mov	 ecx, DWORD PTR _x$237659[ebp]
  06f7c	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  06f82	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  06f88	03 8c 02 24 0e
	00 00		 add	 ecx, DWORD PTR [edx+eax+3620]
  06f8f	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  06f94	83 f8 01	 cmp	 eax, 1
  06f97	0f 85 11 01 00
	00		 jne	 $LN3@SearchUser

; 2536 : 		{
; 2537 : 			if ( gObj[iIndex].pInventory[x].m_Type == ITEMGET(13,19) )

  06f9d	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  06fa0	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  06fa6	8b 4d f8	 mov	 ecx, DWORD PTR _x$237659[ebp]
  06fa9	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  06faf	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  06fb5	8b 84 02 24 0e
	00 00		 mov	 eax, DWORD PTR [edx+eax+3620]
  06fbc	0f bf 4c 08 06	 movsx	 ecx, WORD PTR [eax+ecx+6]
  06fc1	81 f9 13 1a 00
	00		 cmp	 ecx, 6675		; 00001a13H
  06fc7	0f 85 e1 00 00
	00		 jne	 $LN3@SearchUser

; 2538 : 			{
; 2539 : 				int iLEVEL = gObj[iIndex].pInventory[x].m_Level;

  06fcd	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  06fd0	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  06fd6	8b 4d f8	 mov	 ecx, DWORD PTR _x$237659[ebp]
  06fd9	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  06fdf	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  06fe5	8b 84 02 24 0e
	00 00		 mov	 eax, DWORD PTR [edx+eax+3620]
  06fec	0f bf 4c 08 08	 movsx	 ecx, WORD PTR [eax+ecx+8]
  06ff1	89 4d f4	 mov	 DWORD PTR _iLEVEL$237665[ebp], ecx

; 2540 : 
; 2541 : 				if ( BC_WEAPON_LEVEL_RANGE(iLEVEL) != FALSE )

  06ff4	83 7d f4 00	 cmp	 DWORD PTR _iLEVEL$237665[ebp], 0
  06ff8	7d 09		 jge	 SHORT $LN10@SearchUser
  06ffa	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv95[ebp], 0
  07001	eb 0c		 jmp	 SHORT $LN11@SearchUser
$LN10@SearchUser:
  07003	33 c0		 xor	 eax, eax
  07005	83 7d f4 02	 cmp	 DWORD PTR _iLEVEL$237665[ebp], 2
  07009	0f 9e c0	 setle	 al
  0700c	89 45 b0	 mov	 DWORD PTR tv95[ebp], eax
$LN11@SearchUser:
  0700f	83 7d b0 00	 cmp	 DWORD PTR tv95[ebp], 0
  07013	0f 84 95 00 00
	00		 je	 $LN3@SearchUser

; 2542 : 				{
; 2543 : 					::gObjInventoryItemSet(iIndex, x, -1);

  07019	68 ff 00 00 00	 push	 255			; 000000ffH
  0701e	8b 45 f8	 mov	 eax, DWORD PTR _x$237659[ebp]
  07021	50		 push	 eax
  07022	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  07025	51		 push	 ecx
  07026	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  0702b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2544 : 					::gObjInventoryDeleteItem(iIndex, x);

  0702e	8b 45 f8	 mov	 eax, DWORD PTR _x$237659[ebp]
  07031	50		 push	 eax
  07032	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  07035	51		 push	 ecx
  07036	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  0703b	83 c4 08	 add	 esp, 8

; 2545 : 					::GCInventoryItemDeleteSend(iIndex, x, TRUE);

  0703e	6a 01		 push	 1
  07040	0f b6 45 f8	 movzx	 eax, BYTE PTR _x$237659[ebp]
  07044	50		 push	 eax
  07045	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  07048	51		 push	 ecx
  07049	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  0704e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2546 : 
; 2547 : 					LogAddTD("[Blood Castle] Force (Account:%s, Name:%s) to Delete Angel King's Weapon (%d) [Serial:%u]", gObj[iIndex].AccountID, gObj[iIndex].Name, iLEVEL, gObj[iIndex].pInventory[x].m_Number);

  07051	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  07054	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0705a	8b 4d f8	 mov	 ecx, DWORD PTR _x$237659[ebp]
  0705d	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  07063	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  07069	8b 84 02 24 0e
	00 00		 mov	 eax, DWORD PTR [edx+eax+3620]
  07070	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  07073	51		 push	 ecx
  07074	8b 55 f4	 mov	 edx, DWORD PTR _iLEVEL$237665[ebp]
  07077	52		 push	 edx
  07078	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0707b	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  07081	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  07087	8d 54 01 77	 lea	 edx, DWORD PTR [ecx+eax+119]
  0708b	52		 push	 edx
  0708c	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0708f	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  07095	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0709b	8d 54 01 6c	 lea	 edx, DWORD PTR [ecx+eax+108]
  0709f	52		 push	 edx
  070a0	68 00 00 00 00	 push	 OFFSET ??_C@_0FK@KGCEHODG@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CFs@
  070a5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  070ab	83 c4 14	 add	 esp, 20			; 00000014H
$LN3@SearchUser:

; 2548 : 				}
; 2549 : 			}
; 2550 : 		}
; 2551 : 	}

  070ae	e9 a7 fe ff ff	 jmp	 $LN5@SearchUser
$LN8@SearchUser:

; 2552 : }

  070b3	5f		 pop	 edi
  070b4	5e		 pop	 esi
  070b5	5b		 pop	 ebx
  070b6	8b e5		 mov	 esp, ebp
  070b8	5d		 pop	 ebp
  070b9	c2 04 00	 ret	 4
?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z ENDP	; CBloodCastle::SearchUserDeleteQuestItem
_TEXT	ENDS
PUBLIC	??_C@_0FI@BDGGPIDE@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CFs@ ; `string'
PUBLIC	??_C@_0FL@GIMHNEOG@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CFs@ ; `string'
PUBLIC	?DropItemDirectly@CBloodCastle@@QAEHHHHH@Z	; CBloodCastle::DropItemDirectly
PUBLIC	__$ArrayPad$
PUBLIC	?SearchUserDropQuestItem@CBloodCastle@@QAEXH@Z	; CBloodCastle::SearchUserDropQuestItem
;	COMDAT ??_C@_0FI@BDGGPIDE@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CFs@
CONST	SEGMENT
??_C@_0FI@BDGGPIDE@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CFs@ DB '['
	DB	'Blood Castle] Force (Account:%s, Name:%s) to Drop Angel King'''
	DB	's Weapon (%d) [Serial:%u]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FL@GIMHNEOG@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CFs@
CONST	SEGMENT
??_C@_0FL@GIMHNEOG@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CFs@ DB '['
	DB	'Blood Castle] Force (Account:%s, Name:%s) to Drop Angel King'''
	DB	's Weapon (%d) [Serial:%u-%u]', 00H		; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv191 = -104						; size = 4
tv192 = -100						; size = 4
tv138 = -100						; size = 4
tv67 = -100						; size = 4
_iBC_INDEX$237686 = -32					; size = 4
_iBC_INDEX$237684 = -28					; size = 4
_pMsg$237683 = -24					; size = 6
_iLEVEL$237681 = -16					; size = 4
_x$237675 = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
?SearchUserDropQuestItem@CBloodCastle@@QAEXH@Z PROC	; CBloodCastle::SearchUserDropQuestItem
; _this$ = ecx

; 2556 : {

  070c0	55		 push	 ebp
  070c1	8b ec		 mov	 ebp, esp
  070c3	83 ec 68	 sub	 esp, 104		; 00000068H
  070c6	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  070cb	33 c5		 xor	 eax, ebp
  070cd	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  070d0	53		 push	 ebx
  070d1	56		 push	 esi
  070d2	57		 push	 edi
  070d3	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2557 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  070d6	83 7d 08 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  070da	7d 09		 jge	 SHORT $LN16@SearchUser@2
  070dc	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  070e3	eb 0f		 jmp	 SHORT $LN17@SearchUser@2
$LN16@SearchUser@2:
  070e5	33 c0		 xor	 eax, eax
  070e7	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _iIndex$[ebp], 14999 ; 00003a97H
  070ee	0f 9e c0	 setle	 al
  070f1	89 45 9c	 mov	 DWORD PTR tv67[ebp], eax
$LN17@SearchUser@2:
  070f4	83 7d 9c 00	 cmp	 DWORD PTR tv67[ebp], 0
  070f8	75 05		 jne	 SHORT $LN13@SearchUser@2

; 2558 : 	{
; 2559 : 		return;

  070fa	e9 96 03 00 00	 jmp	 $LN14@SearchUser@2
$LN13@SearchUser@2:

; 2560 : 	}
; 2561 : 
; 2562 : 	if ( gObj[iIndex].Type != OBJ_USER || gObj[iIndex].Connected <= PLAYER_LOGGED )

  070ff	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  07102	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  07108	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0710e	0f b7 54 01 68	 movzx	 edx, WORD PTR [ecx+eax+104]
  07113	83 fa 01	 cmp	 edx, 1
  07116	75 16		 jne	 SHORT $LN11@SearchUser@2
  07118	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0711b	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  07121	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  07127	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  0712c	7f 05		 jg	 SHORT $LN12@SearchUser@2
$LN11@SearchUser@2:

; 2563 : 	{
; 2564 : 		return;

  0712e	e9 62 03 00 00	 jmp	 $LN14@SearchUser@2
$LN12@SearchUser@2:

; 2565 : 	}
; 2566 : 
; 2567 : 	for ( int x=0;x<INVENTORY_SIZE;x++)

  07133	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _x$237675[ebp], 0
  0713a	eb 09		 jmp	 SHORT $LN10@SearchUser@2
$LN9@SearchUser@2:
  0713c	8b 45 f4	 mov	 eax, DWORD PTR _x$237675[ebp]
  0713f	83 c0 01	 add	 eax, 1
  07142	89 45 f4	 mov	 DWORD PTR _x$237675[ebp], eax
$LN10@SearchUser@2:
  07145	81 7d f4 ec 00
	00 00		 cmp	 DWORD PTR _x$237675[ebp], 236 ; 000000ecH
  0714c	0f 8d 43 03 00
	00		 jge	 $LN14@SearchUser@2

; 2568 : 	{
; 2569 : 		if ( gObj[iIndex].pInventory[x].IsItem() == TRUE )

  07152	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  07155	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0715b	8b 4d f4	 mov	 ecx, DWORD PTR _x$237675[ebp]
  0715e	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  07164	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0716a	03 8c 02 24 0e
	00 00		 add	 ecx, DWORD PTR [edx+eax+3620]
  07171	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  07176	83 f8 01	 cmp	 eax, 1
  07179	0f 85 11 03 00
	00		 jne	 $LN7@SearchUser@2

; 2570 : 		{
; 2571 : 			if ( gObj[iIndex].pInventory[x].m_Type == ITEMGET(13,19) )

  0717f	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  07182	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  07188	8b 4d f4	 mov	 ecx, DWORD PTR _x$237675[ebp]
  0718b	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  07191	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  07197	8b 84 02 24 0e
	00 00		 mov	 eax, DWORD PTR [edx+eax+3620]
  0719e	0f bf 4c 08 06	 movsx	 ecx, WORD PTR [eax+ecx+6]
  071a3	81 f9 13 1a 00
	00		 cmp	 ecx, 6675		; 00001a13H
  071a9	0f 85 e1 02 00
	00		 jne	 $LN7@SearchUser@2

; 2572 : 			{
; 2573 : 				int iLEVEL = gObj[iIndex].pInventory[x].m_Level;

  071af	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  071b2	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  071b8	8b 4d f4	 mov	 ecx, DWORD PTR _x$237675[ebp]
  071bb	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  071c1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  071c7	8b 84 02 24 0e
	00 00		 mov	 eax, DWORD PTR [edx+eax+3620]
  071ce	0f bf 4c 08 08	 movsx	 ecx, WORD PTR [eax+ecx+8]
  071d3	89 4d f0	 mov	 DWORD PTR _iLEVEL$237681[ebp], ecx

; 2574 : 
; 2575 : 				if ( BC_WEAPON_LEVEL_RANGE(iLEVEL) != FALSE )

  071d6	83 7d f0 00	 cmp	 DWORD PTR _iLEVEL$237681[ebp], 0
  071da	7d 09		 jge	 SHORT $LN18@SearchUser@2
  071dc	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv138[ebp], 0
  071e3	eb 0c		 jmp	 SHORT $LN19@SearchUser@2
$LN18@SearchUser@2:
  071e5	33 c0		 xor	 eax, eax
  071e7	83 7d f0 02	 cmp	 DWORD PTR _iLEVEL$237681[ebp], 2
  071eb	0f 9e c0	 setle	 al
  071ee	89 45 9c	 mov	 DWORD PTR tv138[ebp], eax
$LN19@SearchUser@2:
  071f1	83 7d 9c 00	 cmp	 DWORD PTR tv138[ebp], 0
  071f5	0f 84 95 02 00
	00		 je	 $LN7@SearchUser@2

; 2576 : 				{
; 2577 : 					BYTE pMsg[6];
; 2578 : 					pMsg[5] = x;

  071fb	8a 45 f4	 mov	 al, BYTE PTR _x$237675[ebp]
  071fe	88 45 ed	 mov	 BYTE PTR _pMsg$237683[ebp+5], al

; 2579 : 					pMsg[3] = gObj[iIndex].X;

  07201	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  07204	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0720a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  07210	8a 94 01 44 01
	00 00		 mov	 dl, BYTE PTR [ecx+eax+324]
  07217	88 55 eb	 mov	 BYTE PTR _pMsg$237683[ebp+3], dl

; 2580 : 					pMsg[4] = gObj[iIndex].Y;

  0721a	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0721d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  07223	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  07229	8a 94 01 46 01
	00 00		 mov	 dl, BYTE PTR [ecx+eax+326]
  07230	88 55 ec	 mov	 BYTE PTR _pMsg$237683[ebp+4], dl

; 2581 : 
; 2582 : 					int iBC_INDEX = this->GetBridgeIndex(gObj[iIndex].MapNumber); //season3 add-on

  07233	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  07236	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0723c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  07242	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  0724a	52		 push	 edx
  0724b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0724e	e8 00 00 00 00	 call	 ?GetBridgeIndex@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeIndex
  07253	89 45 e4	 mov	 DWORD PTR _iBC_INDEX$237684[ebp], eax

; 2583 : 
; 2584 : 					this->DropItemDirectly(iBC_INDEX, gObj[iIndex].m_Index, ITEMGET(13, 19), x); //season3 add-on

  07256	8b 45 f4	 mov	 eax, DWORD PTR _x$237675[ebp]
  07259	50		 push	 eax
  0725a	68 13 1a 00 00	 push	 6675			; 00001a13H
  0725f	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  07262	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  07268	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0726e	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  07271	50		 push	 eax
  07272	8b 4d e4	 mov	 ecx, DWORD PTR _iBC_INDEX$237684[ebp]
  07275	51		 push	 ecx
  07276	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  07279	e8 00 00 00 00	 call	 ?DropItemDirectly@CBloodCastle@@QAEHHHHH@Z ; CBloodCastle::DropItemDirectly

; 2585 : 					this->DropItemDirectly(gObj[iIndex].MapNumber - MAP_INDEX_BLOODCASTLE1,	gObj[iIndex].m_Index, ITEMGET(13, 19), x); //remove this

  0727e	8b 45 f4	 mov	 eax, DWORD PTR _x$237675[ebp]
  07281	50		 push	 eax
  07282	68 13 1a 00 00	 push	 6675			; 00001a13H
  07287	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0728a	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  07290	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  07296	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  07299	50		 push	 eax
  0729a	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0729d	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  072a3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  072a9	0f b6 84 0a 49
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+329]
  072b1	83 e8 0b	 sub	 eax, 11			; 0000000bH
  072b4	50		 push	 eax
  072b5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  072b8	e8 00 00 00 00	 call	 ?DropItemDirectly@CBloodCastle@@QAEHHHHH@Z ; CBloodCastle::DropItemDirectly

; 2586 : 
; 2587 : 					if ( BC_MAP_RANGE(gObj[iIndex].MapNumber) != FALSE )

  072bd	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  072c0	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  072c6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  072cc	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  072d4	83 fa 34	 cmp	 edx, 52			; 00000034H
  072d7	75 09		 jne	 SHORT $LN22@SearchUser@2
  072d9	c7 45 9c 01 00
	00 00		 mov	 DWORD PTR tv192[ebp], 1
  072e0	eb 4d		 jmp	 SHORT $LN23@SearchUser@2
$LN22@SearchUser@2:
  072e2	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  072e5	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  072eb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  072f1	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  072f9	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  072fc	7d 09		 jge	 SHORT $LN20@SearchUser@2
  072fe	c7 45 98 00 00
	00 00		 mov	 DWORD PTR tv191[ebp], 0
  07305	eb 22		 jmp	 SHORT $LN21@SearchUser@2
$LN20@SearchUser@2:
  07307	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0730a	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  07310	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  07316	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  0731e	33 c0		 xor	 eax, eax
  07320	83 fa 11	 cmp	 edx, 17			; 00000011H
  07323	0f 9e c0	 setle	 al
  07326	89 45 98	 mov	 DWORD PTR tv191[ebp], eax
$LN21@SearchUser@2:
  07329	8b 4d 98	 mov	 ecx, DWORD PTR tv191[ebp]
  0732c	89 4d 9c	 mov	 DWORD PTR tv192[ebp], ecx
$LN23@SearchUser@2:
  0732f	83 7d 9c 00	 cmp	 DWORD PTR tv192[ebp], 0
  07333	0f 84 fa 00 00
	00		 je	 $LN4@SearchUser@2

; 2588 : 					{
; 2589 : 						int iBC_INDEX = this->GetBridgeIndex(gObj[iIndex].MapNumber);

  07339	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0733c	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  07342	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  07348	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  07350	52		 push	 edx
  07351	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  07354	e8 00 00 00 00	 call	 ?GetBridgeIndex@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeIndex
  07359	89 45 e0	 mov	 DWORD PTR _iBC_INDEX$237686[ebp], eax

; 2590 : 
; 2591 : 						if ( this->m_BridgeData[iBC_INDEX].m_nBC_QUESTITEM_SERIAL != -1 )

  0735c	8b 45 e0	 mov	 eax, DWORD PTR _iBC_INDEX$237686[ebp]
  0735f	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  07365	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  07368	83 bc 01 e8 03
	00 00 ff	 cmp	 DWORD PTR [ecx+eax+1000], -1
  07370	74 4e		 je	 SHORT $LN3@SearchUser@2

; 2592 : 						{
; 2593 : 							if ( this->m_BridgeData[iBC_INDEX].m_nBC_QUESTITEM_SERIAL == gObj[iIndex].pInventory[x].m_Number )

  07372	8b 45 e0	 mov	 eax, DWORD PTR _iBC_INDEX$237686[ebp]
  07375	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0737b	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0737e	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  07384	8b 55 f4	 mov	 edx, DWORD PTR _x$237675[ebp]
  07387	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  0738d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  07393	8b 8c 0e 24 0e
	00 00		 mov	 ecx, DWORD PTR [esi+ecx+3620]
  0739a	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  0739d	8b 84 06 e8 03
	00 00		 mov	 eax, DWORD PTR [esi+eax+1000]
  073a4	3b 04 0a	 cmp	 eax, DWORD PTR [edx+ecx]
  073a7	75 17		 jne	 SHORT $LN3@SearchUser@2

; 2594 : 							{
; 2595 : 								this->m_BridgeData[iBC_INDEX].m_iBC_QUEST_ITEM_USER_INDEX = -1;

  073a9	8b 45 e0	 mov	 eax, DWORD PTR _iBC_INDEX$237686[ebp]
  073ac	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  073b2	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  073b5	c7 84 01 ec 03
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+1004], -1
$LN3@SearchUser@2:

; 2596 : 							}
; 2597 : 						}
; 2598 : 
; 2599 : 						LogAddTD("[Blood Castle] Force (Account:%s, Name:%s) to Drop Angel King's Weapon (%d) [Serial:%u-%u]", gObj[iIndex].AccountID, gObj[iIndex].Name, iLEVEL, this->m_BridgeData[iBC_INDEX].m_nBC_QUESTITEM_SERIAL, gObj[iIndex].pInventory[x].m_Number);

  073c0	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  073c3	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  073c9	8b 4d f4	 mov	 ecx, DWORD PTR _x$237675[ebp]
  073cc	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  073d2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  073d8	8b 84 02 24 0e
	00 00		 mov	 eax, DWORD PTR [edx+eax+3620]
  073df	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  073e2	51		 push	 ecx
  073e3	8b 55 e0	 mov	 edx, DWORD PTR _iBC_INDEX$237686[ebp]
  073e6	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  073ec	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  073ef	8b 8c 10 e8 03
	00 00		 mov	 ecx, DWORD PTR [eax+edx+1000]
  073f6	51		 push	 ecx
  073f7	8b 55 f0	 mov	 edx, DWORD PTR _iLEVEL$237681[ebp]
  073fa	52		 push	 edx
  073fb	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  073fe	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  07404	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0740a	8d 54 01 77	 lea	 edx, DWORD PTR [ecx+eax+119]
  0740e	52		 push	 edx
  0740f	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  07412	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  07418	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0741e	8d 54 01 6c	 lea	 edx, DWORD PTR [ecx+eax+108]
  07422	52		 push	 edx
  07423	68 00 00 00 00	 push	 OFFSET ??_C@_0FL@GIMHNEOG@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CFs@
  07428	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0742e	83 c4 18	 add	 esp, 24			; 00000018H

; 2600 : 					}
; 2601 : 					else

  07431	eb 5d		 jmp	 SHORT $LN7@SearchUser@2
$LN4@SearchUser@2:

; 2602 : 					{
; 2603 : 						LogAddTD("[Blood Castle] Force (Account:%s, Name:%s) to Drop Angel King's Weapon (%d) [Serial:%u]", gObj[iIndex].AccountID, gObj[iIndex].Name, iLEVEL, gObj[iIndex].pInventory[x].m_Number);

  07433	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  07436	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0743c	8b 4d f4	 mov	 ecx, DWORD PTR _x$237675[ebp]
  0743f	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  07445	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0744b	8b 84 02 24 0e
	00 00		 mov	 eax, DWORD PTR [edx+eax+3620]
  07452	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  07455	51		 push	 ecx
  07456	8b 55 f0	 mov	 edx, DWORD PTR _iLEVEL$237681[ebp]
  07459	52		 push	 edx
  0745a	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0745d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  07463	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  07469	8d 54 01 77	 lea	 edx, DWORD PTR [ecx+eax+119]
  0746d	52		 push	 edx
  0746e	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  07471	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  07477	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0747d	8d 54 01 6c	 lea	 edx, DWORD PTR [ecx+eax+108]
  07481	52		 push	 edx
  07482	68 00 00 00 00	 push	 OFFSET ??_C@_0FI@BDGGPIDE@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CFs@
  07487	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0748d	83 c4 14	 add	 esp, 20			; 00000014H
$LN7@SearchUser@2:

; 2604 : 					}
; 2605 : 				}
; 2606 : 			}
; 2607 : 		}
; 2608 : 	}

  07490	e9 a7 fc ff ff	 jmp	 $LN9@SearchUser@2
$LN14@SearchUser@2:

; 2609 : }

  07495	5f		 pop	 edi
  07496	5e		 pop	 esi
  07497	5b		 pop	 ebx
  07498	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0749b	33 cd		 xor	 ecx, ebp
  0749d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  074a2	8b e5		 mov	 esp, ebp
  074a4	5d		 pop	 ebp
  074a5	c2 04 00	 ret	 4
?SearchUserDropQuestItem@CBloodCastle@@QAEXH@Z ENDP	; CBloodCastle::SearchUserDropQuestItem
_TEXT	ENDS
PUBLIC	?SetUserState@CBloodCastle@@QAEXHH@Z		; CBloodCastle::SetUserState
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv195 = -88						; size = 4
tv196 = -84						; size = 4
tv87 = -84						; size = 4
tv85 = -84						; size = 4
tv80 = -84						; size = 4
tv67 = -84						; size = 4
_i$237710 = -16						; size = 4
_iBridgeSubIndex$ = -12					; size = 4
_iBridgeIndex$ = -8					; size = 4
_this$ = -4						; size = 4
_iIndex$ = 8						; size = 4
_iState$ = 12						; size = 4
?SetUserState@CBloodCastle@@QAEXHH@Z PROC		; CBloodCastle::SetUserState
; _this$ = ecx

; 2612 : {

  074b0	55		 push	 ebp
  074b1	8b ec		 mov	 ebp, esp
  074b3	83 ec 58	 sub	 esp, 88			; 00000058H
  074b6	53		 push	 ebx
  074b7	56		 push	 esi
  074b8	57		 push	 edi
  074b9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2613 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  074bc	83 7d 08 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  074c0	7d 09		 jge	 SHORT $LN22@SetUserSta
  074c2	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  074c9	eb 0f		 jmp	 SHORT $LN23@SetUserSta
$LN22@SetUserSta:
  074cb	33 c0		 xor	 eax, eax
  074cd	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _iIndex$[ebp], 14999 ; 00003a97H
  074d4	0f 9e c0	 setle	 al
  074d7	89 45 ac	 mov	 DWORD PTR tv67[ebp], eax
$LN23@SetUserSta:
  074da	83 7d ac 00	 cmp	 DWORD PTR tv67[ebp], 0
  074de	75 05		 jne	 SHORT $LN19@SetUserSta

; 2614 : 	{
; 2615 : 		return;

  074e0	e9 fe 02 00 00	 jmp	 $LN20@SetUserSta
$LN19@SetUserSta:

; 2616 : 	}
; 2617 : 
; 2618 : 	int iBridgeIndex = gObj[iIndex].m_cBloodCastleIndex; //2

  074e5	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  074e8	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  074ee	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  074f4	0f be 94 01 9e
	0e 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3742]
  074fc	89 55 f8	 mov	 DWORD PTR _iBridgeIndex$[ebp], edx

; 2619 : 	int iBridgeSubIndex = gObj[iIndex].m_cBloodCastleSubIndex; //3

  074ff	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  07502	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  07508	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0750e	0f be 94 01 9f
	0e 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3743]
  07516	89 55 f4	 mov	 DWORD PTR _iBridgeSubIndex$[ebp], edx

; 2620 : 
; 2621 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  07519	83 7d f8 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  0751d	7d 09		 jge	 SHORT $LN24@SetUserSta
  0751f	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv80[ebp], 0
  07526	eb 0c		 jmp	 SHORT $LN25@SetUserSta
$LN24@SetUserSta:
  07528	33 c0		 xor	 eax, eax
  0752a	83 7d f8 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  0752e	0f 9e c0	 setle	 al
  07531	89 45 ac	 mov	 DWORD PTR tv80[ebp], eax
$LN25@SetUserSta:
  07534	83 7d ac 00	 cmp	 DWORD PTR tv80[ebp], 0
  07538	75 05		 jne	 SHORT $LN18@SetUserSta

; 2622 : 	{
; 2623 : 		return;

  0753a	e9 a4 02 00 00	 jmp	 $LN20@SetUserSta
$LN18@SetUserSta:

; 2624 : 	}
; 2625 : 
; 2626 : 	if ( BC_SUB_BRIDGE_RANGE(iBridgeSubIndex) == FALSE )

  0753f	83 7d f4 00	 cmp	 DWORD PTR _iBridgeSubIndex$[ebp], 0
  07543	7d 09		 jge	 SHORT $LN26@SetUserSta
  07545	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv85[ebp], 0
  0754c	eb 0c		 jmp	 SHORT $LN27@SetUserSta
$LN26@SetUserSta:
  0754e	33 c0		 xor	 eax, eax
  07550	83 7d f4 27	 cmp	 DWORD PTR _iBridgeSubIndex$[ebp], 39 ; 00000027H
  07554	0f 9e c0	 setle	 al
  07557	89 45 ac	 mov	 DWORD PTR tv85[ebp], eax
$LN27@SetUserSta:
  0755a	83 7d ac 00	 cmp	 DWORD PTR tv85[ebp], 0
  0755e	75 05		 jne	 SHORT $LN17@SetUserSta

; 2627 : 	{
; 2628 : 		return;

  07560	e9 7e 02 00 00	 jmp	 $LN20@SetUserSta
$LN17@SetUserSta:

; 2629 : 	}
; 2630 : 
; 2631 : 	switch ( iState )

  07565	8b 45 0c	 mov	 eax, DWORD PTR _iState$[ebp]
  07568	89 45 ac	 mov	 DWORD PTR tv87[ebp], eax
  0756b	83 7d ac 04	 cmp	 DWORD PTR tv87[ebp], 4
  0756f	0f 87 6e 02 00
	00		 ja	 $LN20@SetUserSta
  07575	8b 4d ac	 mov	 ecx, DWORD PTR tv87[ebp]
  07578	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN32@SetUserSta[ecx*4]
$LN14@SetUserSta:

; 2632 : 	{
; 2633 : 		case 0:
; 2634 : 			this->m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iUserState = 0;

  0757f	8b 45 f8	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  07582	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  07588	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0758b	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0758f	8b 45 f4	 mov	 eax, DWORD PTR _iBridgeSubIndex$[ebp]
  07592	6b c0 14	 imul	 eax, 20			; 00000014H
  07595	c7 44 02 24 00
	00 00 00	 mov	 DWORD PTR [edx+eax+36], 0

; 2635 : 			break;

  0759d	e9 41 02 00 00	 jmp	 $LN20@SetUserSta
$LN13@SetUserSta:

; 2636 : 
; 2637 : 		case 1:
; 2638 : 			this->m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iUserState = 1;

  075a2	8b 45 f8	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  075a5	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  075ab	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  075ae	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  075b2	8b 45 f4	 mov	 eax, DWORD PTR _iBridgeSubIndex$[ebp]
  075b5	6b c0 14	 imul	 eax, 20			; 00000014H
  075b8	c7 44 02 24 01
	00 00 00	 mov	 DWORD PTR [edx+eax+36], 1

; 2639 : 			break;

  075c0	e9 1e 02 00 00	 jmp	 $LN20@SetUserSta
$LN12@SetUserSta:

; 2640 : 
; 2641 : 		case 2:
; 2642 : 			if ( gObj[iIndex].PartyNumber >= 0 )

  075c5	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  075c8	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  075ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  075d4	83 bc 01 2c 04
	00 00 00	 cmp	 DWORD PTR [ecx+eax+1068], 0
  075dc	0f 8c 8d 01 00
	00		 jl	 $LN11@SetUserSta

; 2643 : 			{
; 2644 : 				for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++) //4

  075e2	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$237710[ebp], 0
  075e9	eb 09		 jmp	 SHORT $LN10@SetUserSta
$LN9@SetUserSta:
  075eb	8b 45 f0	 mov	 eax, DWORD PTR _i$237710[ebp]
  075ee	83 c0 01	 add	 eax, 1
  075f1	89 45 f0	 mov	 DWORD PTR _i$237710[ebp], eax
$LN10@SetUserSta:
  075f4	83 7d f0 28	 cmp	 DWORD PTR _i$237710[ebp], 40 ; 00000028H
  075f8	0f 8d 71 01 00
	00		 jge	 $LN11@SetUserSta

; 2645 : 				{
; 2646 : 					if ( i == iBridgeSubIndex )

  075fe	8b 45 f0	 mov	 eax, DWORD PTR _i$237710[ebp]
  07601	3b 45 f4	 cmp	 eax, DWORD PTR _iBridgeSubIndex$[ebp]
  07604	75 02		 jne	 SHORT $LN7@SetUserSta

; 2647 : 					{
; 2648 : 						continue;

  07606	eb e3		 jmp	 SHORT $LN9@SetUserSta
$LN7@SetUserSta:

; 2649 : 					}
; 2650 : 
; 2651 : 					if(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == -1) //season 4 add-on

  07608	8b 45 f8	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0760b	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  07611	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  07614	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  07618	8b 45 f0	 mov	 eax, DWORD PTR _i$237710[ebp]
  0761b	6b c0 14	 imul	 eax, 20			; 00000014H
  0761e	83 7c 02 18 ff	 cmp	 DWORD PTR [edx+eax+24], -1
  07623	75 02		 jne	 SHORT $LN6@SetUserSta

; 2652 : 					{
; 2653 : 						continue;

  07625	eb c4		 jmp	 SHORT $LN9@SetUserSta
$LN6@SetUserSta:

; 2654 : 					}
; 2655 : 
; 2656 : 					if ( gObj[iIndex].PartyNumber == gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber )

  07627	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0762a	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  07630	8b 4d f8	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  07633	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  07639	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0763c	8d 4c 0a 04	 lea	 ecx, DWORD PTR [edx+ecx+4]
  07640	8b 55 f0	 mov	 edx, DWORD PTR _i$237710[ebp]
  07643	6b d2 14	 imul	 edx, 20			; 00000014H
  07646	8b 4c 11 18	 mov	 ecx, DWORD PTR [ecx+edx+24]
  0764a	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  07650	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  07656	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0765c	8b 84 02 2c 04
	00 00		 mov	 eax, DWORD PTR [edx+eax+1068]
  07663	3b 84 0e 2c 04
	00 00		 cmp	 eax, DWORD PTR [esi+ecx+1068]
  0766a	0f 85 fa 00 00
	00		 jne	 $LN5@SetUserSta

; 2657 : 					{
; 2658 : 						if ( BC_MAP_RANGE( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex ].MapNumber ) != FALSE )

  07670	8b 45 f8	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  07673	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  07679	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0767c	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  07680	8b 45 f0	 mov	 eax, DWORD PTR _i$237710[ebp]
  07683	6b c0 14	 imul	 eax, 20			; 00000014H
  07686	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  0768a	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  07690	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  07696	0f b6 84 0a 49
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+329]
  0769e	83 f8 34	 cmp	 eax, 52			; 00000034H
  076a1	75 09		 jne	 SHORT $LN30@SetUserSta
  076a3	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv196[ebp], 1
  076aa	eb 7a		 jmp	 SHORT $LN31@SetUserSta
$LN30@SetUserSta:
  076ac	8b 4d f8	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  076af	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  076b5	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  076b8	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  076bc	8b 4d f0	 mov	 ecx, DWORD PTR _i$237710[ebp]
  076bf	6b c9 14	 imul	 ecx, 20			; 00000014H
  076c2	8b 54 08 18	 mov	 edx, DWORD PTR [eax+ecx+24]
  076c6	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  076cc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  076d1	0f b6 8c 10 49
	01 00 00	 movzx	 ecx, BYTE PTR [eax+edx+329]
  076d9	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  076dc	7d 09		 jge	 SHORT $LN28@SetUserSta
  076de	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv195[ebp], 0
  076e5	eb 39		 jmp	 SHORT $LN29@SetUserSta
$LN28@SetUserSta:
  076e7	8b 55 f8	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  076ea	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  076f0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  076f3	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  076f7	8b 55 f0	 mov	 edx, DWORD PTR _i$237710[ebp]
  076fa	6b d2 14	 imul	 edx, 20			; 00000014H
  076fd	8b 44 11 18	 mov	 eax, DWORD PTR [ecx+edx+24]
  07701	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  07707	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0770d	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  07715	33 c0		 xor	 eax, eax
  07717	83 fa 11	 cmp	 edx, 17			; 00000011H
  0771a	0f 9e c0	 setle	 al
  0771d	89 45 a8	 mov	 DWORD PTR tv195[ebp], eax
$LN29@SetUserSta:
  07720	8b 4d a8	 mov	 ecx, DWORD PTR tv195[ebp]
  07723	89 4d ac	 mov	 DWORD PTR tv196[ebp], ecx
$LN31@SetUserSta:
  07726	83 7d ac 00	 cmp	 DWORD PTR tv196[ebp], 0
  0772a	74 20		 je	 SHORT $LN4@SetUserSta

; 2659 : 						{
; 2660 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 3;

  0772c	8b 45 f8	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0772f	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  07735	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  07738	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0773c	8b 45 f0	 mov	 eax, DWORD PTR _i$237710[ebp]
  0773f	6b c0 14	 imul	 eax, 20			; 00000014H
  07742	c7 44 02 24 03
	00 00 00	 mov	 DWORD PTR [edx+eax+36], 3

; 2661 : 						}
; 2662 : 						else

  0774a	eb 1e		 jmp	 SHORT $LN5@SetUserSta
$LN4@SetUserSta:

; 2663 : 						{
; 2664 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 4;

  0774c	8b 45 f8	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0774f	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  07755	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  07758	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0775c	8b 45 f0	 mov	 eax, DWORD PTR _i$237710[ebp]
  0775f	6b c0 14	 imul	 eax, 20			; 00000014H
  07762	c7 44 02 24 04
	00 00 00	 mov	 DWORD PTR [edx+eax+36], 4
$LN5@SetUserSta:

; 2665 : 						}
; 2666 : 					}
; 2667 : 				}

  0776a	e9 7c fe ff ff	 jmp	 $LN9@SetUserSta
$LN11@SetUserSta:

; 2668 : 			}
; 2669 : 
; 2670 : 			this->m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iUserState = 2;

  0776f	8b 45 f8	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  07772	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  07778	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0777b	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0777f	8b 45 f4	 mov	 eax, DWORD PTR _iBridgeSubIndex$[ebp]
  07782	6b c0 14	 imul	 eax, 20			; 00000014H
  07785	c7 44 02 24 02
	00 00 00	 mov	 DWORD PTR [edx+eax+36], 2

; 2671 : 			this->m_BridgeData[iBridgeIndex].m_iMISSION_SUCCESS = iBridgeSubIndex;

  0778d	8b 45 f8	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  07790	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  07796	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  07799	8b 55 f4	 mov	 edx, DWORD PTR _iBridgeSubIndex$[ebp]
  0779c	89 94 01 a0 03
	00 00		 mov	 DWORD PTR [ecx+eax+928], edx

; 2672 : 			break;

  077a3	eb 3e		 jmp	 SHORT $LN20@SetUserSta
$LN2@SetUserSta:

; 2673 : 
; 2674 : 		case 3:
; 2675 : 			this->m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iUserState = 3;

  077a5	8b 45 f8	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  077a8	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  077ae	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  077b1	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  077b5	8b 45 f4	 mov	 eax, DWORD PTR _iBridgeSubIndex$[ebp]
  077b8	6b c0 14	 imul	 eax, 20			; 00000014H
  077bb	c7 44 02 24 03
	00 00 00	 mov	 DWORD PTR [edx+eax+36], 3

; 2676 : 			break;

  077c3	eb 1e		 jmp	 SHORT $LN20@SetUserSta
$LN1@SetUserSta:

; 2677 : 
; 2678 : 		case 4:
; 2679 : 			this->m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iUserState = 4;

  077c5	8b 45 f8	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  077c8	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  077ce	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  077d1	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  077d5	8b 45 f4	 mov	 eax, DWORD PTR _iBridgeSubIndex$[ebp]
  077d8	6b c0 14	 imul	 eax, 20			; 00000014H
  077db	c7 44 02 24 04
	00 00 00	 mov	 DWORD PTR [edx+eax+36], 4
$LN20@SetUserSta:

; 2680 : 			break;
; 2681 : 	}
; 2682 : }

  077e3	5f		 pop	 edi
  077e4	5e		 pop	 esi
  077e5	5b		 pop	 ebx
  077e6	8b e5		 mov	 esp, ebp
  077e8	5d		 pop	 ebp
  077e9	c2 08 00	 ret	 8
$LN32@SetUserSta:
  077ec	00 00 00 00	 DD	 $LN14@SetUserSta
  077f0	00 00 00 00	 DD	 $LN13@SetUserSta
  077f4	00 00 00 00	 DD	 $LN12@SetUserSta
  077f8	00 00 00 00	 DD	 $LN2@SetUserSta
  077fc	00 00 00 00	 DD	 $LN1@SetUserSta
?SetUserState@CBloodCastle@@QAEXHH@Z ENDP		; CBloodCastle::SetUserState
_TEXT	ENDS
PUBLIC	?DropChaosGem@CBloodCastle@@QAEXH@Z		; CBloodCastle::DropChaosGem
PUBLIC	??_C@_0IN@OCADDENK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Comple@ ; `string'
PUBLIC	?SendRewardScore@CBloodCastle@@QAEXHHHH@Z	; CBloodCastle::SendRewardScore
PUBLIC	?CalcSendRewardZEN@CBloodCastle@@QAEHHH@Z	; CBloodCastle::CalcSendRewardZEN
PUBLIC	?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z	; CBloodCastle::CalcSendRewardEXP
PUBLIC	?_ARGB@@YAKEEEE@Z				; _ARGB
PUBLIC	??_C@_0ED@MHPNGBMF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Comple@ ; `string'
PUBLIC	??_C@_0FJ@GOGDCKAK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Winner?5Party@ ; `string'
PUBLIC	?GetWinnerPartyCompletePoint@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetWinnerPartyCompletePoint
PUBLIC	?GetWinnerPartyCompleteCount@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetWinnerPartyCompleteCount
PUBLIC	?FixUsersPlayStateWin@CBloodCastle@@QAEXH@Z	; CBloodCastle::FixUsersPlayStateWin
PUBLIC	__$ArrayPad$
EXTRN	_memcpy:PROC
EXTRN	?SendNoticeToUser@TNotice@@SAXHPAX@Z:PROC	; TNotice::SendNoticeToUser
EXTRN	?SetNoticeProperty@TNotice@@SAXPAXEKEGE@Z:PROC	; TNotice::SetNoticeProperty
;	COMDAT ??_C@_0IN@OCADDENK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Comple@
CONST	SEGMENT
??_C@_0IN@OCADDENK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Comple@ DB '['
	DB	'Blood Castle] (%d) Quest Complete Rewarded (Account:%s, Name:'
	DB	'%s [State:%d], Exp:%d, ExtExp:%d, Zen:%d, Score:%d, LeftTime:'
	DB	'%d, MapNumber:%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@MHPNGBMF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Comple@
CONST	SEGMENT
??_C@_0ED@MHPNGBMF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Comple@ DB '['
	DB	'Blood Castle] (%d) Quest Complete - All Alive User''s Total E'
	DB	'XP:%d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FJ@GOGDCKAK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Winner?5Party@
CONST	SEGMENT
??_C@_0FJ@GOGDCKAK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Winner?5Party@ DB '['
	DB	'Blood Castle] (%d) Winner Party Point - Alive Party Member : '
	DB	'%d, Alive Party Point : %d', 00H		; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv787 = -1636						; size = 4
tv646 = -1636						; size = 4
tv788 = -1632						; size = 4
tv647 = -1632						; size = 4
tv384 = -1632						; size = 4
tv90 = -1632						; size = 4
tv85 = -1632						; size = 4
_pMsg$237799 = -1564					; size = 989
_iADD_EXP$237774 = -572					; size = 4
_pNotice$237772 = -568					; size = 272
_i$237764 = -296					; size = 4
_iTOTAL_EXP$237762 = -292				; size = 4
_iADD_PARTYPOINT$ = -288				; size = 4
_iALIVE_PARTYCOUNT$ = -284				; size = 4
_iLEFT_TIME$ = -280					; size = 4
_iREWARD_SCR$ = -276					; size = 4
_iREWARD_ZEN$ = -272					; size = 4
_iREWARD_EXP$ = -268					; size = 4
_szNOTIFY_MSG$ = -264					; size = 256
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iBridgeIndex$ = 12					; size = 4
?GiveReward_Win@CBloodCastle@@QAEXHH@Z PROC		; CBloodCastle::GiveReward_Win
; _this$ = ecx

; 2705 : {

  07800	55		 push	 ebp
  07801	8b ec		 mov	 ebp, esp
  07803	81 ec 64 06 00
	00		 sub	 esp, 1636		; 00000664H
  07809	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0780e	33 c5		 xor	 eax, ebp
  07810	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  07813	53		 push	 ebx
  07814	56		 push	 esi
  07815	57		 push	 edi
  07816	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2706 : 	this->FixUsersPlayStateWin(iBridgeIndex);

  07819	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0781c	50		 push	 eax
  0781d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  07820	e8 00 00 00 00	 call	 ?FixUsersPlayStateWin@CBloodCastle@@QAEXH@Z ; CBloodCastle::FixUsersPlayStateWin

; 2707 : 	char szNOTIFY_MSG[256];
; 2708 : 	int iREWARD_EXP = 0;

  07825	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _iREWARD_EXP$[ebp], 0

; 2709 : 	int iREWARD_ZEN = 0;

  0782f	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _iREWARD_ZEN$[ebp], 0

; 2710 : 	int iREWARD_SCR = 0;

  07839	c7 85 ec fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _iREWARD_SCR$[ebp], 0

; 2711 : 	int iLEFT_TIME = this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 1000;

  07843	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  07846	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0784c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0784f	8b 84 01 ac 03
	00 00		 mov	 eax, DWORD PTR [ecx+eax+940]
  07856	99		 cdq
  07857	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  0785c	f7 f9		 idiv	 ecx
  0785e	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _iLEFT_TIME$[ebp], eax

; 2712 : 	int iALIVE_PARTYCOUNT = this->GetWinnerPartyCompleteCount(iBridgeIndex);

  07864	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  07867	50		 push	 eax
  07868	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0786b	e8 00 00 00 00	 call	 ?GetWinnerPartyCompleteCount@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetWinnerPartyCompleteCount
  07870	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _iALIVE_PARTYCOUNT$[ebp], eax

; 2713 : 	int iADD_PARTYPOINT = this->GetWinnerPartyCompletePoint(iBridgeIndex);

  07876	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  07879	50		 push	 eax
  0787a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0787d	e8 00 00 00 00	 call	 ?GetWinnerPartyCompletePoint@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetWinnerPartyCompletePoint
  07882	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _iADD_PARTYPOINT$[ebp], eax

; 2714 : 
; 2715 : 	LogAddTD("[Blood Castle] (%d) Winner Party Point - Alive Party Member : %d, Alive Party Point : %d", iBridgeIndex+1, iALIVE_PARTYCOUNT, iADD_PARTYPOINT);

  07888	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _iADD_PARTYPOINT$[ebp]
  0788e	50		 push	 eax
  0788f	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _iALIVE_PARTYCOUNT$[ebp]
  07895	51		 push	 ecx
  07896	8b 55 0c	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  07899	83 c2 01	 add	 edx, 1
  0789c	52		 push	 edx
  0789d	68 00 00 00 00	 push	 OFFSET ??_C@_0FJ@GOGDCKAK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Winner?5Party@
  078a2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  078a8	83 c4 10	 add	 esp, 16			; 00000010H

; 2716 : 
; 2717 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  078ab	83 7d 08 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  078af	7d 0c		 jge	 SHORT $LN37@GiveReward
  078b1	c7 85 a0 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR tv85[ebp], 0
  078bb	eb 12		 jmp	 SHORT $LN38@GiveReward
$LN37@GiveReward:
  078bd	33 c0		 xor	 eax, eax
  078bf	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _iIndex$[ebp], 14999 ; 00003a97H
  078c6	0f 9e c0	 setle	 al
  078c9	89 85 a0 f9 ff
	ff		 mov	 DWORD PTR tv85[ebp], eax
$LN38@GiveReward:
  078cf	83 bd a0 f9 ff
	ff 00		 cmp	 DWORD PTR tv85[ebp], 0
  078d6	75 05		 jne	 SHORT $LN34@GiveReward

; 2718 : 	{
; 2719 : 		return;

  078d8	e9 00 12 00 00	 jmp	 $LN35@GiveReward
$LN34@GiveReward:

; 2720 : 	}
; 2721 : 
; 2722 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  078dd	83 7d 0c 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  078e1	7d 0c		 jge	 SHORT $LN39@GiveReward
  078e3	c7 85 a0 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR tv90[ebp], 0
  078ed	eb 0f		 jmp	 SHORT $LN40@GiveReward
$LN39@GiveReward:
  078ef	33 c0		 xor	 eax, eax
  078f1	83 7d 0c 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  078f5	0f 9e c0	 setle	 al
  078f8	89 85 a0 f9 ff
	ff		 mov	 DWORD PTR tv90[ebp], eax
$LN40@GiveReward:
  078fe	83 bd a0 f9 ff
	ff 00		 cmp	 DWORD PTR tv90[ebp], 0
  07905	75 05		 jne	 SHORT $LN33@GiveReward

; 2723 : 	{
; 2724 : 		return;

  07907	e9 d1 11 00 00	 jmp	 $LN35@GiveReward
$LN33@GiveReward:

; 2725 : 	}
; 2726 : 	
; 2727 : 	if ( this->m_BridgeData[iBridgeIndex].m_bBC_REWARDED != false )

  0790c	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0790f	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  07915	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  07918	0f b6 94 01 be
	03 00 00	 movzx	 edx, BYTE PTR [ecx+eax+958]
  07920	85 d2		 test	 edx, edx
  07922	74 05		 je	 SHORT $LN32@GiveReward

; 2728 : 	{
; 2729 : 		return;

  07924	e9 b4 11 00 00	 jmp	 $LN35@GiveReward
$LN32@GiveReward:

; 2730 : 	}
; 2731 : 
; 2732 : 	if ( gObj[iIndex].Connected > PLAYER_LOGGED )

  07929	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0792c	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  07932	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  07938	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  0793d	7e 4d		 jle	 SHORT $LN31@GiveReward

; 2733 : 	{
; 2734 : 		gObj[iIndex].Name[MAX_ACCOUNT_LEN] = 0;

  0793f	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  07942	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  07948	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0794e	c6 84 01 81 00
	00 00 00	 mov	 BYTE PTR [ecx+eax+129], 0

; 2735 : 		wsprintf(szNOTIFY_MSG, lMsg.Get(MSGGET(4, 141)), gObj[iIndex].Name);

  07956	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  07959	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0795f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  07965	8d 54 01 77	 lea	 edx, DWORD PTR [ecx+eax+119]
  07969	52		 push	 edx
  0796a	68 8d 04 00 00	 push	 1165			; 0000048dH
  0796f	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  07974	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  07979	50		 push	 eax
  0797a	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szNOTIFY_MSG$[ebp]
  07980	50		 push	 eax
  07981	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  07987	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2736 : 	}
; 2737 : 	else

  0798a	eb 20		 jmp	 SHORT $LN30@GiveReward
$LN31@GiveReward:

; 2738 : 	{
; 2739 : 		wsprintf(szNOTIFY_MSG, lMsg.Get(MSGGET(4, 142)));

  0798c	68 8e 04 00 00	 push	 1166			; 0000048eH
  07991	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  07996	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0799b	50		 push	 eax
  0799c	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szNOTIFY_MSG$[ebp]
  079a2	50		 push	 eax
  079a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  079a9	83 c4 08	 add	 esp, 8
$LN30@GiveReward:

; 2740 : 	}
; 2741 : 
; 2742 : 	if ( this->m_BridgeData[iBridgeIndex].m_iMISSION_SUCCESS != -1 )

  079ac	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  079af	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  079b5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  079b8	83 bc 01 a0 03
	00 00 ff	 cmp	 DWORD PTR [ecx+eax+928], -1
  079c0	0f 84 17 11 00
	00		 je	 $LN35@GiveReward

; 2743 : 	{
; 2744 : 		int iTOTAL_EXP = this->GetAliveUserTotalEXP(iBridgeIndex);

  079c6	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  079c9	50		 push	 eax
  079ca	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  079cd	e8 00 00 00 00	 call	 ?GetAliveUserTotalEXP@CBloodCastle@@IAEHH@Z ; CBloodCastle::GetAliveUserTotalEXP
  079d2	89 85 dc fe ff
	ff		 mov	 DWORD PTR _iTOTAL_EXP$237762[ebp], eax

; 2745 : 		LogAddTD("[Blood Castle] (%d) Quest Complete - All Alive User's Total EXP:%d", iBridgeIndex+1, iTOTAL_EXP);

  079d8	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _iTOTAL_EXP$237762[ebp]
  079de	50		 push	 eax
  079df	8b 4d 0c	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  079e2	83 c1 01	 add	 ecx, 1
  079e5	51		 push	 ecx
  079e6	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@MHPNGBMF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Comple@
  079eb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  079f1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2746 : 
; 2747 : 		for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  079f4	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$237764[ebp], 0
  079fe	eb 0f		 jmp	 SHORT $LN28@GiveReward
$LN27@GiveReward:
  07a00	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _i$237764[ebp]
  07a06	83 c0 01	 add	 eax, 1
  07a09	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _i$237764[ebp], eax
$LN28@GiveReward:
  07a0f	83 bd d8 fe ff
	ff 28		 cmp	 DWORD PTR _i$237764[ebp], 40 ; 00000028H
  07a16	0f 8d ad 10 00
	00		 jge	 $LN26@GiveReward

; 2748 : 		{
; 2749 : 			if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == -1 )

  07a1c	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  07a1f	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  07a25	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  07a28	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  07a2c	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _i$237764[ebp]
  07a32	6b c0 14	 imul	 eax, 20			; 00000014H
  07a35	83 7c 02 18 ff	 cmp	 DWORD PTR [edx+eax+24], -1
  07a3a	75 02		 jne	 SHORT $LN25@GiveReward

; 2750 : 			{
; 2751 : 				continue;

  07a3c	eb c2		 jmp	 SHORT $LN27@GiveReward
$LN25@GiveReward:

; 2752 : 			}
; 2753 : 
; 2754 : 			if ( gObj[ this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex ].Connected < PLAYER_PLAYING )

  07a3e	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  07a41	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  07a47	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  07a4a	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  07a4e	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _i$237764[ebp]
  07a54	6b c0 14	 imul	 eax, 20			; 00000014H
  07a57	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  07a5b	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  07a61	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  07a67	83 7c 0a 04 03	 cmp	 DWORD PTR [edx+ecx+4], 3
  07a6c	7d 02		 jge	 SHORT $LN24@GiveReward

; 2755 : 			{
; 2756 : 				continue;

  07a6e	eb 90		 jmp	 SHORT $LN27@GiveReward
$LN24@GiveReward:

; 2757 : 			}
; 2758 : 
; 2759 : 			if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex == -1 || gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex == -1 ||  gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex != iBridgeIndex )

  07a70	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  07a73	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  07a79	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  07a7c	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  07a80	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _i$237764[ebp]
  07a86	6b c0 14	 imul	 eax, 20			; 00000014H
  07a89	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  07a8d	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  07a93	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  07a99	0f be 84 0a 9e
	0e 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3742]
  07aa1	83 f8 ff	 cmp	 eax, -1
  07aa4	74 6c		 je	 SHORT $LN22@GiveReward
  07aa6	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  07aa9	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  07aaf	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  07ab2	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  07ab6	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _i$237764[ebp]
  07abc	6b c0 14	 imul	 eax, 20			; 00000014H
  07abf	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  07ac3	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  07ac9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  07acf	0f be 84 0a 9f
	0e 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3743]
  07ad7	83 f8 ff	 cmp	 eax, -1
  07ada	74 36		 je	 SHORT $LN22@GiveReward
  07adc	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  07adf	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  07ae5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  07ae8	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  07aec	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _i$237764[ebp]
  07af2	6b c0 14	 imul	 eax, 20			; 00000014H
  07af5	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  07af9	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  07aff	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  07b05	0f be 84 0a 9e
	0e 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3742]
  07b0d	3b 45 0c	 cmp	 eax, DWORD PTR _iBridgeIndex$[ebp]
  07b10	74 05		 je	 SHORT $LN23@GiveReward
$LN22@GiveReward:

; 2760 : 			{
; 2761 : 				continue;

  07b12	e9 e9 fe ff ff	 jmp	 $LN27@GiveReward
$LN23@GiveReward:

; 2762 : 			}
; 2763 : 
; 2764 : 			PMSG_NOTICE pNotice;
; 2765 : 			TNotice::MakeNoticeMsg(&pNotice, 10, szNOTIFY_MSG);

  07b17	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szNOTIFY_MSG$[ebp]
  07b1d	50		 push	 eax
  07b1e	6a 0a		 push	 10			; 0000000aH
  07b20	8d 8d c8 fd ff
	ff		 lea	 ecx, DWORD PTR _pNotice$237772[ebp]
  07b26	51		 push	 ecx
  07b27	e8 00 00 00 00	 call	 ?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z ; TNotice::MakeNoticeMsg
  07b2c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2766 : 			TNotice::SetNoticeProperty(&pNotice, 10, _ARGB(255, 128, 149, 196), 1, 0, 20);

  07b2f	6a 14		 push	 20			; 00000014H
  07b31	6a 00		 push	 0
  07b33	6a 01		 push	 1
  07b35	68 c4 00 00 00	 push	 196			; 000000c4H
  07b3a	68 95 00 00 00	 push	 149			; 00000095H
  07b3f	68 80 00 00 00	 push	 128			; 00000080H
  07b44	68 ff 00 00 00	 push	 255			; 000000ffH
  07b49	e8 00 00 00 00	 call	 ?_ARGB@@YAKEEEE@Z	; _ARGB
  07b4e	83 c4 10	 add	 esp, 16			; 00000010H
  07b51	50		 push	 eax
  07b52	6a 0a		 push	 10			; 0000000aH
  07b54	8d 85 c8 fd ff
	ff		 lea	 eax, DWORD PTR _pNotice$237772[ebp]
  07b5a	50		 push	 eax
  07b5b	e8 00 00 00 00	 call	 ?SetNoticeProperty@TNotice@@SAXPAXEKEGE@Z ; TNotice::SetNoticeProperty
  07b60	83 c4 18	 add	 esp, 24			; 00000018H

; 2767 : 			TNotice::SendNoticeToUser(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, (TNotice*)&pNotice);

  07b63	8d 85 c8 fd ff
	ff		 lea	 eax, DWORD PTR _pNotice$237772[ebp]
  07b69	50		 push	 eax
  07b6a	8b 4d 0c	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  07b6d	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  07b73	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  07b76	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  07b7a	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _i$237764[ebp]
  07b80	6b c9 14	 imul	 ecx, 20			; 00000014H
  07b83	8b 54 08 18	 mov	 edx, DWORD PTR [eax+ecx+24]
  07b87	52		 push	 edx
  07b88	e8 00 00 00 00	 call	 ?SendNoticeToUser@TNotice@@SAXHPAX@Z ; TNotice::SendNoticeToUser
  07b8d	83 c4 08	 add	 esp, 8

; 2768 : 
; 2769 : 			int iADD_EXP = 0;

  07b90	c7 85 c4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _iADD_EXP$237774[ebp], 0

; 2770 : 
; 2771 : 			if ( (gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber != -1 && gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber == this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Door_Party) || this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Door_Index)

  07b9a	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  07b9d	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  07ba3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  07ba6	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  07baa	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _i$237764[ebp]
  07bb0	6b c0 14	 imul	 eax, 20			; 00000014H
  07bb3	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  07bb7	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  07bbd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  07bc3	83 bc 0a 2c 04
	00 00 ff	 cmp	 DWORD PTR [edx+ecx+1068], -1
  07bcb	74 44		 je	 SHORT $LN19@GiveReward
  07bcd	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  07bd0	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  07bd6	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  07bd9	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  07bdd	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _i$237764[ebp]
  07be3	6b c0 14	 imul	 eax, 20			; 00000014H
  07be6	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  07bea	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  07bf0	8b 55 0c	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  07bf3	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  07bf9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  07bfe	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  07c01	8b 8c 08 2c 04
	00 00		 mov	 ecx, DWORD PTR [eax+ecx+1068]
  07c08	3b 8c 16 f8 03
	00 00		 cmp	 ecx, DWORD PTR [esi+edx+1016]
  07c0f	74 32		 je	 SHORT $LN20@GiveReward
$LN19@GiveReward:
  07c11	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  07c14	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  07c1a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  07c1d	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  07c21	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _i$237764[ebp]
  07c27	6b c0 14	 imul	 eax, 20			; 00000014H
  07c2a	8b 4d 0c	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  07c2d	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  07c33	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  07c36	8b 54 02 18	 mov	 edx, DWORD PTR [edx+eax+24]
  07c3a	3b 94 0e fc 03
	00 00		 cmp	 edx, DWORD PTR [esi+ecx+1020]
  07c41	75 1a		 jne	 SHORT $LN21@GiveReward
$LN20@GiveReward:

; 2772 : 			{
; 2773 : 				iADD_EXP += ::g_iBC_Add_Exp[iBridgeIndex].unk0;

  07c43	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  07c46	c1 e0 04	 shl	 eax, 4
  07c49	8b 8d c4 fd ff
	ff		 mov	 ecx, DWORD PTR _iADD_EXP$237774[ebp]
  07c4f	03 88 00 00 00
	00		 add	 ecx, DWORD PTR _g_iBC_Add_Exp[eax]
  07c55	89 8d c4 fd ff
	ff		 mov	 DWORD PTR _iADD_EXP$237774[ebp], ecx

; 2774 : 			}
; 2775 : 			else

  07c5b	eb 72		 jmp	 SHORT $LN18@GiveReward
$LN21@GiveReward:

; 2776 : 			{
; 2777 : 				if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber != -1 )

  07c5d	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  07c60	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  07c66	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  07c69	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  07c6d	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _i$237764[ebp]
  07c73	6b c0 14	 imul	 eax, 20			; 00000014H
  07c76	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  07c7a	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  07c80	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  07c86	83 bc 0a 2c 04
	00 00 ff	 cmp	 DWORD PTR [edx+ecx+1068], -1
  07c8e	74 3f		 je	 SHORT $LN18@GiveReward

; 2778 : 				{
; 2779 : 					if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bLiveWhenDoorBreak != false )

  07c90	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  07c93	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  07c99	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  07c9c	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  07ca0	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _i$237764[ebp]
  07ca6	6b c0 14	 imul	 eax, 20			; 00000014H
  07ca9	0f b6 4c 02 29	 movzx	 ecx, BYTE PTR [edx+eax+41]
  07cae	85 c9		 test	 ecx, ecx
  07cb0	74 1d		 je	 SHORT $LN18@GiveReward

; 2780 : 					{
; 2781 : 						iADD_EXP += ::g_iBC_Add_Exp[iBridgeIndex].unk0 / 2;

  07cb2	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  07cb5	c1 e0 04	 shl	 eax, 4
  07cb8	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR _g_iBC_Add_Exp[eax]
  07cbe	99		 cdq
  07cbf	2b c2		 sub	 eax, edx
  07cc1	d1 f8		 sar	 eax, 1
  07cc3	03 85 c4 fd ff
	ff		 add	 eax, DWORD PTR _iADD_EXP$237774[ebp]
  07cc9	89 85 c4 fd ff
	ff		 mov	 DWORD PTR _iADD_EXP$237774[ebp], eax
$LN18@GiveReward:

; 2782 : 					}
; 2783 : 				}
; 2784 : 			}
; 2785 : 
; 2786 : 			if ( (gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber != -1 && gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber == this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Statue_Party) || this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Statue_Index)

  07ccf	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  07cd2	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  07cd8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  07cdb	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  07cdf	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _i$237764[ebp]
  07ce5	6b c0 14	 imul	 eax, 20			; 00000014H
  07ce8	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  07cec	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  07cf2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  07cf8	83 bc 0a 2c 04
	00 00 ff	 cmp	 DWORD PTR [edx+ecx+1068], -1
  07d00	74 44		 je	 SHORT $LN13@GiveReward
  07d02	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  07d05	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  07d0b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  07d0e	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  07d12	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _i$237764[ebp]
  07d18	6b c0 14	 imul	 eax, 20			; 00000014H
  07d1b	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  07d1f	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  07d25	8b 55 0c	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  07d28	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  07d2e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  07d33	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  07d36	8b 8c 08 2c 04
	00 00		 mov	 ecx, DWORD PTR [eax+ecx+1068]
  07d3d	3b 8c 16 18 04
	00 00		 cmp	 ecx, DWORD PTR [esi+edx+1048]
  07d44	74 32		 je	 SHORT $LN14@GiveReward
$LN13@GiveReward:
  07d46	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  07d49	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  07d4f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  07d52	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  07d56	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _i$237764[ebp]
  07d5c	6b c0 14	 imul	 eax, 20			; 00000014H
  07d5f	8b 4d 0c	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  07d62	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  07d68	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  07d6b	8b 54 02 18	 mov	 edx, DWORD PTR [edx+eax+24]
  07d6f	3b 94 0e 1c 04
	00 00		 cmp	 edx, DWORD PTR [esi+ecx+1052]
  07d76	75 18		 jne	 SHORT $LN15@GiveReward
$LN14@GiveReward:

; 2787 : 			{
; 2788 : 				iADD_EXP += ::g_iBC_Add_Exp[iBridgeIndex].unk4;

  07d78	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  07d7b	c1 e0 04	 shl	 eax, 4
  07d7e	8b 8d c4 fd ff
	ff		 mov	 ecx, DWORD PTR _iADD_EXP$237774[ebp]
  07d84	03 88 04 00 00
	00		 add	 ecx, DWORD PTR _g_iBC_Add_Exp[eax+4]
  07d8a	89 8d c4 fd ff
	ff		 mov	 DWORD PTR _iADD_EXP$237774[ebp], ecx
$LN15@GiveReward:

; 2789 : 			}
; 2790 : 
; 2791 : 			if ( (gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber != -1 && gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber == this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Win_Quest_Party) || this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Win_Quest_Index)

  07d90	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  07d93	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  07d99	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  07d9c	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  07da0	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _i$237764[ebp]
  07da6	6b c0 14	 imul	 eax, 20			; 00000014H
  07da9	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  07dad	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  07db3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  07db9	83 bc 0a 2c 04
	00 00 ff	 cmp	 DWORD PTR [edx+ecx+1068], -1
  07dc1	74 44		 je	 SHORT $LN10@GiveReward
  07dc3	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  07dc6	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  07dcc	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  07dcf	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  07dd3	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _i$237764[ebp]
  07dd9	6b c0 14	 imul	 eax, 20			; 00000014H
  07ddc	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  07de0	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  07de6	8b 55 0c	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  07de9	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  07def	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  07df4	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  07df7	8b 8c 08 2c 04
	00 00		 mov	 ecx, DWORD PTR [eax+ecx+1068]
  07dfe	3b 8c 16 38 04
	00 00		 cmp	 ecx, DWORD PTR [esi+edx+1080]
  07e05	74 32		 je	 SHORT $LN11@GiveReward
$LN10@GiveReward:
  07e07	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  07e0a	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  07e10	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  07e13	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  07e17	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _i$237764[ebp]
  07e1d	6b c0 14	 imul	 eax, 20			; 00000014H
  07e20	8b 4d 0c	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  07e23	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  07e29	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  07e2c	8b 54 02 18	 mov	 edx, DWORD PTR [edx+eax+24]
  07e30	3b 94 0e 3c 04
	00 00		 cmp	 edx, DWORD PTR [esi+ecx+1084]
  07e37	75 18		 jne	 SHORT $LN12@GiveReward
$LN11@GiveReward:

; 2792 : 			{
; 2793 : 				iADD_EXP += ::g_iBC_Add_Exp[iBridgeIndex].unk8;

  07e39	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  07e3c	c1 e0 04	 shl	 eax, 4
  07e3f	8b 8d c4 fd ff
	ff		 mov	 ecx, DWORD PTR _iADD_EXP$237774[ebp]
  07e45	03 88 08 00 00
	00		 add	 ecx, DWORD PTR _g_iBC_Add_Exp[eax+8]
  07e4b	89 8d c4 fd ff
	ff		 mov	 DWORD PTR _iADD_EXP$237774[ebp], ecx
$LN12@GiveReward:

; 2794 : 			}
; 2795 : 
; 2796 : 			switch ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState  )

  07e51	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  07e54	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  07e5a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  07e5d	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  07e61	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _i$237764[ebp]
  07e67	6b c0 14	 imul	 eax, 20			; 00000014H
  07e6a	8b 4c 02 24	 mov	 ecx, DWORD PTR [edx+eax+36]
  07e6e	89 8d a0 f9 ff
	ff		 mov	 DWORD PTR tv384[ebp], ecx
  07e74	83 bd a0 f9 ff
	ff 04		 cmp	 DWORD PTR tv384[ebp], 4
  07e7b	0f 87 87 0b 00
	00		 ja	 $LN8@GiveReward
  07e81	8b 95 a0 f9 ff
	ff		 mov	 edx, DWORD PTR tv384[ebp]
  07e87	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN49@GiveReward[edx*4]
$LN7@GiveReward:

; 2797 : 			{
; 2798 : 				case 0:
; 2799 : 					iADD_EXP += this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 1000 * ::g_iBC_Add_Exp[iBridgeIndex].unkC;

  07e8e	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  07e91	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  07e97	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  07e9a	8b 84 01 ac 03
	00 00		 mov	 eax, DWORD PTR [ecx+eax+940]
  07ea1	99		 cdq
  07ea2	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  07ea7	f7 f9		 idiv	 ecx
  07ea9	8b 55 0c	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  07eac	c1 e2 04	 shl	 edx, 4
  07eaf	0f af 82 0c 00
	00 00		 imul	 eax, DWORD PTR _g_iBC_Add_Exp[edx+12]
  07eb6	03 85 c4 fd ff
	ff		 add	 eax, DWORD PTR _iADD_EXP$237774[ebp]
  07ebc	89 85 c4 fd ff
	ff		 mov	 DWORD PTR _iADD_EXP$237774[ebp], eax

; 2800 : 					iREWARD_EXP = this->CalcSendRewardEXP(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iADD_EXP);

  07ec2	8b 85 c4 fd ff
	ff		 mov	 eax, DWORD PTR _iADD_EXP$237774[ebp]
  07ec8	50		 push	 eax
  07ec9	8b 4d 0c	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  07ecc	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  07ed2	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  07ed5	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  07ed9	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _i$237764[ebp]
  07edf	6b c9 14	 imul	 ecx, 20			; 00000014H
  07ee2	8b 54 08 18	 mov	 edx, DWORD PTR [eax+ecx+24]
  07ee6	52		 push	 edx
  07ee7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  07eea	e8 00 00 00 00	 call	 ?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardEXP
  07eef	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _iREWARD_EXP$[ebp], eax

; 2801 : 					iREWARD_ZEN = this->CalcSendRewardZEN(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, ::g_iQuestWinExpendZEN[iBridgeIndex].SpecialCharacter);

  07ef5	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  07ef8	8b 0c c5 04 00
	00 00		 mov	 ecx, DWORD PTR _g_iQuestWinExpendZEN[eax*8+4]
  07eff	51		 push	 ecx
  07f00	8b 55 0c	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  07f03	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  07f09	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  07f0c	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  07f10	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _i$237764[ebp]
  07f16	6b d2 14	 imul	 edx, 20			; 00000014H
  07f19	8b 44 11 18	 mov	 eax, DWORD PTR [ecx+edx+24]
  07f1d	50		 push	 eax
  07f1e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  07f21	e8 00 00 00 00	 call	 ?CalcSendRewardZEN@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardZEN
  07f26	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _iREWARD_ZEN$[ebp], eax

; 2802 : 					iREWARD_SCR = ::g_iBC_EventScore[iBridgeIndex].unk0;

  07f2c	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  07f2f	6b c0 14	 imul	 eax, 20			; 00000014H
  07f32	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _g_iBC_EventScore[eax]
  07f38	89 8d ec fe ff
	ff		 mov	 DWORD PTR _iREWARD_SCR$[ebp], ecx

; 2803 : 					this->SendRewardScore(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iREWARD_SCR, iLEFT_TIME, 0);

  07f3e	6a 00		 push	 0
  07f40	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _iLEFT_TIME$[ebp]
  07f46	50		 push	 eax
  07f47	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _iREWARD_SCR$[ebp]
  07f4d	51		 push	 ecx
  07f4e	8b 55 0c	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  07f51	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  07f57	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  07f5a	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  07f5e	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _i$237764[ebp]
  07f64	6b d2 14	 imul	 edx, 20			; 00000014H
  07f67	8b 44 11 18	 mov	 eax, DWORD PTR [ecx+edx+24]
  07f6b	50		 push	 eax
  07f6c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  07f6f	e8 00 00 00 00	 call	 ?SendRewardScore@CBloodCastle@@QAEXHHHH@Z ; CBloodCastle::SendRewardScore

; 2804 : 					LogAddTD("[Blood Castle] (%d) Quest Complete Rewarded (Account:%s, Name:%s [State:%d], Exp:%d, ExtExp:%d, Zen:%d, Score:%d, LeftTime:%d, MapNumber:%d)", iBridgeIndex+1, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].AccountID, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name, 0, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_iBloodCastleEXP, iREWARD_EXP, iREWARD_ZEN, iREWARD_SCR, iLEFT_TIME, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber);

  07f74	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  07f77	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  07f7d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  07f80	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  07f84	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _i$237764[ebp]
  07f8a	6b c0 14	 imul	 eax, 20			; 00000014H
  07f8d	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  07f91	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  07f97	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  07f9d	0f b6 84 0a 49
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+329]
  07fa5	50		 push	 eax
  07fa6	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _iLEFT_TIME$[ebp]
  07fac	51		 push	 ecx
  07fad	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _iREWARD_SCR$[ebp]
  07fb3	52		 push	 edx
  07fb4	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _iREWARD_ZEN$[ebp]
  07fba	50		 push	 eax
  07fbb	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _iREWARD_EXP$[ebp]
  07fc1	51		 push	 ecx
  07fc2	8b 55 0c	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  07fc5	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  07fcb	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  07fce	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  07fd2	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _i$237764[ebp]
  07fd8	6b d2 14	 imul	 edx, 20			; 00000014H
  07fdb	8b 44 11 18	 mov	 eax, DWORD PTR [ecx+edx+24]
  07fdf	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  07fe5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  07feb	8b 94 01 a0 0e
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3744]
  07ff2	52		 push	 edx
  07ff3	6a 00		 push	 0
  07ff5	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  07ff8	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  07ffe	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  08001	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  08005	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _i$237764[ebp]
  0800b	6b c0 14	 imul	 eax, 20			; 00000014H
  0800e	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  08012	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  08018	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0801e	8d 44 0a 77	 lea	 eax, DWORD PTR [edx+ecx+119]
  08022	50		 push	 eax
  08023	8b 4d 0c	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  08026	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  0802c	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0802f	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  08033	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _i$237764[ebp]
  08039	6b c9 14	 imul	 ecx, 20			; 00000014H
  0803c	8b 54 08 18	 mov	 edx, DWORD PTR [eax+ecx+24]
  08040	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  08046	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0804b	8d 4c 10 6c	 lea	 ecx, DWORD PTR [eax+edx+108]
  0804f	51		 push	 ecx
  08050	8b 55 0c	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  08053	83 c2 01	 add	 edx, 1
  08056	52		 push	 edx
  08057	68 00 00 00 00	 push	 OFFSET ??_C@_0IN@OCADDENK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Comple@
  0805c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  08062	83 c4 2c	 add	 esp, 44			; 0000002cH

; 2805 : 					break;

  08065	e9 9e 09 00 00	 jmp	 $LN8@GiveReward
$LN6@GiveReward:

; 2806 : 
; 2807 : 				case 1:
; 2808 : 					iADD_EXP += this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 1000 * ::g_iBC_Add_Exp[iBridgeIndex].unkC;

  0806a	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0806d	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  08073	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  08076	8b 84 01 ac 03
	00 00		 mov	 eax, DWORD PTR [ecx+eax+940]
  0807d	99		 cdq
  0807e	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  08083	f7 f9		 idiv	 ecx
  08085	8b 55 0c	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  08088	c1 e2 04	 shl	 edx, 4
  0808b	0f af 82 0c 00
	00 00		 imul	 eax, DWORD PTR _g_iBC_Add_Exp[edx+12]
  08092	03 85 c4 fd ff
	ff		 add	 eax, DWORD PTR _iADD_EXP$237774[ebp]
  08098	89 85 c4 fd ff
	ff		 mov	 DWORD PTR _iADD_EXP$237774[ebp], eax

; 2809 : 					iREWARD_EXP = this->CalcSendRewardEXP(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iADD_EXP);

  0809e	8b 85 c4 fd ff
	ff		 mov	 eax, DWORD PTR _iADD_EXP$237774[ebp]
  080a4	50		 push	 eax
  080a5	8b 4d 0c	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  080a8	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  080ae	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  080b1	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  080b5	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _i$237764[ebp]
  080bb	6b c9 14	 imul	 ecx, 20			; 00000014H
  080be	8b 54 08 18	 mov	 edx, DWORD PTR [eax+ecx+24]
  080c2	52		 push	 edx
  080c3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  080c6	e8 00 00 00 00	 call	 ?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardEXP
  080cb	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _iREWARD_EXP$[ebp], eax

; 2810 : 					iREWARD_ZEN = this->CalcSendRewardZEN(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, ::g_iQuestWinExpendZEN[iBridgeIndex].SpecialCharacter);

  080d1	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  080d4	8b 0c c5 04 00
	00 00		 mov	 ecx, DWORD PTR _g_iQuestWinExpendZEN[eax*8+4]
  080db	51		 push	 ecx
  080dc	8b 55 0c	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  080df	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  080e5	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  080e8	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  080ec	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _i$237764[ebp]
  080f2	6b d2 14	 imul	 edx, 20			; 00000014H
  080f5	8b 44 11 18	 mov	 eax, DWORD PTR [ecx+edx+24]
  080f9	50		 push	 eax
  080fa	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  080fd	e8 00 00 00 00	 call	 ?CalcSendRewardZEN@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardZEN
  08102	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _iREWARD_ZEN$[ebp], eax

; 2811 : 					iREWARD_SCR = ::g_iBC_EventScore[iBridgeIndex].unk4;

  08108	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0810b	6b c0 14	 imul	 eax, 20			; 00000014H
  0810e	8b 88 04 00 00
	00		 mov	 ecx, DWORD PTR _g_iBC_EventScore[eax+4]
  08114	89 8d ec fe ff
	ff		 mov	 DWORD PTR _iREWARD_SCR$[ebp], ecx

; 2812 : 					this->SendRewardScore(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iREWARD_SCR, iLEFT_TIME, 0);

  0811a	6a 00		 push	 0
  0811c	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _iLEFT_TIME$[ebp]
  08122	50		 push	 eax
  08123	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _iREWARD_SCR$[ebp]
  08129	51		 push	 ecx
  0812a	8b 55 0c	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  0812d	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  08133	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  08136	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  0813a	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _i$237764[ebp]
  08140	6b d2 14	 imul	 edx, 20			; 00000014H
  08143	8b 44 11 18	 mov	 eax, DWORD PTR [ecx+edx+24]
  08147	50		 push	 eax
  08148	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0814b	e8 00 00 00 00	 call	 ?SendRewardScore@CBloodCastle@@QAEXHHHH@Z ; CBloodCastle::SendRewardScore

; 2813 : 					LogAddTD("[Blood Castle] (%d) Quest Complete Rewarded (Account:%s, Name:%s [State:%d], Exp:%d, ExtExp:%d, Zen:%d, Score:%d, LeftTime:%d, MapNumber:%d)", iBridgeIndex+1, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].AccountID, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name, 1, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_iBloodCastleEXP, iREWARD_EXP, iREWARD_ZEN, iREWARD_SCR, iLEFT_TIME, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber);

  08150	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  08153	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  08159	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0815c	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  08160	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _i$237764[ebp]
  08166	6b c0 14	 imul	 eax, 20			; 00000014H
  08169	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  0816d	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  08173	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08179	0f b6 84 0a 49
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+329]
  08181	50		 push	 eax
  08182	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _iLEFT_TIME$[ebp]
  08188	51		 push	 ecx
  08189	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _iREWARD_SCR$[ebp]
  0818f	52		 push	 edx
  08190	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _iREWARD_ZEN$[ebp]
  08196	50		 push	 eax
  08197	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _iREWARD_EXP$[ebp]
  0819d	51		 push	 ecx
  0819e	8b 55 0c	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  081a1	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  081a7	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  081aa	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  081ae	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _i$237764[ebp]
  081b4	6b d2 14	 imul	 edx, 20			; 00000014H
  081b7	8b 44 11 18	 mov	 eax, DWORD PTR [ecx+edx+24]
  081bb	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  081c1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  081c7	8b 94 01 a0 0e
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3744]
  081ce	52		 push	 edx
  081cf	6a 01		 push	 1
  081d1	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  081d4	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  081da	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  081dd	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  081e1	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _i$237764[ebp]
  081e7	6b c0 14	 imul	 eax, 20			; 00000014H
  081ea	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  081ee	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  081f4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  081fa	8d 44 0a 77	 lea	 eax, DWORD PTR [edx+ecx+119]
  081fe	50		 push	 eax
  081ff	8b 4d 0c	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  08202	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  08208	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0820b	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  0820f	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _i$237764[ebp]
  08215	6b c9 14	 imul	 ecx, 20			; 00000014H
  08218	8b 54 08 18	 mov	 edx, DWORD PTR [eax+ecx+24]
  0821c	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  08222	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08227	8d 4c 10 6c	 lea	 ecx, DWORD PTR [eax+edx+108]
  0822b	51		 push	 ecx
  0822c	8b 55 0c	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  0822f	83 c2 01	 add	 edx, 1
  08232	52		 push	 edx
  08233	68 00 00 00 00	 push	 OFFSET ??_C@_0IN@OCADDENK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Comple@
  08238	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0823e	83 c4 2c	 add	 esp, 44			; 0000002cH

; 2814 : 					break;

  08241	e9 c2 07 00 00	 jmp	 $LN8@GiveReward
$LN5@GiveReward:

; 2815 : 
; 2816 : 				case 2:
; 2817 : 					iADD_EXP += this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 1000 * ::g_iBC_Add_Exp[iBridgeIndex].unkC;

  08246	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  08249	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0824f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  08252	8b 84 01 ac 03
	00 00		 mov	 eax, DWORD PTR [ecx+eax+940]
  08259	99		 cdq
  0825a	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  0825f	f7 f9		 idiv	 ecx
  08261	8b 55 0c	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  08264	c1 e2 04	 shl	 edx, 4
  08267	0f af 82 0c 00
	00 00		 imul	 eax, DWORD PTR _g_iBC_Add_Exp[edx+12]
  0826e	03 85 c4 fd ff
	ff		 add	 eax, DWORD PTR _iADD_EXP$237774[ebp]
  08274	89 85 c4 fd ff
	ff		 mov	 DWORD PTR _iADD_EXP$237774[ebp], eax

; 2818 : 					iREWARD_EXP = this->CalcSendRewardEXP(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iADD_EXP);

  0827a	8b 85 c4 fd ff
	ff		 mov	 eax, DWORD PTR _iADD_EXP$237774[ebp]
  08280	50		 push	 eax
  08281	8b 4d 0c	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  08284	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  0828a	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0828d	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  08291	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _i$237764[ebp]
  08297	6b c9 14	 imul	 ecx, 20			; 00000014H
  0829a	8b 54 08 18	 mov	 edx, DWORD PTR [eax+ecx+24]
  0829e	52		 push	 edx
  0829f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  082a2	e8 00 00 00 00	 call	 ?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardEXP
  082a7	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _iREWARD_EXP$[ebp], eax

; 2819 : 					iREWARD_ZEN = this->CalcSendRewardZEN(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, ::g_iQuestWinExpendZEN[iBridgeIndex].NormalCharacter);

  082ad	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  082b0	8b 0c c5 00 00
	00 00		 mov	 ecx, DWORD PTR _g_iQuestWinExpendZEN[eax*8]
  082b7	51		 push	 ecx
  082b8	8b 55 0c	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  082bb	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  082c1	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  082c4	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  082c8	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _i$237764[ebp]
  082ce	6b d2 14	 imul	 edx, 20			; 00000014H
  082d1	8b 44 11 18	 mov	 eax, DWORD PTR [ecx+edx+24]
  082d5	50		 push	 eax
  082d6	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  082d9	e8 00 00 00 00	 call	 ?CalcSendRewardZEN@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardZEN
  082de	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _iREWARD_ZEN$[ebp], eax

; 2820 : 					iREWARD_SCR = ::g_iBC_EventScore[iBridgeIndex].unk8;

  082e4	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  082e7	6b c0 14	 imul	 eax, 20			; 00000014H
  082ea	8b 88 08 00 00
	00		 mov	 ecx, DWORD PTR _g_iBC_EventScore[eax+8]
  082f0	89 8d ec fe ff
	ff		 mov	 DWORD PTR _iREWARD_SCR$[ebp], ecx

; 2821 : 					iREWARD_SCR += iADD_PARTYPOINT;

  082f6	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _iREWARD_SCR$[ebp]
  082fc	03 85 e0 fe ff
	ff		 add	 eax, DWORD PTR _iADD_PARTYPOINT$[ebp]
  08302	89 85 ec fe ff
	ff		 mov	 DWORD PTR _iREWARD_SCR$[ebp], eax

; 2822 : 
; 2823 : 					if ( BC_MAP_RANGE(gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber ) != FALSE )

  08308	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0830b	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  08311	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  08314	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  08318	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _i$237764[ebp]
  0831e	6b c0 14	 imul	 eax, 20			; 00000014H
  08321	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  08325	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0832b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08331	0f b6 84 0a 49
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+329]
  08339	83 f8 34	 cmp	 eax, 52			; 00000034H
  0833c	75 0f		 jne	 SHORT $LN43@GiveReward
  0833e	c7 85 a0 f9 ff
	ff 01 00 00 00	 mov	 DWORD PTR tv647[ebp], 1
  08348	e9 8c 00 00 00	 jmp	 $LN44@GiveReward
$LN43@GiveReward:
  0834d	8b 4d 0c	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  08350	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  08356	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  08359	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  0835d	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _i$237764[ebp]
  08363	6b c9 14	 imul	 ecx, 20			; 00000014H
  08366	8b 54 08 18	 mov	 edx, DWORD PTR [eax+ecx+24]
  0836a	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  08370	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08375	0f b6 8c 10 49
	01 00 00	 movzx	 ecx, BYTE PTR [eax+edx+329]
  0837d	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  08380	7d 0c		 jge	 SHORT $LN41@GiveReward
  08382	c7 85 9c f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR tv646[ebp], 0
  0838c	eb 3f		 jmp	 SHORT $LN42@GiveReward
$LN41@GiveReward:
  0838e	8b 55 0c	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  08391	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  08397	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0839a	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  0839e	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _i$237764[ebp]
  083a4	6b d2 14	 imul	 edx, 20			; 00000014H
  083a7	8b 44 11 18	 mov	 eax, DWORD PTR [ecx+edx+24]
  083ab	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  083b1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  083b7	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  083bf	33 c0		 xor	 eax, eax
  083c1	83 fa 11	 cmp	 edx, 17			; 00000011H
  083c4	0f 9e c0	 setle	 al
  083c7	89 85 9c f9 ff
	ff		 mov	 DWORD PTR tv646[ebp], eax
$LN42@GiveReward:
  083cd	8b 8d 9c f9 ff
	ff		 mov	 ecx, DWORD PTR tv646[ebp]
  083d3	89 8d a0 f9 ff
	ff		 mov	 DWORD PTR tv647[ebp], ecx
$LN44@GiveReward:
  083d9	83 bd a0 f9 ff
	ff 00		 cmp	 DWORD PTR tv647[ebp], 0
  083e0	74 26		 je	 SHORT $LN4@GiveReward

; 2824 : 					{
; 2825 : 						this->DropChaosGem(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex);

  083e2	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  083e5	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  083eb	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  083ee	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  083f2	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _i$237764[ebp]
  083f8	6b c0 14	 imul	 eax, 20			; 00000014H
  083fb	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  083ff	51		 push	 ecx
  08400	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  08403	e8 00 00 00 00	 call	 ?DropChaosGem@CBloodCastle@@QAEXH@Z ; CBloodCastle::DropChaosGem
$LN4@GiveReward:

; 2826 : 					}
; 2827 : 
; 2828 : 					this->SendRewardScore(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iREWARD_SCR, iLEFT_TIME, iALIVE_PARTYCOUNT);

  08408	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _iALIVE_PARTYCOUNT$[ebp]
  0840e	50		 push	 eax
  0840f	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _iLEFT_TIME$[ebp]
  08415	51		 push	 ecx
  08416	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _iREWARD_SCR$[ebp]
  0841c	52		 push	 edx
  0841d	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  08420	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  08426	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  08429	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0842d	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _i$237764[ebp]
  08433	6b c0 14	 imul	 eax, 20			; 00000014H
  08436	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  0843a	51		 push	 ecx
  0843b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0843e	e8 00 00 00 00	 call	 ?SendRewardScore@CBloodCastle@@QAEXHHHH@Z ; CBloodCastle::SendRewardScore

; 2829 : 					LogAddTD("[Blood Castle] (%d) Quest Complete Rewarded (Account:%s, Name:%s [State:%d], Exp:%d, ExtExp:%d, Zen:%d, Score:%d, LeftTime:%d, MapNumber:%d)", iBridgeIndex+1, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].AccountID, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name, 2, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_iBloodCastleEXP, iREWARD_EXP, iREWARD_ZEN, iREWARD_SCR, iLEFT_TIME, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber);

  08443	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  08446	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0844c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0844f	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  08453	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _i$237764[ebp]
  08459	6b c0 14	 imul	 eax, 20			; 00000014H
  0845c	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  08460	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  08466	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0846c	0f b6 84 0a 49
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+329]
  08474	50		 push	 eax
  08475	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _iLEFT_TIME$[ebp]
  0847b	51		 push	 ecx
  0847c	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _iREWARD_SCR$[ebp]
  08482	52		 push	 edx
  08483	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _iREWARD_ZEN$[ebp]
  08489	50		 push	 eax
  0848a	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _iREWARD_EXP$[ebp]
  08490	51		 push	 ecx
  08491	8b 55 0c	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  08494	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  0849a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0849d	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  084a1	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _i$237764[ebp]
  084a7	6b d2 14	 imul	 edx, 20			; 00000014H
  084aa	8b 44 11 18	 mov	 eax, DWORD PTR [ecx+edx+24]
  084ae	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  084b4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  084ba	8b 94 01 a0 0e
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3744]
  084c1	52		 push	 edx
  084c2	6a 02		 push	 2
  084c4	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  084c7	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  084cd	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  084d0	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  084d4	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _i$237764[ebp]
  084da	6b c0 14	 imul	 eax, 20			; 00000014H
  084dd	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  084e1	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  084e7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  084ed	8d 44 0a 77	 lea	 eax, DWORD PTR [edx+ecx+119]
  084f1	50		 push	 eax
  084f2	8b 4d 0c	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  084f5	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  084fb	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  084fe	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  08502	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _i$237764[ebp]
  08508	6b c9 14	 imul	 ecx, 20			; 00000014H
  0850b	8b 54 08 18	 mov	 edx, DWORD PTR [eax+ecx+24]
  0850f	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  08515	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0851a	8d 4c 10 6c	 lea	 ecx, DWORD PTR [eax+edx+108]
  0851e	51		 push	 ecx
  0851f	8b 55 0c	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  08522	83 c2 01	 add	 edx, 1
  08525	52		 push	 edx
  08526	68 00 00 00 00	 push	 OFFSET ??_C@_0IN@OCADDENK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Comple@
  0852b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  08531	83 c4 2c	 add	 esp, 44			; 0000002cH

; 2830 : 					break;

  08534	e9 cf 04 00 00	 jmp	 $LN8@GiveReward
$LN3@GiveReward:

; 2831 : 
; 2832 : 				case 3:
; 2833 : 					iADD_EXP += this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 1000 * ::g_iBC_Add_Exp[iBridgeIndex].unkC;

  08539	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0853c	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  08542	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  08545	8b 84 01 ac 03
	00 00		 mov	 eax, DWORD PTR [ecx+eax+940]
  0854c	99		 cdq
  0854d	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  08552	f7 f9		 idiv	 ecx
  08554	8b 55 0c	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  08557	c1 e2 04	 shl	 edx, 4
  0855a	0f af 82 0c 00
	00 00		 imul	 eax, DWORD PTR _g_iBC_Add_Exp[edx+12]
  08561	03 85 c4 fd ff
	ff		 add	 eax, DWORD PTR _iADD_EXP$237774[ebp]
  08567	89 85 c4 fd ff
	ff		 mov	 DWORD PTR _iADD_EXP$237774[ebp], eax

; 2834 : 					iREWARD_EXP = this->CalcSendRewardEXP(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iADD_EXP);

  0856d	8b 85 c4 fd ff
	ff		 mov	 eax, DWORD PTR _iADD_EXP$237774[ebp]
  08573	50		 push	 eax
  08574	8b 4d 0c	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  08577	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  0857d	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  08580	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  08584	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _i$237764[ebp]
  0858a	6b c9 14	 imul	 ecx, 20			; 00000014H
  0858d	8b 54 08 18	 mov	 edx, DWORD PTR [eax+ecx+24]
  08591	52		 push	 edx
  08592	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  08595	e8 00 00 00 00	 call	 ?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardEXP
  0859a	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _iREWARD_EXP$[ebp], eax

; 2835 : 					iREWARD_ZEN = this->CalcSendRewardZEN(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, ::g_iQuestWinExpendZEN[iBridgeIndex].NormalCharacter);

  085a0	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  085a3	8b 0c c5 00 00
	00 00		 mov	 ecx, DWORD PTR _g_iQuestWinExpendZEN[eax*8]
  085aa	51		 push	 ecx
  085ab	8b 55 0c	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  085ae	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  085b4	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  085b7	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  085bb	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _i$237764[ebp]
  085c1	6b d2 14	 imul	 edx, 20			; 00000014H
  085c4	8b 44 11 18	 mov	 eax, DWORD PTR [ecx+edx+24]
  085c8	50		 push	 eax
  085c9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  085cc	e8 00 00 00 00	 call	 ?CalcSendRewardZEN@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardZEN
  085d1	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _iREWARD_ZEN$[ebp], eax

; 2836 : 					iREWARD_SCR = ::g_iBC_EventScore[iBridgeIndex].unkC;

  085d7	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  085da	6b c0 14	 imul	 eax, 20			; 00000014H
  085dd	8b 88 0c 00 00
	00		 mov	 ecx, DWORD PTR _g_iBC_EventScore[eax+12]
  085e3	89 8d ec fe ff
	ff		 mov	 DWORD PTR _iREWARD_SCR$[ebp], ecx

; 2837 : 					iREWARD_SCR += iADD_PARTYPOINT;

  085e9	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _iREWARD_SCR$[ebp]
  085ef	03 85 e0 fe ff
	ff		 add	 eax, DWORD PTR _iADD_PARTYPOINT$[ebp]
  085f5	89 85 ec fe ff
	ff		 mov	 DWORD PTR _iREWARD_SCR$[ebp], eax

; 2838 : 
; 2839 : 					if ( BC_MAP_RANGE(gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber ) != FALSE )

  085fb	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  085fe	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  08604	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  08607	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0860b	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _i$237764[ebp]
  08611	6b c0 14	 imul	 eax, 20			; 00000014H
  08614	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  08618	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0861e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08624	0f b6 84 0a 49
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+329]
  0862c	83 f8 34	 cmp	 eax, 52			; 00000034H
  0862f	75 0f		 jne	 SHORT $LN47@GiveReward
  08631	c7 85 a0 f9 ff
	ff 01 00 00 00	 mov	 DWORD PTR tv788[ebp], 1
  0863b	e9 8c 00 00 00	 jmp	 $LN48@GiveReward
$LN47@GiveReward:
  08640	8b 4d 0c	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  08643	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  08649	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0864c	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  08650	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _i$237764[ebp]
  08656	6b c9 14	 imul	 ecx, 20			; 00000014H
  08659	8b 54 08 18	 mov	 edx, DWORD PTR [eax+ecx+24]
  0865d	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  08663	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08668	0f b6 8c 10 49
	01 00 00	 movzx	 ecx, BYTE PTR [eax+edx+329]
  08670	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  08673	7d 0c		 jge	 SHORT $LN45@GiveReward
  08675	c7 85 9c f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR tv787[ebp], 0
  0867f	eb 3f		 jmp	 SHORT $LN46@GiveReward
$LN45@GiveReward:
  08681	8b 55 0c	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  08684	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  0868a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0868d	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  08691	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _i$237764[ebp]
  08697	6b d2 14	 imul	 edx, 20			; 00000014H
  0869a	8b 44 11 18	 mov	 eax, DWORD PTR [ecx+edx+24]
  0869e	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  086a4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  086aa	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  086b2	33 c0		 xor	 eax, eax
  086b4	83 fa 11	 cmp	 edx, 17			; 00000011H
  086b7	0f 9e c0	 setle	 al
  086ba	89 85 9c f9 ff
	ff		 mov	 DWORD PTR tv787[ebp], eax
$LN46@GiveReward:
  086c0	8b 8d 9c f9 ff
	ff		 mov	 ecx, DWORD PTR tv787[ebp]
  086c6	89 8d a0 f9 ff
	ff		 mov	 DWORD PTR tv788[ebp], ecx
$LN48@GiveReward:
  086cc	83 bd a0 f9 ff
	ff 00		 cmp	 DWORD PTR tv788[ebp], 0
  086d3	74 26		 je	 SHORT $LN2@GiveReward

; 2840 : 					{
; 2841 : 						this->DropChaosGem(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex);

  086d5	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  086d8	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  086de	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  086e1	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  086e5	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _i$237764[ebp]
  086eb	6b c0 14	 imul	 eax, 20			; 00000014H
  086ee	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  086f2	51		 push	 ecx
  086f3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  086f6	e8 00 00 00 00	 call	 ?DropChaosGem@CBloodCastle@@QAEXH@Z ; CBloodCastle::DropChaosGem
$LN2@GiveReward:

; 2842 : 					}
; 2843 : 
; 2844 : 					this->SendRewardScore(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iREWARD_SCR, iLEFT_TIME, iALIVE_PARTYCOUNT);

  086fb	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _iALIVE_PARTYCOUNT$[ebp]
  08701	50		 push	 eax
  08702	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _iLEFT_TIME$[ebp]
  08708	51		 push	 ecx
  08709	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _iREWARD_SCR$[ebp]
  0870f	52		 push	 edx
  08710	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  08713	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  08719	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0871c	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  08720	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _i$237764[ebp]
  08726	6b c0 14	 imul	 eax, 20			; 00000014H
  08729	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  0872d	51		 push	 ecx
  0872e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  08731	e8 00 00 00 00	 call	 ?SendRewardScore@CBloodCastle@@QAEXHHHH@Z ; CBloodCastle::SendRewardScore

; 2845 : 					LogAddTD("[Blood Castle] (%d) Quest Complete Rewarded (Account:%s, Name:%s [State:%d], Exp:%d, ExtExp:%d, Zen:%d, Score:%d, LeftTime:%d, MapNumber:%d)", iBridgeIndex+1, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].AccountID, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name, 3, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_iBloodCastleEXP, iREWARD_EXP, iREWARD_ZEN, iREWARD_SCR, iLEFT_TIME, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber);

  08736	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  08739	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0873f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  08742	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  08746	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _i$237764[ebp]
  0874c	6b c0 14	 imul	 eax, 20			; 00000014H
  0874f	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  08753	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  08759	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0875f	0f b6 84 0a 49
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+329]
  08767	50		 push	 eax
  08768	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _iLEFT_TIME$[ebp]
  0876e	51		 push	 ecx
  0876f	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _iREWARD_SCR$[ebp]
  08775	52		 push	 edx
  08776	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _iREWARD_ZEN$[ebp]
  0877c	50		 push	 eax
  0877d	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _iREWARD_EXP$[ebp]
  08783	51		 push	 ecx
  08784	8b 55 0c	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  08787	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  0878d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  08790	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  08794	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _i$237764[ebp]
  0879a	6b d2 14	 imul	 edx, 20			; 00000014H
  0879d	8b 44 11 18	 mov	 eax, DWORD PTR [ecx+edx+24]
  087a1	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  087a7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  087ad	8b 94 01 a0 0e
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3744]
  087b4	52		 push	 edx
  087b5	6a 03		 push	 3
  087b7	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  087ba	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  087c0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  087c3	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  087c7	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _i$237764[ebp]
  087cd	6b c0 14	 imul	 eax, 20			; 00000014H
  087d0	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  087d4	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  087da	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  087e0	8d 44 0a 77	 lea	 eax, DWORD PTR [edx+ecx+119]
  087e4	50		 push	 eax
  087e5	8b 4d 0c	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  087e8	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  087ee	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  087f1	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  087f5	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _i$237764[ebp]
  087fb	6b c9 14	 imul	 ecx, 20			; 00000014H
  087fe	8b 54 08 18	 mov	 edx, DWORD PTR [eax+ecx+24]
  08802	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  08808	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0880d	8d 4c 10 6c	 lea	 ecx, DWORD PTR [eax+edx+108]
  08811	51		 push	 ecx
  08812	8b 55 0c	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  08815	83 c2 01	 add	 edx, 1
  08818	52		 push	 edx
  08819	68 00 00 00 00	 push	 OFFSET ??_C@_0IN@OCADDENK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Comple@
  0881e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  08824	83 c4 2c	 add	 esp, 44			; 0000002cH

; 2846 : 					break;

  08827	e9 dc 01 00 00	 jmp	 $LN8@GiveReward
$LN1@GiveReward:

; 2847 : 
; 2848 : 				case 4:
; 2849 : 					iADD_EXP += this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 1000 * ::g_iBC_Add_Exp[iBridgeIndex].unkC;

  0882c	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0882f	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  08835	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  08838	8b 84 01 ac 03
	00 00		 mov	 eax, DWORD PTR [ecx+eax+940]
  0883f	99		 cdq
  08840	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  08845	f7 f9		 idiv	 ecx
  08847	8b 55 0c	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  0884a	c1 e2 04	 shl	 edx, 4
  0884d	0f af 82 0c 00
	00 00		 imul	 eax, DWORD PTR _g_iBC_Add_Exp[edx+12]
  08854	03 85 c4 fd ff
	ff		 add	 eax, DWORD PTR _iADD_EXP$237774[ebp]
  0885a	89 85 c4 fd ff
	ff		 mov	 DWORD PTR _iADD_EXP$237774[ebp], eax

; 2850 : 					iREWARD_EXP = this->CalcSendRewardEXP(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iADD_EXP);

  08860	8b 85 c4 fd ff
	ff		 mov	 eax, DWORD PTR _iADD_EXP$237774[ebp]
  08866	50		 push	 eax
  08867	8b 4d 0c	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  0886a	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  08870	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  08873	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  08877	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _i$237764[ebp]
  0887d	6b c9 14	 imul	 ecx, 20			; 00000014H
  08880	8b 54 08 18	 mov	 edx, DWORD PTR [eax+ecx+24]
  08884	52		 push	 edx
  08885	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  08888	e8 00 00 00 00	 call	 ?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardEXP
  0888d	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _iREWARD_EXP$[ebp], eax

; 2851 : 					iREWARD_ZEN = this->CalcSendRewardZEN(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, ::g_iQuestWinExpendZEN[iBridgeIndex].NormalCharacter);

  08893	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  08896	8b 0c c5 00 00
	00 00		 mov	 ecx, DWORD PTR _g_iQuestWinExpendZEN[eax*8]
  0889d	51		 push	 ecx
  0889e	8b 55 0c	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  088a1	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  088a7	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  088aa	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  088ae	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _i$237764[ebp]
  088b4	6b d2 14	 imul	 edx, 20			; 00000014H
  088b7	8b 44 11 18	 mov	 eax, DWORD PTR [ecx+edx+24]
  088bb	50		 push	 eax
  088bc	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  088bf	e8 00 00 00 00	 call	 ?CalcSendRewardZEN@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardZEN
  088c4	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _iREWARD_ZEN$[ebp], eax

; 2852 : 					iREWARD_SCR = ::g_iBC_EventScore[iBridgeIndex].unk10;

  088ca	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  088cd	6b c0 14	 imul	 eax, 20			; 00000014H
  088d0	8b 88 10 00 00
	00		 mov	 ecx, DWORD PTR _g_iBC_EventScore[eax+16]
  088d6	89 8d ec fe ff
	ff		 mov	 DWORD PTR _iREWARD_SCR$[ebp], ecx

; 2853 : 					this->SendRewardScore(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iREWARD_SCR, iLEFT_TIME, iALIVE_PARTYCOUNT);

  088dc	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _iALIVE_PARTYCOUNT$[ebp]
  088e2	50		 push	 eax
  088e3	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _iLEFT_TIME$[ebp]
  088e9	51		 push	 ecx
  088ea	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _iREWARD_SCR$[ebp]
  088f0	52		 push	 edx
  088f1	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  088f4	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  088fa	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  088fd	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  08901	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _i$237764[ebp]
  08907	6b c0 14	 imul	 eax, 20			; 00000014H
  0890a	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  0890e	51		 push	 ecx
  0890f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  08912	e8 00 00 00 00	 call	 ?SendRewardScore@CBloodCastle@@QAEXHHHH@Z ; CBloodCastle::SendRewardScore

; 2854 : 					LogAddTD("[Blood Castle] (%d) Quest Complete Rewarded (Account:%s, Name:%s [State:%d], Exp:%d, ExtExp:%d, Zen:%d, Score:%d, LeftTime:%d, MapNumber:%d)", iBridgeIndex+1, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].AccountID, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name, 4, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_iBloodCastleEXP, iREWARD_EXP, iREWARD_ZEN, iREWARD_SCR, iLEFT_TIME, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber);

  08917	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0891a	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  08920	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  08923	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  08927	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _i$237764[ebp]
  0892d	6b c0 14	 imul	 eax, 20			; 00000014H
  08930	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  08934	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0893a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08940	0f b6 84 0a 49
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+329]
  08948	50		 push	 eax
  08949	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _iLEFT_TIME$[ebp]
  0894f	51		 push	 ecx
  08950	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _iREWARD_SCR$[ebp]
  08956	52		 push	 edx
  08957	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _iREWARD_ZEN$[ebp]
  0895d	50		 push	 eax
  0895e	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _iREWARD_EXP$[ebp]
  08964	51		 push	 ecx
  08965	8b 55 0c	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  08968	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  0896e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  08971	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  08975	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _i$237764[ebp]
  0897b	6b d2 14	 imul	 edx, 20			; 00000014H
  0897e	8b 44 11 18	 mov	 eax, DWORD PTR [ecx+edx+24]
  08982	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  08988	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0898e	8b 94 01 a0 0e
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3744]
  08995	52		 push	 edx
  08996	6a 04		 push	 4
  08998	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0899b	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  089a1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  089a4	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  089a8	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _i$237764[ebp]
  089ae	6b c0 14	 imul	 eax, 20			; 00000014H
  089b1	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  089b5	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  089bb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  089c1	8d 44 0a 77	 lea	 eax, DWORD PTR [edx+ecx+119]
  089c5	50		 push	 eax
  089c6	8b 4d 0c	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  089c9	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  089cf	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  089d2	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  089d6	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _i$237764[ebp]
  089dc	6b c9 14	 imul	 ecx, 20			; 00000014H
  089df	8b 54 08 18	 mov	 edx, DWORD PTR [eax+ecx+24]
  089e3	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  089e9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  089ee	8d 4c 10 6c	 lea	 ecx, DWORD PTR [eax+edx+108]
  089f2	51		 push	 ecx
  089f3	8b 55 0c	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  089f6	83 c2 01	 add	 edx, 1
  089f9	52		 push	 edx
  089fa	68 00 00 00 00	 push	 OFFSET ??_C@_0IN@OCADDENK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Comple@
  089ff	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  08a05	83 c4 2c	 add	 esp, 44			; 0000002cH
$LN8@GiveReward:

; 2855 : 					break;
; 2856 : 			}
; 2857 : 
; 2858 : 			GCS_BC_GIVE_REWARD pMsg;
; 2859 : 
; 2860 : 			pMsg.bWinner = true;

  08a08	c6 85 e7 f9 ff
	ff 01		 mov	 BYTE PTR _pMsg$237799[ebp+3], 1

; 2861 : 			pMsg.btType = -1;

  08a0f	c6 85 e8 f9 ff
	ff ff		 mov	 BYTE PTR _pMsg$237799[ebp+4], 255 ; 000000ffH

; 2862 : 			memcpy(pMsg.m_stBCCharScore[0].CharName , gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name, MAX_ACCOUNT_LEN);

  08a16	6a 0a		 push	 10			; 0000000aH
  08a18	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  08a1b	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  08a21	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  08a24	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  08a28	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _i$237764[ebp]
  08a2e	6b c0 14	 imul	 eax, 20			; 00000014H
  08a31	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  08a35	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  08a3b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08a41	8d 44 0a 77	 lea	 eax, DWORD PTR [edx+ecx+119]
  08a45	50		 push	 eax
  08a46	8d 8d e9 f9 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$237799[ebp+5]
  08a4c	51		 push	 ecx
  08a4d	e8 00 00 00 00	 call	 _memcpy
  08a52	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2863 : 			pMsg.m_stBCCharScore[0].iEXP = iREWARD_EXP;

  08a55	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _iREWARD_EXP$[ebp]
  08a5b	89 85 f9 f9 ff
	ff		 mov	 DWORD PTR _pMsg$237799[ebp+21], eax

; 2864 : 			pMsg.m_stBCCharScore[0].iZEN = iREWARD_ZEN;

  08a61	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _iREWARD_ZEN$[ebp]
  08a67	89 85 fd f9 ff
	ff		 mov	 DWORD PTR _pMsg$237799[ebp+25], eax

; 2865 : 			pMsg.m_stBCCharScore[0].iSCORE = iREWARD_SCR;

  08a6d	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _iREWARD_SCR$[ebp]
  08a73	89 85 f5 f9 ff
	ff		 mov	 DWORD PTR _pMsg$237799[ebp+17], eax

; 2866 : 			PHeadSetB((LPBYTE)&pMsg.PHeader, 0x93, sizeof(GCS_BC_GIVE_REWARD) - (sizeof(ST_BC_SCORE) * (MAX_BLOOD_CASTLE_SUB_BRIDGE -1)) );

  08a79	6a 35		 push	 53			; 00000035H
  08a7b	68 93 00 00 00	 push	 147			; 00000093H
  08a80	8d 85 e4 f9 ff
	ff		 lea	 eax, DWORD PTR _pMsg$237799[ebp]
  08a86	50		 push	 eax
  08a87	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  08a8c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2867 : 
; 2868 : 			DataSend(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, (LPBYTE)&pMsg, pMsg.PHeader.uSize);

  08a8f	0f b6 85 e5 f9
	ff ff		 movzx	 eax, BYTE PTR _pMsg$237799[ebp+1]
  08a96	50		 push	 eax
  08a97	8d 8d e4 f9 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$237799[ebp]
  08a9d	51		 push	 ecx
  08a9e	8b 55 0c	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  08aa1	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  08aa7	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  08aaa	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  08aae	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _i$237764[ebp]
  08ab4	6b d2 14	 imul	 edx, 20			; 00000014H
  08ab7	8b 44 11 18	 mov	 eax, DWORD PTR [ecx+edx+24]
  08abb	50		 push	 eax
  08abc	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  08ac1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2869 : 		}

  08ac4	e9 37 ef ff ff	 jmp	 $LN27@GiveReward
$LN26@GiveReward:

; 2870 : 
; 2871 : 		this->m_BridgeData[iBridgeIndex].m_bBC_REWARDED = true;

  08ac9	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  08acc	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  08ad2	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  08ad5	c6 84 01 be 03
	00 00 01	 mov	 BYTE PTR [ecx+eax+958], 1
$LN35@GiveReward:

; 2872 : 	}
; 2873 : }

  08add	5f		 pop	 edi
  08ade	5e		 pop	 esi
  08adf	5b		 pop	 ebx
  08ae0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  08ae3	33 cd		 xor	 ecx, ebp
  08ae5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  08aea	8b e5		 mov	 esp, ebp
  08aec	5d		 pop	 ebp
  08aed	c2 08 00	 ret	 8
$LN49@GiveReward:
  08af0	00 00 00 00	 DD	 $LN7@GiveReward
  08af4	00 00 00 00	 DD	 $LN6@GiveReward
  08af8	00 00 00 00	 DD	 $LN5@GiveReward
  08afc	00 00 00 00	 DD	 $LN3@GiveReward
  08b00	00 00 00 00	 DD	 $LN1@GiveReward
?GiveReward_Win@CBloodCastle@@QAEXHH@Z ENDP		; CBloodCastle::GiveReward_Win
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\tnotice.h
_TEXT	ENDS
;	COMDAT ?_ARGB@@YAKEEEE@Z
_TEXT	SEGMENT
_a$ = 8							; size = 1
_r$ = 12						; size = 1
_g$ = 16						; size = 1
_b$ = 20						; size = 1
?_ARGB@@YAKEEEE@Z PROC					; _ARGB, COMDAT

; 9    : __inline DWORD _ARGB(BYTE a, BYTE r, BYTE g, BYTE b){ return a*16777216 + b*65536 + g*256 + r;}; // in tnotice.h : line 8

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	0f b6 45 08	 movzx	 eax, BYTE PTR _a$[ebp]
  0000d	c1 e0 18	 shl	 eax, 24			; 00000018H
  00010	0f b6 4d 14	 movzx	 ecx, BYTE PTR _b$[ebp]
  00014	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00017	03 c1		 add	 eax, ecx
  00019	0f b6 55 10	 movzx	 edx, BYTE PTR _g$[ebp]
  0001d	c1 e2 08	 shl	 edx, 8
  00020	03 c2		 add	 eax, edx
  00022	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _r$[ebp]
  00026	03 c1		 add	 eax, ecx
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?_ARGB@@YAKEEEE@Z ENDP					; _ARGB
_TEXT	ENDS
PUBLIC	??_C@_0GA@JIFFPAHP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Send?5User?5Qu@ ; `string'
PUBLIC	??_C@_0GA@HCBPNCII@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Fail?5R@ ; `string'
PUBLIC	??_C@_0FJ@DAACGPGK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@ ; `string'
PUBLIC	?GetWhoGotUltimateWeapon@CBloodCastle@@QAEHH@Z	; CBloodCastle::GetWhoGotUltimateWeapon
PUBLIC	?FixUsersPlayStateFail@CBloodCastle@@QAEXH@Z	; CBloodCastle::FixUsersPlayStateFail
PUBLIC	__$ArrayPad$
;	COMDAT ??_C@_0GA@JIFFPAHP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Send?5User?5Qu@
; File d:\projects\exteam6.3\source\gameserver\gameserver\bloodcastle.cpp
CONST	SEGMENT
??_C@_0GA@JIFFPAHP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Send?5User?5Qu@ DB '['
	DB	'Blood Castle] (%d) Send User Quest Fail Message (Account:%s, '
	DB	'Name:%s [State:%d], MapNumber:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@HCBPNCII@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Fail?5R@
CONST	SEGMENT
??_C@_0GA@HCBPNCII@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Fail?5R@ DB '['
	DB	'Blood Castle] (%d) Quest Fail Rewarded (Account:%s, Name:%s, '
	DB	'Score:%d, ExtEXP:%d, LeftTime:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FJ@DAACGPGK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@
CONST	SEGMENT
??_C@_0FJ@DAACGPGK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@ DB '['
	DB	'Blood Castle] (%d) (Account:%s, Name:%s) got Ultimate Weapon '
	DB	'(%d) but Failed - Time Out', 00H		; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv78 = -1080						; size = 4
tv69 = -1080						; size = 4
_pMsg$237832 = -1012					; size = 989
_iADD_EXP$237821 = -20					; size = 4
_i$237813 = -16						; size = 4
_iUserWhoGotUltimateWeapon$ = -12			; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
?GiveReward_Fail@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::GiveReward_Fail
; _this$ = ecx

; 2876 : {

  08b10	55		 push	 ebp
  08b11	8b ec		 mov	 ebp, esp
  08b13	81 ec 38 04 00
	00		 sub	 esp, 1080		; 00000438H
  08b19	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  08b1e	33 c5		 xor	 eax, ebp
  08b20	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  08b23	53		 push	 ebx
  08b24	56		 push	 esi
  08b25	57		 push	 edi
  08b26	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2877 : 	this->FixUsersPlayStateFail(iBridgeIndex);

  08b29	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  08b2c	50		 push	 eax
  08b2d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  08b30	e8 00 00 00 00	 call	 ?FixUsersPlayStateFail@CBloodCastle@@QAEXH@Z ; CBloodCastle::FixUsersPlayStateFail

; 2878 : 
; 2879 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  08b35	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  08b39	7d 0c		 jge	 SHORT $LN23@GiveReward@2
  08b3b	c7 85 c8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv69[ebp], 0
  08b45	eb 0f		 jmp	 SHORT $LN24@GiveReward@2
$LN23@GiveReward@2:
  08b47	33 c0		 xor	 eax, eax
  08b49	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  08b4d	0f 9e c0	 setle	 al
  08b50	89 85 c8 fb ff
	ff		 mov	 DWORD PTR tv69[ebp], eax
$LN24@GiveReward@2:
  08b56	83 bd c8 fb ff
	ff 00		 cmp	 DWORD PTR tv69[ebp], 0
  08b5d	75 05		 jne	 SHORT $LN20@GiveReward@2

; 2880 : 	{
; 2881 : 		return;

  08b5f	e9 f3 05 00 00	 jmp	 $LN21@GiveReward@2
$LN20@GiveReward@2:

; 2882 : 	}
; 2883 : 
; 2884 : 	int iUserWhoGotUltimateWeapon = -1;

  08b64	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _iUserWhoGotUltimateWeapon$[ebp], -1

; 2885 : 	iUserWhoGotUltimateWeapon = this->GetWhoGotUltimateWeapon(iBridgeIndex);

  08b6b	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  08b6e	50		 push	 eax
  08b6f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  08b72	e8 00 00 00 00	 call	 ?GetWhoGotUltimateWeapon@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetWhoGotUltimateWeapon
  08b77	89 45 f4	 mov	 DWORD PTR _iUserWhoGotUltimateWeapon$[ebp], eax

; 2886 : 
; 2887 : 	if ( iUserWhoGotUltimateWeapon != -1 )

  08b7a	83 7d f4 ff	 cmp	 DWORD PTR _iUserWhoGotUltimateWeapon$[ebp], -1
  08b7e	74 7f		 je	 SHORT $LN19@GiveReward@2

; 2888 : 	{
; 2889 : 		if ( OBJMAX_RANGE(iUserWhoGotUltimateWeapon) != FALSE )

  08b80	83 7d f4 00	 cmp	 DWORD PTR _iUserWhoGotUltimateWeapon$[ebp], 0
  08b84	7d 0c		 jge	 SHORT $LN25@GiveReward@2
  08b86	c7 85 c8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv78[ebp], 0
  08b90	eb 12		 jmp	 SHORT $LN26@GiveReward@2
$LN25@GiveReward@2:
  08b92	33 c0		 xor	 eax, eax
  08b94	81 7d f4 97 3a
	00 00		 cmp	 DWORD PTR _iUserWhoGotUltimateWeapon$[ebp], 14999 ; 00003a97H
  08b9b	0f 9e c0	 setle	 al
  08b9e	89 85 c8 fb ff
	ff		 mov	 DWORD PTR tv78[ebp], eax
$LN26@GiveReward@2:
  08ba4	83 bd c8 fb ff
	ff 00		 cmp	 DWORD PTR tv78[ebp], 0
  08bab	74 52		 je	 SHORT $LN19@GiveReward@2

; 2890 : 		{
; 2891 : 			LogAddTD("[Blood Castle] (%d) (Account:%s, Name:%s) got Ultimate Weapon (%d) but Failed - Time Out", iBridgeIndex+1, gObj[iUserWhoGotUltimateWeapon].AccountID, gObj[iUserWhoGotUltimateWeapon].Name, this->m_BridgeData[iBridgeIndex].m_btBC_QUEST_ITEM_NUMBER);

  08bad	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  08bb0	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  08bb6	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  08bb9	0f b6 94 01 f0
	03 00 00	 movzx	 edx, BYTE PTR [ecx+eax+1008]
  08bc1	52		 push	 edx
  08bc2	8b 45 f4	 mov	 eax, DWORD PTR _iUserWhoGotUltimateWeapon$[ebp]
  08bc5	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  08bcb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08bd1	8d 54 01 77	 lea	 edx, DWORD PTR [ecx+eax+119]
  08bd5	52		 push	 edx
  08bd6	8b 45 f4	 mov	 eax, DWORD PTR _iUserWhoGotUltimateWeapon$[ebp]
  08bd9	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  08bdf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08be5	8d 54 01 6c	 lea	 edx, DWORD PTR [ecx+eax+108]
  08be9	52		 push	 edx
  08bea	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  08bed	83 c0 01	 add	 eax, 1
  08bf0	50		 push	 eax
  08bf1	68 00 00 00 00	 push	 OFFSET ??_C@_0FJ@DAACGPGK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@
  08bf6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  08bfc	83 c4 14	 add	 esp, 20			; 00000014H
$LN19@GiveReward@2:

; 2892 : 		}
; 2893 : 	}
; 2894 : 
; 2895 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  08bff	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$237813[ebp], 0
  08c06	eb 09		 jmp	 SHORT $LN17@GiveReward@2
$LN16@GiveReward@2:
  08c08	8b 45 f0	 mov	 eax, DWORD PTR _i$237813[ebp]
  08c0b	83 c0 01	 add	 eax, 1
  08c0e	89 45 f0	 mov	 DWORD PTR _i$237813[ebp], eax
$LN17@GiveReward@2:
  08c11	83 7d f0 28	 cmp	 DWORD PTR _i$237813[ebp], 40 ; 00000028H
  08c15	0f 8d 3c 05 00
	00		 jge	 $LN21@GiveReward@2

; 2896 : 	{
; 2897 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == -1 )

  08c1b	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  08c1e	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  08c24	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  08c27	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  08c2b	8b 45 f0	 mov	 eax, DWORD PTR _i$237813[ebp]
  08c2e	6b c0 14	 imul	 eax, 20			; 00000014H
  08c31	83 7c 02 18 ff	 cmp	 DWORD PTR [edx+eax+24], -1
  08c36	75 02		 jne	 SHORT $LN14@GiveReward@2

; 2898 : 		{
; 2899 : 			continue;

  08c38	eb ce		 jmp	 SHORT $LN16@GiveReward@2
$LN14@GiveReward@2:

; 2900 : 		}
; 2901 : 
; 2902 : 		if ( gObj[ this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex ].Connected < PLAYER_PLAYING )

  08c3a	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  08c3d	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  08c43	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  08c46	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  08c4a	8b 45 f0	 mov	 eax, DWORD PTR _i$237813[ebp]
  08c4d	6b c0 14	 imul	 eax, 20			; 00000014H
  08c50	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  08c54	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  08c5a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08c60	83 7c 0a 04 03	 cmp	 DWORD PTR [edx+ecx+4], 3
  08c65	7d 02		 jge	 SHORT $LN13@GiveReward@2

; 2903 : 		{
; 2904 : 			continue;

  08c67	eb 9f		 jmp	 SHORT $LN16@GiveReward@2
$LN13@GiveReward@2:

; 2905 : 		}
; 2906 : 
; 2907 : 		if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex == -1 || gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex == -1 )

  08c69	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  08c6c	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  08c72	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  08c75	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  08c79	8b 45 f0	 mov	 eax, DWORD PTR _i$237813[ebp]
  08c7c	6b c0 14	 imul	 eax, 20			; 00000014H
  08c7f	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  08c83	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  08c89	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08c8f	0f be 84 0a 9e
	0e 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3742]
  08c97	83 f8 ff	 cmp	 eax, -1
  08c9a	74 33		 je	 SHORT $LN11@GiveReward@2
  08c9c	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  08c9f	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  08ca5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  08ca8	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  08cac	8b 45 f0	 mov	 eax, DWORD PTR _i$237813[ebp]
  08caf	6b c0 14	 imul	 eax, 20			; 00000014H
  08cb2	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  08cb6	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  08cbc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08cc2	0f be 84 0a 9f
	0e 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3743]
  08cca	83 f8 ff	 cmp	 eax, -1
  08ccd	75 05		 jne	 SHORT $LN12@GiveReward@2
$LN11@GiveReward@2:

; 2908 : 		{
; 2909 : 			continue;

  08ccf	e9 34 ff ff ff	 jmp	 $LN16@GiveReward@2
$LN12@GiveReward@2:

; 2910 : 		}	
; 2911 : 
; 2912 : 		int iADD_EXP = 0;

  08cd4	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _iADD_EXP$237821[ebp], 0

; 2913 : 
; 2914 : 		if ( (gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber != -1 && gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber == this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Door_Party) || this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Door_Index)

  08cdb	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  08cde	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  08ce4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  08ce7	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  08ceb	8b 45 f0	 mov	 eax, DWORD PTR _i$237813[ebp]
  08cee	6b c0 14	 imul	 eax, 20			; 00000014H
  08cf1	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  08cf5	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  08cfb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08d01	83 bc 0a 2c 04
	00 00 ff	 cmp	 DWORD PTR [edx+ecx+1068], -1
  08d09	74 41		 je	 SHORT $LN8@GiveReward@2
  08d0b	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  08d0e	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  08d14	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  08d17	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  08d1b	8b 45 f0	 mov	 eax, DWORD PTR _i$237813[ebp]
  08d1e	6b c0 14	 imul	 eax, 20			; 00000014H
  08d21	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  08d25	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  08d2b	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  08d2e	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  08d34	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08d39	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  08d3c	8b 8c 08 2c 04
	00 00		 mov	 ecx, DWORD PTR [eax+ecx+1068]
  08d43	3b 8c 16 f8 03
	00 00		 cmp	 ecx, DWORD PTR [esi+edx+1016]
  08d4a	74 2f		 je	 SHORT $LN9@GiveReward@2
$LN8@GiveReward@2:
  08d4c	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  08d4f	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  08d55	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  08d58	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  08d5c	8b 45 f0	 mov	 eax, DWORD PTR _i$237813[ebp]
  08d5f	6b c0 14	 imul	 eax, 20			; 00000014H
  08d62	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  08d65	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  08d6b	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  08d6e	8b 54 02 18	 mov	 edx, DWORD PTR [edx+eax+24]
  08d72	3b 94 0e fc 03
	00 00		 cmp	 edx, DWORD PTR [esi+ecx+1020]
  08d79	75 14		 jne	 SHORT $LN10@GiveReward@2
$LN9@GiveReward@2:

; 2915 : 		{
; 2916 : 			iADD_EXP += ::g_iBC_Add_Exp[iBridgeIndex].unk0;

  08d7b	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  08d7e	c1 e0 04	 shl	 eax, 4
  08d81	8b 4d ec	 mov	 ecx, DWORD PTR _iADD_EXP$237821[ebp]
  08d84	03 88 00 00 00
	00		 add	 ecx, DWORD PTR _g_iBC_Add_Exp[eax]
  08d8a	89 4d ec	 mov	 DWORD PTR _iADD_EXP$237821[ebp], ecx

; 2917 : 		}
; 2918 : 		else

  08d8d	eb 66		 jmp	 SHORT $LN7@GiveReward@2
$LN10@GiveReward@2:

; 2919 : 		{
; 2920 : 			if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber != -1 )

  08d8f	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  08d92	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  08d98	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  08d9b	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  08d9f	8b 45 f0	 mov	 eax, DWORD PTR _i$237813[ebp]
  08da2	6b c0 14	 imul	 eax, 20			; 00000014H
  08da5	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  08da9	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  08daf	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08db5	83 bc 0a 2c 04
	00 00 ff	 cmp	 DWORD PTR [edx+ecx+1068], -1
  08dbd	74 36		 je	 SHORT $LN7@GiveReward@2

; 2921 : 			{
; 2922 : 				if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bLiveWhenDoorBreak != false )

  08dbf	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  08dc2	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  08dc8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  08dcb	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  08dcf	8b 45 f0	 mov	 eax, DWORD PTR _i$237813[ebp]
  08dd2	6b c0 14	 imul	 eax, 20			; 00000014H
  08dd5	0f b6 4c 02 29	 movzx	 ecx, BYTE PTR [edx+eax+41]
  08dda	85 c9		 test	 ecx, ecx
  08ddc	74 17		 je	 SHORT $LN7@GiveReward@2

; 2923 : 				{
; 2924 : 					iADD_EXP += ::g_iBC_Add_Exp[iBridgeIndex].unk0 / 2;

  08dde	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  08de1	c1 e0 04	 shl	 eax, 4
  08de4	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR _g_iBC_Add_Exp[eax]
  08dea	99		 cdq
  08deb	2b c2		 sub	 eax, edx
  08ded	d1 f8		 sar	 eax, 1
  08def	03 45 ec	 add	 eax, DWORD PTR _iADD_EXP$237821[ebp]
  08df2	89 45 ec	 mov	 DWORD PTR _iADD_EXP$237821[ebp], eax
$LN7@GiveReward@2:

; 2925 : 				}
; 2926 : 			}
; 2927 : 		}
; 2928 : 
; 2929 : 		if ( (gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber != -1 && gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber == this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Statue_Party) || this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Statue_Index)

  08df5	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  08df8	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  08dfe	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  08e01	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  08e05	8b 45 f0	 mov	 eax, DWORD PTR _i$237813[ebp]
  08e08	6b c0 14	 imul	 eax, 20			; 00000014H
  08e0b	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  08e0f	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  08e15	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08e1b	83 bc 0a 2c 04
	00 00 ff	 cmp	 DWORD PTR [edx+ecx+1068], -1
  08e23	74 41		 je	 SHORT $LN2@GiveReward@2
  08e25	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  08e28	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  08e2e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  08e31	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  08e35	8b 45 f0	 mov	 eax, DWORD PTR _i$237813[ebp]
  08e38	6b c0 14	 imul	 eax, 20			; 00000014H
  08e3b	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  08e3f	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  08e45	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  08e48	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  08e4e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08e53	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  08e56	8b 8c 08 2c 04
	00 00		 mov	 ecx, DWORD PTR [eax+ecx+1068]
  08e5d	3b 8c 16 18 04
	00 00		 cmp	 ecx, DWORD PTR [esi+edx+1048]
  08e64	74 2f		 je	 SHORT $LN3@GiveReward@2
$LN2@GiveReward@2:
  08e66	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  08e69	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  08e6f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  08e72	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  08e76	8b 45 f0	 mov	 eax, DWORD PTR _i$237813[ebp]
  08e79	6b c0 14	 imul	 eax, 20			; 00000014H
  08e7c	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  08e7f	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  08e85	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  08e88	8b 54 02 18	 mov	 edx, DWORD PTR [edx+eax+24]
  08e8c	3b 94 0e 1c 04
	00 00		 cmp	 edx, DWORD PTR [esi+ecx+1052]
  08e93	75 12		 jne	 SHORT $LN4@GiveReward@2
$LN3@GiveReward@2:

; 2930 : 		{
; 2931 : 			iADD_EXP += ::g_iBC_Add_Exp[iBridgeIndex].unk4;

  08e95	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  08e98	c1 e0 04	 shl	 eax, 4
  08e9b	8b 4d ec	 mov	 ecx, DWORD PTR _iADD_EXP$237821[ebp]
  08e9e	03 88 04 00 00
	00		 add	 ecx, DWORD PTR _g_iBC_Add_Exp[eax+4]
  08ea4	89 4d ec	 mov	 DWORD PTR _iADD_EXP$237821[ebp], ecx
$LN4@GiveReward@2:

; 2932 : 		}
; 2933 : 
; 2934 : 		this->CalcSendRewardEXP(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iADD_EXP);

  08ea7	8b 45 ec	 mov	 eax, DWORD PTR _iADD_EXP$237821[ebp]
  08eaa	50		 push	 eax
  08eab	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  08eae	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  08eb4	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  08eb7	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  08ebb	8b 4d f0	 mov	 ecx, DWORD PTR _i$237813[ebp]
  08ebe	6b c9 14	 imul	 ecx, 20			; 00000014H
  08ec1	8b 54 08 18	 mov	 edx, DWORD PTR [eax+ecx+24]
  08ec5	52		 push	 edx
  08ec6	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  08ec9	e8 00 00 00 00	 call	 ?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardEXP

; 2935 : 		this->SendRewardScore(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, ::g_iBC_EventScore_Fail[iBridgeIndex], 0, 0);

  08ece	6a 00		 push	 0
  08ed0	6a 00		 push	 0
  08ed2	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  08ed5	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _g_iBC_EventScore_Fail[eax*4]
  08edc	51		 push	 ecx
  08edd	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  08ee0	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  08ee6	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  08ee9	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  08eed	8b 55 f0	 mov	 edx, DWORD PTR _i$237813[ebp]
  08ef0	6b d2 14	 imul	 edx, 20			; 00000014H
  08ef3	8b 44 11 18	 mov	 eax, DWORD PTR [ecx+edx+24]
  08ef7	50		 push	 eax
  08ef8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  08efb	e8 00 00 00 00	 call	 ?SendRewardScore@CBloodCastle@@QAEXHHHH@Z ; CBloodCastle::SendRewardScore

; 2936 : 
; 2937 : 		LogAddTD("[Blood Castle] (%d) Quest Fail Rewarded (Account:%s, Name:%s, Score:%d, ExtEXP:%d, LeftTime:%d)", iBridgeIndex+1, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].AccountID, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name, ::g_iBC_EventScore_Fail[iBridgeIndex], iADD_EXP, 0);

  08f00	6a 00		 push	 0
  08f02	8b 45 ec	 mov	 eax, DWORD PTR _iADD_EXP$237821[ebp]
  08f05	50		 push	 eax
  08f06	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  08f09	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _g_iBC_EventScore_Fail[ecx*4]
  08f10	52		 push	 edx
  08f11	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  08f14	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  08f1a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  08f1d	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  08f21	8b 45 f0	 mov	 eax, DWORD PTR _i$237813[ebp]
  08f24	6b c0 14	 imul	 eax, 20			; 00000014H
  08f27	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  08f2b	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  08f31	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08f37	8d 44 0a 77	 lea	 eax, DWORD PTR [edx+ecx+119]
  08f3b	50		 push	 eax
  08f3c	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  08f3f	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  08f45	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  08f48	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  08f4c	8b 4d f0	 mov	 ecx, DWORD PTR _i$237813[ebp]
  08f4f	6b c9 14	 imul	 ecx, 20			; 00000014H
  08f52	8b 54 08 18	 mov	 edx, DWORD PTR [eax+ecx+24]
  08f56	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  08f5c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08f61	8d 4c 10 6c	 lea	 ecx, DWORD PTR [eax+edx+108]
  08f65	51		 push	 ecx
  08f66	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  08f69	83 c2 01	 add	 edx, 1
  08f6c	52		 push	 edx
  08f6d	68 00 00 00 00	 push	 OFFSET ??_C@_0GA@HCBPNCII@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Fail?5R@
  08f72	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  08f78	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2938 : 
; 2939 : 		GCS_BC_GIVE_REWARD pMsg;
; 2940 : 
; 2941 : 		pMsg.bWinner = false;

  08f7b	c6 85 0f fc ff
	ff 00		 mov	 BYTE PTR _pMsg$237832[ebp+3], 0

; 2942 : 		pMsg.btType = -1;

  08f82	c6 85 10 fc ff
	ff ff		 mov	 BYTE PTR _pMsg$237832[ebp+4], 255 ; 000000ffH

; 2943 : 		memcpy(pMsg.m_stBCCharScore[0].CharName, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name, MAX_ACCOUNT_LEN);

  08f89	6a 0a		 push	 10			; 0000000aH
  08f8b	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  08f8e	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  08f94	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  08f97	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  08f9b	8b 45 f0	 mov	 eax, DWORD PTR _i$237813[ebp]
  08f9e	6b c0 14	 imul	 eax, 20			; 00000014H
  08fa1	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  08fa5	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  08fab	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  08fb1	8d 44 0a 77	 lea	 eax, DWORD PTR [edx+ecx+119]
  08fb5	50		 push	 eax
  08fb6	8d 8d 11 fc ff
	ff		 lea	 ecx, DWORD PTR _pMsg$237832[ebp+5]
  08fbc	51		 push	 ecx
  08fbd	e8 00 00 00 00	 call	 _memcpy
  08fc2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2944 : 		pMsg.m_stBCCharScore[0].iEXP = iADD_EXP;

  08fc5	8b 45 ec	 mov	 eax, DWORD PTR _iADD_EXP$237821[ebp]
  08fc8	89 85 21 fc ff
	ff		 mov	 DWORD PTR _pMsg$237832[ebp+21], eax

; 2945 : 		pMsg.m_stBCCharScore[0].iZEN = 0;

  08fce	c7 85 25 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _pMsg$237832[ebp+25], 0

; 2946 : 		pMsg.m_stBCCharScore[0].iSCORE = g_iBC_EventScore_Fail[iBridgeIndex];

  08fd8	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  08fdb	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _g_iBC_EventScore_Fail[eax*4]
  08fe2	89 8d 1d fc ff
	ff		 mov	 DWORD PTR _pMsg$237832[ebp+17], ecx

; 2947 : 		PHeadSetB((LPBYTE)&pMsg.PHeader, 0x93, sizeof(GCS_BC_GIVE_REWARD) - (sizeof(ST_BC_SCORE) * (MAX_BLOOD_CASTLE_SUB_BRIDGE -1)) );

  08fe8	6a 35		 push	 53			; 00000035H
  08fea	68 93 00 00 00	 push	 147			; 00000093H
  08fef	8d 85 0c fc ff
	ff		 lea	 eax, DWORD PTR _pMsg$237832[ebp]
  08ff5	50		 push	 eax
  08ff6	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  08ffb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2948 : 
; 2949 : 		if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex != -1 && gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex != -1 )

  08ffe	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  09001	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  09007	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0900a	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0900e	8b 45 f0	 mov	 eax, DWORD PTR _i$237813[ebp]
  09011	6b c0 14	 imul	 eax, 20			; 00000014H
  09014	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  09018	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0901e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  09024	0f be 84 0a 9e
	0e 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3742]
  0902c	83 f8 ff	 cmp	 eax, -1
  0902f	0f 84 1d 01 00
	00		 je	 $LN1@GiveReward@2
  09035	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  09038	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0903e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  09041	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  09045	8b 45 f0	 mov	 eax, DWORD PTR _i$237813[ebp]
  09048	6b c0 14	 imul	 eax, 20			; 00000014H
  0904b	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  0904f	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  09055	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0905b	0f be 84 0a 9f
	0e 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3743]
  09063	83 f8 ff	 cmp	 eax, -1
  09066	0f 84 e6 00 00
	00		 je	 $LN1@GiveReward@2

; 2950 : 		{
; 2951 : 			DataSend(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, (LPBYTE)&pMsg, pMsg.PHeader.uSize);			

  0906c	0f b6 85 0d fc
	ff ff		 movzx	 eax, BYTE PTR _pMsg$237832[ebp+1]
  09073	50		 push	 eax
  09074	8d 8d 0c fc ff
	ff		 lea	 ecx, DWORD PTR _pMsg$237832[ebp]
  0907a	51		 push	 ecx
  0907b	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  0907e	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  09084	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  09087	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  0908b	8b 55 f0	 mov	 edx, DWORD PTR _i$237813[ebp]
  0908e	6b d2 14	 imul	 edx, 20			; 00000014H
  09091	8b 44 11 18	 mov	 eax, DWORD PTR [ecx+edx+24]
  09095	50		 push	 eax
  09096	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0909b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2952 : 
; 2953 : 			LogAddTD("[Blood Castle] (%d) Send User Quest Fail Message (Account:%s, Name:%s [State:%d], MapNumber:%d)", iBridgeIndex+1, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].AccountID, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name, this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber);

  0909e	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  090a1	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  090a7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  090aa	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  090ae	8b 45 f0	 mov	 eax, DWORD PTR _i$237813[ebp]
  090b1	6b c0 14	 imul	 eax, 20			; 00000014H
  090b4	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  090b8	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  090be	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  090c4	0f b6 84 0a 49
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+329]
  090cc	50		 push	 eax
  090cd	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  090d0	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  090d6	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  090d9	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  090dd	8b 4d f0	 mov	 ecx, DWORD PTR _i$237813[ebp]
  090e0	6b c9 14	 imul	 ecx, 20			; 00000014H
  090e3	8b 54 08 24	 mov	 edx, DWORD PTR [eax+ecx+36]
  090e7	52		 push	 edx
  090e8	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  090eb	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  090f1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  090f4	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  090f8	8b 45 f0	 mov	 eax, DWORD PTR _i$237813[ebp]
  090fb	6b c0 14	 imul	 eax, 20			; 00000014H
  090fe	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  09102	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  09108	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0910e	8d 44 0a 77	 lea	 eax, DWORD PTR [edx+ecx+119]
  09112	50		 push	 eax
  09113	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  09116	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  0911c	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0911f	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  09123	8b 4d f0	 mov	 ecx, DWORD PTR _i$237813[ebp]
  09126	6b c9 14	 imul	 ecx, 20			; 00000014H
  09129	8b 54 08 18	 mov	 edx, DWORD PTR [eax+ecx+24]
  0912d	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  09133	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  09138	8d 4c 10 6c	 lea	 ecx, DWORD PTR [eax+edx+108]
  0913c	51		 push	 ecx
  0913d	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  09140	83 c2 01	 add	 edx, 1
  09143	52		 push	 edx
  09144	68 00 00 00 00	 push	 OFFSET ??_C@_0GA@JIFFPAHP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Send?5User?5Qu@
  09149	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0914f	83 c4 18	 add	 esp, 24			; 00000018H
$LN1@GiveReward@2:

; 2954 : 		}	
; 2955 : 	}

  09152	e9 b1 fa ff ff	 jmp	 $LN16@GiveReward@2
$LN21@GiveReward@2:

; 2956 : }

  09157	5f		 pop	 edi
  09158	5e		 pop	 esi
  09159	5b		 pop	 ebx
  0915a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0915d	33 cd		 xor	 ecx, ebp
  0915f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  09164	8b e5		 mov	 esp, ebp
  09166	5d		 pop	 ebp
  09167	c2 04 00	 ret	 4
?GiveReward_Fail@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::GiveReward_Fail
_TEXT	ENDS
EXTRN	?GCKillPlayerExtSend@@YAXHH_JHH@Z:PROC		; GCKillPlayerExtSend
EXTRN	?CheckIsMasterLevelCharacter@CMasterLevelSystem@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CMasterLevelSystem::CheckIsMasterLevelCharacter
EXTRN	?gObjUserSetExp@@YAXPAUOBJECTSTRUCT@@AA_J@Z:PROC ; gObjUserSetExp
EXTRN	?gObjSealUserSetExp@@YAXPAUOBJECTSTRUCT@@AA_JH@Z:PROC ; gObjSealUserSetExp
EXTRN	?GetGettingExpPenaltyRate@CCrywolfSync@@QAEHXZ:PROC ; CCrywolfSync::GetGettingExpPenaltyRate
EXTRN	?g_iCrywolfApplyMvpPenalty@@3HA:DWORD		; g_iCrywolfApplyMvpPenalty
EXTRN	__ftol2:PROC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv225 = -88						; size = 4
tv78 = -88						; size = 4
_iCAL_EXP$ = -20					; size = 8
_iRET_EXP$ = -12					; size = 8
_this$ = -4						; size = 4
_iIndex$ = 8						; size = 4
_iEXP$ = 12						; size = 4
?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z PROC		; CBloodCastle::CalcSendRewardEXP
; _this$ = ecx

; 2960 : {

  09170	55		 push	 ebp
  09171	8b ec		 mov	 ebp, esp
  09173	83 ec 58	 sub	 esp, 88			; 00000058H
  09176	53		 push	 ebx
  09177	56		 push	 esi
  09178	57		 push	 edi
  09179	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2961 : 	if ( iEXP <= 0 )

  0917c	83 7d 0c 00	 cmp	 DWORD PTR _iEXP$[ebp], 0
  09180	7f 07		 jg	 SHORT $LN9@CalcSendRe

; 2962 : 	{
; 2963 : 		return 0;

  09182	33 c0		 xor	 eax, eax
  09184	e9 d3 01 00 00	 jmp	 $LN10@CalcSendRe
$LN9@CalcSendRe:

; 2964 : 	}
; 2965 : 
; 2966 : 	__int64 iRET_EXP = 0; //loc3

  09189	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iRET_EXP$[ebp], 0
  09190	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iRET_EXP$[ebp+4], 0

; 2967 : 	__int64 iCAL_EXP = iEXP; //loc2

  09197	8b 45 0c	 mov	 eax, DWORD PTR _iEXP$[ebp]
  0919a	99		 cdq
  0919b	89 45 ec	 mov	 DWORD PTR _iCAL_EXP$[ebp], eax
  0919e	89 55 f0	 mov	 DWORD PTR _iCAL_EXP$[ebp+4], edx

; 2968 : 	
; 2969 : 	if ( g_CrywolfSync.GetOccupationState() == 1 && g_iCrywolfApplyMvpPenalty )

  091a1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CrywolfSync@@3VCCrywolfSync@@A ; g_CrywolfSync
  091a6	e8 00 00 00 00	 call	 ?GetOccupationState@CCrywolfSync@@QAEHXZ ; CCrywolfSync::GetOccupationState
  091ab	83 f8 01	 cmp	 eax, 1
  091ae	75 34		 jne	 SHORT $LN8@CalcSendRe
  091b0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_iCrywolfApplyMvpPenalty@@3HA, 0 ; g_iCrywolfApplyMvpPenalty
  091b7	74 2b		 je	 SHORT $LN8@CalcSendRe

; 2970 : 	{
; 2971 : 		iCAL_EXP = iCAL_EXP * g_CrywolfSync.GetGettingExpPenaltyRate() / 100; //season 2.5 changed

  091b9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CrywolfSync@@3VCCrywolfSync@@A ; g_CrywolfSync
  091be	e8 00 00 00 00	 call	 ?GetGettingExpPenaltyRate@CCrywolfSync@@QAEHXZ ; CCrywolfSync::GetGettingExpPenaltyRate
  091c3	99		 cdq
  091c4	52		 push	 edx
  091c5	50		 push	 eax
  091c6	8b 45 f0	 mov	 eax, DWORD PTR _iCAL_EXP$[ebp+4]
  091c9	50		 push	 eax
  091ca	8b 4d ec	 mov	 ecx, DWORD PTR _iCAL_EXP$[ebp]
  091cd	51		 push	 ecx
  091ce	e8 00 00 00 00	 call	 __allmul
  091d3	6a 00		 push	 0
  091d5	6a 64		 push	 100			; 00000064H
  091d7	52		 push	 edx
  091d8	50		 push	 eax
  091d9	e8 00 00 00 00	 call	 __alldiv
  091de	89 45 ec	 mov	 DWORD PTR _iCAL_EXP$[ebp], eax
  091e1	89 55 f0	 mov	 DWORD PTR _iCAL_EXP$[ebp+4], edx
$LN8@CalcSendRe:

; 2972 : 	}
; 2973 : 
; 2974 : 	if ( OBJMAX_RANGE(iIndex) == FALSE ) //loc6

  091e4	83 7d 08 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  091e8	7d 09		 jge	 SHORT $LN12@CalcSendRe
  091ea	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
  091f1	eb 0f		 jmp	 SHORT $LN13@CalcSendRe
$LN12@CalcSendRe:
  091f3	33 c0		 xor	 eax, eax
  091f5	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _iIndex$[ebp], 14999 ; 00003a97H
  091fc	0f 9e c0	 setle	 al
  091ff	89 45 a8	 mov	 DWORD PTR tv78[ebp], eax
$LN13@CalcSendRe:
  09202	83 7d a8 00	 cmp	 DWORD PTR tv78[ebp], 0
  09206	75 07		 jne	 SHORT $LN7@CalcSendRe

; 2975 : 	{
; 2976 : 		return 0;

  09208	33 c0		 xor	 eax, eax
  0920a	e9 4d 01 00 00	 jmp	 $LN10@CalcSendRe
$LN7@CalcSendRe:

; 2977 : 	}
; 2978 : 
; 2979 : 	if ( gObj[iIndex].Connected < PLAYER_PLAYING )

  0920f	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  09212	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  09218	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0921e	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  09223	7d 07		 jge	 SHORT $LN6@CalcSendRe

; 2980 : 	{
; 2981 : 		return 0;

  09225	33 c0		 xor	 eax, eax
  09227	e9 30 01 00 00	 jmp	 $LN10@CalcSendRe
$LN6@CalcSendRe:

; 2982 : 	}
; 2983 : 
; 2984 : 	iRET_EXP = iCAL_EXP;

  0922c	8b 45 ec	 mov	 eax, DWORD PTR _iCAL_EXP$[ebp]
  0922f	89 45 f4	 mov	 DWORD PTR _iRET_EXP$[ebp], eax
  09232	8b 4d f0	 mov	 ecx, DWORD PTR _iCAL_EXP$[ebp+4]
  09235	89 4d f8	 mov	 DWORD PTR _iRET_EXP$[ebp+4], ecx

; 2985 : 
; 2986 : 	if ( gObj[iIndex].Type == OBJ_USER )

  09238	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0923b	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  09241	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  09247	0f b7 54 01 68	 movzx	 edx, WORD PTR [ecx+eax+104]
  0924c	83 fa 01	 cmp	 edx, 1
  0924f	0f 85 04 01 00
	00		 jne	 $LN1@CalcSendRe
$LN4@CalcSendRe:

; 2987 : 	{
; 2988 : 		while ( iCAL_EXP > 0 )

  09255	83 7d f0 00	 cmp	 DWORD PTR _iCAL_EXP$[ebp+4], 0
  09259	0f 8c bf 00 00
	00		 jl	 $LN3@CalcSendRe
  0925f	7f 0a		 jg	 SHORT $LN14@CalcSendRe
  09261	83 7d ec 00	 cmp	 DWORD PTR _iCAL_EXP$[ebp], 0
  09265	0f 86 b3 00 00
	00		 jbe	 $LN3@CalcSendRe
$LN14@CalcSendRe:

; 2989 : 		{
; 2990 : 			if ( iCAL_EXP > 0 )

  0926b	83 7d f0 00	 cmp	 DWORD PTR _iCAL_EXP$[ebp+4], 0
  0926f	0f 8c a4 00 00
	00		 jl	 $LN2@CalcSendRe
  09275	7f 0a		 jg	 SHORT $LN15@CalcSendRe
  09277	83 7d ec 00	 cmp	 DWORD PTR _iCAL_EXP$[ebp], 0
  0927b	0f 86 98 00 00
	00		 jbe	 $LN2@CalcSendRe
$LN15@CalcSendRe:

; 2991 : 			{
; 2992 : 				gObjSealUserSetExp(&gObj[iIndex], iCAL_EXP, TRUE); //Seal Exp

  09281	6a 01		 push	 1
  09283	8d 45 ec	 lea	 eax, DWORD PTR _iCAL_EXP$[ebp]
  09286	50		 push	 eax
  09287	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0928a	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  09290	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  09296	51		 push	 ecx
  09297	e8 00 00 00 00	 call	 ?gObjSealUserSetExp@@YAXPAUOBJECTSTRUCT@@AA_JH@Z ; gObjSealUserSetExp
  0929c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2993 : 				gObjUserSetExp(&gObj[iIndex],iCAL_EXP);	//Panda Use

  0929f	8d 45 ec	 lea	 eax, DWORD PTR _iCAL_EXP$[ebp]
  092a2	50		 push	 eax
  092a3	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  092a6	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  092ac	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  092b2	51		 push	 ecx
  092b3	e8 00 00 00 00	 call	 ?gObjUserSetExp@@YAXPAUOBJECTSTRUCT@@AA_J@Z ; gObjUserSetExp
  092b8	83 c4 08	 add	 esp, 8

; 2994 : 
; 2995 : 				iCAL_EXP = (__int64)((int)(iCAL_EXP) * this->m_BridgeData[gObj[iIndex].m_cBloodCastleIndex].m_iBC_REWARD_EXP); //season 4.5 add-on

  092bb	8b 45 ec	 mov	 eax, DWORD PTR _iCAL_EXP$[ebp]
  092be	89 45 a8	 mov	 DWORD PTR tv225[ebp], eax
  092c1	db 45 a8	 fild	 DWORD PTR tv225[ebp]
  092c4	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  092c7	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  092cd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  092d3	0f be 84 0a 9e
	0e 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3742]
  092db	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  092e1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  092e4	d8 8c 01 60 04
	00 00		 fmul	 DWORD PTR [ecx+eax+1120]
  092eb	e8 00 00 00 00	 call	 __ftol2
  092f0	89 45 ec	 mov	 DWORD PTR _iCAL_EXP$[ebp], eax
  092f3	89 55 f0	 mov	 DWORD PTR _iCAL_EXP$[ebp+4], edx

; 2996 : 				iRET_EXP = (int)(iCAL_EXP); //season 4.5 changed + fix

  092f6	8b 45 ec	 mov	 eax, DWORD PTR _iCAL_EXP$[ebp]
  092f9	99		 cdq
  092fa	89 45 f4	 mov	 DWORD PTR _iRET_EXP$[ebp], eax
  092fd	89 55 f8	 mov	 DWORD PTR _iRET_EXP$[ebp+4], edx

; 2997 : 
; 2998 : 				iCAL_EXP = this->LevelUp(iIndex, iCAL_EXP, 4);

  09300	6a 04		 push	 4
  09302	8b 45 ec	 mov	 eax, DWORD PTR _iCAL_EXP$[ebp]
  09305	50		 push	 eax
  09306	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  09309	51		 push	 ecx
  0930a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0930d	e8 00 00 00 00	 call	 ?LevelUp@CBloodCastle@@QAEHHHH@Z ; CBloodCastle::LevelUp
  09312	99		 cdq
  09313	89 45 ec	 mov	 DWORD PTR _iCAL_EXP$[ebp], eax
  09316	89 55 f0	 mov	 DWORD PTR _iCAL_EXP$[ebp+4], edx
$LN2@CalcSendRe:

; 2999 : 			}
; 3000 : 		}

  09319	e9 37 ff ff ff	 jmp	 $LN4@CalcSendRe
$LN3@CalcSendRe:

; 3001 : 
; 3002 : 		if(g_MasterLevelSystem.CheckIsMasterLevelCharacter(&gObj[iIndex]) == FALSE) //season3 add-on

  0931e	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  09321	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  09327	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0932d	50		 push	 eax
  0932e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterLevelSystem@@3VCMasterLevelSystem@@A ; g_MasterLevelSystem
  09333	e8 00 00 00 00	 call	 ?CheckIsMasterLevelCharacter@CMasterLevelSystem@@QAEHPAUOBJECTSTRUCT@@@Z ; CMasterLevelSystem::CheckIsMasterLevelCharacter
  09338	85 c0		 test	 eax, eax
  0933a	75 1d		 jne	 SHORT $LN1@CalcSendRe

; 3003 : 		{
; 3004 : 			GCKillPlayerExtSend(iIndex, (WORD)-1, iRET_EXP, 0, 0);

  0933c	6a 00		 push	 0
  0933e	6a 00		 push	 0
  09340	8b 45 f8	 mov	 eax, DWORD PTR _iRET_EXP$[ebp+4]
  09343	50		 push	 eax
  09344	8b 4d f4	 mov	 ecx, DWORD PTR _iRET_EXP$[ebp]
  09347	51		 push	 ecx
  09348	68 ff ff 00 00	 push	 65535			; 0000ffffH
  0934d	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  09350	52		 push	 edx
  09351	e8 00 00 00 00	 call	 ?GCKillPlayerExtSend@@YAXHH_JHH@Z ; GCKillPlayerExtSend
  09356	83 c4 18	 add	 esp, 24			; 00000018H
$LN1@CalcSendRe:

; 3005 : 		}
; 3006 : 	}
; 3007 : 
; 3008 : 	return iRET_EXP;

  09359	8b 45 f4	 mov	 eax, DWORD PTR _iRET_EXP$[ebp]
$LN10@CalcSendRe:

; 3009 : }

  0935c	5f		 pop	 edi
  0935d	5e		 pop	 esi
  0935e	5b		 pop	 ebx
  0935f	8b e5		 mov	 esp, ebp
  09361	5d		 pop	 ebp
  09362	c2 08 00	 ret	 8
?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z ENDP		; CBloodCastle::CalcSendRewardEXP
_TEXT	ENDS
EXTRN	?gObjCheckMaxZen@@YAHHH@Z:PROC			; gObjCheckMaxZen
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv68 = -76						; size = 4
_iRET_ZEN$ = -8						; size = 4
_this$ = -4						; size = 4
_iIndex$ = 8						; size = 4
_iZEN$ = 12						; size = 4
?CalcSendRewardZEN@CBloodCastle@@QAEHHH@Z PROC		; CBloodCastle::CalcSendRewardZEN
; _this$ = ecx

; 3012 : {

  09370	55		 push	 ebp
  09371	8b ec		 mov	 ebp, esp
  09373	83 ec 4c	 sub	 esp, 76			; 0000004cH
  09376	53		 push	 ebx
  09377	56		 push	 esi
  09378	57		 push	 edi
  09379	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3013 : 	if ( iZEN <= 0 )

  0937c	83 7d 0c 00	 cmp	 DWORD PTR _iZEN$[ebp], 0
  09380	7f 07		 jg	 SHORT $LN4@CalcSendRe@2

; 3014 : 	{
; 3015 : 		return 0;

  09382	33 c0		 xor	 eax, eax
  09384	e9 10 01 00 00	 jmp	 $LN5@CalcSendRe@2
$LN4@CalcSendRe@2:

; 3016 : 	}
; 3017 : 
; 3018 : 	int iRET_ZEN = 0;

  09389	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iRET_ZEN$[ebp], 0

; 3019 : 
; 3020 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  09390	83 7d 08 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  09394	7d 09		 jge	 SHORT $LN7@CalcSendRe@2
  09396	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
  0939d	eb 0f		 jmp	 SHORT $LN8@CalcSendRe@2
$LN7@CalcSendRe@2:
  0939f	33 c0		 xor	 eax, eax
  093a1	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _iIndex$[ebp], 14999 ; 00003a97H
  093a8	0f 9e c0	 setle	 al
  093ab	89 45 b4	 mov	 DWORD PTR tv68[ebp], eax
$LN8@CalcSendRe@2:
  093ae	83 7d b4 00	 cmp	 DWORD PTR tv68[ebp], 0
  093b2	75 07		 jne	 SHORT $LN3@CalcSendRe@2

; 3021 : 	{
; 3022 : 		return 0;

  093b4	33 c0		 xor	 eax, eax
  093b6	e9 de 00 00 00	 jmp	 $LN5@CalcSendRe@2
$LN3@CalcSendRe@2:

; 3023 : 	}
; 3024 : 
; 3025 : 	if ( gObj[iIndex].Connected < PLAYER_PLAYING )

  093bb	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  093be	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  093c4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  093ca	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  093cf	7d 07		 jge	 SHORT $LN2@CalcSendRe@2

; 3026 : 	{
; 3027 : 		return 0;

  093d1	33 c0		 xor	 eax, eax
  093d3	e9 c1 00 00 00	 jmp	 $LN5@CalcSendRe@2
$LN2@CalcSendRe@2:

; 3028 : 	}
; 3029 : 
; 3030 : 	if ( gObjCheckMaxZen(iIndex, iZEN) == FALSE )

  093d8	8b 45 0c	 mov	 eax, DWORD PTR _iZEN$[ebp]
  093db	50		 push	 eax
  093dc	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  093df	51		 push	 ecx
  093e0	e8 00 00 00 00	 call	 ?gObjCheckMaxZen@@YAHHH@Z ; gObjCheckMaxZen
  093e5	83 c4 08	 add	 esp, 8
  093e8	85 c0		 test	 eax, eax
  093ea	75 52		 jne	 SHORT $LN1@CalcSendRe@2

; 3031 : 	{
; 3032 : 		iRET_ZEN = MAX_ZEN - gObj[iIndex].Money;

  093ec	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  093ef	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  093f5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  093fb	ba 00 94 35 77	 mov	 edx, 2000000000		; 77359400H
  09400	2b 94 01 f0 00
	00 00		 sub	 edx, DWORD PTR [ecx+eax+240]
  09407	89 55 f8	 mov	 DWORD PTR _iRET_ZEN$[ebp], edx

; 3033 : 		gObj[iIndex].Money += iRET_ZEN;

  0940a	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0940d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  09413	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  09419	8b 94 01 f0 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+240]
  09420	03 55 f8	 add	 edx, DWORD PTR _iRET_ZEN$[ebp]
  09423	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  09426	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0942c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  09432	89 94 01 f0 00
	00 00		 mov	 DWORD PTR [ecx+eax+240], edx

; 3034 : 
; 3035 : 		return iRET_ZEN;

  09439	8b 45 f8	 mov	 eax, DWORD PTR _iRET_ZEN$[ebp]
  0943c	eb 5b		 jmp	 SHORT $LN5@CalcSendRe@2
$LN1@CalcSendRe@2:

; 3036 : 	}
; 3037 : 
; 3038 : 	gObj[iIndex].Money += iZEN;

  0943e	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  09441	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  09447	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0944d	8b 94 01 f0 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+240]
  09454	03 55 0c	 add	 edx, DWORD PTR _iZEN$[ebp]
  09457	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0945a	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  09460	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  09466	89 94 01 f0 00
	00 00		 mov	 DWORD PTR [ecx+eax+240], edx

; 3039 : 	iRET_ZEN = iZEN;

  0946d	8b 45 0c	 mov	 eax, DWORD PTR _iZEN$[ebp]
  09470	89 45 f8	 mov	 DWORD PTR _iRET_ZEN$[ebp], eax

; 3040 : 	GCMoneySend(iIndex, gObj[iIndex].Money);

  09473	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  09476	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0947c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  09482	8b 94 01 f0 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+240]
  09489	52		 push	 edx
  0948a	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0948d	50		 push	 eax
  0948e	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  09493	83 c4 08	 add	 esp, 8

; 3041 : 
; 3042 : 	return iRET_ZEN;

  09496	8b 45 f8	 mov	 eax, DWORD PTR _iRET_ZEN$[ebp]
$LN5@CalcSendRe@2:

; 3043 : }

  09499	5f		 pop	 edi
  0949a	5e		 pop	 esi
  0949b	5b		 pop	 ebx
  0949c	8b e5		 mov	 esp, ebp
  0949e	5d		 pop	 ebp
  0949f	c2 08 00	 ret	 8
?CalcSendRewardZEN@CBloodCastle@@QAEHHH@Z ENDP		; CBloodCastle::CalcSendRewardZEN
_TEXT	ENDS
EXTRN	?ItemGetNumberMake@@YAHHH@Z:PROC		; ItemGetNumberMake
EXTRN	?GenExcOpt@@YAHH@Z:PROC				; GenExcOpt
EXTRN	?Main@cBloodCastleRewardItem@@QAE_NH@Z:PROC	; cBloodCastleRewardItem::Main
EXTRN	?gBloodCastleRewardItem@@3VcBloodCastleRewardItem@@A:BYTE ; gBloodCastleRewardItem
EXTRN	?CompleteBC@CAchievements@@QAEXH@Z:PROC		; CAchievements::CompleteBC
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv75 = -92						; size = 4
tv67 = -92						; size = 4
_iType$237895 = -24					; size = 4
_Anc1$ = -20						; size = 4
_Exe1$ = -16						; size = 4
_iMapNumber$ = -12					; size = 4
_iMaxHitUser$ = -8					; size = 4
_this$ = -4						; size = 4
_iIndex$ = 8						; size = 4
?DropChaosGem@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::DropChaosGem
; _this$ = ecx

; 3047 : {

  094b0	55		 push	 ebp
  094b1	8b ec		 mov	 ebp, esp
  094b3	83 ec 5c	 sub	 esp, 92			; 0000005cH
  094b6	53		 push	 ebx
  094b7	56		 push	 esi
  094b8	57		 push	 edi
  094b9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3048 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  094bc	83 7d 08 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  094c0	7d 09		 jge	 SHORT $LN18@DropChaosG
  094c2	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  094c9	eb 0f		 jmp	 SHORT $LN19@DropChaosG
$LN18@DropChaosG:
  094cb	33 c0		 xor	 eax, eax
  094cd	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _iIndex$[ebp], 14999 ; 00003a97H
  094d4	0f 9e c0	 setle	 al
  094d7	89 45 a4	 mov	 DWORD PTR tv67[ebp], eax
$LN19@DropChaosG:
  094da	83 7d a4 00	 cmp	 DWORD PTR tv67[ebp], 0
  094de	75 05		 jne	 SHORT $LN15@DropChaosG

; 3049 : 	{
; 3050 : 		return;

  094e0	e9 9f 01 00 00	 jmp	 $LN16@DropChaosG
$LN15@DropChaosG:

; 3051 : 	}
; 3052 : 
; 3053 : #if(SYSTEM_ACHIEVEMENTS)
; 3054 : 	g_Achievements.CompleteBC(iIndex);

  094e5	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  094e8	50		 push	 eax
  094e9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Achievements@@3VCAchievements@@A ; g_Achievements
  094ee	e8 00 00 00 00	 call	 ?CompleteBC@CAchievements@@QAEXH@Z ; CAchievements::CompleteBC

; 3055 : #endif
; 3056 : 
; 3057 : 	int iMaxHitUser = iIndex;

  094f3	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  094f6	89 45 f8	 mov	 DWORD PTR _iMaxHitUser$[ebp], eax

; 3058 : 	//int iType = ::ItemGetNumberMake(12, 15);
; 3059 : 
; 3060 : 	int iMapNumber = -1;

  094f9	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _iMapNumber$[ebp], -1

; 3061 : 
; 3062 : 	switch(gObj[iIndex].MapNumber)

  09500	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  09503	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  09509	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0950f	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  09517	89 55 a4	 mov	 DWORD PTR tv75[ebp], edx
  0951a	8b 45 a4	 mov	 eax, DWORD PTR tv75[ebp]
  0951d	83 e8 0b	 sub	 eax, 11			; 0000000bH
  09520	89 45 a4	 mov	 DWORD PTR tv75[ebp], eax
  09523	83 7d a4 29	 cmp	 DWORD PTR tv75[ebp], 41	; 00000029H
  09527	77 57		 ja	 SHORT $LN13@DropChaosG
  09529	8b 4d a4	 mov	 ecx, DWORD PTR tv75[ebp]
  0952c	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR $LN20@DropChaosG[ecx]
  09533	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN21@DropChaosG[edx*4]
$LN12@DropChaosG:

; 3063 : 	{
; 3064 : 	case MAP_INDEX_BLOODCASTLE1:
; 3065 : 		iMapNumber = 238;

  0953a	c7 45 f4 ee 00
	00 00		 mov	 DWORD PTR _iMapNumber$[ebp], 238 ; 000000eeH

; 3066 : 		break;

  09541	eb 3d		 jmp	 SHORT $LN13@DropChaosG
$LN11@DropChaosG:

; 3067 : 	case MAP_INDEX_BLOODCASTLE2:
; 3068 : 		iMapNumber = 239;

  09543	c7 45 f4 ef 00
	00 00		 mov	 DWORD PTR _iMapNumber$[ebp], 239 ; 000000efH

; 3069 : 		break;

  0954a	eb 34		 jmp	 SHORT $LN13@DropChaosG
$LN10@DropChaosG:

; 3070 : 	case MAP_INDEX_BLOODCASTLE3:
; 3071 : 		iMapNumber = 240;

  0954c	c7 45 f4 f0 00
	00 00		 mov	 DWORD PTR _iMapNumber$[ebp], 240 ; 000000f0H

; 3072 : 		break;

  09553	eb 2b		 jmp	 SHORT $LN13@DropChaosG
$LN9@DropChaosG:

; 3073 : 	case MAP_INDEX_BLOODCASTLE4:
; 3074 : 		iMapNumber = 241;

  09555	c7 45 f4 f1 00
	00 00		 mov	 DWORD PTR _iMapNumber$[ebp], 241 ; 000000f1H

; 3075 : 		break;

  0955c	eb 22		 jmp	 SHORT $LN13@DropChaosG
$LN8@DropChaosG:

; 3076 : 	case MAP_INDEX_BLOODCASTLE5:
; 3077 : 		iMapNumber = 242;

  0955e	c7 45 f4 f2 00
	00 00		 mov	 DWORD PTR _iMapNumber$[ebp], 242 ; 000000f2H

; 3078 : 		break;

  09565	eb 19		 jmp	 SHORT $LN13@DropChaosG
$LN7@DropChaosG:

; 3079 : 	case MAP_INDEX_BLOODCASTLE6:
; 3080 : 		iMapNumber = 243;

  09567	c7 45 f4 f3 00
	00 00		 mov	 DWORD PTR _iMapNumber$[ebp], 243 ; 000000f3H

; 3081 : 		break;

  0956e	eb 10		 jmp	 SHORT $LN13@DropChaosG
$LN6@DropChaosG:

; 3082 : 	case MAP_INDEX_BLOODCASTLE7:
; 3083 : 		iMapNumber = 244;

  09570	c7 45 f4 f4 00
	00 00		 mov	 DWORD PTR _iMapNumber$[ebp], 244 ; 000000f4H

; 3084 : 		break;

  09577	eb 07		 jmp	 SHORT $LN13@DropChaosG
$LN5@DropChaosG:

; 3085 : 	case MAP_INDEX_BLOODCASTLE8:
; 3086 : 		iMapNumber = 245;

  09579	c7 45 f4 f5 00
	00 00		 mov	 DWORD PTR _iMapNumber$[ebp], 245 ; 000000f5H
$LN13@DropChaosG:

; 3087 : 		break;
; 3088 : 	}
; 3089 : 
; 3090 : 	////Configs
; 3091 : 	//int Ex_BCDropType	= GetPrivateProfileInt("BloodCastle","BCDropType",12,"..\\Data\\ExData\\Events.ini");
; 3092 : 	//int Ex_BCDropID		= GetPrivateProfileInt("BloodCastle","BCDropID",15,"..\\Data\\ExData\\Events.ini");
; 3093 : 	//int Ex_BCDropLevel	= GetPrivateProfileInt("BloodCastle","BCDropLevel",0,"..\\Data\\ExData\\Events.ini");
; 3094 : 	//int Ex_BCDropSkill	= GetPrivateProfileInt("BloodCastle","BCDropSkill",0,"..\\Data\\ExData\\Events.ini");
; 3095 : 	//int Ex_BCDropLuck	= GetPrivateProfileInt("BloodCastle","BCDropLuck",0,"..\\Data\\ExData\\Events.ini");
; 3096 : 	//int Ex_BCDropOpt	= GetPrivateProfileInt("BloodCastle","BCDropOpt",0,"..\\Data\\ExData\\Events.ini");
; 3097 : 	//int Ex_BCDropExcOpt	= GetPrivateProfileInt("BloodCastle","BCDropExcOpt",0,"..\\Data\\ExData\\Events.ini");
; 3098 : 	//int Ex_BCDropAncOpt	= GetPrivateProfileInt("BloodCastle","BCDropAncOpt",0,"..\\Data\\ExData\\Events.ini");
; 3099 : 
; 3100 : 
; 3101 : 
; 3102 : 	//Ex_BCDropLuck_DRYNEA
; 3103 : 	int Exe1 = 0;

  09580	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Exe1$[ebp], 0

; 3104 : 	int Anc1 = 0;

  09587	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _Anc1$[ebp], 0

; 3105 : 
; 3106 : #ifdef BC_LVL_DROP
; 3107 : 	//if(g_ExLicense.CheckUser(eExUB::drynea) || g_ExLicense.CheckUser(eExUB::Local2) || g_ExLicense.CheckUser(eExUB::Local))
; 3108 : 	//{
; 3109 : 	//	switch(gObj[iIndex].MapNumber)
; 3110 : 	//	{
; 3111 : 	//	case MAP_INDEX_BLOODCASTLE1:
; 3112 : 	//		{
; 3113 : 	//			if ( ExConfig.Event.Ex_BCDropExcOpt_DRYNEA[1] > 0 )
; 3114 : 	//			Exe1 = GenExcOpt(ExConfig.Event.Ex_BCDropExcOpt_DRYNEA[1]);
; 3115 : 
; 3116 : 	//			if ( ExConfig.Event.Ex_BCDropAncOpt_DRYNEA[1] == 5 || ExConfig.Event.Ex_BCDropAncOpt_DRYNEA[1] == 10 )
; 3117 : 	//			Anc1 = ExConfig.Event.Ex_BCDropAncOpt_DRYNEA[1];
; 3118 : 
; 3119 : 	//			int iType = ItemGetNumberMake(ExConfig.Event.Ex_BCDropType_DRYNEA[1], ExConfig.Event.Ex_BCDropID_DRYNEA[1]);
; 3120 : 
; 3121 : 	//			ItemSerialCreateSend(gObj[iIndex].m_Index, (BYTE)iMapNumber, (BYTE)gObj[iIndex].X, (BYTE)gObj[iIndex].Y, iType, 
; 3122 : 	//			(BYTE)ExConfig.Event.Ex_BCDropLevel_DRYNEA[1], 0, (BYTE)ExConfig.Event.Ex_BCDropSkill_DRYNEA[1], (BYTE)ExConfig.Event.Ex_BCDropLuck_DRYNEA[1], 
; 3123 : 	//			(BYTE)ExConfig.Event.Ex_BCDropOpt_DRYNEA[1], iMaxHitUser, (BYTE)Exe1, (BYTE)Anc1);
; 3124 : 	//		}
; 3125 : 	//		break;
; 3126 : 	//	case MAP_INDEX_BLOODCASTLE2:
; 3127 : 	//		{
; 3128 : 	//			if ( ExConfig.Event.Ex_BCDropExcOpt_DRYNEA[2] > 0 )
; 3129 : 	//			Exe1 = GenExcOpt(ExConfig.Event.Ex_BCDropExcOpt_DRYNEA[2]);
; 3130 : 
; 3131 : 	//			if ( ExConfig.Event.Ex_BCDropAncOpt_DRYNEA[2] == 5 || ExConfig.Event.Ex_BCDropAncOpt_DRYNEA[2] == 10 )
; 3132 : 	//			Anc1 = ExConfig.Event.Ex_BCDropAncOpt_DRYNEA[2];
; 3133 : 
; 3134 : 	//			int iType = ItemGetNumberMake(ExConfig.Event.Ex_BCDropType_DRYNEA[2], ExConfig.Event.Ex_BCDropID_DRYNEA[2]);
; 3135 : 
; 3136 : 	//			ItemSerialCreateSend(gObj[iIndex].m_Index, (BYTE)iMapNumber, (BYTE)gObj[iIndex].X, (BYTE)gObj[iIndex].Y, iType, 
; 3137 : 	//			(BYTE)ExConfig.Event.Ex_BCDropLevel_DRYNEA[2], 0, (BYTE)ExConfig.Event.Ex_BCDropSkill_DRYNEA[2], (BYTE)ExConfig.Event.Ex_BCDropLuck_DRYNEA[2], 
; 3138 : 	//			(BYTE)ExConfig.Event.Ex_BCDropOpt_DRYNEA[2], iMaxHitUser, (BYTE)Exe1, (BYTE)Anc1);
; 3139 : 	//		}
; 3140 : 	//		break;
; 3141 : 	//	case MAP_INDEX_BLOODCASTLE3:
; 3142 : 	//		{
; 3143 : 	//			if ( ExConfig.Event.Ex_BCDropExcOpt_DRYNEA[3] > 0 )
; 3144 : 	//			Exe1 = GenExcOpt(ExConfig.Event.Ex_BCDropExcOpt_DRYNEA[3]);
; 3145 : 
; 3146 : 	//			if ( ExConfig.Event.Ex_BCDropAncOpt_DRYNEA[3] == 5 || ExConfig.Event.Ex_BCDropAncOpt_DRYNEA[3] == 10 )
; 3147 : 	//			Anc1 = ExConfig.Event.Ex_BCDropAncOpt_DRYNEA[3];
; 3148 : 
; 3149 : 	//			int iType = ItemGetNumberMake(ExConfig.Event.Ex_BCDropType_DRYNEA[3], ExConfig.Event.Ex_BCDropID_DRYNEA[3]);
; 3150 : 
; 3151 : 	//			ItemSerialCreateSend(gObj[iIndex].m_Index, (BYTE)iMapNumber, (BYTE)gObj[iIndex].X, (BYTE)gObj[iIndex].Y, iType, 
; 3152 : 	//			(BYTE)ExConfig.Event.Ex_BCDropLevel_DRYNEA[3], 0, (BYTE)ExConfig.Event.Ex_BCDropSkill_DRYNEA[3], (BYTE)ExConfig.Event.Ex_BCDropLuck_DRYNEA[3], 
; 3153 : 	//			(BYTE)ExConfig.Event.Ex_BCDropOpt_DRYNEA[3], iMaxHitUser, (BYTE)Exe1, (BYTE)Anc1);
; 3154 : 	//		}
; 3155 : 	//		break;
; 3156 : 	//	case MAP_INDEX_BLOODCASTLE4:
; 3157 : 	//		{
; 3158 : 	//			if ( ExConfig.Event.Ex_BCDropExcOpt_DRYNEA[4] > 0 )
; 3159 : 	//			Exe1 = GenExcOpt(ExConfig.Event.Ex_BCDropExcOpt_DRYNEA[4]);
; 3160 : 
; 3161 : 	//			if ( ExConfig.Event.Ex_BCDropAncOpt_DRYNEA[4] == 5 || ExConfig.Event.Ex_BCDropAncOpt_DRYNEA[4] == 10 )
; 3162 : 	//			Anc1 = ExConfig.Event.Ex_BCDropAncOpt_DRYNEA[4];
; 3163 : 
; 3164 : 	//			int iType = ItemGetNumberMake(ExConfig.Event.Ex_BCDropType_DRYNEA[4], ExConfig.Event.Ex_BCDropID_DRYNEA[4]);
; 3165 : 
; 3166 : 	//			ItemSerialCreateSend(gObj[iIndex].m_Index, (BYTE)iMapNumber, (BYTE)gObj[iIndex].X, (BYTE)gObj[iIndex].Y, iType, 
; 3167 : 	//			(BYTE)ExConfig.Event.Ex_BCDropLevel_DRYNEA[4], 0, (BYTE)ExConfig.Event.Ex_BCDropSkill_DRYNEA[4], (BYTE)ExConfig.Event.Ex_BCDropLuck_DRYNEA[4], 
; 3168 : 	//			(BYTE)ExConfig.Event.Ex_BCDropOpt_DRYNEA[4], iMaxHitUser, (BYTE)Exe1, (BYTE)Anc1);
; 3169 : 	//		}
; 3170 : 	//		break;
; 3171 : 	//	case MAP_INDEX_BLOODCASTLE5:
; 3172 : 	//		{
; 3173 : 	//			if ( ExConfig.Event.Ex_BCDropExcOpt_DRYNEA[5] > 0 )
; 3174 : 	//			Exe1 = GenExcOpt(ExConfig.Event.Ex_BCDropExcOpt_DRYNEA[5]);
; 3175 : 
; 3176 : 	//			if ( ExConfig.Event.Ex_BCDropAncOpt_DRYNEA[5] == 5 || ExConfig.Event.Ex_BCDropAncOpt_DRYNEA[5] == 10 )
; 3177 : 	//			Anc1 = ExConfig.Event.Ex_BCDropAncOpt_DRYNEA[5];
; 3178 : 
; 3179 : 	//			int iType = ItemGetNumberMake(ExConfig.Event.Ex_BCDropType_DRYNEA[5], ExConfig.Event.Ex_BCDropID_DRYNEA[5]);
; 3180 : 
; 3181 : 	//			ItemSerialCreateSend(gObj[iIndex].m_Index, (BYTE)iMapNumber, (BYTE)gObj[iIndex].X, (BYTE)gObj[iIndex].Y, iType, 
; 3182 : 	//			(BYTE)ExConfig.Event.Ex_BCDropLevel_DRYNEA[5], 0, (BYTE)ExConfig.Event.Ex_BCDropSkill_DRYNEA[5], (BYTE)ExConfig.Event.Ex_BCDropLuck_DRYNEA[5], 
; 3183 : 	//			(BYTE)ExConfig.Event.Ex_BCDropOpt_DRYNEA[5], iMaxHitUser, (BYTE)Exe1, (BYTE)Anc1);
; 3184 : 	//		}
; 3185 : 	//		break;
; 3186 : 	//	case MAP_INDEX_BLOODCASTLE6:
; 3187 : 	//		{
; 3188 : 	//			if ( ExConfig.Event.Ex_BCDropExcOpt_DRYNEA[6] > 0 )
; 3189 : 	//			Exe1 = GenExcOpt(ExConfig.Event.Ex_BCDropExcOpt_DRYNEA[6]);
; 3190 : 
; 3191 : 	//			if ( ExConfig.Event.Ex_BCDropAncOpt_DRYNEA[6] == 5 || ExConfig.Event.Ex_BCDropAncOpt_DRYNEA[6] == 10 )
; 3192 : 	//			Anc1 = ExConfig.Event.Ex_BCDropAncOpt_DRYNEA[6];
; 3193 : 
; 3194 : 	//			int iType = ItemGetNumberMake(ExConfig.Event.Ex_BCDropType_DRYNEA[6], ExConfig.Event.Ex_BCDropID_DRYNEA[6]);
; 3195 : 
; 3196 : 	//			ItemSerialCreateSend(gObj[iIndex].m_Index, (BYTE)iMapNumber, (BYTE)gObj[iIndex].X, (BYTE)gObj[iIndex].Y, iType, 
; 3197 : 	//			(BYTE)ExConfig.Event.Ex_BCDropLevel_DRYNEA[6], 0, (BYTE)ExConfig.Event.Ex_BCDropSkill_DRYNEA[6], (BYTE)ExConfig.Event.Ex_BCDropLuck_DRYNEA[6], 
; 3198 : 	//			(BYTE)ExConfig.Event.Ex_BCDropOpt_DRYNEA[6], iMaxHitUser, (BYTE)Exe1, (BYTE)Anc1);
; 3199 : 	//		}
; 3200 : 	//		break;
; 3201 : 	//	case MAP_INDEX_BLOODCASTLE7:
; 3202 : 	//		{
; 3203 : 	//			if ( ExConfig.Event.Ex_BCDropExcOpt_DRYNEA[7] > 0 )
; 3204 : 	//			Exe1 = GenExcOpt(ExConfig.Event.Ex_BCDropExcOpt_DRYNEA[7]);
; 3205 : 
; 3206 : 	//			if ( ExConfig.Event.Ex_BCDropAncOpt_DRYNEA[7] == 5 || ExConfig.Event.Ex_BCDropAncOpt_DRYNEA[7] == 10 )
; 3207 : 	//			Anc1 = ExConfig.Event.Ex_BCDropAncOpt_DRYNEA[7];
; 3208 : 
; 3209 : 	//			int iType = ItemGetNumberMake(ExConfig.Event.Ex_BCDropType_DRYNEA[7], ExConfig.Event.Ex_BCDropID_DRYNEA[7]);
; 3210 : 
; 3211 : 	//			ItemSerialCreateSend(gObj[iIndex].m_Index, (BYTE)iMapNumber, (BYTE)gObj[iIndex].X, (BYTE)gObj[iIndex].Y, iType, 
; 3212 : 	//			(BYTE)ExConfig.Event.Ex_BCDropLevel_DRYNEA[7], 0, (BYTE)ExConfig.Event.Ex_BCDropSkill_DRYNEA[7], (BYTE)ExConfig.Event.Ex_BCDropLuck_DRYNEA[7], 
; 3213 : 	//			(BYTE)ExConfig.Event.Ex_BCDropOpt_DRYNEA[7], iMaxHitUser, (BYTE)Exe1, (BYTE)Anc1);
; 3214 : 	//		}
; 3215 : 	//		break;
; 3216 : 	//	case MAP_INDEX_BLOODCASTLE8:
; 3217 : 	//		{
; 3218 : 	//			if ( ExConfig.Event.Ex_BCDropExcOpt_DRYNEA[8] > 0 )
; 3219 : 	//			Exe1 = GenExcOpt(ExConfig.Event.Ex_BCDropExcOpt_DRYNEA[8]);
; 3220 : 
; 3221 : 	//			if ( ExConfig.Event.Ex_BCDropAncOpt_DRYNEA[8] == 5 || ExConfig.Event.Ex_BCDropAncOpt_DRYNEA[8] == 10 )
; 3222 : 	//			Anc1 = ExConfig.Event.Ex_BCDropAncOpt_DRYNEA[8];
; 3223 : 
; 3224 : 	//			int iType = ItemGetNumberMake(ExConfig.Event.Ex_BCDropType_DRYNEA[8], ExConfig.Event.Ex_BCDropID_DRYNEA[8]);
; 3225 : 
; 3226 : 	//			ItemSerialCreateSend(gObj[iIndex].m_Index, (BYTE)iMapNumber, (BYTE)gObj[iIndex].X, (BYTE)gObj[iIndex].Y, iType, 
; 3227 : 	//			(BYTE)ExConfig.Event.Ex_BCDropLevel_DRYNEA[8], 0, (BYTE)ExConfig.Event.Ex_BCDropSkill_DRYNEA[8], (BYTE)ExConfig.Event.Ex_BCDropLuck_DRYNEA[8], 
; 3228 : 	//			(BYTE)ExConfig.Event.Ex_BCDropOpt_DRYNEA[8], iMaxHitUser, (BYTE)Exe1, (BYTE)Anc1);
; 3229 : 	//		}
; 3230 : 	//		break;
; 3231 : 	//	}
; 3232 : 	//}
; 3233 : 	//else
; 3234 : 	{
; 3235 : 		if (!gBloodCastleRewardItem.Main(gObj[iIndex].m_Index))

  0958e	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  09591	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  09597	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0959d	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  095a0	52		 push	 edx
  095a1	b9 00 00 00 00	 mov	 ecx, OFFSET ?gBloodCastleRewardItem@@3VcBloodCastleRewardItem@@A ; gBloodCastleRewardItem
  095a6	e8 00 00 00 00	 call	 ?Main@cBloodCastleRewardItem@@QAE_NH@Z ; cBloodCastleRewardItem::Main
  095ab	0f b6 c0	 movzx	 eax, al
  095ae	85 c0		 test	 eax, eax
  095b0	0f 85 ce 00 00
	00		 jne	 $LN16@DropChaosG

; 3236 : 		{
; 3237 : 			if ( ExConfig.Event.Ex_BCDropExcOpt > 0 )

  095b6	83 3d e0 06 00
	00 00		 cmp	 DWORD PTR ?ExConfig@@3VcExConfigs@@A+1760, 0
  095bd	7e 11		 jle	 SHORT $LN3@DropChaosG

; 3238 : 			Exe1 = GenExcOpt(ExConfig.Event.Ex_BCDropExcOpt);

  095bf	a1 e0 06 00 00	 mov	 eax, DWORD PTR ?ExConfig@@3VcExConfigs@@A+1760
  095c4	50		 push	 eax
  095c5	e8 00 00 00 00	 call	 ?GenExcOpt@@YAHH@Z	; GenExcOpt
  095ca	83 c4 04	 add	 esp, 4
  095cd	89 45 f0	 mov	 DWORD PTR _Exe1$[ebp], eax
$LN3@DropChaosG:

; 3239 : 
; 3240 : 			if ( ExConfig.Event.Ex_BCDropAncOpt == 5 || ExConfig.Event.Ex_BCDropAncOpt == 10 )

  095d0	83 3d e4 06 00
	00 05		 cmp	 DWORD PTR ?ExConfig@@3VcExConfigs@@A+1764, 5
  095d7	74 09		 je	 SHORT $LN1@DropChaosG
  095d9	83 3d e4 06 00
	00 0a		 cmp	 DWORD PTR ?ExConfig@@3VcExConfigs@@A+1764, 10 ; 0000000aH
  095e0	75 08		 jne	 SHORT $LN2@DropChaosG
$LN1@DropChaosG:

; 3241 : 			Anc1 = ExConfig.Event.Ex_BCDropAncOpt;

  095e2	a1 e4 06 00 00	 mov	 eax, DWORD PTR ?ExConfig@@3VcExConfigs@@A+1764
  095e7	89 45 ec	 mov	 DWORD PTR _Anc1$[ebp], eax
$LN2@DropChaosG:

; 3242 : 
; 3243 : 			int iType = ItemGetNumberMake(ExConfig.Event.Ex_BCDropType, ExConfig.Event.Ex_BCDropID);

  095ea	a1 cc 06 00 00	 mov	 eax, DWORD PTR ?ExConfig@@3VcExConfigs@@A+1740
  095ef	50		 push	 eax
  095f0	8b 0d c8 06 00
	00		 mov	 ecx, DWORD PTR ?ExConfig@@3VcExConfigs@@A+1736
  095f6	51		 push	 ecx
  095f7	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  095fc	83 c4 08	 add	 esp, 8
  095ff	89 45 e8	 mov	 DWORD PTR _iType$237895[ebp], eax

; 3244 : 
; 3245 : 			ItemSerialCreateSend(gObj[iIndex].m_Index, (BYTE)iMapNumber, (BYTE)gObj[iIndex].X, (BYTE)gObj[iIndex].Y, iType, 
; 3246 : 			(BYTE)ExConfig.Event.Ex_BCDropLevel, 0, (BYTE)ExConfig.Event.Ex_BCDropSkill, (BYTE)ExConfig.Event.Ex_BCDropLuck, 
; 3247 : 			(BYTE)ExConfig.Event.Ex_BCDropOpt, iMaxHitUser, (BYTE)Exe1, (BYTE)Anc1);

  09602	0f b6 45 ec	 movzx	 eax, BYTE PTR _Anc1$[ebp]
  09606	50		 push	 eax
  09607	0f b6 4d f0	 movzx	 ecx, BYTE PTR _Exe1$[ebp]
  0960b	51		 push	 ecx
  0960c	8b 55 f8	 mov	 edx, DWORD PTR _iMaxHitUser$[ebp]
  0960f	52		 push	 edx
  09610	0f b6 05 dc 06
	00 00		 movzx	 eax, BYTE PTR ?ExConfig@@3VcExConfigs@@A+1756
  09617	50		 push	 eax
  09618	0f b6 0d d8 06
	00 00		 movzx	 ecx, BYTE PTR ?ExConfig@@3VcExConfigs@@A+1752
  0961f	51		 push	 ecx
  09620	0f b6 15 d4 06
	00 00		 movzx	 edx, BYTE PTR ?ExConfig@@3VcExConfigs@@A+1748
  09627	52		 push	 edx
  09628	6a 00		 push	 0
  0962a	0f b6 05 d0 06
	00 00		 movzx	 eax, BYTE PTR ?ExConfig@@3VcExConfigs@@A+1744
  09631	50		 push	 eax
  09632	8b 4d e8	 mov	 ecx, DWORD PTR _iType$237895[ebp]
  09635	51		 push	 ecx
  09636	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  09639	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  0963f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  09644	0f b6 8c 10 46
	01 00 00	 movzx	 ecx, BYTE PTR [eax+edx+326]
  0964c	51		 push	 ecx
  0964d	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  09650	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  09656	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0965b	0f b6 8c 10 44
	01 00 00	 movzx	 ecx, BYTE PTR [eax+edx+324]
  09663	51		 push	 ecx
  09664	0f b6 55 f4	 movzx	 edx, BYTE PTR _iMapNumber$[ebp]
  09668	52		 push	 edx
  09669	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0966c	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  09672	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  09678	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  0967b	52		 push	 edx
  0967c	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  09681	83 c4 34	 add	 esp, 52			; 00000034H
$LN16@DropChaosG:

; 3248 : 		}
; 3249 : 	}
; 3250 : 
; 3251 : #else
; 3252 : 	if ( ExConfig.Event.Ex_BCDropExcOpt > 0 )
; 3253 : 		Exe1 = GenExcOpt(ExConfig.Event.Ex_BCDropExcOpt);
; 3254 : 
; 3255 : 	if ( ExConfig.Event.Ex_BCDropAncOpt == 5 || ExConfig.Event.Ex_BCDropAncOpt == 10 )
; 3256 : 		Anc1 = ExConfig.Event.Ex_BCDropAncOpt;
; 3257 : 
; 3258 : 	int iType = ItemGetNumberMake(ExConfig.Event.Ex_BCDropType, ExConfig.Event.Ex_BCDropID);
; 3259 : 
; 3260 : 	ItemSerialCreateSend(gObj[iIndex].m_Index, (BYTE)iMapNumber, (BYTE)gObj[iIndex].X, (BYTE)gObj[iIndex].Y, iType, 
; 3261 : 		(BYTE)ExConfig.Event.Ex_BCDropLevel, 0, (BYTE)ExConfig.Event.Ex_BCDropSkill, (BYTE)ExConfig.Event.Ex_BCDropLuck, 
; 3262 : 		(BYTE)ExConfig.Event.Ex_BCDropOpt, iMaxHitUser, (BYTE)Exe1, (BYTE)Anc1);
; 3263 : #endif
; 3264 : }

  09684	5f		 pop	 edi
  09685	5e		 pop	 esi
  09686	5b		 pop	 ebx
  09687	8b e5		 mov	 esp, ebp
  09689	5d		 pop	 ebp
  0968a	c2 04 00	 ret	 4
  0968d	8d 49 00	 npad	 3
$LN21@DropChaosG:
  09690	00 00 00 00	 DD	 $LN12@DropChaosG
  09694	00 00 00 00	 DD	 $LN11@DropChaosG
  09698	00 00 00 00	 DD	 $LN10@DropChaosG
  0969c	00 00 00 00	 DD	 $LN9@DropChaosG
  096a0	00 00 00 00	 DD	 $LN8@DropChaosG
  096a4	00 00 00 00	 DD	 $LN7@DropChaosG
  096a8	00 00 00 00	 DD	 $LN6@DropChaosG
  096ac	00 00 00 00	 DD	 $LN5@DropChaosG
  096b0	00 00 00 00	 DD	 $LN13@DropChaosG
$LN20@DropChaosG:
  096b4	00		 DB	 0
  096b5	01		 DB	 1
  096b6	02		 DB	 2
  096b7	03		 DB	 3
  096b8	04		 DB	 4
  096b9	05		 DB	 5
  096ba	06		 DB	 6
  096bb	08		 DB	 8
  096bc	08		 DB	 8
  096bd	08		 DB	 8
  096be	08		 DB	 8
  096bf	08		 DB	 8
  096c0	08		 DB	 8
  096c1	08		 DB	 8
  096c2	08		 DB	 8
  096c3	08		 DB	 8
  096c4	08		 DB	 8
  096c5	08		 DB	 8
  096c6	08		 DB	 8
  096c7	08		 DB	 8
  096c8	08		 DB	 8
  096c9	08		 DB	 8
  096ca	08		 DB	 8
  096cb	08		 DB	 8
  096cc	08		 DB	 8
  096cd	08		 DB	 8
  096ce	08		 DB	 8
  096cf	08		 DB	 8
  096d0	08		 DB	 8
  096d1	08		 DB	 8
  096d2	08		 DB	 8
  096d3	08		 DB	 8
  096d4	08		 DB	 8
  096d5	08		 DB	 8
  096d6	08		 DB	 8
  096d7	08		 DB	 8
  096d8	08		 DB	 8
  096d9	08		 DB	 8
  096da	08		 DB	 8
  096db	08		 DB	 8
  096dc	08		 DB	 8
  096dd	07		 DB	 7
?DropChaosGem@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::DropChaosGem
_TEXT	ENDS
PUBLIC	??_C@_0BP@EMDINEAJ@Can?5not?5connect?5Ranking?5Server?$AA@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?DataSend@wsJoinServerCli@@QAEHPADH@Z:PROC	; wsJoinServerCli::DataSend
EXTRN	?GMRankingServerConnect@@YAHPADK@Z:PROC		; GMRankingServerConnect
EXTRN	?gDevilSquareEventServerIp@@3PADA:BYTE		; gDevilSquareEventServerIp
EXTRN	?CreateSocket@MyWinsockBase@@QAEHPAUHWND__@@@Z:PROC ; MyWinsockBase::CreateSocket
EXTRN	?ghWnd@@3PAUHWND__@@A:DWORD			; ghWnd
EXTRN	?Close@MyWinsockBase@@QAEHXZ:PROC		; MyWinsockBase::Close
EXTRN	?wsRServerCli@@3VwsJoinServerCli@@A:BYTE	; wsRServerCli
EXTRN	?DevilSquareEventConnect@@3HA:DWORD		; DevilSquareEventConnect
EXTRN	?IsDevilSquareEventConnected@@3HA:DWORD		; IsDevilSquareEventConnected
EXTRN	?gGameServerCode@@3FA:WORD			; gGameServerCode
;	COMDAT ??_C@_0BP@EMDINEAJ@Can?5not?5connect?5Ranking?5Server?$AA@
CONST	SEGMENT
??_C@_0BP@EMDINEAJ@Can?5not?5connect?5Ranking?5Server?$AA@ DB 'Can not co'
	DB	'nnect Ranking Server', 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv67 = -124						; size = 4
_pMsg$ = -56						; size = 48
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iSCORE$ = 12						; size = 4
_iLeftTime$ = 16					; size = 4
_iAlivePartyCount$ = 20					; size = 4
?SendRewardScore@CBloodCastle@@QAEXHHHH@Z PROC		; CBloodCastle::SendRewardScore
; _this$ = ecx

; 3280 : {

  096e0	55		 push	 ebp
  096e1	8b ec		 mov	 ebp, esp
  096e3	83 ec 7c	 sub	 esp, 124		; 0000007cH
  096e6	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  096eb	33 c5		 xor	 eax, ebp
  096ed	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  096f0	53		 push	 ebx
  096f1	56		 push	 esi
  096f2	57		 push	 edi
  096f3	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3281 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  096f6	83 7d 08 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  096fa	7d 09		 jge	 SHORT $LN7@SendReward
  096fc	c7 45 84 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  09703	eb 0f		 jmp	 SHORT $LN8@SendReward
$LN7@SendReward:
  09705	33 c0		 xor	 eax, eax
  09707	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _iIndex$[ebp], 14999 ; 00003a97H
  0970e	0f 9e c0	 setle	 al
  09711	89 45 84	 mov	 DWORD PTR tv67[ebp], eax
$LN8@SendReward:
  09714	83 7d 84 00	 cmp	 DWORD PTR tv67[ebp], 0
  09718	75 05		 jne	 SHORT $LN4@SendReward

; 3282 : 	{
; 3283 : 		return;

  0971a	e9 2b 01 00 00	 jmp	 $LN5@SendReward
$LN4@SendReward:

; 3284 : 	}
; 3285 : 
; 3286 : 	PMSG_ANS_BLOODCASTLESCORE_5TH pMsg;
; 3287 : 
; 3288 : 	pMsg.h.c = 0xC1;

  0971f	c6 45 c8 c1	 mov	 BYTE PTR _pMsg$[ebp], 193 ; 000000c1H

; 3289 : 	pMsg.h.headcode = 0x0D;

  09723	c6 45 ca 0d	 mov	 BYTE PTR _pMsg$[ebp+2], 13 ; 0000000dH

; 3290 : 	pMsg.h.size = sizeof(pMsg);

  09727	c6 45 c9 30	 mov	 BYTE PTR _pMsg$[ebp+1], 48 ; 00000030H

; 3291 : 	pMsg.Score = iSCORE;

  0972b	8b 45 0c	 mov	 eax, DWORD PTR _iSCORE$[ebp]
  0972e	89 45 e4	 mov	 DWORD PTR _pMsg$[ebp+28], eax

; 3292 : 	pMsg.BridgeNum = gObj[iIndex].m_cBloodCastleIndex;

  09731	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  09734	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0973a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  09740	0f be 94 01 9e
	0e 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3742]
  09748	89 55 ec	 mov	 DWORD PTR _pMsg$[ebp+36], edx

; 3293 : 	pMsg.Class = gObj[iIndex].Class;

  0974b	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0974e	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  09754	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0975a	0f b7 94 01 b8
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+184]
  09762	89 55 e8	 mov	 DWORD PTR _pMsg$[ebp+32], edx

; 3294 : 	pMsg.ServerCode = gGameServerCode;

  09765	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?gGameServerCode@@3FA ; gGameServerCode
  0976c	89 45 e0	 mov	 DWORD PTR _pMsg$[ebp+24], eax

; 3295 : 	pMsg.iLeftTime = iLeftTime;

  0976f	8b 45 10	 mov	 eax, DWORD PTR _iLeftTime$[ebp]
  09772	89 45 f0	 mov	 DWORD PTR _pMsg$[ebp+40], eax

; 3296 : 	memcpy(pMsg.AccountID, gObj[iIndex].AccountID, MAX_ACCOUNT_LEN);

  09775	6a 0a		 push	 10			; 0000000aH
  09777	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0977a	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  09780	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  09786	8d 54 01 6c	 lea	 edx, DWORD PTR [ecx+eax+108]
  0978a	52		 push	 edx
  0978b	8d 45 cb	 lea	 eax, DWORD PTR _pMsg$[ebp+3]
  0978e	50		 push	 eax
  0978f	e8 00 00 00 00	 call	 _memcpy
  09794	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3297 : 	memcpy(pMsg.GameID, gObj[iIndex].Name, MAX_ACCOUNT_LEN);

  09797	6a 0a		 push	 10			; 0000000aH
  09799	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0979c	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  097a2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  097a8	8d 54 01 77	 lea	 edx, DWORD PTR [ecx+eax+119]
  097ac	52		 push	 edx
  097ad	8d 45 d5	 lea	 eax, DWORD PTR _pMsg$[ebp+13]
  097b0	50		 push	 eax
  097b1	e8 00 00 00 00	 call	 _memcpy
  097b6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3298 : 	pMsg.iAlivePartyCount = iAlivePartyCount;

  097b9	8b 45 14	 mov	 eax, DWORD PTR _iAlivePartyCount$[ebp]
  097bc	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+44], eax

; 3299 : 
; 3300 : 	if( ::IsDevilSquareEventConnected == FALSE && ::DevilSquareEventConnect == FALSE )

  097bf	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?IsDevilSquareEventConnected@@3HA, 0 ; IsDevilSquareEventConnected
  097c6	75 5d		 jne	 SHORT $LN3@SendReward
  097c8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?DevilSquareEventConnect@@3HA, 0 ; DevilSquareEventConnect
  097cf	75 54		 jne	 SHORT $LN3@SendReward

; 3301 : 	{
; 3302 : 		wsRServerCli.Close();

  097d1	b9 04 00 00 00	 mov	 ecx, OFFSET ?wsRServerCli@@3VwsJoinServerCli@@A+4
  097d6	e8 00 00 00 00	 call	 ?Close@MyWinsockBase@@QAEHXZ ; MyWinsockBase::Close

; 3303 : 		wsRServerCli.CreateSocket(ghWnd);

  097db	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  097e0	50		 push	 eax
  097e1	b9 04 00 00 00	 mov	 ecx, OFFSET ?wsRServerCli@@3VwsJoinServerCli@@A+4
  097e6	e8 00 00 00 00	 call	 ?CreateSocket@MyWinsockBase@@QAEHPAUHWND__@@@Z ; MyWinsockBase::CreateSocket

; 3304 : 
; 3305 : 		if ( GMRankingServerConnect(gDevilSquareEventServerIp, WM_GM_RANKING_CLIENT_MSG_PROC) == FALSE )

  097eb	68 0c 04 00 00	 push	 1036			; 0000040cH
  097f0	68 00 00 00 00	 push	 OFFSET ?gDevilSquareEventServerIp@@3PADA ; gDevilSquareEventServerIp
  097f5	e8 00 00 00 00	 call	 ?GMRankingServerConnect@@YAHPADK@Z ; GMRankingServerConnect
  097fa	83 c4 08	 add	 esp, 8
  097fd	85 c0		 test	 eax, eax
  097ff	75 1a		 jne	 SHORT $LN2@SendReward

; 3306 : 		{
; 3307 : 			::IsDevilSquareEventConnected = FALSE;

  09801	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?IsDevilSquareEventConnected@@3HA, 0 ; IsDevilSquareEventConnected

; 3308 : 			LogAddTD("Can not connect Ranking Server");

  0980b	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@EMDINEAJ@Can?5not?5connect?5Ranking?5Server?$AA@
  09810	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  09816	83 c4 04	 add	 esp, 4

; 3309 : 
; 3310 : 			return;

  09819	eb 2f		 jmp	 SHORT $LN5@SendReward
$LN2@SendReward:

; 3311 : 		}
; 3312 : 
; 3313 : 		::IsDevilSquareEventConnected = TRUE;

  0981b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?IsDevilSquareEventConnected@@3HA, 1 ; IsDevilSquareEventConnected
$LN3@SendReward:

; 3314 : 	}
; 3315 : 
; 3316 : 	if ( ::DevilSquareEventConnect == FALSE && ::IsDevilSquareEventConnected != FALSE )

  09825	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?DevilSquareEventConnect@@3HA, 0 ; DevilSquareEventConnect
  0982c	75 1c		 jne	 SHORT $LN5@SendReward
  0982e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?IsDevilSquareEventConnected@@3HA, 0 ; IsDevilSquareEventConnected
  09835	74 13		 je	 SHORT $LN5@SendReward

; 3317 : 	{
; 3318 : 		wsRServerCli.DataSend((char *)&pMsg, pMsg.h.size);

  09837	0f b6 45 c9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0983b	50		 push	 eax
  0983c	8d 4d c8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0983f	51		 push	 ecx
  09840	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsRServerCli@@3VwsJoinServerCli@@A ; wsRServerCli
  09845	e8 00 00 00 00	 call	 ?DataSend@wsJoinServerCli@@QAEHPADH@Z ; wsJoinServerCli::DataSend
$LN5@SendReward:

; 3319 : 	}
; 3320 : }

  0984a	5f		 pop	 edi
  0984b	5e		 pop	 esi
  0984c	5b		 pop	 ebx
  0984d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  09850	33 cd		 xor	 ecx, ebp
  09852	e8 00 00 00 00	 call	 @__security_check_cookie@4
  09857	8b e5		 mov	 esp, ebp
  09859	5d		 pop	 ebp
  0985a	c2 10 00	 ret	 16			; 00000010H
?SendRewardScore@CBloodCastle@@QAEXHHHH@Z ENDP		; CBloodCastle::SendRewardScore
; Function compile flags: /Odtp /ZI
tv67 = -76						; size = 4
_i$237942 = -8						; size = 4
_this$ = -4						; size = 4
_lpMsg$ = 8						; size = 4
_iSize$ = 12						; size = 4
_iBridgeIndex$ = 16					; size = 4
?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z PROC	; CBloodCastle::SendBridgeAnyMsg
; _this$ = ecx

; 3323 : {

  09860	55		 push	 ebp
  09861	8b ec		 mov	 ebp, esp
  09863	83 ec 4c	 sub	 esp, 76			; 0000004cH
  09866	53		 push	 ebx
  09867	56		 push	 esi
  09868	57		 push	 edi
  09869	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3324 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  0986c	83 7d 10 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  09870	7d 09		 jge	 SHORT $LN10@SendBridge
  09872	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  09879	eb 0c		 jmp	 SHORT $LN11@SendBridge
$LN10@SendBridge:
  0987b	33 c0		 xor	 eax, eax
  0987d	83 7d 10 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  09881	0f 9e c0	 setle	 al
  09884	89 45 b4	 mov	 DWORD PTR tv67[ebp], eax
$LN11@SendBridge:
  09887	83 7d b4 00	 cmp	 DWORD PTR tv67[ebp], 0
  0988b	75 05		 jne	 SHORT $LN7@SendBridge

; 3325 : 	{
; 3326 : 		return;

  0988d	e9 04 01 00 00	 jmp	 $LN8@SendBridge
$LN7@SendBridge:

; 3327 : 	}
; 3328 : 
; 3329 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  09892	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$237942[ebp], 0
  09899	eb 09		 jmp	 SHORT $LN6@SendBridge
$LN5@SendBridge:
  0989b	8b 45 f8	 mov	 eax, DWORD PTR _i$237942[ebp]
  0989e	83 c0 01	 add	 eax, 1
  098a1	89 45 f8	 mov	 DWORD PTR _i$237942[ebp], eax
$LN6@SendBridge:
  098a4	83 7d f8 28	 cmp	 DWORD PTR _i$237942[ebp], 40 ; 00000028H
  098a8	0f 8d e8 00 00
	00		 jge	 $LN8@SendBridge

; 3330 : 	{
; 3331 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  098ae	8b 45 10	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  098b1	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  098b7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  098ba	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  098be	8b 45 f8	 mov	 eax, DWORD PTR _i$237942[ebp]
  098c1	6b c0 14	 imul	 eax, 20			; 00000014H
  098c4	83 7c 02 18 ff	 cmp	 DWORD PTR [edx+eax+24], -1
  098c9	0f 84 c2 00 00
	00		 je	 $LN3@SendBridge

; 3332 : 		{
; 3333 : 			if ( gObj[ this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex ].Connected == PLAYER_PLAYING )

  098cf	8b 45 10	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  098d2	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  098d8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  098db	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  098df	8b 45 f8	 mov	 eax, DWORD PTR _i$237942[ebp]
  098e2	6b c0 14	 imul	 eax, 20			; 00000014H
  098e5	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  098e9	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  098ef	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  098f5	83 7c 0a 04 03	 cmp	 DWORD PTR [edx+ecx+4], 3
  098fa	0f 85 91 00 00
	00		 jne	 $LN3@SendBridge

; 3334 : 			{
; 3335 : 				if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex != -1 && gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex != -1 )

  09900	8b 45 10	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  09903	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  09909	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0990c	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  09910	8b 45 f8	 mov	 eax, DWORD PTR _i$237942[ebp]
  09913	6b c0 14	 imul	 eax, 20			; 00000014H
  09916	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  0991a	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  09920	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  09926	0f be 84 0a 9e
	0e 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3742]
  0992e	83 f8 ff	 cmp	 eax, -1
  09931	74 5e		 je	 SHORT $LN3@SendBridge
  09933	8b 45 10	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  09936	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0993c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0993f	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  09943	8b 45 f8	 mov	 eax, DWORD PTR _i$237942[ebp]
  09946	6b c0 14	 imul	 eax, 20			; 00000014H
  09949	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  0994d	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  09953	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  09959	0f be 84 0a 9f
	0e 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3743]
  09961	83 f8 ff	 cmp	 eax, -1
  09964	74 2b		 je	 SHORT $LN3@SendBridge

; 3336 : 				{
; 3337 : 					DataSend(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, lpMsg, iSize);

  09966	8b 45 0c	 mov	 eax, DWORD PTR _iSize$[ebp]
  09969	50		 push	 eax
  0996a	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0996d	51		 push	 ecx
  0996e	8b 55 10	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  09971	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  09977	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0997a	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  0997e	8b 55 f8	 mov	 edx, DWORD PTR _i$237942[ebp]
  09981	6b d2 14	 imul	 edx, 20			; 00000014H
  09984	8b 44 11 18	 mov	 eax, DWORD PTR [ecx+edx+24]
  09988	50		 push	 eax
  09989	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0998e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@SendBridge:

; 3338 : 				}
; 3339 : 			}
; 3340 : 		}
; 3341 : 	}

  09991	e9 05 ff ff ff	 jmp	 $LN5@SendBridge
$LN8@SendBridge:

; 3342 : 
; 3343 : }

  09996	5f		 pop	 edi
  09997	5e		 pop	 esi
  09998	5b		 pop	 ebx
  09999	8b e5		 mov	 esp, ebp
  0999b	5d		 pop	 ebp
  0999c	c2 0c 00	 ret	 12			; 0000000cH
?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z ENDP	; CBloodCastle::SendBridgeAnyMsg
; Function compile flags: /Odtp /ZI
_i$237954 = -8						; size = 4
_this$ = -4						; size = 4
_lpMsg$ = 8						; size = 4
_iSize$ = 12						; size = 4
?SendAllUserAnyMsg@CBloodCastle@@QAEXPAEH@Z PROC	; CBloodCastle::SendAllUserAnyMsg
; _this$ = ecx

; 3346 : {

  099a0	55		 push	 ebp
  099a1	8b ec		 mov	 ebp, esp
  099a3	83 ec 48	 sub	 esp, 72			; 00000048H
  099a6	53		 push	 ebx
  099a7	56		 push	 esi
  099a8	57		 push	 edi
  099a9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3347 : 	for ( int i=OBJ_STARTUSERINDEX;i<OBJMAX;i++)

  099ac	c7 45 f8 b0 36
	00 00		 mov	 DWORD PTR _i$237954[ebp], 14000 ; 000036b0H
  099b3	eb 09		 jmp	 SHORT $LN5@SendAllUse
$LN4@SendAllUse:
  099b5	8b 45 f8	 mov	 eax, DWORD PTR _i$237954[ebp]
  099b8	83 c0 01	 add	 eax, 1
  099bb	89 45 f8	 mov	 DWORD PTR _i$237954[ebp], eax
$LN5@SendAllUse:
  099be	81 7d f8 98 3a
	00 00		 cmp	 DWORD PTR _i$237954[ebp], 15000 ; 00003a98H
  099c5	7d 45		 jge	 SHORT $LN6@SendAllUse

; 3348 : 	{
; 3349 : 		if ( gObj[i].Connected == PLAYER_PLAYING )

  099c7	8b 45 f8	 mov	 eax, DWORD PTR _i$237954[ebp]
  099ca	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  099d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  099d6	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  099db	75 2d		 jne	 SHORT $LN2@SendAllUse

; 3350 : 		{
; 3351 : 			if ( gObj[i].Type == OBJ_USER )

  099dd	8b 45 f8	 mov	 eax, DWORD PTR _i$237954[ebp]
  099e0	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  099e6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  099ec	0f b7 54 01 68	 movzx	 edx, WORD PTR [ecx+eax+104]
  099f1	83 fa 01	 cmp	 edx, 1
  099f4	75 14		 jne	 SHORT $LN2@SendAllUse

; 3352 : 			{
; 3353 : 				DataSend(i, lpMsg, iSize);

  099f6	8b 45 0c	 mov	 eax, DWORD PTR _iSize$[ebp]
  099f9	50		 push	 eax
  099fa	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  099fd	51		 push	 ecx
  099fe	8b 55 f8	 mov	 edx, DWORD PTR _i$237954[ebp]
  09a01	52		 push	 edx
  09a02	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  09a07	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@SendAllUse:

; 3354 : 			}
; 3355 : 		}
; 3356 : 	}

  09a0a	eb a9		 jmp	 SHORT $LN4@SendAllUse
$LN6@SendAllUse:

; 3357 : }

  09a0c	5f		 pop	 edi
  09a0d	5e		 pop	 esi
  09a0e	5b		 pop	 ebx
  09a0f	8b e5		 mov	 esp, ebp
  09a11	5d		 pop	 ebp
  09a12	c2 08 00	 ret	 8
?SendAllUserAnyMsg@CBloodCastle@@QAEXPAEH@Z ENDP	; CBloodCastle::SendAllUserAnyMsg
_TEXT	ENDS
PUBLIC	??_C@_0GL@KHMMCCLP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Monster?5Kill@ ; `string'
;	COMDAT ??_C@_0GL@KHMMCCLP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Monster?5Kill@
CONST	SEGMENT
??_C@_0GL@KHMMCCLP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Monster?5Kill@ DB '['
	DB	'Blood Castle] (%d) Monster Kill Count Set - Monster:%d, Curre'
	DB	'nt Monster:%d, USER TOT:%d, LIVE:%d, DEAD:%d', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv145 = -92						; size = 4
tv146 = -88						; size = 4
tv67 = -88						; size = 4
_i$237968 = -20						; size = 4
_iKILL_USER_COUNT$ = -16				; size = 4
_iLIVE_USER_COUNT$ = -12				; size = 4
_iTOT_USER_COUNT$ = -8					; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?SetMonsterKillCount@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::SetMonsterKillCount
; _this$ = ecx

; 3360 : {

  09a20	55		 push	 ebp
  09a21	8b ec		 mov	 ebp, esp
  09a23	83 ec 5c	 sub	 esp, 92			; 0000005cH
  09a26	53		 push	 ebx
  09a27	56		 push	 esi
  09a28	57		 push	 edi
  09a29	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3361 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  09a2c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  09a30	7d 09		 jge	 SHORT $LN12@SetMonster@2
  09a32	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  09a39	eb 0c		 jmp	 SHORT $LN13@SetMonster@2
$LN12@SetMonster@2:
  09a3b	33 c0		 xor	 eax, eax
  09a3d	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  09a41	0f 9e c0	 setle	 al
  09a44	89 45 a8	 mov	 DWORD PTR tv67[ebp], eax
$LN13@SetMonster@2:
  09a47	83 7d a8 00	 cmp	 DWORD PTR tv67[ebp], 0
  09a4b	75 05		 jne	 SHORT $LN9@SetMonster@2

; 3362 : 	{
; 3363 : 		return;

  09a4d	e9 e1 01 00 00	 jmp	 $LN10@SetMonster@2
$LN9@SetMonster@2:

; 3364 : 	}
; 3365 : 
; 3366 : 	int iTOT_USER_COUNT = 0;

  09a52	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iTOT_USER_COUNT$[ebp], 0

; 3367 : 	int iLIVE_USER_COUNT = 0;

  09a59	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iLIVE_USER_COUNT$[ebp], 0

; 3368 : 	int iKILL_USER_COUNT = 0;

  09a60	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _iKILL_USER_COUNT$[ebp], 0

; 3369 : 
; 3370 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  09a67	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$237968[ebp], 0
  09a6e	eb 09		 jmp	 SHORT $LN8@SetMonster@2
$LN7@SetMonster@2:
  09a70	8b 45 ec	 mov	 eax, DWORD PTR _i$237968[ebp]
  09a73	83 c0 01	 add	 eax, 1
  09a76	89 45 ec	 mov	 DWORD PTR _i$237968[ebp], eax
$LN8@SetMonster@2:
  09a79	83 7d ec 28	 cmp	 DWORD PTR _i$237968[ebp], 40 ; 00000028H
  09a7d	0f 8d 37 01 00
	00		 jge	 $LN6@SetMonster@2

; 3371 : 	{
; 3372 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  09a83	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  09a86	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  09a8c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  09a8f	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  09a93	8b 45 ec	 mov	 eax, DWORD PTR _i$237968[ebp]
  09a96	6b c0 14	 imul	 eax, 20			; 00000014H
  09a99	83 7c 02 18 ff	 cmp	 DWORD PTR [edx+eax+24], -1
  09a9e	0f 84 11 01 00
	00		 je	 $LN5@SetMonster@2

; 3373 : 		{
; 3374 : 			iTOT_USER_COUNT++;

  09aa4	8b 45 f8	 mov	 eax, DWORD PTR _iTOT_USER_COUNT$[ebp]
  09aa7	83 c0 01	 add	 eax, 1
  09aaa	89 45 f8	 mov	 DWORD PTR _iTOT_USER_COUNT$[ebp], eax

; 3375 : 
; 3376 : 			if ( BC_MAP_RANGE(gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber) != FALSE )

  09aad	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  09ab0	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  09ab6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  09ab9	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  09abd	8b 45 ec	 mov	 eax, DWORD PTR _i$237968[ebp]
  09ac0	6b c0 14	 imul	 eax, 20			; 00000014H
  09ac3	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  09ac7	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  09acd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  09ad3	0f b6 84 0a 49
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+329]
  09adb	83 f8 34	 cmp	 eax, 52			; 00000034H
  09ade	75 09		 jne	 SHORT $LN16@SetMonster@2
  09ae0	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv146[ebp], 1
  09ae7	eb 7a		 jmp	 SHORT $LN17@SetMonster@2
$LN16@SetMonster@2:
  09ae9	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  09aec	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  09af2	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  09af5	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  09af9	8b 4d ec	 mov	 ecx, DWORD PTR _i$237968[ebp]
  09afc	6b c9 14	 imul	 ecx, 20			; 00000014H
  09aff	8b 54 08 18	 mov	 edx, DWORD PTR [eax+ecx+24]
  09b03	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  09b09	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  09b0e	0f b6 8c 10 49
	01 00 00	 movzx	 ecx, BYTE PTR [eax+edx+329]
  09b16	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  09b19	7d 09		 jge	 SHORT $LN14@SetMonster@2
  09b1b	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv145[ebp], 0
  09b22	eb 39		 jmp	 SHORT $LN15@SetMonster@2
$LN14@SetMonster@2:
  09b24	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  09b27	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  09b2d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  09b30	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  09b34	8b 55 ec	 mov	 edx, DWORD PTR _i$237968[ebp]
  09b37	6b d2 14	 imul	 edx, 20			; 00000014H
  09b3a	8b 44 11 18	 mov	 eax, DWORD PTR [ecx+edx+24]
  09b3e	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  09b44	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  09b4a	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  09b52	33 c0		 xor	 eax, eax
  09b54	83 fa 11	 cmp	 edx, 17			; 00000011H
  09b57	0f 9e c0	 setle	 al
  09b5a	89 45 a4	 mov	 DWORD PTR tv145[ebp], eax
$LN15@SetMonster@2:
  09b5d	8b 4d a4	 mov	 ecx, DWORD PTR tv145[ebp]
  09b60	89 4d a8	 mov	 DWORD PTR tv146[ebp], ecx
$LN17@SetMonster@2:
  09b63	83 7d a8 00	 cmp	 DWORD PTR tv146[ebp], 0
  09b67	74 43		 je	 SHORT $LN4@SetMonster@2

; 3377 : 			{
; 3378 : 				if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected > PLAYER_LOGGED )

  09b69	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  09b6c	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  09b72	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  09b75	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  09b79	8b 45 ec	 mov	 eax, DWORD PTR _i$237968[ebp]
  09b7c	6b c0 14	 imul	 eax, 20			; 00000014H
  09b7f	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  09b83	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  09b89	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  09b8f	83 7c 0a 04 02	 cmp	 DWORD PTR [edx+ecx+4], 2
  09b94	7e 0b		 jle	 SHORT $LN3@SetMonster@2

; 3379 : 				{
; 3380 : 					iLIVE_USER_COUNT++;

  09b96	8b 45 f4	 mov	 eax, DWORD PTR _iLIVE_USER_COUNT$[ebp]
  09b99	83 c0 01	 add	 eax, 1
  09b9c	89 45 f4	 mov	 DWORD PTR _iLIVE_USER_COUNT$[ebp], eax

; 3381 : 				}
; 3382 : 				else

  09b9f	eb 09		 jmp	 SHORT $LN2@SetMonster@2
$LN3@SetMonster@2:

; 3383 : 				{
; 3384 : 					iKILL_USER_COUNT++;

  09ba1	8b 45 f0	 mov	 eax, DWORD PTR _iKILL_USER_COUNT$[ebp]
  09ba4	83 c0 01	 add	 eax, 1
  09ba7	89 45 f0	 mov	 DWORD PTR _iKILL_USER_COUNT$[ebp], eax
$LN2@SetMonster@2:

; 3385 : 				}
; 3386 : 			}
; 3387 : 			else

  09baa	eb 09		 jmp	 SHORT $LN5@SetMonster@2
$LN4@SetMonster@2:

; 3388 : 			{
; 3389 : 				iKILL_USER_COUNT++;

  09bac	8b 45 f0	 mov	 eax, DWORD PTR _iKILL_USER_COUNT$[ebp]
  09baf	83 c0 01	 add	 eax, 1
  09bb2	89 45 f0	 mov	 DWORD PTR _iKILL_USER_COUNT$[ebp], eax
$LN5@SetMonster@2:

; 3390 : 			}
; 3391 : 
; 3392 : 		}
; 3393 : 	}

  09bb5	e9 b6 fe ff ff	 jmp	 $LN7@SetMonster@2
$LN6@SetMonster@2:

; 3394 : 
; 3395 : 	this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_MAX_COUNT = iLIVE_USER_COUNT * 40;

  09bba	8b 45 f4	 mov	 eax, DWORD PTR _iLIVE_USER_COUNT$[ebp]
  09bbd	6b c0 28	 imul	 eax, 40			; 00000028H
  09bc0	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  09bc3	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  09bc9	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  09bcc	89 84 0a cc 03
	00 00		 mov	 DWORD PTR [edx+ecx+972], eax

; 3396 : 	this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_KILL_COUNT = 0;

  09bd3	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  09bd6	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  09bdc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  09bdf	c7 84 01 d0 03
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+976], 0

; 3397 : 
; 3398 : 	LogAddTD("[Blood Castle] (%d) Monster Kill Count Set - Monster:%d, Current Monster:%d, USER TOT:%d, LIVE:%d, DEAD:%d", iBridgeIndex+1, this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_MAX_COUNT, this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_KILL_COUNT, iTOT_USER_COUNT, iLIVE_USER_COUNT, iKILL_USER_COUNT);

  09bea	8b 45 f0	 mov	 eax, DWORD PTR _iKILL_USER_COUNT$[ebp]
  09bed	50		 push	 eax
  09bee	8b 4d f4	 mov	 ecx, DWORD PTR _iLIVE_USER_COUNT$[ebp]
  09bf1	51		 push	 ecx
  09bf2	8b 55 f8	 mov	 edx, DWORD PTR _iTOT_USER_COUNT$[ebp]
  09bf5	52		 push	 edx
  09bf6	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  09bf9	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  09bff	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  09c02	8b 94 01 d0 03
	00 00		 mov	 edx, DWORD PTR [ecx+eax+976]
  09c09	52		 push	 edx
  09c0a	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  09c0d	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  09c13	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  09c16	8b 94 01 cc 03
	00 00		 mov	 edx, DWORD PTR [ecx+eax+972]
  09c1d	52		 push	 edx
  09c1e	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  09c21	83 c0 01	 add	 eax, 1
  09c24	50		 push	 eax
  09c25	68 00 00 00 00	 push	 OFFSET ??_C@_0GL@KHMMCCLP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Monster?5Kill@
  09c2a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  09c30	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN10@SetMonster@2:

; 3399 : }

  09c33	5f		 pop	 edi
  09c34	5e		 pop	 esi
  09c35	5b		 pop	 ebx
  09c36	8b e5		 mov	 esp, ebp
  09c38	5d		 pop	 ebp
  09c39	c2 04 00	 ret	 4
?SetMonsterKillCount@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::SetMonsterKillCount
_TEXT	ENDS
PUBLIC	??_C@_0FM@GIGMADKF@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@ ; `string'
PUBLIC	?CheckMonsterKillCount@CBloodCastle@@QAE_NH@Z	; CBloodCastle::CheckMonsterKillCount
;	COMDAT ??_C@_0FM@GIGMADKF@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@
CONST	SEGMENT
??_C@_0FM@GIGMADKF@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@ DB '['
	DB	'Blood Castle][Bug Tracer] (%d) All Monster Kill Success(Max K'
	DB	'ill Count:%d / Kill Count:%d)', 00H		; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv67 = -72						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?CheckMonsterKillCount@CBloodCastle@@QAE_NH@Z PROC	; CBloodCastle::CheckMonsterKillCount
; _this$ = ecx

; 3402 : {

  09c40	55		 push	 ebp
  09c41	8b ec		 mov	 ebp, esp
  09c43	83 ec 48	 sub	 esp, 72			; 00000048H
  09c46	53		 push	 ebx
  09c47	56		 push	 esi
  09c48	57		 push	 edi
  09c49	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3403 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  09c4c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  09c50	7d 09		 jge	 SHORT $LN5@CheckMonst
  09c52	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  09c59	eb 0c		 jmp	 SHORT $LN6@CheckMonst
$LN5@CheckMonst:
  09c5b	33 c0		 xor	 eax, eax
  09c5d	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  09c61	0f 9e c0	 setle	 al
  09c64	89 45 b8	 mov	 DWORD PTR tv67[ebp], eax
$LN6@CheckMonst:
  09c67	83 7d b8 00	 cmp	 DWORD PTR tv67[ebp], 0
  09c6b	75 04		 jne	 SHORT $LN2@CheckMonst

; 3404 : 	{
; 3405 : 		return false;

  09c6d	32 c0		 xor	 al, al
  09c6f	eb 6b		 jmp	 SHORT $LN3@CheckMonst
$LN2@CheckMonst:

; 3406 : 	}
; 3407 : 
; 3408 : 	if( this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_KILL_COUNT >= this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_MAX_COUNT )

  09c71	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  09c74	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  09c7a	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  09c7d	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  09c83	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  09c86	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  09c89	8b 84 02 d0 03
	00 00		 mov	 eax, DWORD PTR [edx+eax+976]
  09c90	3b 84 0e cc 03
	00 00		 cmp	 eax, DWORD PTR [esi+ecx+972]
  09c97	7c 41		 jl	 SHORT $LN1@CheckMonst

; 3409 : 	{
; 3410 : 		LogAddTD("[Blood Castle][Bug Tracer] (%d) All Monster Kill Success(Max Kill Count:%d / Kill Count:%d)", iBridgeIndex+1, this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_MAX_COUNT, this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_KILL_COUNT);

  09c99	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  09c9c	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  09ca2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  09ca5	8b 94 01 d0 03
	00 00		 mov	 edx, DWORD PTR [ecx+eax+976]
  09cac	52		 push	 edx
  09cad	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  09cb0	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  09cb6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  09cb9	8b 94 01 cc 03
	00 00		 mov	 edx, DWORD PTR [ecx+eax+972]
  09cc0	52		 push	 edx
  09cc1	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  09cc4	83 c0 01	 add	 eax, 1
  09cc7	50		 push	 eax
  09cc8	68 00 00 00 00	 push	 OFFSET ??_C@_0FM@GIGMADKF@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@
  09ccd	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  09cd3	83 c4 10	 add	 esp, 16			; 00000010H

; 3411 : 		return true;

  09cd6	b0 01		 mov	 al, 1
  09cd8	eb 02		 jmp	 SHORT $LN3@CheckMonst
$LN1@CheckMonst:

; 3412 : 	}
; 3413 : 
; 3414 : 	return false;

  09cda	32 c0		 xor	 al, al
$LN3@CheckMonst:

; 3415 : }

  09cdc	5f		 pop	 edi
  09cdd	5e		 pop	 esi
  09cde	5b		 pop	 ebx
  09cdf	8b e5		 mov	 esp, ebp
  09ce1	5d		 pop	 ebp
  09ce2	c2 04 00	 ret	 4
?CheckMonsterKillCount@CBloodCastle@@QAE_NH@Z ENDP	; CBloodCastle::CheckMonsterKillCount
_TEXT	ENDS
PUBLIC	?CheckMonsterKillSuccess@CBloodCastle@@QAE_NH@Z	; CBloodCastle::CheckMonsterKillSuccess
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv67 = -72						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?CheckMonsterKillSuccess@CBloodCastle@@QAE_NH@Z PROC	; CBloodCastle::CheckMonsterKillSuccess
; _this$ = ecx

; 3418 : {

  09cf0	55		 push	 ebp
  09cf1	8b ec		 mov	 ebp, esp
  09cf3	83 ec 48	 sub	 esp, 72			; 00000048H
  09cf6	53		 push	 ebx
  09cf7	56		 push	 esi
  09cf8	57		 push	 edi
  09cf9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3419 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  09cfc	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  09d00	7d 09		 jge	 SHORT $LN4@CheckMonst@2
  09d02	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  09d09	eb 0c		 jmp	 SHORT $LN5@CheckMonst@2
$LN4@CheckMonst@2:
  09d0b	33 c0		 xor	 eax, eax
  09d0d	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  09d11	0f 9e c0	 setle	 al
  09d14	89 45 b8	 mov	 DWORD PTR tv67[ebp], eax
$LN5@CheckMonst@2:
  09d17	83 7d b8 00	 cmp	 DWORD PTR tv67[ebp], 0
  09d1b	75 04		 jne	 SHORT $LN1@CheckMonst@2

; 3420 : 	{
; 3421 : 		return false;

  09d1d	32 c0		 xor	 al, al
  09d1f	eb 13		 jmp	 SHORT $LN2@CheckMonst@2
$LN1@CheckMonst@2:

; 3422 : 	}
; 3423 : 
; 3424 : 	return this->m_BridgeData[iBridgeIndex].m_bBC_MONSTER_KILL_COMPLETE;

  09d21	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  09d24	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  09d2a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  09d2d	8a 84 01 b8 03
	00 00		 mov	 al, BYTE PTR [ecx+eax+952]
$LN2@CheckMonst@2:

; 3425 : }

  09d34	5f		 pop	 edi
  09d35	5e		 pop	 esi
  09d36	5b		 pop	 ebx
  09d37	8b e5		 mov	 esp, ebp
  09d39	5d		 pop	 ebp
  09d3a	c2 04 00	 ret	 4
?CheckMonsterKillSuccess@CBloodCastle@@QAE_NH@Z ENDP	; CBloodCastle::CheckMonsterKillSuccess
_TEXT	ENDS
PUBLIC	??_C@_0GL@DCFNJCHO@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@ ; `string'
PUBLIC	?CheckBossKillCount@CBloodCastle@@QAE_NH@Z	; CBloodCastle::CheckBossKillCount
;	COMDAT ??_C@_0GL@DCFNJCHO@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@
CONST	SEGMENT
??_C@_0GL@DCFNJCHO@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@ DB '['
	DB	'Blood Castle][Bug Tracer] (%d) All Boss Monster Kill Success('
	DB	'Max Boss Kill Count:%d / Boss Kill Count:%d)', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv67 = -72						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?CheckBossKillCount@CBloodCastle@@QAE_NH@Z PROC		; CBloodCastle::CheckBossKillCount
; _this$ = ecx

; 3428 : {

  09d40	55		 push	 ebp
  09d41	8b ec		 mov	 ebp, esp
  09d43	83 ec 48	 sub	 esp, 72			; 00000048H
  09d46	53		 push	 ebx
  09d47	56		 push	 esi
  09d48	57		 push	 edi
  09d49	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3429 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  09d4c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  09d50	7d 09		 jge	 SHORT $LN5@CheckBossK
  09d52	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  09d59	eb 0c		 jmp	 SHORT $LN6@CheckBossK
$LN5@CheckBossK:
  09d5b	33 c0		 xor	 eax, eax
  09d5d	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  09d61	0f 9e c0	 setle	 al
  09d64	89 45 b8	 mov	 DWORD PTR tv67[ebp], eax
$LN6@CheckBossK:
  09d67	83 7d b8 00	 cmp	 DWORD PTR tv67[ebp], 0
  09d6b	75 04		 jne	 SHORT $LN2@CheckBossK

; 3430 : 	{
; 3431 : 		return false;

  09d6d	32 c0		 xor	 al, al
  09d6f	eb 6b		 jmp	 SHORT $LN3@CheckBossK
$LN2@CheckBossK:

; 3432 : 	}
; 3433 : 
; 3434 : 	if ( this->m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_KILL_COUNT >= this->m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_MAX_COUNT )

  09d71	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  09d74	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  09d7a	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  09d7d	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  09d83	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  09d86	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  09d89	8b 84 02 e0 03
	00 00		 mov	 eax, DWORD PTR [edx+eax+992]
  09d90	3b 84 0e dc 03
	00 00		 cmp	 eax, DWORD PTR [esi+ecx+988]
  09d97	7c 41		 jl	 SHORT $LN1@CheckBossK

; 3435 : 	{
; 3436 : 		LogAddTD("[Blood Castle][Bug Tracer] (%d) All Boss Monster Kill Success(Max Boss Kill Count:%d / Boss Kill Count:%d)", iBridgeIndex+1, this->m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_MAX_COUNT, this->m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_KILL_COUNT);

  09d99	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  09d9c	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  09da2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  09da5	8b 94 01 e0 03
	00 00		 mov	 edx, DWORD PTR [ecx+eax+992]
  09dac	52		 push	 edx
  09dad	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  09db0	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  09db6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  09db9	8b 94 01 dc 03
	00 00		 mov	 edx, DWORD PTR [ecx+eax+988]
  09dc0	52		 push	 edx
  09dc1	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  09dc4	83 c0 01	 add	 eax, 1
  09dc7	50		 push	 eax
  09dc8	68 00 00 00 00	 push	 OFFSET ??_C@_0GL@DCFNJCHO@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@
  09dcd	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  09dd3	83 c4 10	 add	 esp, 16			; 00000010H

; 3437 : 		return true;

  09dd6	b0 01		 mov	 al, 1
  09dd8	eb 02		 jmp	 SHORT $LN3@CheckBossK
$LN1@CheckBossK:

; 3438 : 	}
; 3439 : 
; 3440 : 	return false;

  09dda	32 c0		 xor	 al, al
$LN3@CheckBossK:

; 3441 : }

  09ddc	5f		 pop	 edi
  09ddd	5e		 pop	 esi
  09dde	5b		 pop	 ebx
  09ddf	8b e5		 mov	 esp, ebp
  09de1	5d		 pop	 ebp
  09de2	c2 04 00	 ret	 4
?CheckBossKillCount@CBloodCastle@@QAE_NH@Z ENDP		; CBloodCastle::CheckBossKillCount
_TEXT	ENDS
PUBLIC	?CheckBossKillSuccess@CBloodCastle@@QAE_NH@Z	; CBloodCastle::CheckBossKillSuccess
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv67 = -72						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?CheckBossKillSuccess@CBloodCastle@@QAE_NH@Z PROC	; CBloodCastle::CheckBossKillSuccess
; _this$ = ecx

; 3444 : {

  09df0	55		 push	 ebp
  09df1	8b ec		 mov	 ebp, esp
  09df3	83 ec 48	 sub	 esp, 72			; 00000048H
  09df6	53		 push	 ebx
  09df7	56		 push	 esi
  09df8	57		 push	 edi
  09df9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3445 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  09dfc	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  09e00	7d 09		 jge	 SHORT $LN4@CheckBossK@2
  09e02	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  09e09	eb 0c		 jmp	 SHORT $LN5@CheckBossK@2
$LN4@CheckBossK@2:
  09e0b	33 c0		 xor	 eax, eax
  09e0d	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  09e11	0f 9e c0	 setle	 al
  09e14	89 45 b8	 mov	 DWORD PTR tv67[ebp], eax
$LN5@CheckBossK@2:
  09e17	83 7d b8 00	 cmp	 DWORD PTR tv67[ebp], 0
  09e1b	75 04		 jne	 SHORT $LN1@CheckBossK@2

; 3446 : 	{
; 3447 : 		return false;

  09e1d	32 c0		 xor	 al, al
  09e1f	eb 13		 jmp	 SHORT $LN2@CheckBossK@2
$LN1@CheckBossK@2:

; 3448 : 	}
; 3449 : 
; 3450 : 	return this->m_BridgeData[iBridgeIndex].m_bBC_BOSS_MONSTER_KILL_COMPLETE;

  09e21	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  09e24	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  09e2a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  09e2d	8a 84 01 b9 03
	00 00		 mov	 al, BYTE PTR [ecx+eax+953]
$LN2@CheckBossK@2:

; 3451 : }

  09e34	5f		 pop	 edi
  09e35	5e		 pop	 esi
  09e36	5b		 pop	 ebx
  09e37	8b e5		 mov	 esp, ebp
  09e39	5d		 pop	 ebp
  09e3a	c2 04 00	 ret	 4
?CheckBossKillSuccess@CBloodCastle@@QAE_NH@Z ENDP	; CBloodCastle::CheckBossKillSuccess
_TEXT	ENDS
PUBLIC	??_C@_0EL@LDIFKEKC@error?9L3?5?3?5?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5C@ ; `string'
PUBLIC	??_C@_0EL@NNMPGAAC@error?9L3?5?3?5?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5U@ ; `string'
PUBLIC	__$ArrayPad$
;	COMDAT ??_C@_0EL@LDIFKEKC@error?9L3?5?3?5?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5C@
CONST	SEGMENT
??_C@_0EL@LDIFKEKC@error?9L3?5?3?5?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5C@ DB 'e'
	DB	'rror-L3 : [Blood Castle] (%d) Connection Closed UserIndex:%d,'
	DB	' SubIndex:%d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@NNMPGAAC@error?9L3?5?3?5?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5U@
CONST	SEGMENT
??_C@_0EL@NNMPGAAC@error?9L3?5?3?5?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5U@ DB 'e'
	DB	'rror-L3 : [Blood Castle] (%d) User Out of Bound UserIndex:%d,'
	DB	' SubIndex:%d', 00H				; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv93 = -100						; size = 4
tv67 = -100						; size = 4
_pMsg$238021 = -32					; size = 14
_i$238008 = -16						; size = 4
_bRET_VAL$ = -9						; size = 1
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
?CheckEveryUserDie@CBloodCastle@@QAE_NH@Z PROC		; CBloodCastle::CheckEveryUserDie
; _this$ = ecx

; 3455 : {

  09e40	55		 push	 ebp
  09e41	8b ec		 mov	 ebp, esp
  09e43	83 ec 64	 sub	 esp, 100		; 00000064H
  09e46	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  09e4b	33 c5		 xor	 eax, ebp
  09e4d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  09e50	53		 push	 ebx
  09e51	56		 push	 esi
  09e52	57		 push	 edi
  09e53	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3456 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  09e56	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  09e5a	7d 09		 jge	 SHORT $LN14@CheckEvery
  09e5c	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  09e63	eb 0c		 jmp	 SHORT $LN15@CheckEvery
$LN14@CheckEvery:
  09e65	33 c0		 xor	 eax, eax
  09e67	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  09e6b	0f 9e c0	 setle	 al
  09e6e	89 45 9c	 mov	 DWORD PTR tv67[ebp], eax
$LN15@CheckEvery:
  09e71	83 7d 9c 00	 cmp	 DWORD PTR tv67[ebp], 0
  09e75	75 07		 jne	 SHORT $LN11@CheckEvery

; 3457 : 	{
; 3458 : 		return false;

  09e77	32 c0		 xor	 al, al
  09e79	e9 17 02 00 00	 jmp	 $LN12@CheckEvery
$LN11@CheckEvery:

; 3459 : 	}
; 3460 : 
; 3461 : 	bool bRET_VAL = true;

  09e7e	c6 45 f7 01	 mov	 BYTE PTR _bRET_VAL$[ebp], 1

; 3462 : 
; 3463 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  09e82	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$238008[ebp], 0
  09e89	eb 09		 jmp	 SHORT $LN10@CheckEvery
$LN9@CheckEvery:
  09e8b	8b 45 f0	 mov	 eax, DWORD PTR _i$238008[ebp]
  09e8e	83 c0 01	 add	 eax, 1
  09e91	89 45 f0	 mov	 DWORD PTR _i$238008[ebp], eax
$LN10@CheckEvery:
  09e94	83 7d f0 28	 cmp	 DWORD PTR _i$238008[ebp], 40 ; 00000028H
  09e98	0f 8d f4 01 00
	00		 jge	 $LN8@CheckEvery

; 3464 : 	{
; 3465 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  09e9e	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  09ea1	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  09ea7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  09eaa	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  09eae	8b 45 f0	 mov	 eax, DWORD PTR _i$238008[ebp]
  09eb1	6b c0 14	 imul	 eax, 20			; 00000014H
  09eb4	83 7c 02 18 ff	 cmp	 DWORD PTR [edx+eax+24], -1
  09eb9	0f 84 ce 01 00
	00		 je	 $LN7@CheckEvery

; 3466 : 		{
; 3467 : 			if ( OBJMAX_RANGE(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex) == FALSE )

  09ebf	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  09ec2	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  09ec8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  09ecb	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  09ecf	8b 45 f0	 mov	 eax, DWORD PTR _i$238008[ebp]
  09ed2	6b c0 14	 imul	 eax, 20			; 00000014H
  09ed5	83 7c 02 18 00	 cmp	 DWORD PTR [edx+eax+24], 0
  09eda	7d 09		 jge	 SHORT $LN16@CheckEvery
  09edc	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv93[ebp], 0
  09ee3	eb 26		 jmp	 SHORT $LN17@CheckEvery
$LN16@CheckEvery:
  09ee5	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  09ee8	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  09eee	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  09ef1	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  09ef5	8b 4d f0	 mov	 ecx, DWORD PTR _i$238008[ebp]
  09ef8	6b c9 14	 imul	 ecx, 20			; 00000014H
  09efb	33 d2		 xor	 edx, edx
  09efd	81 7c 08 18 97
	3a 00 00	 cmp	 DWORD PTR [eax+ecx+24], 14999 ; 00003a97H
  09f05	0f 9e c2	 setle	 dl
  09f08	89 55 9c	 mov	 DWORD PTR tv93[ebp], edx
$LN17@CheckEvery:
  09f0b	83 7d 9c 00	 cmp	 DWORD PTR tv93[ebp], 0
  09f0f	75 39		 jne	 SHORT $LN6@CheckEvery

; 3468 : 			{
; 3469 : 				LogAddTD("error-L3 : [Blood Castle] (%d) User Out of Bound UserIndex:%d, SubIndex:%d", iBridgeIndex+1, this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, i);

  09f11	8b 45 f0	 mov	 eax, DWORD PTR _i$238008[ebp]
  09f14	50		 push	 eax
  09f15	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  09f18	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  09f1e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  09f21	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  09f25	8b 4d f0	 mov	 ecx, DWORD PTR _i$238008[ebp]
  09f28	6b c9 14	 imul	 ecx, 20			; 00000014H
  09f2b	8b 54 08 18	 mov	 edx, DWORD PTR [eax+ecx+24]
  09f2f	52		 push	 edx
  09f30	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  09f33	83 c0 01	 add	 eax, 1
  09f36	50		 push	 eax
  09f37	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@NNMPGAAC@error?9L3?5?3?5?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5U@
  09f3c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  09f42	83 c4 10	 add	 esp, 16			; 00000010H

; 3470 : 				continue;

  09f45	e9 41 ff ff ff	 jmp	 $LN9@CheckEvery
$LN6@CheckEvery:

; 3471 : 			}
; 3472 : 
; 3473 : 			if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber == this->GetBridgeMapNumber(iBridgeIndex) ) //season3 changed

  09f4a	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  09f4d	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  09f53	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  09f56	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  09f5a	8b 45 f0	 mov	 eax, DWORD PTR _i$238008[ebp]
  09f5d	6b c0 14	 imul	 eax, 20			; 00000014H
  09f60	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  09f64	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  09f6a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  09f70	0f b6 b4 0a 49
	01 00 00	 movzx	 esi, BYTE PTR [edx+ecx+329]
  09f78	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  09f7b	50		 push	 eax
  09f7c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  09f7f	e8 00 00 00 00	 call	 ?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeMapNumber
  09f84	3b f0		 cmp	 esi, eax
  09f86	75 6c		 jne	 SHORT $LN5@CheckEvery

; 3474 : 			{
; 3475 : 				if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected > PLAYER_LOGGED )

  09f88	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  09f8b	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  09f91	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  09f94	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  09f98	8b 45 f0	 mov	 eax, DWORD PTR _i$238008[ebp]
  09f9b	6b c0 14	 imul	 eax, 20			; 00000014H
  09f9e	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  09fa2	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  09fa8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  09fae	83 7c 0a 04 02	 cmp	 DWORD PTR [edx+ecx+4], 2
  09fb3	7e 06		 jle	 SHORT $LN4@CheckEvery

; 3476 : 				{
; 3477 : 					bRET_VAL = false;

  09fb5	c6 45 f7 00	 mov	 BYTE PTR _bRET_VAL$[ebp], 0

; 3478 : 				}
; 3479 : 				else

  09fb9	eb 34		 jmp	 SHORT $LN3@CheckEvery
$LN4@CheckEvery:

; 3480 : 				{
; 3481 : 					LogAddTD("error-L3 : [Blood Castle] (%d) Connection Closed UserIndex:%d, SubIndex:%d", iBridgeIndex+1, this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, i);

  09fbb	8b 45 f0	 mov	 eax, DWORD PTR _i$238008[ebp]
  09fbe	50		 push	 eax
  09fbf	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  09fc2	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  09fc8	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  09fcb	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  09fcf	8b 4d f0	 mov	 ecx, DWORD PTR _i$238008[ebp]
  09fd2	6b c9 14	 imul	 ecx, 20			; 00000014H
  09fd5	8b 54 08 18	 mov	 edx, DWORD PTR [eax+ecx+24]
  09fd9	52		 push	 edx
  09fda	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  09fdd	83 c0 01	 add	 eax, 1
  09fe0	50		 push	 eax
  09fe1	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@LDIFKEKC@error?9L3?5?3?5?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5C@
  09fe6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  09fec	83 c4 10	 add	 esp, 16			; 00000010H
$LN3@CheckEvery:

; 3482 : 				}
; 3483 : 			}
; 3484 : 			else

  09fef	e9 99 00 00 00	 jmp	 $LN7@CheckEvery
$LN5@CheckEvery:

; 3485 : 			{
; 3486 : 				if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bSendQuitMsg == false )

  09ff4	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  09ff7	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  09ffd	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0a000	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0a004	8b 45 f0	 mov	 eax, DWORD PTR _i$238008[ebp]
  0a007	6b c0 14	 imul	 eax, 20			; 00000014H
  0a00a	0f b6 4c 02 28	 movzx	 ecx, BYTE PTR [edx+eax+40]
  0a00f	85 c9		 test	 ecx, ecx
  0a011	75 7a		 jne	 SHORT $LN7@CheckEvery

; 3487 : 				{
; 3488 : 					this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bSendQuitMsg = true;

  0a013	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0a016	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0a01c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0a01f	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0a023	8b 45 f0	 mov	 eax, DWORD PTR _i$238008[ebp]
  0a026	6b c0 14	 imul	 eax, 20			; 00000014H
  0a029	c6 44 02 28 01	 mov	 BYTE PTR [edx+eax+40], 1

; 3489 : 
; 3490 : 					PMSG_STATEBLOODCASTLE pMsg;
; 3491 : 
; 3492 : 					PHeadSetB((LPBYTE)&pMsg, 0x9B, sizeof(PMSG_STATEBLOODCASTLE));

  0a02e	6a 0e		 push	 14			; 0000000eH
  0a030	68 9b 00 00 00	 push	 155			; 0000009bH
  0a035	8d 45 e0	 lea	 eax, DWORD PTR _pMsg$238021[ebp]
  0a038	50		 push	 eax
  0a039	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  0a03e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3493 : 					pMsg.btPlayState = 2;

  0a041	c6 45 e3 02	 mov	 BYTE PTR _pMsg$238021[ebp+3], 2

; 3494 : 					pMsg.wRemainSec = 0;

  0a045	33 c0		 xor	 eax, eax
  0a047	66 89 45 e4	 mov	 WORD PTR _pMsg$238021[ebp+4], ax

; 3495 : 					pMsg.wMaxKillMonster = 0;

  0a04b	33 c0		 xor	 eax, eax
  0a04d	66 89 45 e6	 mov	 WORD PTR _pMsg$238021[ebp+6], ax

; 3496 : 					pMsg.wCurKillMonster = 0;

  0a051	33 c0		 xor	 eax, eax
  0a053	66 89 45 e8	 mov	 WORD PTR _pMsg$238021[ebp+8], ax

; 3497 : 					pMsg.wUserHaveWeapon = 0;

  0a057	33 c0		 xor	 eax, eax
  0a059	66 89 45 ea	 mov	 WORD PTR _pMsg$238021[ebp+10], ax

; 3498 : 					pMsg.btWeaponNum = -1;

  0a05d	c6 45 ec ff	 mov	 BYTE PTR _pMsg$238021[ebp+12], 255 ; 000000ffH

; 3499 : 
; 3500 : 					DataSend(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0a061	0f b6 45 e1	 movzx	 eax, BYTE PTR _pMsg$238021[ebp+1]
  0a065	50		 push	 eax
  0a066	8d 4d e0	 lea	 ecx, DWORD PTR _pMsg$238021[ebp]
  0a069	51		 push	 ecx
  0a06a	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  0a06d	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  0a073	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0a076	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  0a07a	8b 55 f0	 mov	 edx, DWORD PTR _i$238008[ebp]
  0a07d	6b d2 14	 imul	 edx, 20			; 00000014H
  0a080	8b 44 11 18	 mov	 eax, DWORD PTR [ecx+edx+24]
  0a084	50		 push	 eax
  0a085	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0a08a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@CheckEvery:

; 3501 : 				}
; 3502 : 			}
; 3503 : 		}
; 3504 : 	}

  0a08d	e9 f9 fd ff ff	 jmp	 $LN9@CheckEvery
$LN8@CheckEvery:

; 3505 : 
; 3506 : 	return bRET_VAL;

  0a092	8a 45 f7	 mov	 al, BYTE PTR _bRET_VAL$[ebp]
$LN12@CheckEvery:

; 3507 : }

  0a095	5f		 pop	 edi
  0a096	5e		 pop	 esi
  0a097	5b		 pop	 ebx
  0a098	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0a09b	33 cd		 xor	 ecx, ebp
  0a09d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0a0a2	8b e5		 mov	 esp, ebp
  0a0a4	5d		 pop	 ebp
  0a0a5	c2 04 00	 ret	 4
?CheckEveryUserDie@CBloodCastle@@QAE_NH@Z ENDP		; CBloodCastle::CheckEveryUserDie
_TEXT	ENDS
PUBLIC	??_C@_0FH@CEGPGOIB@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Angel?5King?5?9@ ; `string'
PUBLIC	??_C@_0EA@LFJOCLMK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Angel?5King?8s@ ; `string'
;	COMDAT ??_C@_0FH@CEGPGOIB@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Angel?5King?5?9@
CONST	SEGMENT
??_C@_0FH@CEGPGOIB@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Angel?5King?5?9@ DB '['
	DB	'Blood Castle] (%d) Angel King - gObjAdd() failed (no space to'
	DB	' add monster, result:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@LFJOCLMK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Angel?5King?8s@
CONST	SEGMENT
??_C@_0EA@LFJOCLMK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Angel?5King?8s@ DB '['
	DB	'Blood Castle] (%d) Angel King''s Monster Position Doesn''t Ex'
	DB	'ist', 00H					; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv67 = -84						; size = 4
_result$238041 = -16					; size = 4
_i$238033 = -12						; size = 4
_bRET_VAL$ = -5						; size = 1
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?CheckAngelKingExist@CBloodCastle@@QAE_NH@Z PROC	; CBloodCastle::CheckAngelKingExist
; _this$ = ecx

; 3511 : {

  0a0b0	55		 push	 ebp
  0a0b1	8b ec		 mov	 ebp, esp
  0a0b3	83 ec 54	 sub	 esp, 84			; 00000054H
  0a0b6	53		 push	 ebx
  0a0b7	56		 push	 esi
  0a0b8	57		 push	 edi
  0a0b9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3512 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  0a0bc	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  0a0c0	7d 09		 jge	 SHORT $LN14@CheckAngel
  0a0c2	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  0a0c9	eb 0c		 jmp	 SHORT $LN15@CheckAngel
$LN14@CheckAngel:
  0a0cb	33 c0		 xor	 eax, eax
  0a0cd	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  0a0d1	0f 9e c0	 setle	 al
  0a0d4	89 45 ac	 mov	 DWORD PTR tv67[ebp], eax
$LN15@CheckAngel:
  0a0d7	83 7d ac 00	 cmp	 DWORD PTR tv67[ebp], 0
  0a0db	75 07		 jne	 SHORT $LN11@CheckAngel

; 3513 : 	{
; 3514 : 		return false;

  0a0dd	32 c0		 xor	 al, al
  0a0df	e9 8f 01 00 00	 jmp	 $LN12@CheckAngel
$LN11@CheckAngel:

; 3515 : 	}
; 3516 : 
; 3517 : 	bool bRET_VAL = false;

  0a0e4	c6 45 fb 00	 mov	 BYTE PTR _bRET_VAL$[ebp], 0

; 3518 : 
; 3519 : 	if ( this->m_BridgeData[iBridgeIndex].m_iAngelKingPosNum == -1 )

  0a0e8	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0a0eb	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0a0f1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0a0f4	83 bc 01 f4 03
	00 00 ff	 cmp	 DWORD PTR [ecx+eax+1012], -1
  0a0fc	75 1c		 jne	 SHORT $LN10@CheckAngel

; 3520 : 	{
; 3521 : 		LogAddTD("[Blood Castle] (%d) Angel King's Monster Position Doesn't Exist", iBridgeIndex+1);

  0a0fe	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0a101	83 c0 01	 add	 eax, 1
  0a104	50		 push	 eax
  0a105	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@LFJOCLMK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Angel?5King?8s@
  0a10a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0a110	83 c4 08	 add	 esp, 8

; 3522 : 		return false;

  0a113	32 c0		 xor	 al, al
  0a115	e9 59 01 00 00	 jmp	 $LN12@CheckAngel
$LN10@CheckAngel:

; 3523 : 	}
; 3524 : 
; 3525 : 	for ( int i=0;i<OBJ_STARTUSERINDEX;i++)

  0a11a	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$238033[ebp], 0
  0a121	eb 09		 jmp	 SHORT $LN9@CheckAngel
$LN8@CheckAngel:
  0a123	8b 45 f4	 mov	 eax, DWORD PTR _i$238033[ebp]
  0a126	83 c0 01	 add	 eax, 1
  0a129	89 45 f4	 mov	 DWORD PTR _i$238033[ebp], eax
$LN9@CheckAngel:
  0a12c	81 7d f4 b0 36
	00 00		 cmp	 DWORD PTR _i$238033[ebp], 14000 ; 000036b0H
  0a133	0f 8d 80 00 00
	00		 jge	 $LN7@CheckAngel

; 3526 : 	{
; 3527 : 		if ( gObj[i].Connected == PLAYER_PLAYING && gObj[i].Type == OBJ_NPC )

  0a139	8b 45 f4	 mov	 eax, DWORD PTR _i$238033[ebp]
  0a13c	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0a142	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0a148	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  0a14d	75 65		 jne	 SHORT $LN6@CheckAngel
  0a14f	8b 45 f4	 mov	 eax, DWORD PTR _i$238033[ebp]
  0a152	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0a158	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0a15e	0f b7 54 01 68	 movzx	 edx, WORD PTR [ecx+eax+104]
  0a163	83 fa 03	 cmp	 edx, 3
  0a166	75 4c		 jne	 SHORT $LN6@CheckAngel

; 3528 : 		{
; 3529 : 			if ( gObj[i].Class == 232 )

  0a168	8b 45 f4	 mov	 eax, DWORD PTR _i$238033[ebp]
  0a16b	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0a171	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0a177	0f b7 94 01 b8
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+184]
  0a17f	81 fa e8 00 00
	00		 cmp	 edx, 232		; 000000e8H
  0a185	75 2d		 jne	 SHORT $LN6@CheckAngel

; 3530 : 			{
; 3531 : 				if (gObj[i].MapNumber == this->GetBridgeMapNumber(iBridgeIndex) ) //season3 changed

  0a187	8b 45 f4	 mov	 eax, DWORD PTR _i$238033[ebp]
  0a18a	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0a190	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0a196	0f b6 b4 01 49
	01 00 00	 movzx	 esi, BYTE PTR [ecx+eax+329]
  0a19e	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  0a1a1	52		 push	 edx
  0a1a2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0a1a5	e8 00 00 00 00	 call	 ?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeMapNumber
  0a1aa	3b f0		 cmp	 esi, eax
  0a1ac	75 06		 jne	 SHORT $LN6@CheckAngel

; 3532 : 				{
; 3533 : 					bRET_VAL = true;

  0a1ae	c6 45 fb 01	 mov	 BYTE PTR _bRET_VAL$[ebp], 1

; 3534 : 					break;

  0a1b2	eb 05		 jmp	 SHORT $LN7@CheckAngel
$LN6@CheckAngel:

; 3535 : 				}
; 3536 : 			}
; 3537 : 		}
; 3538 : 	}

  0a1b4	e9 6a ff ff ff	 jmp	 $LN8@CheckAngel
$LN7@CheckAngel:

; 3539 : 
; 3540 : 	if ( bRET_VAL == false )

  0a1b9	0f b6 45 fb	 movzx	 eax, BYTE PTR _bRET_VAL$[ebp]
  0a1bd	85 c0		 test	 eax, eax
  0a1bf	0f 85 ab 00 00
	00		 jne	 $LN3@CheckAngel

; 3541 : 	{
; 3542 : 		int result = gObjAddMonster(this->GetBridgeMapNumber(iBridgeIndex)); //season3 changed

  0a1c5	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0a1c8	50		 push	 eax
  0a1c9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0a1cc	e8 00 00 00 00	 call	 ?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeMapNumber
  0a1d1	50		 push	 eax
  0a1d2	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  0a1d7	83 c4 04	 add	 esp, 4
  0a1da	0f bf c8	 movsx	 ecx, ax
  0a1dd	89 4d f0	 mov	 DWORD PTR _result$238041[ebp], ecx

; 3543 : 
; 3544 : 		if ( result >= 0 )

  0a1e0	83 7d f0 00	 cmp	 DWORD PTR _result$238041[ebp], 0
  0a1e4	7c 6d		 jl	 SHORT $LN2@CheckAngel

; 3545 : 		{
; 3546 : 			gObjSetPosMonster(result, this->m_BridgeData[iBridgeIndex].m_iAngelKingPosNum);

  0a1e6	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0a1e9	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0a1ef	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0a1f2	8b 94 01 f4 03
	00 00		 mov	 edx, DWORD PTR [ecx+eax+1012]
  0a1f9	52		 push	 edx
  0a1fa	8b 45 f0	 mov	 eax, DWORD PTR _result$238041[ebp]
  0a1fd	50		 push	 eax
  0a1fe	e8 00 00 00 00	 call	 ?gObjSetPosMonster@@YAHHH@Z ; gObjSetPosMonster
  0a203	83 c4 08	 add	 esp, 8

; 3547 : 			gObjSetMonster(result, 232);

  0a206	68 e8 00 00 00	 push	 232			; 000000e8H
  0a20b	8b 45 f0	 mov	 eax, DWORD PTR _result$238041[ebp]
  0a20e	50		 push	 eax
  0a20f	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster
  0a214	83 c4 08	 add	 esp, 8

; 3548 : 			gObj[result].m_cBloodCastleIndex = this->GetBridgeIndex(gObj[result].MapNumber);

  0a217	8b 45 f0	 mov	 eax, DWORD PTR _result$238041[ebp]
  0a21a	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0a220	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0a226	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  0a22e	52		 push	 edx
  0a22f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0a232	e8 00 00 00 00	 call	 ?GetBridgeIndex@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeIndex
  0a237	8b 4d f0	 mov	 ecx, DWORD PTR _result$238041[ebp]
  0a23a	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0a240	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0a246	88 84 0a 9e 0e
	00 00		 mov	 BYTE PTR [edx+ecx+3742], al

; 3549 : 			bRET_VAL = true;

  0a24d	c6 45 fb 01	 mov	 BYTE PTR _bRET_VAL$[ebp], 1

; 3550 : 		}
; 3551 : 		else

  0a251	eb 1d		 jmp	 SHORT $LN3@CheckAngel
$LN2@CheckAngel:

; 3552 : 		{
; 3553 : 			LogAddTD("[Blood Castle] (%d) Angel King - gObjAdd() failed (no space to add monster, result:%d)", iBridgeIndex+1, result);

  0a253	8b 45 f0	 mov	 eax, DWORD PTR _result$238041[ebp]
  0a256	50		 push	 eax
  0a257	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  0a25a	83 c1 01	 add	 ecx, 1
  0a25d	51		 push	 ecx
  0a25e	68 00 00 00 00	 push	 OFFSET ??_C@_0FH@CEGPGOIB@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Angel?5King?5?9@
  0a263	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0a269	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3554 : 			return false;

  0a26c	32 c0		 xor	 al, al
  0a26e	eb 03		 jmp	 SHORT $LN12@CheckAngel
$LN3@CheckAngel:

; 3555 : 		}
; 3556 : 	}
; 3557 : 
; 3558 : 	return bRET_VAL;

  0a270	8a 45 fb	 mov	 al, BYTE PTR _bRET_VAL$[ebp]
$LN12@CheckAngel:

; 3559 : }

  0a273	5f		 pop	 edi
  0a274	5e		 pop	 esi
  0a275	5b		 pop	 ebx
  0a276	8b e5		 mov	 esp, ebp
  0a278	5d		 pop	 ebp
  0a279	c2 04 00	 ret	 4
?CheckAngelKingExist@CBloodCastle@@QAE_NH@Z ENDP	; CBloodCastle::CheckAngelKingExist
; Function compile flags: /Odtp /ZI
tv139 = -96						; size = 4
tv170 = -92						; size = 4
tv140 = -92						; size = 4
tv80 = -92						; size = 4
tv67 = -92						; size = 4
_iLEVEL$238066 = -24					; size = 4
_x$238060 = -20						; size = 4
_iIndex$238055 = -16					; size = 4
_i$238051 = -12						; size = 4
_iBridgeUserIndex$ = -8					; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?GetWhoGotUltimateWeapon@CBloodCastle@@QAEHH@Z PROC	; CBloodCastle::GetWhoGotUltimateWeapon
; _this$ = ecx

; 3562 : {

  0a280	55		 push	 ebp
  0a281	8b ec		 mov	 ebp, esp
  0a283	83 ec 60	 sub	 esp, 96			; 00000060H
  0a286	53		 push	 ebx
  0a287	56		 push	 esi
  0a288	57		 push	 edi
  0a289	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3563 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  0a28c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  0a290	7d 09		 jge	 SHORT $LN19@GetWhoGotU
  0a292	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  0a299	eb 0c		 jmp	 SHORT $LN20@GetWhoGotU
$LN19@GetWhoGotU:
  0a29b	33 c0		 xor	 eax, eax
  0a29d	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  0a2a1	0f 9e c0	 setle	 al
  0a2a4	89 45 a4	 mov	 DWORD PTR tv67[ebp], eax
$LN20@GetWhoGotU:
  0a2a7	83 7d a4 00	 cmp	 DWORD PTR tv67[ebp], 0
  0a2ab	75 0a		 jne	 SHORT $LN16@GetWhoGotU

; 3564 : 	{
; 3565 : 		return -1;

  0a2ad	b8 ff ff ff ff	 mov	 eax, -1
  0a2b2	e9 3d 02 00 00	 jmp	 $LN17@GetWhoGotU
$LN16@GetWhoGotU:

; 3566 : 	}
; 3567 : 
; 3568 : 	int iBridgeUserIndex = -1;

  0a2b7	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _iBridgeUserIndex$[ebp], -1

; 3569 : 
; 3570 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  0a2be	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$238051[ebp], 0
  0a2c5	eb 09		 jmp	 SHORT $LN15@GetWhoGotU
$LN14@GetWhoGotU:
  0a2c7	8b 45 f4	 mov	 eax, DWORD PTR _i$238051[ebp]
  0a2ca	83 c0 01	 add	 eax, 1
  0a2cd	89 45 f4	 mov	 DWORD PTR _i$238051[ebp], eax
$LN15@GetWhoGotU:
  0a2d0	83 7d f4 28	 cmp	 DWORD PTR _i$238051[ebp], 40 ; 00000028H
  0a2d4	0f 8d 17 02 00
	00		 jge	 $LN13@GetWhoGotU

; 3571 : 	{
; 3572 : 		int iIndex = this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex;

  0a2da	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0a2dd	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0a2e3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0a2e6	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0a2ea	8b 45 f4	 mov	 eax, DWORD PTR _i$238051[ebp]
  0a2ed	6b c0 14	 imul	 eax, 20			; 00000014H
  0a2f0	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  0a2f4	89 4d f0	 mov	 DWORD PTR _iIndex$238055[ebp], ecx

; 3573 : 
; 3574 : 		if ( OBJMAX_RANGE(iIndex) == FALSE )

  0a2f7	83 7d f0 00	 cmp	 DWORD PTR _iIndex$238055[ebp], 0
  0a2fb	7d 09		 jge	 SHORT $LN21@GetWhoGotU
  0a2fd	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv80[ebp], 0
  0a304	eb 0f		 jmp	 SHORT $LN22@GetWhoGotU
$LN21@GetWhoGotU:
  0a306	33 c0		 xor	 eax, eax
  0a308	81 7d f0 97 3a
	00 00		 cmp	 DWORD PTR _iIndex$238055[ebp], 14999 ; 00003a97H
  0a30f	0f 9e c0	 setle	 al
  0a312	89 45 a4	 mov	 DWORD PTR tv80[ebp], eax
$LN22@GetWhoGotU:
  0a315	83 7d a4 00	 cmp	 DWORD PTR tv80[ebp], 0
  0a319	75 02		 jne	 SHORT $LN12@GetWhoGotU

; 3575 : 		{
; 3576 : 			continue;

  0a31b	eb aa		 jmp	 SHORT $LN14@GetWhoGotU
$LN12@GetWhoGotU:

; 3577 : 		}
; 3578 : 
; 3579 : 		if( gObj[iIndex].Type != OBJ_USER || gObj[iIndex].Connected <= PLAYER_LOGGED )

  0a31d	8b 45 f0	 mov	 eax, DWORD PTR _iIndex$238055[ebp]
  0a320	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0a326	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0a32c	0f b7 54 01 68	 movzx	 edx, WORD PTR [ecx+eax+104]
  0a331	83 fa 01	 cmp	 edx, 1
  0a334	75 16		 jne	 SHORT $LN10@GetWhoGotU
  0a336	8b 45 f0	 mov	 eax, DWORD PTR _iIndex$238055[ebp]
  0a339	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0a33f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0a345	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  0a34a	7f 05		 jg	 SHORT $LN11@GetWhoGotU
$LN10@GetWhoGotU:

; 3580 : 		{
; 3581 : 			continue;

  0a34c	e9 76 ff ff ff	 jmp	 $LN14@GetWhoGotU
$LN11@GetWhoGotU:

; 3582 : 		}
; 3583 : 
; 3584 : 		if ( BC_MAP_RANGE( gObj[iIndex].MapNumber ) == FALSE )

  0a351	8b 45 f0	 mov	 eax, DWORD PTR _iIndex$238055[ebp]
  0a354	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0a35a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0a360	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  0a368	83 fa 34	 cmp	 edx, 52			; 00000034H
  0a36b	75 09		 jne	 SHORT $LN25@GetWhoGotU
  0a36d	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR tv140[ebp], 1
  0a374	eb 4d		 jmp	 SHORT $LN26@GetWhoGotU
$LN25@GetWhoGotU:
  0a376	8b 45 f0	 mov	 eax, DWORD PTR _iIndex$238055[ebp]
  0a379	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0a37f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0a385	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  0a38d	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  0a390	7d 09		 jge	 SHORT $LN23@GetWhoGotU
  0a392	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv139[ebp], 0
  0a399	eb 22		 jmp	 SHORT $LN24@GetWhoGotU
$LN23@GetWhoGotU:
  0a39b	8b 45 f0	 mov	 eax, DWORD PTR _iIndex$238055[ebp]
  0a39e	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0a3a4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0a3aa	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  0a3b2	33 c0		 xor	 eax, eax
  0a3b4	83 fa 11	 cmp	 edx, 17			; 00000011H
  0a3b7	0f 9e c0	 setle	 al
  0a3ba	89 45 a0	 mov	 DWORD PTR tv139[ebp], eax
$LN24@GetWhoGotU:
  0a3bd	8b 4d a0	 mov	 ecx, DWORD PTR tv139[ebp]
  0a3c0	89 4d a4	 mov	 DWORD PTR tv140[ebp], ecx
$LN26@GetWhoGotU:
  0a3c3	83 7d a4 00	 cmp	 DWORD PTR tv140[ebp], 0
  0a3c7	75 05		 jne	 SHORT $LN9@GetWhoGotU

; 3585 : 		{
; 3586 : 			continue;

  0a3c9	e9 f9 fe ff ff	 jmp	 $LN14@GetWhoGotU
$LN9@GetWhoGotU:

; 3587 : 		}
; 3588 : 
; 3589 : 		for ( int x=0;x<INVENTORY_SIZE;x++)

  0a3ce	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _x$238060[ebp], 0
  0a3d5	eb 09		 jmp	 SHORT $LN8@GetWhoGotU
$LN7@GetWhoGotU:
  0a3d7	8b 45 ec	 mov	 eax, DWORD PTR _x$238060[ebp]
  0a3da	83 c0 01	 add	 eax, 1
  0a3dd	89 45 ec	 mov	 DWORD PTR _x$238060[ebp], eax
$LN8@GetWhoGotU:
  0a3e0	81 7d ec ec 00
	00 00		 cmp	 DWORD PTR _x$238060[ebp], 236 ; 000000ecH
  0a3e7	0f 8d ff 00 00
	00		 jge	 $LN6@GetWhoGotU

; 3590 : 		{
; 3591 : 			if ( gObj[iIndex].pInventory[x].IsItem() == TRUE )

  0a3ed	8b 45 f0	 mov	 eax, DWORD PTR _iIndex$238055[ebp]
  0a3f0	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0a3f6	8b 4d ec	 mov	 ecx, DWORD PTR _x$238060[ebp]
  0a3f9	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0a3ff	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0a405	03 8c 02 24 0e
	00 00		 add	 ecx, DWORD PTR [edx+eax+3620]
  0a40c	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0a411	83 f8 01	 cmp	 eax, 1
  0a414	0f 85 cd 00 00
	00		 jne	 $LN5@GetWhoGotU

; 3592 : 			{
; 3593 : 				if ( gObj[iIndex].pInventory[x].m_Type == ITEMGET(13,19) )

  0a41a	8b 45 f0	 mov	 eax, DWORD PTR _iIndex$238055[ebp]
  0a41d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0a423	8b 4d ec	 mov	 ecx, DWORD PTR _x$238060[ebp]
  0a426	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0a42c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0a432	8b 84 02 24 0e
	00 00		 mov	 eax, DWORD PTR [edx+eax+3620]
  0a439	0f bf 4c 08 06	 movsx	 ecx, WORD PTR [eax+ecx+6]
  0a43e	81 f9 13 1a 00
	00		 cmp	 ecx, 6675		; 00001a13H
  0a444	0f 85 9d 00 00
	00		 jne	 $LN5@GetWhoGotU

; 3594 : 				{
; 3595 : 					int iLEVEL = gObj[iIndex].pInventory[x].m_Level;

  0a44a	8b 45 f0	 mov	 eax, DWORD PTR _iIndex$238055[ebp]
  0a44d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0a453	8b 4d ec	 mov	 ecx, DWORD PTR _x$238060[ebp]
  0a456	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0a45c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0a462	8b 84 02 24 0e
	00 00		 mov	 eax, DWORD PTR [edx+eax+3620]
  0a469	0f bf 4c 08 08	 movsx	 ecx, WORD PTR [eax+ecx+8]
  0a46e	89 4d e8	 mov	 DWORD PTR _iLEVEL$238066[ebp], ecx

; 3596 : 
; 3597 : 					if ( BC_WEAPON_LEVEL_RANGE(iLEVEL) != FALSE )

  0a471	83 7d e8 00	 cmp	 DWORD PTR _iLEVEL$238066[ebp], 0
  0a475	7d 09		 jge	 SHORT $LN27@GetWhoGotU
  0a477	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv170[ebp], 0
  0a47e	eb 0c		 jmp	 SHORT $LN28@GetWhoGotU
$LN27@GetWhoGotU:
  0a480	33 c0		 xor	 eax, eax
  0a482	83 7d e8 02	 cmp	 DWORD PTR _iLEVEL$238066[ebp], 2
  0a486	0f 9e c0	 setle	 al
  0a489	89 45 a4	 mov	 DWORD PTR tv170[ebp], eax
$LN28@GetWhoGotU:
  0a48c	83 7d a4 00	 cmp	 DWORD PTR tv170[ebp], 0
  0a490	74 55		 je	 SHORT $LN5@GetWhoGotU

; 3598 : 					{
; 3599 : 						if ( this->m_BridgeData[iBridgeIndex].m_nBC_QUESTITEM_SERIAL != -1 )

  0a492	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0a495	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0a49b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0a49e	83 bc 01 e8 03
	00 00 ff	 cmp	 DWORD PTR [ecx+eax+1000], -1
  0a4a6	74 3f		 je	 SHORT $LN5@GetWhoGotU

; 3600 : 						{
; 3601 : 							if ( this->m_BridgeData[iBridgeIndex].m_nBC_QUESTITEM_SERIAL == gObj[iIndex].pInventory[x].m_Number )

  0a4a8	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0a4ab	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0a4b1	8b 4d f0	 mov	 ecx, DWORD PTR _iIndex$238055[ebp]
  0a4b4	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0a4ba	8b 55 ec	 mov	 edx, DWORD PTR _x$238060[ebp]
  0a4bd	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  0a4c3	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0a4c9	8b 8c 0e 24 0e
	00 00		 mov	 ecx, DWORD PTR [esi+ecx+3620]
  0a4d0	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  0a4d3	8b 84 06 e8 03
	00 00		 mov	 eax, DWORD PTR [esi+eax+1000]
  0a4da	3b 04 0a	 cmp	 eax, DWORD PTR [edx+ecx]
  0a4dd	75 08		 jne	 SHORT $LN5@GetWhoGotU

; 3602 : 							{
; 3603 : 								iBridgeUserIndex = iIndex;

  0a4df	8b 45 f0	 mov	 eax, DWORD PTR _iIndex$238055[ebp]
  0a4e2	89 45 f8	 mov	 DWORD PTR _iBridgeUserIndex$[ebp], eax

; 3604 : 								break;

  0a4e5	eb 05		 jmp	 SHORT $LN6@GetWhoGotU
$LN5@GetWhoGotU:

; 3605 : 							}
; 3606 : 						}
; 3607 : 					}
; 3608 : 				}
; 3609 : 			}
; 3610 : 		}

  0a4e7	e9 eb fe ff ff	 jmp	 $LN7@GetWhoGotU
$LN6@GetWhoGotU:

; 3611 : 
; 3612 : 	}

  0a4ec	e9 d6 fd ff ff	 jmp	 $LN14@GetWhoGotU
$LN13@GetWhoGotU:

; 3613 : 
; 3614 : 	return iBridgeUserIndex;

  0a4f1	8b 45 f8	 mov	 eax, DWORD PTR _iBridgeUserIndex$[ebp]
$LN17@GetWhoGotU:

; 3615 : }

  0a4f4	5f		 pop	 edi
  0a4f5	5e		 pop	 esi
  0a4f6	5b		 pop	 ebx
  0a4f7	8b e5		 mov	 esp, ebp
  0a4f9	5d		 pop	 ebp
  0a4fa	c2 04 00	 ret	 4
?GetWhoGotUltimateWeapon@CBloodCastle@@QAEHH@Z ENDP	; CBloodCastle::GetWhoGotUltimateWeapon
_TEXT	ENDS
PUBLIC	?GetCurrentLiveUserCount@CBloodCastle@@QAEHH@Z	; CBloodCastle::GetCurrentLiveUserCount
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv130 = -88						; size = 4
tv131 = -84						; size = 4
tv80 = -84						; size = 4
tv67 = -84						; size = 4
_iIndex$238080 = -16					; size = 4
_i$238076 = -12						; size = 4
_iRetLiveUserCount$ = -8				; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?GetCurrentLiveUserCount@CBloodCastle@@QAEHH@Z PROC	; CBloodCastle::GetCurrentLiveUserCount
; _this$ = ecx

; 3618 : {

  0a500	55		 push	 ebp
  0a501	8b ec		 mov	 ebp, esp
  0a503	83 ec 58	 sub	 esp, 88			; 00000058H
  0a506	53		 push	 ebx
  0a507	56		 push	 esi
  0a508	57		 push	 edi
  0a509	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3619 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  0a50c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  0a510	7d 09		 jge	 SHORT $LN11@GetCurrent@2
  0a512	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  0a519	eb 0c		 jmp	 SHORT $LN12@GetCurrent@2
$LN11@GetCurrent@2:
  0a51b	33 c0		 xor	 eax, eax
  0a51d	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  0a521	0f 9e c0	 setle	 al
  0a524	89 45 ac	 mov	 DWORD PTR tv67[ebp], eax
$LN12@GetCurrent@2:
  0a527	83 7d ac 00	 cmp	 DWORD PTR tv67[ebp], 0
  0a52b	75 0a		 jne	 SHORT $LN8@GetCurrent@2

; 3620 : 	{
; 3621 : 		return -1;

  0a52d	b8 ff ff ff ff	 mov	 eax, -1
  0a532	e9 28 01 00 00	 jmp	 $LN9@GetCurrent@2
$LN8@GetCurrent@2:

; 3622 : 	}
; 3623 : 
; 3624 : 	int iRetLiveUserCount = 0;

  0a537	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iRetLiveUserCount$[ebp], 0

; 3625 : 
; 3626 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  0a53e	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$238076[ebp], 0
  0a545	eb 09		 jmp	 SHORT $LN7@GetCurrent@2
$LN6@GetCurrent@2:
  0a547	8b 45 f4	 mov	 eax, DWORD PTR _i$238076[ebp]
  0a54a	83 c0 01	 add	 eax, 1
  0a54d	89 45 f4	 mov	 DWORD PTR _i$238076[ebp], eax
$LN7@GetCurrent@2:
  0a550	83 7d f4 28	 cmp	 DWORD PTR _i$238076[ebp], 40 ; 00000028H
  0a554	0f 8d 02 01 00
	00		 jge	 $LN5@GetCurrent@2

; 3627 : 	{
; 3628 : 		int iIndex = this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex;

  0a55a	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0a55d	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0a563	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0a566	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0a56a	8b 45 f4	 mov	 eax, DWORD PTR _i$238076[ebp]
  0a56d	6b c0 14	 imul	 eax, 20			; 00000014H
  0a570	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  0a574	89 4d f0	 mov	 DWORD PTR _iIndex$238080[ebp], ecx

; 3629 : 
; 3630 : 		if ( OBJMAX_RANGE(iIndex) == FALSE )

  0a577	83 7d f0 00	 cmp	 DWORD PTR _iIndex$238080[ebp], 0
  0a57b	7d 09		 jge	 SHORT $LN13@GetCurrent@2
  0a57d	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv80[ebp], 0
  0a584	eb 0f		 jmp	 SHORT $LN14@GetCurrent@2
$LN13@GetCurrent@2:
  0a586	33 c0		 xor	 eax, eax
  0a588	81 7d f0 97 3a
	00 00		 cmp	 DWORD PTR _iIndex$238080[ebp], 14999 ; 00003a97H
  0a58f	0f 9e c0	 setle	 al
  0a592	89 45 ac	 mov	 DWORD PTR tv80[ebp], eax
$LN14@GetCurrent@2:
  0a595	83 7d ac 00	 cmp	 DWORD PTR tv80[ebp], 0
  0a599	75 02		 jne	 SHORT $LN4@GetCurrent@2

; 3631 : 		{
; 3632 : 			continue;

  0a59b	eb aa		 jmp	 SHORT $LN6@GetCurrent@2
$LN4@GetCurrent@2:

; 3633 : 		}
; 3634 : 
; 3635 : 		if ( BC_MAP_RANGE( gObj[iIndex].MapNumber ) == FALSE )

  0a59d	8b 45 f0	 mov	 eax, DWORD PTR _iIndex$238080[ebp]
  0a5a0	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0a5a6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0a5ac	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  0a5b4	83 fa 34	 cmp	 edx, 52			; 00000034H
  0a5b7	75 09		 jne	 SHORT $LN17@GetCurrent@2
  0a5b9	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv131[ebp], 1
  0a5c0	eb 4d		 jmp	 SHORT $LN18@GetCurrent@2
$LN17@GetCurrent@2:
  0a5c2	8b 45 f0	 mov	 eax, DWORD PTR _iIndex$238080[ebp]
  0a5c5	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0a5cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0a5d1	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  0a5d9	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  0a5dc	7d 09		 jge	 SHORT $LN15@GetCurrent@2
  0a5de	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv130[ebp], 0
  0a5e5	eb 22		 jmp	 SHORT $LN16@GetCurrent@2
$LN15@GetCurrent@2:
  0a5e7	8b 45 f0	 mov	 eax, DWORD PTR _iIndex$238080[ebp]
  0a5ea	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0a5f0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0a5f6	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  0a5fe	33 c0		 xor	 eax, eax
  0a600	83 fa 11	 cmp	 edx, 17			; 00000011H
  0a603	0f 9e c0	 setle	 al
  0a606	89 45 a8	 mov	 DWORD PTR tv130[ebp], eax
$LN16@GetCurrent@2:
  0a609	8b 4d a8	 mov	 ecx, DWORD PTR tv130[ebp]
  0a60c	89 4d ac	 mov	 DWORD PTR tv131[ebp], ecx
$LN18@GetCurrent@2:
  0a60f	83 7d ac 00	 cmp	 DWORD PTR tv131[ebp], 0
  0a613	75 05		 jne	 SHORT $LN3@GetCurrent@2

; 3636 : 		{
; 3637 : 			continue;

  0a615	e9 2d ff ff ff	 jmp	 $LN6@GetCurrent@2
$LN3@GetCurrent@2:

; 3638 : 		}
; 3639 : 
; 3640 : 		if( gObj[iIndex].Type != OBJ_USER  )

  0a61a	8b 45 f0	 mov	 eax, DWORD PTR _iIndex$238080[ebp]
  0a61d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0a623	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0a629	0f b7 54 01 68	 movzx	 edx, WORD PTR [ecx+eax+104]
  0a62e	83 fa 01	 cmp	 edx, 1
  0a631	74 05		 je	 SHORT $LN2@GetCurrent@2

; 3641 : 		{
; 3642 : 			continue;

  0a633	e9 0f ff ff ff	 jmp	 $LN6@GetCurrent@2
$LN2@GetCurrent@2:

; 3643 : 		}
; 3644 : 
; 3645 : 		if ( gObj[iIndex].Connected > PLAYER_LOGGED )

  0a638	8b 45 f0	 mov	 eax, DWORD PTR _iIndex$238080[ebp]
  0a63b	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0a641	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0a647	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  0a64c	7e 09		 jle	 SHORT $LN1@GetCurrent@2

; 3646 : 		{
; 3647 : 			iRetLiveUserCount++;

  0a64e	8b 45 f8	 mov	 eax, DWORD PTR _iRetLiveUserCount$[ebp]
  0a651	83 c0 01	 add	 eax, 1
  0a654	89 45 f8	 mov	 DWORD PTR _iRetLiveUserCount$[ebp], eax
$LN1@GetCurrent@2:

; 3648 : 		}
; 3649 : 	}

  0a657	e9 eb fe ff ff	 jmp	 $LN6@GetCurrent@2
$LN5@GetCurrent@2:

; 3650 : 
; 3651 : 	return iRetLiveUserCount;

  0a65c	8b 45 f8	 mov	 eax, DWORD PTR _iRetLiveUserCount$[ebp]
$LN9@GetCurrent@2:

; 3652 : }

  0a65f	5f		 pop	 edi
  0a660	5e		 pop	 esi
  0a661	5b		 pop	 ebx
  0a662	8b e5		 mov	 esp, ebp
  0a664	5d		 pop	 ebp
  0a665	c2 04 00	 ret	 4
?GetCurrentLiveUserCount@CBloodCastle@@QAEHH@Z ENDP	; CBloodCastle::GetCurrentLiveUserCount
_TEXT	ENDS
PUBLIC	??_C@_04BGCMBJDA@Item?$AA@			; `string'
PUBLIC	??_C@_0EM@CLFOPJPH@?$FLBlood?5Castle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5DropItem@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z:PROC	; MsgSendV2
EXTRN	?LevelSmallConvert@@YAEHH@Z:PROC		; LevelSmallConvert
EXTRN	?ItemByteConvert@@YAXPAEVCItem@@@Z:PROC		; ItemByteConvert
EXTRN	?gObjMakePreviewCharSet@@YAXH@Z:PROC		; gObjMakePreviewCharSet
EXTRN	?SkillChangeUse@CObjUseSkill@@QAEHH@Z:PROC	; CObjUseSkill::SkillChangeUse
EXTRN	?gObjUseSkill@@3VCObjUseSkill@@A:DWORD		; gObjUseSkill
EXTRN	?ItemDrop@MapClass@@QAEHHHMHHEEEEEKHHHEQAEE@Z:PROC ; MapClass::ItemDrop
EXTRN	?GetActiveSocketOption@CSocketOption@@QAEXPAVCItem@@PAEAAE@Z:PROC ; CSocketOption::GetActiveSocketOption
EXTRN	?g_SocketOption@@3VCSocketOption@@A:BYTE	; g_SocketOption
EXTRN	?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z:PROC	; ItemIsBufExOption
EXTRN	?GetItemOptionLevel@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z:PROC ; CJewelOfHarmonySystem::GetItemOptionLevel
EXTRN	?GetItemStrengthenOption@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z:PROC ; CJewelOfHarmonySystem::GetItemStrengthenOption
EXTRN	?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A:BYTE ; g_kJewelOfHarmonySystem
EXTRN	_memset:PROC
;	COMDAT ??_C@_04BGCMBJDA@Item?$AA@
CONST	SEGMENT
??_C@_04BGCMBJDA@Item?$AA@ DB 'Item', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@CLFOPJPH@?$FLBlood?5Castle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5DropItem@
CONST	SEGMENT
??_C@_0EM@CLFOPJPH@?$FLBlood?5Castle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5DropItem@ DB '['
	DB	'Blood Castle] [%s][%s] DropItemDirectly() failed (iBridgeInde'
	DB	'x wrong - %d)', 00H				; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv77 = -232						; size = 4
tv78 = -228						; size = 4
_pMsg$238127 = -160					; size = 17
_SocketIndex$ = -137					; size = 1
_SocketOption$ = -136					; size = 5
_aAntiLootIndex$ = -128					; size = 4
_szItemName$ = -124					; size = 50
_item_number$ = -72					; size = 4
_ItemEffectEx$ = -66					; size = 1
_SOption$ = -65						; size = 1
_PetExp$ = -64						; size = 4
_PetLevel$ = -60					; size = 4
_NewOption$ = -56					; size = 8
_ItemExLevel$ = -46					; size = 1
_ItemExOption$ = -45					; size = 1
_s_num$ = -44						; size = 4
_NOption$ = -40						; size = 1
_Option3$ = -39						; size = 1
_Option2$ = -38						; size = 1
_Option1$ = -37						; size = 1
_ret$ = -36						; size = 4
_dur$ = -32						; size = 4
_level$ = -28						; size = 4
_type$ = -24						; size = 4
_map_num$ = -20						; size = 4
_pResult$ = -16						; size = 5
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
_iIndex$ = 12						; size = 4
_iItemType$ = 16					; size = 4
_iItemPos$ = 20						; size = 4
?DropItemDirectly@CBloodCastle@@QAEHHHHH@Z PROC		; CBloodCastle::DropItemDirectly
; _this$ = ecx

; 3656 : {

  0a670	55		 push	 ebp
  0a671	8b ec		 mov	 ebp, esp
  0a673	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  0a679	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0a67e	33 c5		 xor	 eax, ebp
  0a680	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0a683	53		 push	 ebx
  0a684	56		 push	 esi
  0a685	57		 push	 edi
  0a686	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3657 : 	if ( BC_MAP_RANGE(this->GetBridgeMapNumber(iBridgeIndex)) == FALSE )

  0a689	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0a68c	50		 push	 eax
  0a68d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0a690	e8 00 00 00 00	 call	 ?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeMapNumber
  0a695	83 f8 34	 cmp	 eax, 52			; 00000034H
  0a698	75 0c		 jne	 SHORT $LN12@DropItemDi
  0a69a	c7 85 1c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv78[ebp], 1
  0a6a4	eb 43		 jmp	 SHORT $LN13@DropItemDi
$LN12@DropItemDi:
  0a6a6	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  0a6a9	51		 push	 ecx
  0a6aa	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0a6ad	e8 00 00 00 00	 call	 ?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeMapNumber
  0a6b2	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  0a6b5	7d 0c		 jge	 SHORT $LN10@DropItemDi
  0a6b7	c7 85 18 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv77[ebp], 0
  0a6c1	eb 1a		 jmp	 SHORT $LN11@DropItemDi
$LN10@DropItemDi:
  0a6c3	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  0a6c6	52		 push	 edx
  0a6c7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0a6ca	e8 00 00 00 00	 call	 ?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeMapNumber
  0a6cf	33 c9		 xor	 ecx, ecx
  0a6d1	83 f8 11	 cmp	 eax, 17			; 00000011H
  0a6d4	0f 9e c1	 setle	 cl
  0a6d7	89 8d 18 ff ff
	ff		 mov	 DWORD PTR tv77[ebp], ecx
$LN11@DropItemDi:
  0a6dd	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR tv77[ebp]
  0a6e3	89 95 1c ff ff
	ff		 mov	 DWORD PTR tv78[ebp], edx
$LN13@DropItemDi:
  0a6e9	83 bd 1c ff ff
	ff 00		 cmp	 DWORD PTR tv78[ebp], 0
  0a6f0	75 41		 jne	 SHORT $LN7@DropItemDi

; 3658 : 	{
; 3659 : 		LogAddTD("[Blood Castle] [%s][%s] DropItemDirectly() failed (iBridgeIndex wrong - %d)",	gObj[iIndex].AccountID, gObj[iIndex].Name, iBridgeIndex);

  0a6f2	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0a6f5	50		 push	 eax
  0a6f6	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0a6f9	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0a6ff	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0a705	8d 44 0a 77	 lea	 eax, DWORD PTR [edx+ecx+119]
  0a709	50		 push	 eax
  0a70a	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0a70d	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0a713	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0a719	8d 44 0a 6c	 lea	 eax, DWORD PTR [edx+ecx+108]
  0a71d	50		 push	 eax
  0a71e	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@CLFOPJPH@?$FLBlood?5Castle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5DropItem@
  0a723	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0a729	83 c4 10	 add	 esp, 16			; 00000010H

; 3660 : 		return FALSE;

  0a72c	33 c0		 xor	 eax, eax
  0a72e	e9 47 06 00 00	 jmp	 $LN8@DropItemDi
$LN7@DropItemDi:

; 3661 : 	}
; 3662 : 
; 3663 : 	PMSG_ITEMTHROW_RESULT pResult;
; 3664 : 
; 3665 : 	PHeadSetB((LPBYTE)&pResult, 0x23, sizeof(pResult));

  0a733	6a 05		 push	 5
  0a735	6a 23		 push	 35			; 00000023H
  0a737	8d 45 f0	 lea	 eax, DWORD PTR _pResult$[ebp]
  0a73a	50		 push	 eax
  0a73b	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  0a740	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3666 : 	pResult.Result = TRUE;

  0a743	c6 45 f3 01	 mov	 BYTE PTR _pResult$[ebp+3], 1

; 3667 : 	pResult.Ipos = iItemPos;

  0a747	8a 45 14	 mov	 al, BYTE PTR _iItemPos$[ebp]
  0a74a	88 45 f4	 mov	 BYTE PTR _pResult$[ebp+4], al

; 3668 : 	int map_num = gObj[iIndex].MapNumber;

  0a74d	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0a750	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0a756	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0a75c	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  0a764	89 55 ec	 mov	 DWORD PTR _map_num$[ebp], edx

; 3669 : 	int type = gObj[iIndex].pInventory[iItemPos].m_Type;

  0a767	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0a76a	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0a770	8b 4d 14	 mov	 ecx, DWORD PTR _iItemPos$[ebp]
  0a773	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0a779	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0a77f	8b 84 02 24 0e
	00 00		 mov	 eax, DWORD PTR [edx+eax+3620]
  0a786	0f bf 4c 08 06	 movsx	 ecx, WORD PTR [eax+ecx+6]
  0a78b	89 4d e8	 mov	 DWORD PTR _type$[ebp], ecx

; 3670 : 	int level = gObj[iIndex].pInventory[iItemPos].m_Level;

  0a78e	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0a791	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0a797	8b 4d 14	 mov	 ecx, DWORD PTR _iItemPos$[ebp]
  0a79a	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0a7a0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0a7a6	8b 84 02 24 0e
	00 00		 mov	 eax, DWORD PTR [edx+eax+3620]
  0a7ad	0f bf 4c 08 08	 movsx	 ecx, WORD PTR [eax+ecx+8]
  0a7b2	89 4d e4	 mov	 DWORD PTR _level$[ebp], ecx

; 3671 : 	float dur = gObj[iIndex].pInventory[iItemPos].m_Durability;

  0a7b5	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0a7b8	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0a7be	8b 4d 14	 mov	 ecx, DWORD PTR _iItemPos$[ebp]
  0a7c1	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0a7c7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0a7cd	8b 84 02 24 0e
	00 00		 mov	 eax, DWORD PTR [edx+eax+3620]
  0a7d4	d9 44 08 24	 fld	 DWORD PTR [eax+ecx+36]
  0a7d8	d9 5d e0	 fstp	 DWORD PTR _dur$[ebp]

; 3672 : 	BOOL ret = gObj[iIndex].pInventory[iItemPos].IsItem();

  0a7db	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0a7de	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0a7e4	8b 4d 14	 mov	 ecx, DWORD PTR _iItemPos$[ebp]
  0a7e7	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0a7ed	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0a7f3	03 8c 02 24 0e
	00 00		 add	 ecx, DWORD PTR [edx+eax+3620]
  0a7fa	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0a7ff	89 45 dc	 mov	 DWORD PTR _ret$[ebp], eax

; 3673 : 	BYTE Option1 = gObj[iIndex].pInventory[iItemPos].m_Option1;

  0a802	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0a805	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0a80b	8b 4d 14	 mov	 ecx, DWORD PTR _iItemPos$[ebp]
  0a80e	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0a814	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0a81a	8b 84 02 24 0e
	00 00		 mov	 eax, DWORD PTR [edx+eax+3620]
  0a821	8a 8c 08 94 00
	00 00		 mov	 cl, BYTE PTR [eax+ecx+148]
  0a828	88 4d db	 mov	 BYTE PTR _Option1$[ebp], cl

; 3674 : 	BYTE Option2 = gObj[iIndex].pInventory[iItemPos].m_Option2;

  0a82b	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0a82e	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0a834	8b 4d 14	 mov	 ecx, DWORD PTR _iItemPos$[ebp]
  0a837	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0a83d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0a843	8b 84 02 24 0e
	00 00		 mov	 eax, DWORD PTR [edx+eax+3620]
  0a84a	8a 8c 08 95 00
	00 00		 mov	 cl, BYTE PTR [eax+ecx+149]
  0a851	88 4d da	 mov	 BYTE PTR _Option2$[ebp], cl

; 3675 : 	BYTE Option3 = gObj[iIndex].pInventory[iItemPos].m_Option3;

  0a854	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0a857	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0a85d	8b 4d 14	 mov	 ecx, DWORD PTR _iItemPos$[ebp]
  0a860	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0a866	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0a86c	8b 84 02 24 0e
	00 00		 mov	 eax, DWORD PTR [edx+eax+3620]
  0a873	8a 8c 08 96 00
	00 00		 mov	 cl, BYTE PTR [eax+ecx+150]
  0a87a	88 4d d9	 mov	 BYTE PTR _Option3$[ebp], cl

; 3676 : 	BYTE NOption = gObj[iIndex].pInventory[iItemPos].m_NewOption;

  0a87d	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0a880	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0a886	8b 4d 14	 mov	 ecx, DWORD PTR _iItemPos$[ebp]
  0a889	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0a88f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0a895	8b 84 02 24 0e
	00 00		 mov	 eax, DWORD PTR [edx+eax+3620]
  0a89c	8a 8c 08 97 00
	00 00		 mov	 cl, BYTE PTR [eax+ecx+151]
  0a8a3	88 4d d8	 mov	 BYTE PTR _NOption$[ebp], cl

; 3677 : 	DWORD s_num = gObj[iIndex].pInventory[iItemPos].m_Number;

  0a8a6	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0a8a9	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0a8af	8b 4d 14	 mov	 ecx, DWORD PTR _iItemPos$[ebp]
  0a8b2	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0a8b8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0a8be	8b 84 02 24 0e
	00 00		 mov	 eax, DWORD PTR [edx+eax+3620]
  0a8c5	8b 0c 01	 mov	 ecx, DWORD PTR [ecx+eax]
  0a8c8	89 4d d4	 mov	 DWORD PTR _s_num$[ebp], ecx

; 3678 : 	BYTE ItemExOption = g_kJewelOfHarmonySystem.GetItemStrengthenOption(&gObj[iIndex].pInventory[iItemPos]);

  0a8cb	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0a8ce	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0a8d4	8b 4d 14	 mov	 ecx, DWORD PTR _iItemPos$[ebp]
  0a8d7	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0a8dd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0a8e3	03 8c 02 24 0e
	00 00		 add	 ecx, DWORD PTR [edx+eax+3620]
  0a8ea	51		 push	 ecx
  0a8eb	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  0a8f0	e8 00 00 00 00	 call	 ?GetItemStrengthenOption@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemStrengthenOption
  0a8f5	88 45 d3	 mov	 BYTE PTR _ItemExOption$[ebp], al

; 3679 : 	BYTE ItemExLevel = g_kJewelOfHarmonySystem.GetItemOptionLevel(&gObj[iIndex].pInventory[iItemPos]);

  0a8f8	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0a8fb	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0a901	8b 4d 14	 mov	 ecx, DWORD PTR _iItemPos$[ebp]
  0a904	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0a90a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0a910	03 8c 02 24 0e
	00 00		 add	 ecx, DWORD PTR [edx+eax+3620]
  0a917	51		 push	 ecx
  0a918	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  0a91d	e8 00 00 00 00	 call	 ?GetItemOptionLevel@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemOptionLevel
  0a922	88 45 d2	 mov	 BYTE PTR _ItemExLevel$[ebp], al

; 3680 : 
; 3681 : 	BYTE NewOption[MAX_EXOPTION_SIZE];
; 3682 : 	::ItemIsBufExOption(NewOption, &gObj[iIndex].pInventory[iItemPos]);

  0a925	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0a928	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0a92e	8b 4d 14	 mov	 ecx, DWORD PTR _iItemPos$[ebp]
  0a931	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0a937	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0a93d	03 8c 02 24 0e
	00 00		 add	 ecx, DWORD PTR [edx+eax+3620]
  0a944	51		 push	 ecx
  0a945	8d 45 c8	 lea	 eax, DWORD PTR _NewOption$[ebp]
  0a948	50		 push	 eax
  0a949	e8 00 00 00 00	 call	 ?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z ; ItemIsBufExOption
  0a94e	83 c4 08	 add	 esp, 8

; 3683 : 	int PetLevel = gObj[iIndex].pInventory[iItemPos].m_PetItem_Level;

  0a951	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0a954	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0a95a	8b 4d 14	 mov	 ecx, DWORD PTR _iItemPos$[ebp]
  0a95d	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0a963	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0a969	8b 84 02 24 0e
	00 00		 mov	 eax, DWORD PTR [edx+eax+3620]
  0a970	8b 8c 08 bc 00
	00 00		 mov	 ecx, DWORD PTR [eax+ecx+188]
  0a977	89 4d c4	 mov	 DWORD PTR _PetLevel$[ebp], ecx

; 3684 : 	int PetExp = gObj[iIndex].pInventory[iItemPos].m_PetItem_Exp;

  0a97a	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0a97d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0a983	8b 4d 14	 mov	 ecx, DWORD PTR _iItemPos$[ebp]
  0a986	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0a98c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0a992	8b 84 02 24 0e
	00 00		 mov	 eax, DWORD PTR [edx+eax+3620]
  0a999	8b 8c 08 c0 00
	00 00		 mov	 ecx, DWORD PTR [eax+ecx+192]
  0a9a0	89 4d c0	 mov	 DWORD PTR _PetExp$[ebp], ecx

; 3685 : 	BYTE SOption = gObj[iIndex].pInventory[iItemPos].m_SetOption;

  0a9a3	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0a9a6	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0a9ac	8b 4d 14	 mov	 ecx, DWORD PTR _iItemPos$[ebp]
  0a9af	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0a9b5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0a9bb	8b 84 02 24 0e
	00 00		 mov	 eax, DWORD PTR [edx+eax+3620]
  0a9c2	8a 8c 08 ae 00
	00 00		 mov	 cl, BYTE PTR [eax+ecx+174]
  0a9c9	88 4d bf	 mov	 BYTE PTR _SOption$[ebp], cl

; 3686 : 	BYTE ItemEffectEx = gObj[iIndex].pInventory[iItemPos].m_ItemOptionEx;

  0a9cc	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0a9cf	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0a9d5	8b 4d 14	 mov	 ecx, DWORD PTR _iItemPos$[ebp]
  0a9d8	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0a9de	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0a9e4	8b 84 02 24 0e
	00 00		 mov	 eax, DWORD PTR [edx+eax+3620]
  0a9eb	8a 8c 08 ca 00
	00 00		 mov	 cl, BYTE PTR [eax+ecx+202]
  0a9f2	88 4d be	 mov	 BYTE PTR _ItemEffectEx$[ebp], cl

; 3687 : 	int item_number = gObj[iIndex].pInventory[iItemPos].m_Number;

  0a9f5	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0a9f8	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0a9fe	8b 4d 14	 mov	 ecx, DWORD PTR _iItemPos$[ebp]
  0aa01	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0aa07	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0aa0d	8b 84 02 24 0e
	00 00		 mov	 eax, DWORD PTR [edx+eax+3620]
  0aa14	8b 0c 01	 mov	 ecx, DWORD PTR [ecx+eax]
  0aa17	89 4d b8	 mov	 DWORD PTR _item_number$[ebp], ecx

; 3688 : 	char szItemName[50] = "Item";

  0aa1a	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_04BGCMBJDA@Item?$AA@
  0aa1f	89 45 84	 mov	 DWORD PTR _szItemName$[ebp], eax
  0aa22	8a 0d 04 00 00
	00		 mov	 cl, BYTE PTR ??_C@_04BGCMBJDA@Item?$AA@+4
  0aa28	88 4d 88	 mov	 BYTE PTR _szItemName$[ebp+4], cl
  0aa2b	6a 2d		 push	 45			; 0000002dH
  0aa2d	6a 00		 push	 0
  0aa2f	8d 45 89	 lea	 eax, DWORD PTR _szItemName$[ebp+5]
  0aa32	50		 push	 eax
  0aa33	e8 00 00 00 00	 call	 _memset
  0aa38	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3689 : 	int aAntiLootIndex = -1; //loc38

  0aa3b	c7 45 80 ff ff
	ff ff		 mov	 DWORD PTR _aAntiLootIndex$[ebp], -1

; 3690 : 
; 3691 : 	//Season 4 add-on
; 3692 : 	BYTE SocketOption[5]; //
; 3693 : 	SocketOption[0] = 0xFF;

  0aa42	c6 85 78 ff ff
	ff ff		 mov	 BYTE PTR _SocketOption$[ebp], 255 ; 000000ffH

; 3694 : 	SocketOption[1] = 0xFF;

  0aa49	c6 85 79 ff ff
	ff ff		 mov	 BYTE PTR _SocketOption$[ebp+1], 255 ; 000000ffH

; 3695 : 	SocketOption[2] = 0xFF;

  0aa50	c6 85 7a ff ff
	ff ff		 mov	 BYTE PTR _SocketOption$[ebp+2], 255 ; 000000ffH

; 3696 : 	SocketOption[3] = 0xFF;

  0aa57	c6 85 7b ff ff
	ff ff		 mov	 BYTE PTR _SocketOption$[ebp+3], 255 ; 000000ffH

; 3697 : 	SocketOption[4] = 0xFF;

  0aa5e	c6 85 7c ff ff
	ff ff		 mov	 BYTE PTR _SocketOption$[ebp+4], 255 ; 000000ffH

; 3698 : 
; 3699 : 	BYTE SocketIndex = 0; //

  0aa65	c6 85 77 ff ff
	ff 00		 mov	 BYTE PTR _SocketIndex$[ebp], 0

; 3700 : 
; 3701 : 	g_SocketOption.GetActiveSocketOption(&gObj[iIndex].pInventory[iItemPos],SocketOption,SocketIndex);

  0aa6c	8d 85 77 ff ff
	ff		 lea	 eax, DWORD PTR _SocketIndex$[ebp]
  0aa72	50		 push	 eax
  0aa73	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _SocketOption$[ebp]
  0aa79	51		 push	 ecx
  0aa7a	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0aa7d	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  0aa83	8b 45 14	 mov	 eax, DWORD PTR _iItemPos$[ebp]
  0aa86	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  0aa8c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0aa92	03 84 11 24 0e
	00 00		 add	 eax, DWORD PTR [ecx+edx+3620]
  0aa99	50		 push	 eax
  0aa9a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_SocketOption@@3VCSocketOption@@A ; g_SocketOption
  0aa9f	e8 00 00 00 00	 call	 ?GetActiveSocketOption@CSocketOption@@QAEXPAVCItem@@PAEAAE@Z ; CSocketOption::GetActiveSocketOption

; 3702 : 
; 3703 : 	if ( MapC[map_num].ItemDrop(type, level, dur, gObj[iIndex].X, gObj[iIndex].Y,Option1, Option2, Option3, NOption, SOption, item_number, aAntiLootIndex, PetLevel, PetExp, ItemEffectEx, SocketOption, SocketIndex) == TRUE )

  0aaa4	0f b6 85 77 ff
	ff ff		 movzx	 eax, BYTE PTR _SocketIndex$[ebp]
  0aaab	50		 push	 eax
  0aaac	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _SocketOption$[ebp]
  0aab2	51		 push	 ecx
  0aab3	0f b6 55 be	 movzx	 edx, BYTE PTR _ItemEffectEx$[ebp]
  0aab7	52		 push	 edx
  0aab8	8b 45 c0	 mov	 eax, DWORD PTR _PetExp$[ebp]
  0aabb	50		 push	 eax
  0aabc	8b 4d c4	 mov	 ecx, DWORD PTR _PetLevel$[ebp]
  0aabf	51		 push	 ecx
  0aac0	8b 55 80	 mov	 edx, DWORD PTR _aAntiLootIndex$[ebp]
  0aac3	52		 push	 edx
  0aac4	8b 45 b8	 mov	 eax, DWORD PTR _item_number$[ebp]
  0aac7	50		 push	 eax
  0aac8	0f b6 4d bf	 movzx	 ecx, BYTE PTR _SOption$[ebp]
  0aacc	51		 push	 ecx
  0aacd	0f b6 55 d8	 movzx	 edx, BYTE PTR _NOption$[ebp]
  0aad1	52		 push	 edx
  0aad2	0f b6 45 d9	 movzx	 eax, BYTE PTR _Option3$[ebp]
  0aad6	50		 push	 eax
  0aad7	0f b6 4d da	 movzx	 ecx, BYTE PTR _Option2$[ebp]
  0aadb	51		 push	 ecx
  0aadc	0f b6 55 db	 movzx	 edx, BYTE PTR _Option1$[ebp]
  0aae0	52		 push	 edx
  0aae1	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0aae4	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0aaea	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0aaf0	0f bf 94 01 46
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+326]
  0aaf8	52		 push	 edx
  0aaf9	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0aafc	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0ab02	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0ab08	0f bf 94 01 44
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+324]
  0ab10	52		 push	 edx
  0ab11	51		 push	 ecx
  0ab12	d9 45 e0	 fld	 DWORD PTR _dur$[ebp]
  0ab15	d9 1c 24	 fstp	 DWORD PTR [esp]
  0ab18	8b 45 e4	 mov	 eax, DWORD PTR _level$[ebp]
  0ab1b	50		 push	 eax
  0ab1c	8b 4d e8	 mov	 ecx, DWORD PTR _type$[ebp]
  0ab1f	51		 push	 ecx
  0ab20	8b 4d ec	 mov	 ecx, DWORD PTR _map_num$[ebp]
  0ab23	69 c9 b8 3d 05
	00		 imul	 ecx, 343480		; 00053db8H
  0ab29	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  0ab2f	e8 00 00 00 00	 call	 ?ItemDrop@MapClass@@QAEHHHMHHEEEEEKHHHEQAEE@Z ; MapClass::ItemDrop
  0ab34	83 f8 01	 cmp	 eax, 1
  0ab37	0f 85 01 01 00
	00		 jne	 $LN6@DropItemDi

; 3704 : 	{
; 3705 : 		::gObjInventoryDeleteItem(iIndex, iItemPos);

  0ab3d	8b 45 14	 mov	 eax, DWORD PTR _iItemPos$[ebp]
  0ab40	50		 push	 eax
  0ab41	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0ab44	51		 push	 ecx
  0ab45	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  0ab4a	83 c4 08	 add	 esp, 8

; 3706 : 		pResult.Result = TRUE;

  0ab4d	c6 45 f3 01	 mov	 BYTE PTR _pResult$[ebp+3], 1

; 3707 : 		LogAddTD(lMsg.Get(MSGGET(1, 223)), gObj[iIndex].AccountID, gObj[iIndex].Name, gObj[iIndex].MapNumber, gObj[iIndex].X, gObj[iIndex].Y, s_num, szItemName, type, level, Option1, Option2, Option3, (int)dur, NewOption[0], NewOption[1], NewOption[2], NewOption[3], NewOption[4], NewOption[5], NewOption[6], SOption, ItemEffectEx>>7, ItemExOption, ItemExLevel);

  0ab51	0f b6 45 d2	 movzx	 eax, BYTE PTR _ItemExLevel$[ebp]
  0ab55	50		 push	 eax
  0ab56	0f b6 4d d3	 movzx	 ecx, BYTE PTR _ItemExOption$[ebp]
  0ab5a	51		 push	 ecx
  0ab5b	0f b6 55 be	 movzx	 edx, BYTE PTR _ItemEffectEx$[ebp]
  0ab5f	c1 fa 07	 sar	 edx, 7
  0ab62	52		 push	 edx
  0ab63	0f b6 45 bf	 movzx	 eax, BYTE PTR _SOption$[ebp]
  0ab67	50		 push	 eax
  0ab68	0f b6 4d ce	 movzx	 ecx, BYTE PTR _NewOption$[ebp+6]
  0ab6c	51		 push	 ecx
  0ab6d	0f b6 55 cd	 movzx	 edx, BYTE PTR _NewOption$[ebp+5]
  0ab71	52		 push	 edx
  0ab72	0f b6 45 cc	 movzx	 eax, BYTE PTR _NewOption$[ebp+4]
  0ab76	50		 push	 eax
  0ab77	0f b6 4d cb	 movzx	 ecx, BYTE PTR _NewOption$[ebp+3]
  0ab7b	51		 push	 ecx
  0ab7c	0f b6 55 ca	 movzx	 edx, BYTE PTR _NewOption$[ebp+2]
  0ab80	52		 push	 edx
  0ab81	0f b6 45 c9	 movzx	 eax, BYTE PTR _NewOption$[ebp+1]
  0ab85	50		 push	 eax
  0ab86	0f b6 4d c8	 movzx	 ecx, BYTE PTR _NewOption$[ebp]
  0ab8a	51		 push	 ecx
  0ab8b	d9 45 e0	 fld	 DWORD PTR _dur$[ebp]
  0ab8e	e8 00 00 00 00	 call	 __ftol2_sse
  0ab93	50		 push	 eax
  0ab94	0f b6 55 d9	 movzx	 edx, BYTE PTR _Option3$[ebp]
  0ab98	52		 push	 edx
  0ab99	0f b6 45 da	 movzx	 eax, BYTE PTR _Option2$[ebp]
  0ab9d	50		 push	 eax
  0ab9e	0f b6 4d db	 movzx	 ecx, BYTE PTR _Option1$[ebp]
  0aba2	51		 push	 ecx
  0aba3	8b 55 e4	 mov	 edx, DWORD PTR _level$[ebp]
  0aba6	52		 push	 edx
  0aba7	8b 45 e8	 mov	 eax, DWORD PTR _type$[ebp]
  0abaa	50		 push	 eax
  0abab	8d 4d 84	 lea	 ecx, DWORD PTR _szItemName$[ebp]
  0abae	51		 push	 ecx
  0abaf	8b 55 d4	 mov	 edx, DWORD PTR _s_num$[ebp]
  0abb2	52		 push	 edx
  0abb3	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0abb6	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0abbc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0abc2	0f bf 94 01 46
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+326]
  0abca	52		 push	 edx
  0abcb	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0abce	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0abd4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0abda	0f bf 94 01 44
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+324]
  0abe2	52		 push	 edx
  0abe3	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0abe6	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0abec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0abf2	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  0abfa	52		 push	 edx
  0abfb	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0abfe	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0ac04	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0ac0a	8d 54 01 77	 lea	 edx, DWORD PTR [ecx+eax+119]
  0ac0e	52		 push	 edx
  0ac0f	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0ac12	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0ac18	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0ac1e	8d 54 01 6c	 lea	 edx, DWORD PTR [ecx+eax+108]
  0ac22	52		 push	 edx
  0ac23	68 df 01 00 00	 push	 479			; 000001dfH
  0ac28	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0ac2d	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0ac32	50		 push	 eax
  0ac33	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0ac39	83 c4 64	 add	 esp, 100		; 00000064H

; 3708 : 	}
; 3709 : 	else

  0ac3c	eb 04		 jmp	 SHORT $LN5@DropItemDi
$LN6@DropItemDi:

; 3710 : 	{
; 3711 : 		pResult.Result = FALSE;

  0ac3e	c6 45 f3 00	 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN5@DropItemDi:

; 3712 : 	}
; 3713 : 
; 3714 : 	DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  0ac42	0f b6 45 f1	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0ac46	50		 push	 eax
  0ac47	8d 4d f0	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0ac4a	51		 push	 ecx
  0ac4b	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0ac4e	52		 push	 edx
  0ac4f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0ac54	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3715 : 
; 3716 : 	if ( pResult.Result == TRUE )

  0ac57	0f b6 45 f3	 movzx	 eax, BYTE PTR _pResult$[ebp+3]
  0ac5b	83 f8 01	 cmp	 eax, 1
  0ac5e	0f 85 12 01 00
	00		 jne	 $LN3@DropItemDi

; 3717 : 	{
; 3718 : 		if ( iItemPos < INVENTORY_BAG_START )

  0ac64	83 7d 14 0c	 cmp	 DWORD PTR _iItemPos$[ebp], 12 ; 0000000cH
  0ac68	0f 8d 08 01 00
	00		 jge	 $LN3@DropItemDi

; 3719 : 		{
; 3720 : 			if ( iItemPos== 10 || iItemPos == 11 )

  0ac6e	83 7d 14 0a	 cmp	 DWORD PTR _iItemPos$[ebp], 10 ; 0000000aH
  0ac72	74 06		 je	 SHORT $LN1@DropItemDi
  0ac74	83 7d 14 0b	 cmp	 DWORD PTR _iItemPos$[ebp], 11 ; 0000000bH
  0ac78	75 0e		 jne	 SHORT $LN2@DropItemDi
$LN1@DropItemDi:

; 3721 : 			{
; 3722 : 				gObjUseSkill.SkillChangeUse(iIndex);

  0ac7a	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0ac7d	50		 push	 eax
  0ac7e	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  0ac83	e8 00 00 00 00	 call	 ?SkillChangeUse@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SkillChangeUse
$LN2@DropItemDi:

; 3723 : 			}
; 3724 : 
; 3725 : 			::gObjMakePreviewCharSet(iIndex);

  0ac88	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0ac8b	50		 push	 eax
  0ac8c	e8 00 00 00 00	 call	 ?gObjMakePreviewCharSet@@YAXH@Z ; gObjMakePreviewCharSet
  0ac91	83 c4 04	 add	 esp, 4

; 3726 : 
; 3727 : 			PMSG_USEREQUIPMENTCHANGED pMsg;
; 3728 : 
; 3729 : 			PHeadSetB((LPBYTE)&pMsg, 0x25, sizeof(PMSG_USEREQUIPMENTCHANGED));

  0ac94	6a 11		 push	 17			; 00000011H
  0ac96	6a 25		 push	 37			; 00000025H
  0ac98	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _pMsg$238127[ebp]
  0ac9e	50		 push	 eax
  0ac9f	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  0aca4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3730 : 			pMsg.NumberH = SET_NUMBERH(iIndex);

  0aca7	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0acaa	c1 e8 08	 shr	 eax, 8
  0acad	88 85 63 ff ff
	ff		 mov	 BYTE PTR _pMsg$238127[ebp+3], al

; 3731 : 			pMsg.NumberL = SET_NUMBERL(iIndex);

  0acb3	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0acb6	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0acbb	88 85 64 ff ff
	ff		 mov	 BYTE PTR _pMsg$238127[ebp+4], al

; 3732 : 			ItemByteConvert(pMsg.ItemInfo, gObj[iIndex].pInventory[iItemPos]);

  0acc1	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0acc4	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0acca	8b 4d 14	 mov	 ecx, DWORD PTR _iItemPos$[ebp]
  0accd	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0acd3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0acd9	8b b4 02 24 0e
	00 00		 mov	 esi, DWORD PTR [edx+eax+3620]
  0ace0	03 f1		 add	 esi, ecx
  0ace2	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  0ace8	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  0aced	8b fc		 mov	 edi, esp
  0acef	f3 a5		 rep movsd
  0acf1	8d 85 65 ff ff
	ff		 lea	 eax, DWORD PTR _pMsg$238127[ebp+5]
  0acf7	50		 push	 eax
  0acf8	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert
  0acfd	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H

; 3733 : 			pMsg.ItemInfo[1] = iItemPos<<4;

  0ad03	8b 45 14	 mov	 eax, DWORD PTR _iItemPos$[ebp]
  0ad06	c1 e0 04	 shl	 eax, 4
  0ad09	88 85 66 ff ff
	ff		 mov	 BYTE PTR _pMsg$238127[ebp+6], al

; 3734 : 			pMsg.ItemInfo[1] |= LevelSmallConvert(iIndex, iItemPos) & 0x0F;

  0ad0f	8b 45 14	 mov	 eax, DWORD PTR _iItemPos$[ebp]
  0ad12	50		 push	 eax
  0ad13	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0ad16	51		 push	 ecx
  0ad17	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEHH@Z ; LevelSmallConvert
  0ad1c	83 c4 08	 add	 esp, 8
  0ad1f	0f b6 d0	 movzx	 edx, al
  0ad22	83 e2 0f	 and	 edx, 15			; 0000000fH
  0ad25	0f b6 85 66 ff
	ff ff		 movzx	 eax, BYTE PTR _pMsg$238127[ebp+6]
  0ad2c	0b c2		 or	 eax, edx
  0ad2e	88 85 66 ff ff
	ff		 mov	 BYTE PTR _pMsg$238127[ebp+6], al

; 3735 : 
; 3736 : 			DataSend(iIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0ad34	0f b6 85 61 ff
	ff ff		 movzx	 eax, BYTE PTR _pMsg$238127[ebp+1]
  0ad3b	50		 push	 eax
  0ad3c	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _pMsg$238127[ebp]
  0ad42	51		 push	 ecx
  0ad43	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0ad46	52		 push	 edx
  0ad47	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0ad4c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3737 : 			MsgSendV2(&gObj[iIndex], (LPBYTE)&pMsg, pMsg.h.size);

  0ad4f	0f b6 85 61 ff
	ff ff		 movzx	 eax, BYTE PTR _pMsg$238127[ebp+1]
  0ad56	50		 push	 eax
  0ad57	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _pMsg$238127[ebp]
  0ad5d	51		 push	 ecx
  0ad5e	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0ad61	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  0ad67	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0ad6d	52		 push	 edx
  0ad6e	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  0ad73	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@DropItemDi:

; 3738 : 		}
; 3739 : 	}
; 3740 : 
; 3741 : 	return (pResult.Result);

  0ad76	0f b6 45 f3	 movzx	 eax, BYTE PTR _pResult$[ebp+3]
$LN8@DropItemDi:

; 3742 : }

  0ad7a	5f		 pop	 edi
  0ad7b	5e		 pop	 esi
  0ad7c	5b		 pop	 ebx
  0ad7d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0ad80	33 cd		 xor	 ecx, ebp
  0ad82	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0ad87	8b e5		 mov	 esp, ebp
  0ad89	5d		 pop	 ebp
  0ad8a	c2 10 00	 ret	 16			; 00000010H
?DropItemDirectly@CBloodCastle@@QAEHHHHH@Z ENDP		; CBloodCastle::DropItemDirectly
_TEXT	ENDS
PUBLIC	?CheckUserHaveUlimateWeapon@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckUserHaveUlimateWeapon
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv67 = -80						; size = 4
_x$238145 = -12						; size = 4
_bRetVal$ = -5						; size = 1
_this$ = -4						; size = 4
_iIndex$ = 8						; size = 4
?CheckUserHaveUlimateWeapon@CBloodCastle@@QAE_NH@Z PROC	; CBloodCastle::CheckUserHaveUlimateWeapon
; _this$ = ecx

; 3745 : {

  0ad90	55		 push	 ebp
  0ad91	8b ec		 mov	 ebp, esp
  0ad93	83 ec 50	 sub	 esp, 80			; 00000050H
  0ad96	53		 push	 ebx
  0ad97	56		 push	 esi
  0ad98	57		 push	 edi
  0ad99	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3746 : 	if ( OBJMAX_RANGE(iIndex ) == FALSE )

  0ad9c	83 7d 08 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  0ada0	7d 09		 jge	 SHORT $LN12@CheckUserH
  0ada2	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  0ada9	eb 0f		 jmp	 SHORT $LN13@CheckUserH
$LN12@CheckUserH:
  0adab	33 c0		 xor	 eax, eax
  0adad	81 7d 08 97 3a
	00 00		 cmp	 DWORD PTR _iIndex$[ebp], 14999 ; 00003a97H
  0adb4	0f 9e c0	 setle	 al
  0adb7	89 45 b0	 mov	 DWORD PTR tv67[ebp], eax
$LN13@CheckUserH:
  0adba	83 7d b0 00	 cmp	 DWORD PTR tv67[ebp], 0
  0adbe	75 07		 jne	 SHORT $LN9@CheckUserH

; 3747 : 	{
; 3748 : 		return false;

  0adc0	32 c0		 xor	 al, al
  0adc2	e9 15 01 00 00	 jmp	 $LN10@CheckUserH
$LN9@CheckUserH:

; 3749 : 	}
; 3750 : 
; 3751 : 	if ( gObj[iIndex].Type != OBJ_USER || gObj[iIndex].Connected <= PLAYER_LOGGED )

  0adc7	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0adca	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0add0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0add6	0f b7 54 01 68	 movzx	 edx, WORD PTR [ecx+eax+104]
  0addb	83 fa 01	 cmp	 edx, 1
  0adde	75 16		 jne	 SHORT $LN7@CheckUserH
  0ade0	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0ade3	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0ade9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0adef	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  0adf4	7f 07		 jg	 SHORT $LN8@CheckUserH
$LN7@CheckUserH:

; 3752 : 	{
; 3753 : 		return false;

  0adf6	32 c0		 xor	 al, al
  0adf8	e9 df 00 00 00	 jmp	 $LN10@CheckUserH
$LN8@CheckUserH:

; 3754 : 	}
; 3755 : 
; 3756 : 	bool bRetVal = false;

  0adfd	c6 45 fb 00	 mov	 BYTE PTR _bRetVal$[ebp], 0

; 3757 : 
; 3758 : 	for ( int x=0;x<INVENTORY_SIZE;x++)

  0ae01	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _x$238145[ebp], 0
  0ae08	eb 09		 jmp	 SHORT $LN6@CheckUserH
$LN5@CheckUserH:
  0ae0a	8b 45 f4	 mov	 eax, DWORD PTR _x$238145[ebp]
  0ae0d	83 c0 01	 add	 eax, 1
  0ae10	89 45 f4	 mov	 DWORD PTR _x$238145[ebp], eax
$LN6@CheckUserH:
  0ae13	81 7d f4 ec 00
	00 00		 cmp	 DWORD PTR _x$238145[ebp], 236 ; 000000ecH
  0ae1a	0f 8d b9 00 00
	00		 jge	 $LN4@CheckUserH

; 3759 : 	{
; 3760 : 		if ( gObj[iIndex].pInventory[x].IsItem() == TRUE )

  0ae20	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0ae23	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0ae29	8b 4d f4	 mov	 ecx, DWORD PTR _x$238145[ebp]
  0ae2c	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0ae32	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0ae38	03 8c 02 24 0e
	00 00		 add	 ecx, DWORD PTR [edx+eax+3620]
  0ae3f	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0ae44	83 f8 01	 cmp	 eax, 1
  0ae47	0f 85 87 00 00
	00		 jne	 $LN3@CheckUserH

; 3761 : 		{
; 3762 : 			if ( gObj[iIndex].pInventory[x].m_Type == ITEMGET(0,19) || gObj[iIndex].pInventory[x].m_Type == ITEMGET(5,10) || gObj[iIndex].pInventory[x].m_Type == ITEMGET(4,18) )

  0ae4d	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0ae50	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0ae56	8b 4d f4	 mov	 ecx, DWORD PTR _x$238145[ebp]
  0ae59	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0ae5f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0ae65	8b 84 02 24 0e
	00 00		 mov	 eax, DWORD PTR [edx+eax+3620]
  0ae6c	0f bf 4c 08 06	 movsx	 ecx, WORD PTR [eax+ecx+6]
  0ae71	83 f9 13	 cmp	 ecx, 19			; 00000013H
  0ae74	74 58		 je	 SHORT $LN1@CheckUserH
  0ae76	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0ae79	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0ae7f	8b 4d f4	 mov	 ecx, DWORD PTR _x$238145[ebp]
  0ae82	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0ae88	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0ae8e	8b 84 02 24 0e
	00 00		 mov	 eax, DWORD PTR [edx+eax+3620]
  0ae95	0f bf 4c 08 06	 movsx	 ecx, WORD PTR [eax+ecx+6]
  0ae9a	81 f9 0a 0a 00
	00		 cmp	 ecx, 2570		; 00000a0aH
  0aea0	74 2c		 je	 SHORT $LN1@CheckUserH
  0aea2	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0aea5	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0aeab	8b 4d f4	 mov	 ecx, DWORD PTR _x$238145[ebp]
  0aeae	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0aeb4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0aeba	8b 84 02 24 0e
	00 00		 mov	 eax, DWORD PTR [edx+eax+3620]
  0aec1	0f bf 4c 08 06	 movsx	 ecx, WORD PTR [eax+ecx+6]
  0aec6	81 f9 12 08 00
	00		 cmp	 ecx, 2066		; 00000812H
  0aecc	75 06		 jne	 SHORT $LN3@CheckUserH
$LN1@CheckUserH:

; 3763 : 			{
; 3764 : 				bRetVal = true;

  0aece	c6 45 fb 01	 mov	 BYTE PTR _bRetVal$[ebp], 1

; 3765 : 				break;

  0aed2	eb 05		 jmp	 SHORT $LN4@CheckUserH
$LN3@CheckUserH:

; 3766 : 			}
; 3767 : 		}
; 3768 : 	}

  0aed4	e9 31 ff ff ff	 jmp	 $LN5@CheckUserH
$LN4@CheckUserH:

; 3769 : 
; 3770 : 	return bRetVal;

  0aed9	8a 45 fb	 mov	 al, BYTE PTR _bRetVal$[ebp]
$LN10@CheckUserH:

; 3771 : }

  0aedc	5f		 pop	 edi
  0aedd	5e		 pop	 esi
  0aede	5b		 pop	 ebx
  0aedf	8b e5		 mov	 esp, ebp
  0aee1	5d		 pop	 ebp
  0aee2	c2 04 00	 ret	 4
?CheckUserHaveUlimateWeapon@CBloodCastle@@QAE_NH@Z ENDP	; CBloodCastle::CheckUserHaveUlimateWeapon
; Function compile flags: /Odtp /ZI
tv67 = -72						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?CheckWinnerExist@CBloodCastle@@QAE_NH@Z PROC		; CBloodCastle::CheckWinnerExist
; _this$ = ecx

; 3774 : {

  0aef0	55		 push	 ebp
  0aef1	8b ec		 mov	 ebp, esp
  0aef3	83 ec 48	 sub	 esp, 72			; 00000048H
  0aef6	53		 push	 ebx
  0aef7	56		 push	 esi
  0aef8	57		 push	 edi
  0aef9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3775 : 	if ( !BC_BRIDGE_RANGE(iBridgeIndex))

  0aefc	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  0af00	7d 09		 jge	 SHORT $LN5@CheckWinne
  0af02	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  0af09	eb 0c		 jmp	 SHORT $LN6@CheckWinne
$LN5@CheckWinne:
  0af0b	33 c0		 xor	 eax, eax
  0af0d	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  0af11	0f 9e c0	 setle	 al
  0af14	89 45 b8	 mov	 DWORD PTR tv67[ebp], eax
$LN6@CheckWinne:
  0af17	83 7d b8 00	 cmp	 DWORD PTR tv67[ebp], 0
  0af1b	75 04		 jne	 SHORT $LN2@CheckWinne

; 3776 : 		return false;

  0af1d	32 c0		 xor	 al, al
  0af1f	eb 1c		 jmp	 SHORT $LN3@CheckWinne
$LN2@CheckWinne:

; 3777 : 
; 3778 : 	if ( this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX != -1 )

  0af21	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0af24	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0af2a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0af2d	83 bc 01 58 04
	00 00 ff	 cmp	 DWORD PTR [ecx+eax+1112], -1
  0af35	74 04		 je	 SHORT $LN1@CheckWinne

; 3779 : 		return true;

  0af37	b0 01		 mov	 al, 1
  0af39	eb 02		 jmp	 SHORT $LN3@CheckWinne
$LN1@CheckWinne:

; 3780 : 
; 3781 : 	return false;

  0af3b	32 c0		 xor	 al, al
$LN3@CheckWinne:

; 3782 : }

  0af3d	5f		 pop	 edi
  0af3e	5e		 pop	 esi
  0af3f	5b		 pop	 ebx
  0af40	8b e5		 mov	 esp, ebp
  0af42	5d		 pop	 ebp
  0af43	c2 04 00	 ret	 4
?CheckWinnerExist@CBloodCastle@@QAE_NH@Z ENDP		; CBloodCastle::CheckWinnerExist
_TEXT	ENDS
PUBLIC	??_C@_0JA@CMOHDFEJ@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@ ; `string'
PUBLIC	??_C@_0JC@KJKEDLHF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@ ; `string'
PUBLIC	??_C@_0HO@GOGOOKAA@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@ ; `string'
PUBLIC	??_C@_0HC@NFIOOIHG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@ ; `string'
PUBLIC	??_C@_0HA@BEDGBNCH@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@ ; `string'
;	COMDAT ??_C@_0JA@CMOHDFEJ@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@
CONST	SEGMENT
??_C@_0JA@CMOHDFEJ@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@ DB '['
	DB	'Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - !CHECK_'
	DB	'BLOODCASTLE(gObj[m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_US'
	DB	'ER_INDEX].MapNumber)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0JC@KJKEDLHF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@
CONST	SEGMENT
??_C@_0JC@KJKEDLHF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@ DB '['
	DB	'Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - (gObj[m'
	DB	'_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].m_cBlood'
	DB	'CastleIndex == -1) ...', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0HO@GOGOOKAA@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@
CONST	SEGMENT
??_C@_0HO@GOGOOKAA@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@ DB '['
	DB	'Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - !gObjIs'
	DB	'Connected(m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDE'
	DB	'X)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0HC@NFIOOIHG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@
CONST	SEGMENT
??_C@_0HC@NFIOOIHG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@ DB '['
	DB	'Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - m_Bridg'
	DB	'eData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX == -1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HA@BEDGBNCH@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@
CONST	SEGMENT
??_C@_0HA@BEDGBNCH@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@ DB '['
	DB	'Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - !CHECK_'
	DB	'LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT)', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv180 = -76						; size = 4
tv181 = -72						; size = 4
tv67 = -72						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?CheckWinnerValid@CBloodCastle@@QAE_NH@Z PROC		; CBloodCastle::CheckWinnerValid
; _this$ = ecx

; 3785 : {

  0af50	55		 push	 ebp
  0af51	8b ec		 mov	 ebp, esp
  0af53	83 ec 4c	 sub	 esp, 76			; 0000004cH
  0af56	53		 push	 ebx
  0af57	56		 push	 esi
  0af58	57		 push	 edi
  0af59	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3786 : 	if ( !BC_BRIDGE_RANGE(iBridgeIndex))

  0af5c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  0af60	7d 09		 jge	 SHORT $LN9@CheckWinne@2
  0af62	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  0af69	eb 0c		 jmp	 SHORT $LN10@CheckWinne@2
$LN9@CheckWinne@2:
  0af6b	33 c0		 xor	 eax, eax
  0af6d	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  0af71	0f 9e c0	 setle	 al
  0af74	89 45 b8	 mov	 DWORD PTR tv67[ebp], eax
$LN10@CheckWinne@2:
  0af77	83 7d b8 00	 cmp	 DWORD PTR tv67[ebp], 0
  0af7b	75 1c		 jne	 SHORT $LN6@CheckWinne@2

; 3787 : 	{
; 3788 : 		LogAddTD("[Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - !CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT)", iBridgeIndex+1);

  0af7d	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0af80	83 c0 01	 add	 eax, 1
  0af83	50		 push	 eax
  0af84	68 00 00 00 00	 push	 OFFSET ??_C@_0HA@BEDGBNCH@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@
  0af89	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0af8f	83 c4 08	 add	 esp, 8

; 3789 : 		return false;

  0af92	32 c0		 xor	 al, al
  0af94	e9 cd 01 00 00	 jmp	 $LN7@CheckWinne@2
$LN6@CheckWinne@2:

; 3790 : 	}
; 3791 : 
; 3792 : 	if ( this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX == -1 )

  0af99	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0af9c	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0afa2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0afa5	83 bc 01 58 04
	00 00 ff	 cmp	 DWORD PTR [ecx+eax+1112], -1
  0afad	75 1c		 jne	 SHORT $LN5@CheckWinne@2

; 3793 : 	{
; 3794 : 		LogAddTD("[Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX == -1", iBridgeIndex+1);

  0afaf	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0afb2	83 c0 01	 add	 eax, 1
  0afb5	50		 push	 eax
  0afb6	68 00 00 00 00	 push	 OFFSET ??_C@_0HC@NFIOOIHG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@
  0afbb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0afc1	83 c4 08	 add	 esp, 8

; 3795 : 		return false;

  0afc4	32 c0		 xor	 al, al
  0afc6	e9 9b 01 00 00	 jmp	 $LN7@CheckWinne@2
$LN5@CheckWinne@2:

; 3796 : 	}
; 3797 : 
; 3798 : 	if ( !gObjIsConnected(this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX) )

  0afcb	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0afce	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0afd4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0afd7	8b 94 01 58 04
	00 00		 mov	 edx, DWORD PTR [ecx+eax+1112]
  0afde	52		 push	 edx
  0afdf	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0afe4	83 c4 04	 add	 esp, 4
  0afe7	85 c0		 test	 eax, eax
  0afe9	75 1c		 jne	 SHORT $LN4@CheckWinne@2

; 3799 : 	{
; 3800 : 		LogAddTD("[Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - !gObjIsConnected(m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX)", iBridgeIndex+1);

  0afeb	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0afee	83 c0 01	 add	 eax, 1
  0aff1	50		 push	 eax
  0aff2	68 00 00 00 00	 push	 OFFSET ??_C@_0HO@GOGOOKAA@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@
  0aff7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0affd	83 c4 08	 add	 esp, 8

; 3801 : 		return false;

  0b000	32 c0		 xor	 al, al
  0b002	e9 5f 01 00 00	 jmp	 $LN7@CheckWinne@2
$LN4@CheckWinne@2:

; 3802 : 	}
; 3803 : 
; 3804 : 	if ( gObj[this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].m_cBloodCastleIndex == -1 || gObj[this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].m_cBloodCastleSubIndex == -1 || gObj[this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].m_cBloodCastleIndex != iBridgeIndex )

  0b007	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0b00a	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0b010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0b013	8b 94 01 58 04
	00 00		 mov	 edx, DWORD PTR [ecx+eax+1112]
  0b01a	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  0b020	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0b025	0f be 8c 10 9e
	0e 00 00	 movsx	 ecx, BYTE PTR [eax+edx+3742]
  0b02d	83 f9 ff	 cmp	 ecx, -1
  0b030	74 56		 je	 SHORT $LN2@CheckWinne@2
  0b032	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0b035	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0b03b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0b03e	8b 94 01 58 04
	00 00		 mov	 edx, DWORD PTR [ecx+eax+1112]
  0b045	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  0b04b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0b050	0f be 8c 10 9f
	0e 00 00	 movsx	 ecx, BYTE PTR [eax+edx+3743]
  0b058	83 f9 ff	 cmp	 ecx, -1
  0b05b	74 2b		 je	 SHORT $LN2@CheckWinne@2
  0b05d	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0b060	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0b066	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0b069	8b 94 01 58 04
	00 00		 mov	 edx, DWORD PTR [ecx+eax+1112]
  0b070	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  0b076	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0b07b	0f be 8c 10 9e
	0e 00 00	 movsx	 ecx, BYTE PTR [eax+edx+3742]
  0b083	3b 4d 08	 cmp	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  0b086	74 1c		 je	 SHORT $LN3@CheckWinne@2
$LN2@CheckWinne@2:

; 3805 : 	{
; 3806 : 		LogAddTD("[Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - (gObj[m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].m_cBloodCastleIndex == -1) ...", iBridgeIndex+1);

  0b088	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0b08b	83 c0 01	 add	 eax, 1
  0b08e	50		 push	 eax
  0b08f	68 00 00 00 00	 push	 OFFSET ??_C@_0JC@KJKEDLHF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@
  0b094	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0b09a	83 c4 08	 add	 esp, 8

; 3807 : 		return false;

  0b09d	32 c0		 xor	 al, al
  0b09f	e9 c2 00 00 00	 jmp	 $LN7@CheckWinne@2
$LN3@CheckWinne@2:

; 3808 : 	}
; 3809 : 
; 3810 : 	if ( !BC_MAP_RANGE(gObj[this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].MapNumber) )

  0b0a4	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0b0a7	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0b0ad	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0b0b0	8b 94 01 58 04
	00 00		 mov	 edx, DWORD PTR [ecx+eax+1112]
  0b0b7	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  0b0bd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0b0c2	0f b6 8c 10 49
	01 00 00	 movzx	 ecx, BYTE PTR [eax+edx+329]
  0b0ca	83 f9 34	 cmp	 ecx, 52			; 00000034H
  0b0cd	75 09		 jne	 SHORT $LN13@CheckWinne@2
  0b0cf	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv181[ebp], 1
  0b0d6	eb 6d		 jmp	 SHORT $LN14@CheckWinne@2
$LN13@CheckWinne@2:
  0b0d8	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  0b0db	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  0b0e1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0b0e4	8b 8c 10 58 04
	00 00		 mov	 ecx, DWORD PTR [eax+edx+1112]
  0b0eb	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0b0f1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0b0f7	0f b6 84 0a 49
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+329]
  0b0ff	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  0b102	7d 09		 jge	 SHORT $LN11@CheckWinne@2
  0b104	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv180[ebp], 0
  0b10b	eb 32		 jmp	 SHORT $LN12@CheckWinne@2
$LN11@CheckWinne@2:
  0b10d	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  0b110	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  0b116	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0b119	8b 84 0a 58 04
	00 00		 mov	 eax, DWORD PTR [edx+ecx+1112]
  0b120	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0b126	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0b12c	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  0b134	33 c0		 xor	 eax, eax
  0b136	83 fa 11	 cmp	 edx, 17			; 00000011H
  0b139	0f 9e c0	 setle	 al
  0b13c	89 45 b4	 mov	 DWORD PTR tv180[ebp], eax
$LN12@CheckWinne@2:
  0b13f	8b 4d b4	 mov	 ecx, DWORD PTR tv180[ebp]
  0b142	89 4d b8	 mov	 DWORD PTR tv181[ebp], ecx
$LN14@CheckWinne@2:
  0b145	83 7d b8 00	 cmp	 DWORD PTR tv181[ebp], 0
  0b149	75 19		 jne	 SHORT $LN1@CheckWinne@2

; 3811 : 	{
; 3812 : 		LogAddTD("[Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - !CHECK_BLOODCASTLE(gObj[m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].MapNumber)", iBridgeIndex+1);

  0b14b	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0b14e	83 c0 01	 add	 eax, 1
  0b151	50		 push	 eax
  0b152	68 00 00 00 00	 push	 OFFSET ??_C@_0JA@CMOHDFEJ@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@
  0b157	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0b15d	83 c4 08	 add	 esp, 8

; 3813 : 		return false;

  0b160	32 c0		 xor	 al, al
  0b162	eb 02		 jmp	 SHORT $LN7@CheckWinne@2
$LN1@CheckWinne@2:

; 3814 : 	}
; 3815 : 
; 3816 : 	return true;

  0b164	b0 01		 mov	 al, 1
$LN7@CheckWinne@2:

; 3817 : }

  0b166	5f		 pop	 edi
  0b167	5e		 pop	 esi
  0b168	5b		 pop	 ebx
  0b169	8b e5		 mov	 esp, ebp
  0b16b	5d		 pop	 ebp
  0b16c	c2 04 00	 ret	 4
?CheckWinnerValid@CBloodCastle@@QAE_NH@Z ENDP		; CBloodCastle::CheckWinnerValid
_TEXT	ENDS
PUBLIC	?CheckUserWinnerParty@CBloodCastle@@QAE_NHH@Z	; CBloodCastle::CheckUserWinnerParty
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv92 = -80						; size = 4
tv67 = -80						; size = 4
_iPartyIndex2$ = -12					; size = 4
_iPartyIndex1$ = -8					; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
_iIndex$ = 12						; size = 4
?CheckUserWinnerParty@CBloodCastle@@QAE_NHH@Z PROC	; CBloodCastle::CheckUserWinnerParty
; _this$ = ecx

; 3820 : {

  0b170	55		 push	 ebp
  0b171	8b ec		 mov	 ebp, esp
  0b173	83 ec 50	 sub	 esp, 80			; 00000050H
  0b176	53		 push	 ebx
  0b177	56		 push	 esi
  0b178	57		 push	 edi
  0b179	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3821 : 	if ( !BC_BRIDGE_RANGE(iBridgeIndex))

  0b17c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  0b180	7d 09		 jge	 SHORT $LN7@CheckUserW
  0b182	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  0b189	eb 0c		 jmp	 SHORT $LN8@CheckUserW
$LN7@CheckUserW:
  0b18b	33 c0		 xor	 eax, eax
  0b18d	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  0b191	0f 9e c0	 setle	 al
  0b194	89 45 b0	 mov	 DWORD PTR tv67[ebp], eax
$LN8@CheckUserW:
  0b197	83 7d b0 00	 cmp	 DWORD PTR tv67[ebp], 0
  0b19b	75 07		 jne	 SHORT $LN4@CheckUserW

; 3822 : 		return false;

  0b19d	32 c0		 xor	 al, al
  0b19f	e9 ae 00 00 00	 jmp	 $LN5@CheckUserW
$LN4@CheckUserW:

; 3823 : 
; 3824 : 	if ( gObjIsConnected(this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX) == FALSE )

  0b1a4	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0b1a7	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0b1ad	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0b1b0	8b 94 01 58 04
	00 00		 mov	 edx, DWORD PTR [ecx+eax+1112]
  0b1b7	52		 push	 edx
  0b1b8	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0b1bd	83 c4 04	 add	 esp, 4
  0b1c0	85 c0		 test	 eax, eax
  0b1c2	75 07		 jne	 SHORT $LN3@CheckUserW

; 3825 : 		return false;

  0b1c4	32 c0		 xor	 al, al
  0b1c6	e9 87 00 00 00	 jmp	 $LN5@CheckUserW
$LN3@CheckUserW:

; 3826 : 
; 3827 : 	if ( gObjIsConnected(iIndex) == FALSE )

  0b1cb	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0b1ce	50		 push	 eax
  0b1cf	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0b1d4	83 c4 04	 add	 esp, 4
  0b1d7	85 c0		 test	 eax, eax
  0b1d9	75 04		 jne	 SHORT $LN2@CheckUserW

; 3828 : 		return false;

  0b1db	32 c0		 xor	 al, al
  0b1dd	eb 73		 jmp	 SHORT $LN5@CheckUserW
$LN2@CheckUserW:

; 3829 : 
; 3830 : 	int iPartyIndex1 = gObj[iIndex].PartyNumber;

  0b1df	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0b1e2	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0b1e8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0b1ee	8b 94 01 2c 04
	00 00		 mov	 edx, DWORD PTR [ecx+eax+1068]
  0b1f5	89 55 f8	 mov	 DWORD PTR _iPartyIndex1$[ebp], edx

; 3831 : 	int iPartyIndex2 = gObj[this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].PartyNumber;

  0b1f8	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0b1fb	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0b201	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0b204	8b 94 01 58 04
	00 00		 mov	 edx, DWORD PTR [ecx+eax+1112]
  0b20b	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  0b211	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0b216	8b 8c 10 2c 04
	00 00		 mov	 ecx, DWORD PTR [eax+edx+1068]
  0b21d	89 4d f4	 mov	 DWORD PTR _iPartyIndex2$[ebp], ecx

; 3832 : 
; 3833 : 	if ( OBJMAX_RANGE(iPartyIndex1) != FALSE && iPartyIndex1 == iPartyIndex2 )

  0b220	83 7d f8 00	 cmp	 DWORD PTR _iPartyIndex1$[ebp], 0
  0b224	7d 09		 jge	 SHORT $LN9@CheckUserW
  0b226	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv92[ebp], 0
  0b22d	eb 0f		 jmp	 SHORT $LN10@CheckUserW
$LN9@CheckUserW:
  0b22f	33 c0		 xor	 eax, eax
  0b231	81 7d f8 97 3a
	00 00		 cmp	 DWORD PTR _iPartyIndex1$[ebp], 14999 ; 00003a97H
  0b238	0f 9e c0	 setle	 al
  0b23b	89 45 b0	 mov	 DWORD PTR tv92[ebp], eax
$LN10@CheckUserW:
  0b23e	83 7d b0 00	 cmp	 DWORD PTR tv92[ebp], 0
  0b242	74 0c		 je	 SHORT $LN1@CheckUserW
  0b244	8b 45 f8	 mov	 eax, DWORD PTR _iPartyIndex1$[ebp]
  0b247	3b 45 f4	 cmp	 eax, DWORD PTR _iPartyIndex2$[ebp]
  0b24a	75 04		 jne	 SHORT $LN1@CheckUserW

; 3834 : 		return true;

  0b24c	b0 01		 mov	 al, 1
  0b24e	eb 02		 jmp	 SHORT $LN5@CheckUserW
$LN1@CheckUserW:

; 3835 : 
; 3836 : 	return false;

  0b250	32 c0		 xor	 al, al
$LN5@CheckUserW:

; 3837 : }

  0b252	5f		 pop	 edi
  0b253	5e		 pop	 esi
  0b254	5b		 pop	 ebx
  0b255	8b e5		 mov	 esp, ebp
  0b257	5d		 pop	 ebp
  0b258	c2 08 00	 ret	 8
?CheckUserWinnerParty@CBloodCastle@@QAE_NHH@Z ENDP	; CBloodCastle::CheckUserWinnerParty
_TEXT	ENDS
PUBLIC	?CheckPartyExist@CBloodCastle@@QAE_NH@Z		; CBloodCastle::CheckPartyExist
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv133 = -88						; size = 4
tv147 = -84						; size = 4
tv134 = -84						; size = 4
tv73 = -84						; size = 4
_iPartyUserIndex$238192 = -16				; size = 4
_iUserIndex$ = -12					; size = 4
_iPartyIndex$ = -8					; size = 4
_this$ = -4						; size = 4
_iIndex$ = 8						; size = 4
?CheckPartyExist@CBloodCastle@@QAE_NH@Z PROC		; CBloodCastle::CheckPartyExist
; _this$ = ecx

; 3840 : {

  0b260	55		 push	 ebp
  0b261	8b ec		 mov	 ebp, esp
  0b263	83 ec 58	 sub	 esp, 88			; 00000058H
  0b266	53		 push	 ebx
  0b267	56		 push	 esi
  0b268	57		 push	 edi
  0b269	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3841 : 	if ( !gObjIsConnected(iIndex))

  0b26c	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0b26f	50		 push	 eax
  0b270	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0b275	83 c4 04	 add	 esp, 4
  0b278	85 c0		 test	 eax, eax
  0b27a	75 07		 jne	 SHORT $LN9@CheckParty

; 3842 : 		return false;

  0b27c	32 c0		 xor	 al, al
  0b27e	e9 8e 01 00 00	 jmp	 $LN10@CheckParty
$LN9@CheckParty:

; 3843 : 
; 3844 : 	int iPartyIndex = gObj[iIndex].PartyNumber;

  0b283	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0b286	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0b28c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0b292	8b 94 01 2c 04
	00 00		 mov	 edx, DWORD PTR [ecx+eax+1068]
  0b299	89 55 f8	 mov	 DWORD PTR _iPartyIndex$[ebp], edx

; 3845 : 	int iUserIndex;
; 3846 : 
; 3847 : 	if ( !OBJMAX_RANGE(iPartyIndex))

  0b29c	83 7d f8 00	 cmp	 DWORD PTR _iPartyIndex$[ebp], 0
  0b2a0	7d 09		 jge	 SHORT $LN12@CheckParty
  0b2a2	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  0b2a9	eb 0f		 jmp	 SHORT $LN13@CheckParty
$LN12@CheckParty:
  0b2ab	33 c0		 xor	 eax, eax
  0b2ad	81 7d f8 97 3a
	00 00		 cmp	 DWORD PTR _iPartyIndex$[ebp], 14999 ; 00003a97H
  0b2b4	0f 9e c0	 setle	 al
  0b2b7	89 45 ac	 mov	 DWORD PTR tv73[ebp], eax
$LN13@CheckParty:
  0b2ba	83 7d ac 00	 cmp	 DWORD PTR tv73[ebp], 0
  0b2be	75 07		 jne	 SHORT $LN8@CheckParty

; 3848 : 		return false;

  0b2c0	32 c0		 xor	 al, al
  0b2c2	e9 4a 01 00 00	 jmp	 $LN10@CheckParty
$LN8@CheckParty:

; 3849 : 
; 3850 : 	for ( int iPartyUserIndex =0;iPartyUserIndex<MAX_USER_IN_PARTY;iPartyUserIndex++)

  0b2c7	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _iPartyUserIndex$238192[ebp], 0
  0b2ce	eb 09		 jmp	 SHORT $LN7@CheckParty
$LN6@CheckParty:
  0b2d0	8b 45 f0	 mov	 eax, DWORD PTR _iPartyUserIndex$238192[ebp]
  0b2d3	83 c0 01	 add	 eax, 1
  0b2d6	89 45 f0	 mov	 DWORD PTR _iPartyUserIndex$238192[ebp], eax
$LN7@CheckParty:
  0b2d9	83 7d f0 0a	 cmp	 DWORD PTR _iPartyUserIndex$238192[ebp], 10 ; 0000000aH
  0b2dd	0f 8d 2c 01 00
	00		 jge	 $LN5@CheckParty

; 3851 : 	{
; 3852 : 		iUserIndex = gParty.m_PartyS[iPartyIndex].Number[iPartyUserIndex];

  0b2e3	8b 45 f8	 mov	 eax, DWORD PTR _iPartyIndex$[ebp]
  0b2e6	6b c0 6c	 imul	 eax, 108		; 0000006cH
  0b2e9	8b 4d f0	 mov	 ecx, DWORD PTR _iPartyUserIndex$238192[ebp]
  0b2ec	8b 94 88 0c 00
	00 00		 mov	 edx, DWORD PTR ?gParty@@3VPartyClass@@A[eax+ecx*4+12]
  0b2f3	89 55 f4	 mov	 DWORD PTR _iUserIndex$[ebp], edx

; 3853 : 
; 3854 : 		if ( gObjIsConnected(iUserIndex))

  0b2f6	8b 45 f4	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  0b2f9	50		 push	 eax
  0b2fa	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0b2ff	83 c4 04	 add	 esp, 4
  0b302	85 c0		 test	 eax, eax
  0b304	0f 84 00 01 00
	00		 je	 $LN4@CheckParty

; 3855 : 		{
; 3856 : 			if ( BC_MAP_RANGE(gObj[iUserIndex].MapNumber) && BC_BRIDGE_RANGE(gObj[iUserIndex].m_cBloodCastleIndex) )

  0b30a	8b 45 f4	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  0b30d	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0b313	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0b319	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  0b321	83 fa 34	 cmp	 edx, 52			; 00000034H
  0b324	75 09		 jne	 SHORT $LN16@CheckParty
  0b326	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv134[ebp], 1
  0b32d	eb 4d		 jmp	 SHORT $LN17@CheckParty
$LN16@CheckParty:
  0b32f	8b 45 f4	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  0b332	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0b338	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0b33e	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  0b346	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  0b349	7d 09		 jge	 SHORT $LN14@CheckParty
  0b34b	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv133[ebp], 0
  0b352	eb 22		 jmp	 SHORT $LN15@CheckParty
$LN14@CheckParty:
  0b354	8b 45 f4	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  0b357	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0b35d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0b363	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  0b36b	33 c0		 xor	 eax, eax
  0b36d	83 fa 11	 cmp	 edx, 17			; 00000011H
  0b370	0f 9e c0	 setle	 al
  0b373	89 45 a8	 mov	 DWORD PTR tv133[ebp], eax
$LN15@CheckParty:
  0b376	8b 4d a8	 mov	 ecx, DWORD PTR tv133[ebp]
  0b379	89 4d ac	 mov	 DWORD PTR tv134[ebp], ecx
$LN17@CheckParty:
  0b37c	83 7d ac 00	 cmp	 DWORD PTR tv134[ebp], 0
  0b380	0f 84 84 00 00
	00		 je	 $LN4@CheckParty
  0b386	8b 45 f4	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  0b389	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0b38f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0b395	0f be 94 01 9e
	0e 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3742]
  0b39d	85 d2		 test	 edx, edx
  0b39f	7d 09		 jge	 SHORT $LN18@CheckParty
  0b3a1	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv147[ebp], 0
  0b3a8	eb 22		 jmp	 SHORT $LN19@CheckParty
$LN18@CheckParty:
  0b3aa	8b 45 f4	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  0b3ad	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0b3b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0b3b9	0f be 94 01 9e
	0e 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3742]
  0b3c1	33 c0		 xor	 eax, eax
  0b3c3	83 fa 07	 cmp	 edx, 7
  0b3c6	0f 9e c0	 setle	 al
  0b3c9	89 45 ac	 mov	 DWORD PTR tv147[ebp], eax
$LN19@CheckParty:
  0b3cc	83 7d ac 00	 cmp	 DWORD PTR tv147[ebp], 0
  0b3d0	74 38		 je	 SHORT $LN4@CheckParty

; 3857 : 			{
; 3858 : 				if ( gObj[iUserIndex].Live == 1 )

  0b3d2	8b 45 f4	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  0b3d5	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0b3db	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0b3e1	0f b6 54 01 6a	 movzx	 edx, BYTE PTR [ecx+eax+106]
  0b3e6	83 fa 01	 cmp	 edx, 1
  0b3e9	75 1f		 jne	 SHORT $LN4@CheckParty

; 3859 : 				{
; 3860 : 					if ( gObj[iUserIndex].m_bBloodCastleComplete == false )

  0b3eb	8b 45 f4	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  0b3ee	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0b3f4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0b3fa	0f b6 94 01 a4
	0e 00 00	 movzx	 edx, BYTE PTR [ecx+eax+3748]
  0b402	85 d2		 test	 edx, edx
  0b404	75 04		 jne	 SHORT $LN4@CheckParty

; 3861 : 					{
; 3862 : 						return true;

  0b406	b0 01		 mov	 al, 1
  0b408	eb 07		 jmp	 SHORT $LN10@CheckParty
$LN4@CheckParty:

; 3863 : 					}
; 3864 : 				}
; 3865 : 			}
; 3866 : 		}
; 3867 : 	}

  0b40a	e9 c1 fe ff ff	 jmp	 $LN6@CheckParty
$LN5@CheckParty:

; 3868 : 
; 3869 : 	return false;

  0b40f	32 c0		 xor	 al, al
$LN10@CheckParty:

; 3870 : }

  0b411	5f		 pop	 edi
  0b412	5e		 pop	 esi
  0b413	5b		 pop	 ebx
  0b414	8b e5		 mov	 esp, ebp
  0b416	5d		 pop	 ebp
  0b417	c2 04 00	 ret	 4
?CheckPartyExist@CBloodCastle@@QAE_NH@Z ENDP		; CBloodCastle::CheckPartyExist
; Function compile flags: /Odtp /ZI
tv146 = -88						; size = 4
tv160 = -84						; size = 4
tv147 = -84						; size = 4
tv86 = -84						; size = 4
tv67 = -84						; size = 4
_iPartyUserIndex$238209 = -16				; size = 4
_iUserIndex$ = -12					; size = 4
_iPartyIndex$ = -8					; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?CheckWinnerPartyComplete@CBloodCastle@@QAE_NH@Z PROC	; CBloodCastle::CheckWinnerPartyComplete
; _this$ = ecx

; 3873 : {

  0b420	55		 push	 ebp
  0b421	8b ec		 mov	 ebp, esp
  0b423	83 ec 58	 sub	 esp, 88			; 00000058H
  0b426	53		 push	 ebx
  0b427	56		 push	 esi
  0b428	57		 push	 edi
  0b429	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3874 : 	if ( !BC_BRIDGE_RANGE(iBridgeIndex) )

  0b42c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  0b430	7d 09		 jge	 SHORT $LN13@CheckWinne@3
  0b432	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  0b439	eb 0c		 jmp	 SHORT $LN14@CheckWinne@3
$LN13@CheckWinne@3:
  0b43b	33 c0		 xor	 eax, eax
  0b43d	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  0b441	0f 9e c0	 setle	 al
  0b444	89 45 ac	 mov	 DWORD PTR tv67[ebp], eax
$LN14@CheckWinne@3:
  0b447	83 7d ac 00	 cmp	 DWORD PTR tv67[ebp], 0
  0b44b	75 07		 jne	 SHORT $LN10@CheckWinne@3

; 3875 : 		return false;

  0b44d	32 c0		 xor	 al, al
  0b44f	e9 c4 01 00 00	 jmp	 $LN11@CheckWinne@3
$LN10@CheckWinne@3:

; 3876 : 
; 3877 : 	if ( !gObjIsConnected(this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX))

  0b454	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0b457	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0b45d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0b460	8b 94 01 58 04
	00 00		 mov	 edx, DWORD PTR [ecx+eax+1112]
  0b467	52		 push	 edx
  0b468	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0b46d	83 c4 04	 add	 esp, 4
  0b470	85 c0		 test	 eax, eax
  0b472	75 07		 jne	 SHORT $LN9@CheckWinne@3

; 3878 : 		return false;

  0b474	32 c0		 xor	 al, al
  0b476	e9 9d 01 00 00	 jmp	 $LN11@CheckWinne@3
$LN9@CheckWinne@3:

; 3879 : 
; 3880 : 	int iPartyIndex = gObj[this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].PartyNumber;

  0b47b	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0b47e	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0b484	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0b487	8b 94 01 58 04
	00 00		 mov	 edx, DWORD PTR [ecx+eax+1112]
  0b48e	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  0b494	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0b499	8b 8c 10 2c 04
	00 00		 mov	 ecx, DWORD PTR [eax+edx+1068]
  0b4a0	89 4d f8	 mov	 DWORD PTR _iPartyIndex$[ebp], ecx

; 3881 : 	int iUserIndex;
; 3882 : 
; 3883 : 	if ( !OBJMAX_RANGE(iPartyIndex))

  0b4a3	83 7d f8 00	 cmp	 DWORD PTR _iPartyIndex$[ebp], 0
  0b4a7	7d 09		 jge	 SHORT $LN15@CheckWinne@3
  0b4a9	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv86[ebp], 0
  0b4b0	eb 0f		 jmp	 SHORT $LN16@CheckWinne@3
$LN15@CheckWinne@3:
  0b4b2	33 c0		 xor	 eax, eax
  0b4b4	81 7d f8 97 3a
	00 00		 cmp	 DWORD PTR _iPartyIndex$[ebp], 14999 ; 00003a97H
  0b4bb	0f 9e c0	 setle	 al
  0b4be	89 45 ac	 mov	 DWORD PTR tv86[ebp], eax
$LN16@CheckWinne@3:
  0b4c1	83 7d ac 00	 cmp	 DWORD PTR tv86[ebp], 0
  0b4c5	75 07		 jne	 SHORT $LN8@CheckWinne@3

; 3884 : 		return true;

  0b4c7	b0 01		 mov	 al, 1
  0b4c9	e9 4a 01 00 00	 jmp	 $LN11@CheckWinne@3
$LN8@CheckWinne@3:

; 3885 : 
; 3886 : 	for ( int iPartyUserIndex =0;iPartyUserIndex<MAX_USER_IN_PARTY;iPartyUserIndex++)

  0b4ce	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _iPartyUserIndex$238209[ebp], 0
  0b4d5	eb 09		 jmp	 SHORT $LN7@CheckWinne@3
$LN6@CheckWinne@3:
  0b4d7	8b 45 f0	 mov	 eax, DWORD PTR _iPartyUserIndex$238209[ebp]
  0b4da	83 c0 01	 add	 eax, 1
  0b4dd	89 45 f0	 mov	 DWORD PTR _iPartyUserIndex$238209[ebp], eax
$LN7@CheckWinne@3:
  0b4e0	83 7d f0 0a	 cmp	 DWORD PTR _iPartyUserIndex$238209[ebp], 10 ; 0000000aH
  0b4e4	0f 8d 2c 01 00
	00		 jge	 $LN5@CheckWinne@3

; 3887 : 	{
; 3888 : 		iUserIndex = gParty.m_PartyS[iPartyIndex].Number[iPartyUserIndex];

  0b4ea	8b 45 f8	 mov	 eax, DWORD PTR _iPartyIndex$[ebp]
  0b4ed	6b c0 6c	 imul	 eax, 108		; 0000006cH
  0b4f0	8b 4d f0	 mov	 ecx, DWORD PTR _iPartyUserIndex$238209[ebp]
  0b4f3	8b 94 88 0c 00
	00 00		 mov	 edx, DWORD PTR ?gParty@@3VPartyClass@@A[eax+ecx*4+12]
  0b4fa	89 55 f4	 mov	 DWORD PTR _iUserIndex$[ebp], edx

; 3889 : 
; 3890 : 		if ( gObjIsConnected(iUserIndex))

  0b4fd	8b 45 f4	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  0b500	50		 push	 eax
  0b501	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0b506	83 c4 04	 add	 esp, 4
  0b509	85 c0		 test	 eax, eax
  0b50b	0f 84 00 01 00
	00		 je	 $LN4@CheckWinne@3

; 3891 : 		{
; 3892 : 			if ( BC_MAP_RANGE(gObj[iUserIndex].MapNumber) && BC_BRIDGE_RANGE(gObj[iUserIndex].m_cBloodCastleIndex) )

  0b511	8b 45 f4	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  0b514	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0b51a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0b520	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  0b528	83 fa 34	 cmp	 edx, 52			; 00000034H
  0b52b	75 09		 jne	 SHORT $LN19@CheckWinne@3
  0b52d	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv147[ebp], 1
  0b534	eb 4d		 jmp	 SHORT $LN20@CheckWinne@3
$LN19@CheckWinne@3:
  0b536	8b 45 f4	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  0b539	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0b53f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0b545	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  0b54d	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  0b550	7d 09		 jge	 SHORT $LN17@CheckWinne@3
  0b552	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv146[ebp], 0
  0b559	eb 22		 jmp	 SHORT $LN18@CheckWinne@3
$LN17@CheckWinne@3:
  0b55b	8b 45 f4	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  0b55e	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0b564	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0b56a	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  0b572	33 c0		 xor	 eax, eax
  0b574	83 fa 11	 cmp	 edx, 17			; 00000011H
  0b577	0f 9e c0	 setle	 al
  0b57a	89 45 a8	 mov	 DWORD PTR tv146[ebp], eax
$LN18@CheckWinne@3:
  0b57d	8b 4d a8	 mov	 ecx, DWORD PTR tv146[ebp]
  0b580	89 4d ac	 mov	 DWORD PTR tv147[ebp], ecx
$LN20@CheckWinne@3:
  0b583	83 7d ac 00	 cmp	 DWORD PTR tv147[ebp], 0
  0b587	0f 84 84 00 00
	00		 je	 $LN4@CheckWinne@3
  0b58d	8b 45 f4	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  0b590	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0b596	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0b59c	0f be 94 01 9e
	0e 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3742]
  0b5a4	85 d2		 test	 edx, edx
  0b5a6	7d 09		 jge	 SHORT $LN21@CheckWinne@3
  0b5a8	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv160[ebp], 0
  0b5af	eb 22		 jmp	 SHORT $LN22@CheckWinne@3
$LN21@CheckWinne@3:
  0b5b1	8b 45 f4	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  0b5b4	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0b5ba	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0b5c0	0f be 94 01 9e
	0e 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3742]
  0b5c8	33 c0		 xor	 eax, eax
  0b5ca	83 fa 07	 cmp	 edx, 7
  0b5cd	0f 9e c0	 setle	 al
  0b5d0	89 45 ac	 mov	 DWORD PTR tv160[ebp], eax
$LN22@CheckWinne@3:
  0b5d3	83 7d ac 00	 cmp	 DWORD PTR tv160[ebp], 0
  0b5d7	74 38		 je	 SHORT $LN4@CheckWinne@3

; 3893 : 			{
; 3894 : 				if ( gObj[iUserIndex].Live == 1 )

  0b5d9	8b 45 f4	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  0b5dc	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0b5e2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0b5e8	0f b6 54 01 6a	 movzx	 edx, BYTE PTR [ecx+eax+106]
  0b5ed	83 fa 01	 cmp	 edx, 1
  0b5f0	75 1f		 jne	 SHORT $LN4@CheckWinne@3

; 3895 : 				{
; 3896 : 					if ( gObj[iUserIndex].m_bBloodCastleComplete == false )

  0b5f2	8b 45 f4	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  0b5f5	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0b5fb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0b601	0f b6 94 01 a4
	0e 00 00	 movzx	 edx, BYTE PTR [ecx+eax+3748]
  0b609	85 d2		 test	 edx, edx
  0b60b	75 04		 jne	 SHORT $LN4@CheckWinne@3

; 3897 : 					{
; 3898 : 						return false;

  0b60d	32 c0		 xor	 al, al
  0b60f	eb 07		 jmp	 SHORT $LN11@CheckWinne@3
$LN4@CheckWinne@3:

; 3899 : 					}
; 3900 : 				}
; 3901 : 			}
; 3902 : 		}
; 3903 : 	}

  0b611	e9 c1 fe ff ff	 jmp	 $LN6@CheckWinne@3
$LN5@CheckWinne@3:

; 3904 : 
; 3905 : 	return true;

  0b616	b0 01		 mov	 al, 1
$LN11@CheckWinne@3:

; 3906 : }

  0b618	5f		 pop	 edi
  0b619	5e		 pop	 esi
  0b61a	5b		 pop	 ebx
  0b61b	8b e5		 mov	 esp, ebp
  0b61d	5d		 pop	 ebp
  0b61e	c2 04 00	 ret	 4
?CheckWinnerPartyComplete@CBloodCastle@@QAE_NH@Z ENDP	; CBloodCastle::CheckWinnerPartyComplete
_TEXT	ENDS
PUBLIC	?SetBridgeWinner@CBloodCastle@@QAE_NHH@Z	; CBloodCastle::SetBridgeWinner
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv95 = -76						; size = 4
tv128 = -72						; size = 4
tv67 = -72						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
_iIndex$ = 12						; size = 4
?SetBridgeWinner@CBloodCastle@@QAE_NHH@Z PROC		; CBloodCastle::SetBridgeWinner
; _this$ = ecx

; 3909 : {

  0b630	55		 push	 ebp
  0b631	8b ec		 mov	 ebp, esp
  0b633	83 ec 4c	 sub	 esp, 76			; 0000004cH
  0b636	53		 push	 ebx
  0b637	56		 push	 esi
  0b638	57		 push	 edi
  0b639	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3910 : 	if ( !BC_BRIDGE_RANGE(iBridgeIndex) )

  0b63c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  0b640	7d 09		 jge	 SHORT $LN7@SetBridgeW
  0b642	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  0b649	eb 0c		 jmp	 SHORT $LN8@SetBridgeW
$LN7@SetBridgeW:
  0b64b	33 c0		 xor	 eax, eax
  0b64d	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  0b651	0f 9e c0	 setle	 al
  0b654	89 45 b8	 mov	 DWORD PTR tv67[ebp], eax
$LN8@SetBridgeW:
  0b657	83 7d b8 00	 cmp	 DWORD PTR tv67[ebp], 0
  0b65b	75 07		 jne	 SHORT $LN4@SetBridgeW

; 3911 : 		return false;

  0b65d	32 c0		 xor	 al, al
  0b65f	e9 d2 00 00 00	 jmp	 $LN5@SetBridgeW
$LN4@SetBridgeW:

; 3912 : 
; 3913 : 	if ( gObjIsConnected(this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX) != 0 )

  0b664	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0b667	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0b66d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0b670	8b 94 01 58 04
	00 00		 mov	 edx, DWORD PTR [ecx+eax+1112]
  0b677	52		 push	 edx
  0b678	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0b67d	83 c4 04	 add	 esp, 4
  0b680	85 c0		 test	 eax, eax
  0b682	74 07		 je	 SHORT $LN3@SetBridgeW

; 3914 : 		return false;

  0b684	32 c0		 xor	 al, al
  0b686	e9 ab 00 00 00	 jmp	 $LN5@SetBridgeW
$LN3@SetBridgeW:

; 3915 : 
; 3916 : 	if ( !gObjIsConnected(iIndex))

  0b68b	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0b68e	50		 push	 eax
  0b68f	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0b694	83 c4 04	 add	 esp, 4
  0b697	85 c0		 test	 eax, eax
  0b699	75 07		 jne	 SHORT $LN2@SetBridgeW

; 3917 : 		return false;

  0b69b	32 c0		 xor	 al, al
  0b69d	e9 94 00 00 00	 jmp	 $LN5@SetBridgeW
$LN2@SetBridgeW:

; 3918 : 
; 3919 : 	if ( !BC_MAP_RANGE(gObj[iIndex].MapNumber))

  0b6a2	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0b6a5	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0b6ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0b6b1	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  0b6b9	83 fa 34	 cmp	 edx, 52			; 00000034H
  0b6bc	75 09		 jne	 SHORT $LN11@SetBridgeW
  0b6be	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv128[ebp], 1
  0b6c5	eb 4d		 jmp	 SHORT $LN12@SetBridgeW
$LN11@SetBridgeW:
  0b6c7	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0b6ca	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0b6d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0b6d6	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  0b6de	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  0b6e1	7d 09		 jge	 SHORT $LN9@SetBridgeW
  0b6e3	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv95[ebp], 0
  0b6ea	eb 22		 jmp	 SHORT $LN10@SetBridgeW
$LN9@SetBridgeW:
  0b6ec	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0b6ef	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0b6f5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0b6fb	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  0b703	33 c0		 xor	 eax, eax
  0b705	83 fa 11	 cmp	 edx, 17			; 00000011H
  0b708	0f 9e c0	 setle	 al
  0b70b	89 45 b4	 mov	 DWORD PTR tv95[ebp], eax
$LN10@SetBridgeW:
  0b70e	8b 4d b4	 mov	 ecx, DWORD PTR tv95[ebp]
  0b711	89 4d b8	 mov	 DWORD PTR tv128[ebp], ecx
$LN12@SetBridgeW:
  0b714	83 7d b8 00	 cmp	 DWORD PTR tv128[ebp], 0
  0b718	75 04		 jne	 SHORT $LN1@SetBridgeW

; 3920 : 		return false;

  0b71a	32 c0		 xor	 al, al
  0b71c	eb 18		 jmp	 SHORT $LN5@SetBridgeW
$LN1@SetBridgeW:

; 3921 : 
; 3922 : 	this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX = iIndex;

  0b71e	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0b721	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0b727	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0b72a	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0b72d	89 94 01 58 04
	00 00		 mov	 DWORD PTR [ecx+eax+1112], edx

; 3923 : 
; 3924 : 	return true;

  0b734	b0 01		 mov	 al, 1
$LN5@SetBridgeW:

; 3925 : }

  0b736	5f		 pop	 edi
  0b737	5e		 pop	 esi
  0b738	5b		 pop	 ebx
  0b739	8b e5		 mov	 esp, ebp
  0b73b	5d		 pop	 ebp
  0b73c	c2 08 00	 ret	 8
?SetBridgeWinner@CBloodCastle@@QAE_NHH@Z ENDP		; CBloodCastle::SetBridgeWinner
; Function compile flags: /Odtp /ZI
tv146 = -92						; size = 4
tv160 = -88						; size = 4
tv147 = -88						; size = 4
tv86 = -88						; size = 4
tv67 = -88						; size = 4
_iPartyUserIndex$238236 = -20				; size = 4
_iUserIndex$ = -16					; size = 4
_iPartyComplete$ = -12					; size = 4
_iPartyIndex$ = -8					; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?GetWinnerPartyCompleteCount@CBloodCastle@@QAEHH@Z PROC	; CBloodCastle::GetWinnerPartyCompleteCount
; _this$ = ecx

; 3928 : {

  0b740	55		 push	 ebp
  0b741	8b ec		 mov	 ebp, esp
  0b743	83 ec 5c	 sub	 esp, 92			; 0000005cH
  0b746	53		 push	 ebx
  0b747	56		 push	 esi
  0b748	57		 push	 edi
  0b749	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3929 : 	if ( !BC_BRIDGE_RANGE(iBridgeIndex) )

  0b74c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  0b750	7d 09		 jge	 SHORT $LN13@GetWinnerP
  0b752	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  0b759	eb 0c		 jmp	 SHORT $LN14@GetWinnerP
$LN13@GetWinnerP:
  0b75b	33 c0		 xor	 eax, eax
  0b75d	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  0b761	0f 9e c0	 setle	 al
  0b764	89 45 a8	 mov	 DWORD PTR tv67[ebp], eax
$LN14@GetWinnerP:
  0b767	83 7d a8 00	 cmp	 DWORD PTR tv67[ebp], 0
  0b76b	75 07		 jne	 SHORT $LN10@GetWinnerP

; 3930 : 		return false;

  0b76d	33 c0		 xor	 eax, eax
  0b76f	e9 d2 01 00 00	 jmp	 $LN11@GetWinnerP
$LN10@GetWinnerP:

; 3931 : 
; 3932 : 	if ( !gObjIsConnected(this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX))

  0b774	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0b777	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0b77d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0b780	8b 94 01 58 04
	00 00		 mov	 edx, DWORD PTR [ecx+eax+1112]
  0b787	52		 push	 edx
  0b788	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0b78d	83 c4 04	 add	 esp, 4
  0b790	85 c0		 test	 eax, eax
  0b792	75 07		 jne	 SHORT $LN9@GetWinnerP

; 3933 : 		return false;

  0b794	33 c0		 xor	 eax, eax
  0b796	e9 ab 01 00 00	 jmp	 $LN11@GetWinnerP
$LN9@GetWinnerP:

; 3934 : 
; 3935 : 	int iPartyIndex = gObj[this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].PartyNumber;

  0b79b	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0b79e	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0b7a4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0b7a7	8b 94 01 58 04
	00 00		 mov	 edx, DWORD PTR [ecx+eax+1112]
  0b7ae	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  0b7b4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0b7b9	8b 8c 10 2c 04
	00 00		 mov	 ecx, DWORD PTR [eax+edx+1068]
  0b7c0	89 4d f8	 mov	 DWORD PTR _iPartyIndex$[ebp], ecx

; 3936 : 	
; 3937 : 	if ( !OBJMAX_RANGE(iPartyIndex))

  0b7c3	83 7d f8 00	 cmp	 DWORD PTR _iPartyIndex$[ebp], 0
  0b7c7	7d 09		 jge	 SHORT $LN15@GetWinnerP
  0b7c9	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv86[ebp], 0
  0b7d0	eb 0f		 jmp	 SHORT $LN16@GetWinnerP
$LN15@GetWinnerP:
  0b7d2	33 c0		 xor	 eax, eax
  0b7d4	81 7d f8 97 3a
	00 00		 cmp	 DWORD PTR _iPartyIndex$[ebp], 14999 ; 00003a97H
  0b7db	0f 9e c0	 setle	 al
  0b7de	89 45 a8	 mov	 DWORD PTR tv86[ebp], eax
$LN16@GetWinnerP:
  0b7e1	83 7d a8 00	 cmp	 DWORD PTR tv86[ebp], 0
  0b7e5	75 07		 jne	 SHORT $LN8@GetWinnerP

; 3938 : 		return false;

  0b7e7	33 c0		 xor	 eax, eax
  0b7e9	e9 58 01 00 00	 jmp	 $LN11@GetWinnerP
$LN8@GetWinnerP:

; 3939 : 
; 3940 : 	int iPartyComplete=0;

  0b7ee	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iPartyComplete$[ebp], 0

; 3941 : 	int iUserIndex;
; 3942 : 
; 3943 : 	for ( int iPartyUserIndex =0;iPartyUserIndex<MAX_USER_IN_PARTY;iPartyUserIndex++)

  0b7f5	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _iPartyUserIndex$238236[ebp], 0
  0b7fc	eb 09		 jmp	 SHORT $LN7@GetWinnerP
$LN6@GetWinnerP:
  0b7fe	8b 45 ec	 mov	 eax, DWORD PTR _iPartyUserIndex$238236[ebp]
  0b801	83 c0 01	 add	 eax, 1
  0b804	89 45 ec	 mov	 DWORD PTR _iPartyUserIndex$238236[ebp], eax
$LN7@GetWinnerP:
  0b807	83 7d ec 0a	 cmp	 DWORD PTR _iPartyUserIndex$238236[ebp], 10 ; 0000000aH
  0b80b	0f 8d 32 01 00
	00		 jge	 $LN5@GetWinnerP

; 3944 : 	{
; 3945 : 		iUserIndex = gParty.m_PartyS[iPartyIndex].Number[iPartyUserIndex];

  0b811	8b 45 f8	 mov	 eax, DWORD PTR _iPartyIndex$[ebp]
  0b814	6b c0 6c	 imul	 eax, 108		; 0000006cH
  0b817	8b 4d ec	 mov	 ecx, DWORD PTR _iPartyUserIndex$238236[ebp]
  0b81a	8b 94 88 0c 00
	00 00		 mov	 edx, DWORD PTR ?gParty@@3VPartyClass@@A[eax+ecx*4+12]
  0b821	89 55 f0	 mov	 DWORD PTR _iUserIndex$[ebp], edx

; 3946 : 
; 3947 : 		if ( gObjIsConnected(iUserIndex))

  0b824	8b 45 f0	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  0b827	50		 push	 eax
  0b828	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0b82d	83 c4 04	 add	 esp, 4
  0b830	85 c0		 test	 eax, eax
  0b832	0f 84 06 01 00
	00		 je	 $LN4@GetWinnerP

; 3948 : 		{
; 3949 : 			if ( BC_MAP_RANGE(gObj[iUserIndex].MapNumber) && BC_BRIDGE_RANGE(gObj[iUserIndex].m_cBloodCastleIndex) )

  0b838	8b 45 f0	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  0b83b	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0b841	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0b847	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  0b84f	83 fa 34	 cmp	 edx, 52			; 00000034H
  0b852	75 09		 jne	 SHORT $LN19@GetWinnerP
  0b854	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv147[ebp], 1
  0b85b	eb 4d		 jmp	 SHORT $LN20@GetWinnerP
$LN19@GetWinnerP:
  0b85d	8b 45 f0	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  0b860	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0b866	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0b86c	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  0b874	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  0b877	7d 09		 jge	 SHORT $LN17@GetWinnerP
  0b879	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv146[ebp], 0
  0b880	eb 22		 jmp	 SHORT $LN18@GetWinnerP
$LN17@GetWinnerP:
  0b882	8b 45 f0	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  0b885	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0b88b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0b891	0f b6 94 01 49
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+329]
  0b899	33 c0		 xor	 eax, eax
  0b89b	83 fa 11	 cmp	 edx, 17			; 00000011H
  0b89e	0f 9e c0	 setle	 al
  0b8a1	89 45 a4	 mov	 DWORD PTR tv146[ebp], eax
$LN18@GetWinnerP:
  0b8a4	8b 4d a4	 mov	 ecx, DWORD PTR tv146[ebp]
  0b8a7	89 4d a8	 mov	 DWORD PTR tv147[ebp], ecx
$LN20@GetWinnerP:
  0b8aa	83 7d a8 00	 cmp	 DWORD PTR tv147[ebp], 0
  0b8ae	0f 84 8a 00 00
	00		 je	 $LN4@GetWinnerP
  0b8b4	8b 45 f0	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  0b8b7	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0b8bd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0b8c3	0f be 94 01 9e
	0e 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3742]
  0b8cb	85 d2		 test	 edx, edx
  0b8cd	7d 09		 jge	 SHORT $LN21@GetWinnerP
  0b8cf	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv160[ebp], 0
  0b8d6	eb 22		 jmp	 SHORT $LN22@GetWinnerP
$LN21@GetWinnerP:
  0b8d8	8b 45 f0	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  0b8db	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0b8e1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0b8e7	0f be 94 01 9e
	0e 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3742]
  0b8ef	33 c0		 xor	 eax, eax
  0b8f1	83 fa 07	 cmp	 edx, 7
  0b8f4	0f 9e c0	 setle	 al
  0b8f7	89 45 a8	 mov	 DWORD PTR tv160[ebp], eax
$LN22@GetWinnerP:
  0b8fa	83 7d a8 00	 cmp	 DWORD PTR tv160[ebp], 0
  0b8fe	74 3e		 je	 SHORT $LN4@GetWinnerP

; 3950 : 			{
; 3951 : 				if ( gObj[iUserIndex].Live == 1 )

  0b900	8b 45 f0	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  0b903	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0b909	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0b90f	0f b6 54 01 6a	 movzx	 edx, BYTE PTR [ecx+eax+106]
  0b914	83 fa 01	 cmp	 edx, 1
  0b917	75 25		 jne	 SHORT $LN4@GetWinnerP

; 3952 : 				{
; 3953 : 					if ( gObj[iUserIndex].m_bBloodCastleComplete == true )

  0b919	8b 45 f0	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  0b91c	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0b922	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0b928	0f b6 94 01 a4
	0e 00 00	 movzx	 edx, BYTE PTR [ecx+eax+3748]
  0b930	83 fa 01	 cmp	 edx, 1
  0b933	75 09		 jne	 SHORT $LN4@GetWinnerP

; 3954 : 					{
; 3955 : 						iPartyComplete++;

  0b935	8b 45 f4	 mov	 eax, DWORD PTR _iPartyComplete$[ebp]
  0b938	83 c0 01	 add	 eax, 1
  0b93b	89 45 f4	 mov	 DWORD PTR _iPartyComplete$[ebp], eax
$LN4@GetWinnerP:

; 3956 : 					}
; 3957 : 				}
; 3958 : 			}
; 3959 : 		}
; 3960 : 	}

  0b93e	e9 bb fe ff ff	 jmp	 $LN6@GetWinnerP
$LN5@GetWinnerP:

; 3961 : 
; 3962 : 	return iPartyComplete;

  0b943	8b 45 f4	 mov	 eax, DWORD PTR _iPartyComplete$[ebp]
$LN11@GetWinnerP:

; 3963 : }

  0b946	5f		 pop	 edi
  0b947	5e		 pop	 esi
  0b948	5b		 pop	 ebx
  0b949	8b e5		 mov	 esp, ebp
  0b94b	5d		 pop	 ebp
  0b94c	c2 04 00	 ret	 4
?GetWinnerPartyCompleteCount@CBloodCastle@@QAEHH@Z ENDP	; CBloodCastle::GetWinnerPartyCompleteCount
; Function compile flags: /Odtp /ZI
tv71 = -76						; size = 4
_iPartyComplete$ = -8					; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?GetWinnerPartyCompletePoint@CBloodCastle@@QAEHH@Z PROC	; CBloodCastle::GetWinnerPartyCompletePoint
; _this$ = ecx

; 3966 : {

  0b950	55		 push	 ebp
  0b951	8b ec		 mov	 ebp, esp
  0b953	83 ec 4c	 sub	 esp, 76			; 0000004cH
  0b956	53		 push	 ebx
  0b957	56		 push	 esi
  0b958	57		 push	 edi
  0b959	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3967 : 	int iPartyComplete = this->GetWinnerPartyCompleteCount(iBridgeIndex);

  0b95c	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0b95f	50		 push	 eax
  0b960	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0b963	e8 00 00 00 00	 call	 ?GetWinnerPartyCompleteCount@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetWinnerPartyCompleteCount
  0b968	89 45 f8	 mov	 DWORD PTR _iPartyComplete$[ebp], eax

; 3968 : 	iPartyComplete--;

  0b96b	8b 45 f8	 mov	 eax, DWORD PTR _iPartyComplete$[ebp]
  0b96e	83 e8 01	 sub	 eax, 1
  0b971	89 45 f8	 mov	 DWORD PTR _iPartyComplete$[ebp], eax

; 3969 : 
; 3970 : 	if ( CHECK_LIMIT(iPartyComplete, MAX_USER_IN_PARTY) )

  0b974	79 09		 jns	 SHORT $LN4@GetWinnerP@2
  0b976	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
  0b97d	eb 0c		 jmp	 SHORT $LN5@GetWinnerP@2
$LN4@GetWinnerP@2:
  0b97f	33 c0		 xor	 eax, eax
  0b981	83 7d f8 09	 cmp	 DWORD PTR _iPartyComplete$[ebp], 9
  0b985	0f 9e c0	 setle	 al
  0b988	89 45 b4	 mov	 DWORD PTR tv71[ebp], eax
$LN5@GetWinnerP@2:
  0b98b	83 7d b4 00	 cmp	 DWORD PTR tv71[ebp], 0
  0b98f	74 0c		 je	 SHORT $LN1@GetWinnerP@2

; 3971 : 		return g_iBC_Party_EventPoint[iPartyComplete];

  0b991	8b 45 f8	 mov	 eax, DWORD PTR _iPartyComplete$[ebp]
  0b994	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _g_iBC_Party_EventPoint[eax*4]
  0b99b	eb 02		 jmp	 SHORT $LN2@GetWinnerP@2
$LN1@GetWinnerP@2:

; 3972 : 
; 3973 : 	return 0;

  0b99d	33 c0		 xor	 eax, eax
$LN2@GetWinnerP@2:

; 3974 : }

  0b99f	5f		 pop	 edi
  0b9a0	5e		 pop	 esi
  0b9a1	5b		 pop	 ebx
  0b9a2	8b e5		 mov	 esp, ebp
  0b9a4	5d		 pop	 ebp
  0b9a5	c2 04 00	 ret	 4
?GetWinnerPartyCompletePoint@CBloodCastle@@QAEHH@Z ENDP	; CBloodCastle::GetWinnerPartyCompletePoint
_TEXT	ENDS
PUBLIC	?ChangeMonsterState@CBloodCastle@@QAEXHH@Z	; CBloodCastle::ChangeMonsterState
EXTRN	?GetAttr@CMonsterAttr@@QAEPAUMONSTER_ATTRIBUTE@@H@Z:PROC ; CMonsterAttr::GetAttr
EXTRN	?gMAttr@@3VCMonsterAttr@@A:BYTE			; gMAttr
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv67 = -88						; size = 4
_lpMA$ = -20						; size = 4
_iAddDefense$ = -16					; size = 4
_iAddDamageMin$ = -12					; size = 4
_iAddDamageMax$ = -8					; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
_iIndex$ = 12						; size = 4
?ChangeMonsterState@CBloodCastle@@QAEXHH@Z PROC		; CBloodCastle::ChangeMonsterState
; _this$ = ecx

; 3977 : {

  0b9b0	55		 push	 ebp
  0b9b1	8b ec		 mov	 ebp, esp
  0b9b3	83 ec 58	 sub	 esp, 88			; 00000058H
  0b9b6	53		 push	 ebx
  0b9b7	56		 push	 esi
  0b9b8	57		 push	 edi
  0b9b9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3978 : 	if ( !BC_BRIDGE_RANGE(iBridgeIndex) )

  0b9bc	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  0b9c0	7d 09		 jge	 SHORT $LN8@ChangeMons
  0b9c2	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  0b9c9	eb 0c		 jmp	 SHORT $LN9@ChangeMons
$LN8@ChangeMons:
  0b9cb	33 c0		 xor	 eax, eax
  0b9cd	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  0b9d1	0f 9e c0	 setle	 al
  0b9d4	89 45 a8	 mov	 DWORD PTR tv67[ebp], eax
$LN9@ChangeMons:
  0b9d7	83 7d a8 00	 cmp	 DWORD PTR tv67[ebp], 0
  0b9db	75 05		 jne	 SHORT $LN5@ChangeMons

; 3979 : 		return;

  0b9dd	e9 00 01 00 00	 jmp	 $LN6@ChangeMons
$LN5@ChangeMons:

; 3980 : 
; 3981 : 	int iAddDamageMax = 0;

  0b9e2	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iAddDamageMax$[ebp], 0

; 3982 : 	int iAddDamageMin = 0;

  0b9e9	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iAddDamageMin$[ebp], 0

; 3983 : 	int iAddDefense = 0;

  0b9f0	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _iAddDefense$[ebp], 0

; 3984 : 
; 3985 : 	if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC < 300000 )

  0b9f7	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0b9fa	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0ba00	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0ba03	81 bc 01 ac 03
	00 00 e0 93 04
	00		 cmp	 DWORD PTR [ecx+eax+940], 300000 ; 000493e0H
  0ba0e	7d 1a		 jge	 SHORT $LN4@ChangeMons

; 3986 : 	{
; 3987 : 		iAddDamageMin = g_iBC_MONSTER_CHANGE_STATE[1][0];

  0ba10	a1 0c 00 00 00	 mov	 eax, DWORD PTR _g_iBC_MONSTER_CHANGE_STATE+12
  0ba15	89 45 f4	 mov	 DWORD PTR _iAddDamageMin$[ebp], eax

; 3988 : 		iAddDamageMax = g_iBC_MONSTER_CHANGE_STATE[1][1];

  0ba18	a1 10 00 00 00	 mov	 eax, DWORD PTR _g_iBC_MONSTER_CHANGE_STATE+16
  0ba1d	89 45 f8	 mov	 DWORD PTR _iAddDamageMax$[ebp], eax

; 3989 : 		iAddDefense = g_iBC_MONSTER_CHANGE_STATE[1][2];

  0ba20	a1 14 00 00 00	 mov	 eax, DWORD PTR _g_iBC_MONSTER_CHANGE_STATE+20
  0ba25	89 45 f0	 mov	 DWORD PTR _iAddDefense$[ebp], eax
  0ba28	eb 31		 jmp	 SHORT $LN3@ChangeMons
$LN4@ChangeMons:

; 3990 : 	}
; 3991 : 	else if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC < 600000 )

  0ba2a	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0ba2d	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0ba33	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0ba36	81 bc 01 ac 03
	00 00 c0 27 09
	00		 cmp	 DWORD PTR [ecx+eax+940], 600000 ; 000927c0H
  0ba41	7d 18		 jge	 SHORT $LN3@ChangeMons

; 3992 : 	{
; 3993 : 		iAddDamageMin = g_iBC_MONSTER_CHANGE_STATE[0][0];

  0ba43	a1 00 00 00 00	 mov	 eax, DWORD PTR _g_iBC_MONSTER_CHANGE_STATE
  0ba48	89 45 f4	 mov	 DWORD PTR _iAddDamageMin$[ebp], eax

; 3994 : 		iAddDamageMax = g_iBC_MONSTER_CHANGE_STATE[0][1];

  0ba4b	a1 04 00 00 00	 mov	 eax, DWORD PTR _g_iBC_MONSTER_CHANGE_STATE+4
  0ba50	89 45 f8	 mov	 DWORD PTR _iAddDamageMax$[ebp], eax

; 3995 : 		iAddDefense = g_iBC_MONSTER_CHANGE_STATE[0][2];

  0ba53	a1 08 00 00 00	 mov	 eax, DWORD PTR _g_iBC_MONSTER_CHANGE_STATE+8
  0ba58	89 45 f0	 mov	 DWORD PTR _iAddDefense$[ebp], eax
$LN3@ChangeMons:

; 3996 : 	}
; 3997 : 
; 3998 : 	LPMONSTER_ATTRIBUTE lpMA = gMAttr.GetAttr(gObj[iIndex].Class);

  0ba5b	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0ba5e	69 c0 38 2b 00
	00		 imul	 eax, 11064		; 00002b38H
  0ba64	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0ba6a	0f b7 94 01 b8
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+184]
  0ba72	52		 push	 edx
  0ba73	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMAttr@@3VCMonsterAttr@@A ; gMAttr
  0ba78	e8 00 00 00 00	 call	 ?GetAttr@CMonsterAttr@@QAEPAUMONSTER_ATTRIBUTE@@H@Z ; CMonsterAttr::GetAttr
  0ba7d	89 45 ec	 mov	 DWORD PTR _lpMA$[ebp], eax

; 3999 : 
; 4000 : 	if ( lpMA == NULL )

  0ba80	83 7d ec 00	 cmp	 DWORD PTR _lpMA$[ebp], 0
  0ba84	75 02		 jne	 SHORT $LN1@ChangeMons

; 4001 : 		return;

  0ba86	eb 5a		 jmp	 SHORT $LN6@ChangeMons
$LN1@ChangeMons:

; 4002 : 
; 4003 : 	gObj[iIndex].m_AttackDamageMin = lpMA->m_DamageMin + iAddDamageMin;

  0ba88	8b 45 ec	 mov	 eax, DWORD PTR _lpMA$[ebp]
  0ba8b	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  0ba8e	03 4d f4	 add	 ecx, DWORD PTR _iAddDamageMin$[ebp]
  0ba91	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0ba94	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  0ba9a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0ba9f	89 8c 10 60 04
	00 00		 mov	 DWORD PTR [eax+edx+1120], ecx

; 4004 : 	gObj[iIndex].m_AttackDamageMax = lpMA->m_DamageMax + iAddDamageMax;

  0baa6	8b 45 ec	 mov	 eax, DWORD PTR _lpMA$[ebp]
  0baa9	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0baac	03 4d f8	 add	 ecx, DWORD PTR _iAddDamageMax$[ebp]
  0baaf	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0bab2	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  0bab8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0babd	89 8c 10 64 04
	00 00		 mov	 DWORD PTR [eax+edx+1124], ecx

; 4005 : 	gObj[iIndex].m_Defense = lpMA->m_Defense + iAddDefense;

  0bac4	8b 45 ec	 mov	 eax, DWORD PTR _lpMA$[ebp]
  0bac7	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0baca	03 4d f0	 add	 ecx, DWORD PTR _iAddDefense$[ebp]
  0bacd	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0bad0	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  0bad6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0badb	89 8c 10 94 04
	00 00		 mov	 DWORD PTR [eax+edx+1172], ecx
$LN6@ChangeMons:

; 4006 : }

  0bae2	5f		 pop	 edi
  0bae3	5e		 pop	 esi
  0bae4	5b		 pop	 ebx
  0bae5	8b e5		 mov	 esp, ebp
  0bae7	5d		 pop	 ebp
  0bae8	c2 08 00	 ret	 8
?ChangeMonsterState@CBloodCastle@@QAEXHH@Z ENDP		; CBloodCastle::ChangeMonsterState
_TEXT	ENDS
PUBLIC	??_C@_0EB@FFFJNKMC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fix@ ; `string'
PUBLIC	__real@0000000000000000
;	COMDAT ??_C@_0EB@FFFJNKMC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fix@
CONST	SEGMENT
??_C@_0EB@FFFJNKMC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fix@ DB '['
	DB	'Blood Castle] (%d) [%s][%s] FixUsersPlayStateWin() - State : '
	DB	'%d', 00H					; `string'
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv324 = -84						; size = 4
tv298 = -84						; size = 4
tv233 = -84						; size = 4
tv200 = -84						; size = 4
tv352 = -80						; size = 4
tv325 = -80						; size = 4
tv299 = -80						; size = 4
tv277 = -80						; size = 4
tv254 = -80						; size = 4
tv234 = -80						; size = 4
tv201 = -80						; size = 4
tv179 = -80						; size = 4
tv173 = -80						; size = 4
tv67 = -80						; size = 4
_lpObj$238278 = -12					; size = 4
_i$238270 = -8						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?FixUsersPlayStateWin@CBloodCastle@@QAEXH@Z PROC	; CBloodCastle::FixUsersPlayStateWin
; _this$ = ecx

; 4009 : {

  0baf0	55		 push	 ebp
  0baf1	8b ec		 mov	 ebp, esp
  0baf3	83 ec 54	 sub	 esp, 84			; 00000054H
  0baf6	53		 push	 ebx
  0baf7	56		 push	 esi
  0baf8	57		 push	 edi
  0baf9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4010 : 	if ( !BC_BRIDGE_RANGE(iBridgeIndex) )

  0bafc	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  0bb00	7d 09		 jge	 SHORT $LN33@FixUsersPl
  0bb02	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  0bb09	eb 0c		 jmp	 SHORT $LN34@FixUsersPl
$LN33@FixUsersPl:
  0bb0b	33 c0		 xor	 eax, eax
  0bb0d	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  0bb11	0f 9e c0	 setle	 al
  0bb14	89 45 b0	 mov	 DWORD PTR tv67[ebp], eax
$LN34@FixUsersPl:
  0bb17	83 7d b0 00	 cmp	 DWORD PTR tv67[ebp], 0
  0bb1b	75 05		 jne	 SHORT $LN30@FixUsersPl

; 4011 : 		return;

  0bb1d	e9 27 06 00 00	 jmp	 $LN31@FixUsersPl
$LN30@FixUsersPl:

; 4012 : 
; 4013 : 	if ( this->m_BridgeData[iBridgeIndex].m_iMISSION_SUCCESS != -1 )

  0bb22	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0bb25	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0bb2b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0bb2e	83 bc 01 a0 03
	00 00 ff	 cmp	 DWORD PTR [ecx+eax+928], -1
  0bb36	0f 84 0d 06 00
	00		 je	 $LN26@FixUsersPl

; 4014 : 	{
; 4015 : 		for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  0bb3c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$238270[ebp], 0
  0bb43	eb 09		 jmp	 SHORT $LN28@FixUsersPl
$LN27@FixUsersPl:
  0bb45	8b 45 f8	 mov	 eax, DWORD PTR _i$238270[ebp]
  0bb48	83 c0 01	 add	 eax, 1
  0bb4b	89 45 f8	 mov	 DWORD PTR _i$238270[ebp], eax
$LN28@FixUsersPl:
  0bb4e	83 7d f8 28	 cmp	 DWORD PTR _i$238270[ebp], 40 ; 00000028H
  0bb52	0f 8d f1 05 00
	00		 jge	 $LN26@FixUsersPl

; 4016 : 		{
; 4017 : 			if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == -1 )

  0bb58	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0bb5b	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0bb61	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0bb64	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0bb68	8b 45 f8	 mov	 eax, DWORD PTR _i$238270[ebp]
  0bb6b	6b c0 14	 imul	 eax, 20			; 00000014H
  0bb6e	83 7c 02 18 ff	 cmp	 DWORD PTR [edx+eax+24], -1
  0bb73	75 02		 jne	 SHORT $LN25@FixUsersPl

; 4018 : 				continue;

  0bb75	eb ce		 jmp	 SHORT $LN27@FixUsersPl
$LN25@FixUsersPl:

; 4019 : 
; 4020 : 			if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected < PLAYER_PLAYING )

  0bb77	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0bb7a	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0bb80	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0bb83	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0bb87	8b 45 f8	 mov	 eax, DWORD PTR _i$238270[ebp]
  0bb8a	6b c0 14	 imul	 eax, 20			; 00000014H
  0bb8d	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  0bb91	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0bb97	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0bb9d	83 7c 0a 04 03	 cmp	 DWORD PTR [edx+ecx+4], 3
  0bba2	7d 02		 jge	 SHORT $LN24@FixUsersPl

; 4021 : 				continue;

  0bba4	eb 9f		 jmp	 SHORT $LN27@FixUsersPl
$LN24@FixUsersPl:

; 4022 : 
; 4023 : 			if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex == -1 ||
; 4024 : 				 gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex == -1 ||
; 4025 : 				 gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex != iBridgeIndex )

  0bba6	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0bba9	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0bbaf	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0bbb2	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0bbb6	8b 45 f8	 mov	 eax, DWORD PTR _i$238270[ebp]
  0bbb9	6b c0 14	 imul	 eax, 20			; 00000014H
  0bbbc	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  0bbc0	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0bbc6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0bbcc	0f be 84 0a 9e
	0e 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3742]
  0bbd4	83 f8 ff	 cmp	 eax, -1
  0bbd7	74 66		 je	 SHORT $LN22@FixUsersPl
  0bbd9	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0bbdc	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0bbe2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0bbe5	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0bbe9	8b 45 f8	 mov	 eax, DWORD PTR _i$238270[ebp]
  0bbec	6b c0 14	 imul	 eax, 20			; 00000014H
  0bbef	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  0bbf3	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0bbf9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0bbff	0f be 84 0a 9f
	0e 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3743]
  0bc07	83 f8 ff	 cmp	 eax, -1
  0bc0a	74 33		 je	 SHORT $LN22@FixUsersPl
  0bc0c	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0bc0f	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0bc15	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0bc18	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0bc1c	8b 45 f8	 mov	 eax, DWORD PTR _i$238270[ebp]
  0bc1f	6b c0 14	 imul	 eax, 20			; 00000014H
  0bc22	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  0bc26	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0bc2c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0bc32	0f be 84 0a 9e
	0e 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3742]
  0bc3a	3b 45 08	 cmp	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0bc3d	74 05		 je	 SHORT $LN23@FixUsersPl
$LN22@FixUsersPl:

; 4026 : 				continue;

  0bc3f	e9 01 ff ff ff	 jmp	 $LN27@FixUsersPl
$LN23@FixUsersPl:

; 4027 : 
; 4028 : 			LPOBJ lpObj = &gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex];

  0bc44	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0bc47	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0bc4d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0bc50	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0bc54	8b 45 f8	 mov	 eax, DWORD PTR _i$238270[ebp]
  0bc57	6b c0 14	 imul	 eax, 20			; 00000014H
  0bc5a	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  0bc5e	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0bc64	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0bc6a	89 4d f4	 mov	 DWORD PTR _lpObj$238278[ebp], ecx

; 4029 : 
; 4030 : 			switch ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState )

  0bc6d	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0bc70	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0bc76	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0bc79	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0bc7d	8b 45 f8	 mov	 eax, DWORD PTR _i$238270[ebp]
  0bc80	6b c0 14	 imul	 eax, 20			; 00000014H
  0bc83	8b 4c 02 24	 mov	 ecx, DWORD PTR [edx+eax+36]
  0bc87	89 4d b0	 mov	 DWORD PTR tv173[ebp], ecx
  0bc8a	83 7d b0 04	 cmp	 DWORD PTR tv173[ebp], 4
  0bc8e	0f 87 72 04 00
	00		 ja	 $LN20@FixUsersPl
  0bc94	8b 55 b0	 mov	 edx, DWORD PTR tv173[ebp]
  0bc97	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN59@FixUsersPl[edx*4]
$LN19@FixUsersPl:

; 4031 : 			{
; 4032 : 				case 0:
; 4033 : 					if ( OBJMAX_RANGE(lpObj->PartyNumber) && lpObj->PartyNumber == gObj[this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].PartyNumber )

  0bc9e	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$238278[ebp]
  0bca1	83 b8 2c 04 00
	00 00		 cmp	 DWORD PTR [eax+1068], 0
  0bca8	7d 09		 jge	 SHORT $LN35@FixUsersPl
  0bcaa	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv179[ebp], 0
  0bcb1	eb 15		 jmp	 SHORT $LN36@FixUsersPl
$LN35@FixUsersPl:
  0bcb3	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$238278[ebp]
  0bcb6	33 d2		 xor	 edx, edx
  0bcb8	81 b9 2c 04 00
	00 97 3a 00 00	 cmp	 DWORD PTR [ecx+1068], 14999 ; 00003a97H
  0bcc2	0f 9e c2	 setle	 dl
  0bcc5	89 55 b0	 mov	 DWORD PTR tv179[ebp], edx
$LN36@FixUsersPl:
  0bcc8	83 7d b0 00	 cmp	 DWORD PTR tv179[ebp], 0
  0bccc	0f 84 eb 00 00
	00		 je	 $LN18@FixUsersPl
  0bcd2	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0bcd5	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0bcdb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0bcde	8b 94 01 58 04
	00 00		 mov	 edx, DWORD PTR [ecx+eax+1112]
  0bce5	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  0bceb	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$238278[ebp]
  0bcee	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0bcf4	8b 80 2c 04 00
	00		 mov	 eax, DWORD PTR [eax+1068]
  0bcfa	3b 84 11 2c 04
	00 00		 cmp	 eax, DWORD PTR [ecx+edx+1068]
  0bd01	0f 85 b6 00 00
	00		 jne	 $LN18@FixUsersPl

; 4034 : 					{
; 4035 : 						if ( BC_MAP_RANGE(lpObj->MapNumber) && lpObj->Live == TRUE && lpObj->Life > 0.0 )

  0bd07	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$238278[ebp]
  0bd0a	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  0bd11	83 f9 34	 cmp	 ecx, 52			; 00000034H
  0bd14	75 09		 jne	 SHORT $LN39@FixUsersPl
  0bd16	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv201[ebp], 1
  0bd1d	eb 33		 jmp	 SHORT $LN40@FixUsersPl
$LN39@FixUsersPl:
  0bd1f	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$238278[ebp]
  0bd22	0f b6 82 49 01
	00 00		 movzx	 eax, BYTE PTR [edx+329]
  0bd29	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  0bd2c	7d 09		 jge	 SHORT $LN37@FixUsersPl
  0bd2e	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv200[ebp], 0
  0bd35	eb 15		 jmp	 SHORT $LN38@FixUsersPl
$LN37@FixUsersPl:
  0bd37	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$238278[ebp]
  0bd3a	0f b6 91 49 01
	00 00		 movzx	 edx, BYTE PTR [ecx+329]
  0bd41	33 c0		 xor	 eax, eax
  0bd43	83 fa 11	 cmp	 edx, 17			; 00000011H
  0bd46	0f 9e c0	 setle	 al
  0bd49	89 45 ac	 mov	 DWORD PTR tv200[ebp], eax
$LN38@FixUsersPl:
  0bd4c	8b 4d ac	 mov	 ecx, DWORD PTR tv200[ebp]
  0bd4f	89 4d b0	 mov	 DWORD PTR tv201[ebp], ecx
$LN40@FixUsersPl:
  0bd52	83 7d b0 00	 cmp	 DWORD PTR tv201[ebp], 0
  0bd56	74 42		 je	 SHORT $LN17@FixUsersPl
  0bd58	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$238278[ebp]
  0bd5b	0f b6 48 6a	 movzx	 ecx, BYTE PTR [eax+106]
  0bd5f	83 f9 01	 cmp	 ecx, 1
  0bd62	75 36		 jne	 SHORT $LN17@FixUsersPl
  0bd64	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$238278[ebp]
  0bd67	d9 80 fc 00 00
	00		 fld	 DWORD PTR [eax+252]
  0bd6d	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@0000000000000000
  0bd73	df e0		 fnstsw	 ax
  0bd75	f6 c4 41	 test	 ah, 65			; 00000041H
  0bd78	75 20		 jne	 SHORT $LN17@FixUsersPl

; 4036 : 						{
; 4037 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 3;

  0bd7a	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0bd7d	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0bd83	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0bd86	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0bd8a	8b 45 f8	 mov	 eax, DWORD PTR _i$238270[ebp]
  0bd8d	6b c0 14	 imul	 eax, 20			; 00000014H
  0bd90	c7 44 02 24 03
	00 00 00	 mov	 DWORD PTR [edx+eax+36], 3

; 4038 : 						}
; 4039 : 						else

  0bd98	eb 1e		 jmp	 SHORT $LN16@FixUsersPl
$LN17@FixUsersPl:

; 4040 : 						{
; 4041 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 4;

  0bd9a	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0bd9d	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0bda3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0bda6	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0bdaa	8b 45 f8	 mov	 eax, DWORD PTR _i$238270[ebp]
  0bdad	6b c0 14	 imul	 eax, 20			; 00000014H
  0bdb0	c7 44 02 24 04
	00 00 00	 mov	 DWORD PTR [edx+eax+36], 4
$LN16@FixUsersPl:

; 4042 : 						}
; 4043 : 					}
; 4044 : 					else 

  0bdb8	e9 90 00 00 00	 jmp	 $LN14@FixUsersPl
$LN18@FixUsersPl:

; 4045 : 					{
; 4046 : 						if ( !BC_MAP_RANGE(lpObj->MapNumber) || lpObj->Live == 0 || lpObj->Life <= 0.0 )

  0bdbd	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$238278[ebp]
  0bdc0	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  0bdc7	83 f9 34	 cmp	 ecx, 52			; 00000034H
  0bdca	75 09		 jne	 SHORT $LN43@FixUsersPl
  0bdcc	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv234[ebp], 1
  0bdd3	eb 33		 jmp	 SHORT $LN44@FixUsersPl
$LN43@FixUsersPl:
  0bdd5	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$238278[ebp]
  0bdd8	0f b6 82 49 01
	00 00		 movzx	 eax, BYTE PTR [edx+329]
  0bddf	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  0bde2	7d 09		 jge	 SHORT $LN41@FixUsersPl
  0bde4	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv233[ebp], 0
  0bdeb	eb 15		 jmp	 SHORT $LN42@FixUsersPl
$LN41@FixUsersPl:
  0bded	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$238278[ebp]
  0bdf0	0f b6 91 49 01
	00 00		 movzx	 edx, BYTE PTR [ecx+329]
  0bdf7	33 c0		 xor	 eax, eax
  0bdf9	83 fa 11	 cmp	 edx, 17			; 00000011H
  0bdfc	0f 9e c0	 setle	 al
  0bdff	89 45 ac	 mov	 DWORD PTR tv233[ebp], eax
$LN42@FixUsersPl:
  0be02	8b 4d ac	 mov	 ecx, DWORD PTR tv233[ebp]
  0be05	89 4d b0	 mov	 DWORD PTR tv234[ebp], ecx
$LN44@FixUsersPl:
  0be08	83 7d b0 00	 cmp	 DWORD PTR tv234[ebp], 0
  0be0c	74 21		 je	 SHORT $LN13@FixUsersPl
  0be0e	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$238278[ebp]
  0be11	0f b6 48 6a	 movzx	 ecx, BYTE PTR [eax+106]
  0be15	85 c9		 test	 ecx, ecx
  0be17	74 16		 je	 SHORT $LN13@FixUsersPl
  0be19	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$238278[ebp]
  0be1c	d9 80 fc 00 00
	00		 fld	 DWORD PTR [eax+252]
  0be22	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@0000000000000000
  0be28	df e0		 fnstsw	 ax
  0be2a	f6 c4 41	 test	 ah, 65			; 00000041H
  0be2d	7a 1e		 jp	 SHORT $LN14@FixUsersPl
$LN13@FixUsersPl:

; 4047 : 						{
; 4048 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 1;

  0be2f	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0be32	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0be38	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0be3b	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0be3f	8b 45 f8	 mov	 eax, DWORD PTR _i$238270[ebp]
  0be42	6b c0 14	 imul	 eax, 20			; 00000014H
  0be45	c7 44 02 24 01
	00 00 00	 mov	 DWORD PTR [edx+eax+36], 1
$LN14@FixUsersPl:

; 4049 : 						}
; 4050 : 					}
; 4051 : 					break;

  0be4d	e9 b4 02 00 00	 jmp	 $LN20@FixUsersPl
$LN12@FixUsersPl:

; 4052 : 				case 1:
; 4053 : 					if ( OBJMAX_RANGE(lpObj->PartyNumber) && lpObj->PartyNumber == gObj[this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].PartyNumber )

  0be52	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$238278[ebp]
  0be55	83 b8 2c 04 00
	00 00		 cmp	 DWORD PTR [eax+1068], 0
  0be5c	7d 09		 jge	 SHORT $LN45@FixUsersPl
  0be5e	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv254[ebp], 0
  0be65	eb 15		 jmp	 SHORT $LN46@FixUsersPl
$LN45@FixUsersPl:
  0be67	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$238278[ebp]
  0be6a	33 d2		 xor	 edx, edx
  0be6c	81 b9 2c 04 00
	00 97 3a 00 00	 cmp	 DWORD PTR [ecx+1068], 14999 ; 00003a97H
  0be76	0f 9e c2	 setle	 dl
  0be79	89 55 b0	 mov	 DWORD PTR tv254[ebp], edx
$LN46@FixUsersPl:
  0be7c	83 7d b0 00	 cmp	 DWORD PTR tv254[ebp], 0
  0be80	74 4f		 je	 SHORT $LN11@FixUsersPl
  0be82	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0be85	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0be8b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0be8e	8b 94 01 58 04
	00 00		 mov	 edx, DWORD PTR [ecx+eax+1112]
  0be95	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  0be9b	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$238278[ebp]
  0be9e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0bea4	8b 80 2c 04 00
	00		 mov	 eax, DWORD PTR [eax+1068]
  0beaa	3b 84 11 2c 04
	00 00		 cmp	 eax, DWORD PTR [ecx+edx+1068]
  0beb1	75 1e		 jne	 SHORT $LN11@FixUsersPl

; 4054 : 					{
; 4055 : 						this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 4;

  0beb3	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0beb6	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0bebc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0bebf	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0bec3	8b 45 f8	 mov	 eax, DWORD PTR _i$238270[ebp]
  0bec6	6b c0 14	 imul	 eax, 20			; 00000014H
  0bec9	c7 44 02 24 04
	00 00 00	 mov	 DWORD PTR [edx+eax+36], 4
$LN11@FixUsersPl:

; 4056 : 					}
; 4057 : 					break;

  0bed1	e9 30 02 00 00	 jmp	 $LN20@FixUsersPl
$LN10@FixUsersPl:

; 4058 : 				case 3:
; 4059 : 					if ( OBJMAX_RANGE(lpObj->PartyNumber) && lpObj->PartyNumber == gObj[this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].PartyNumber )

  0bed6	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$238278[ebp]
  0bed9	83 b8 2c 04 00
	00 00		 cmp	 DWORD PTR [eax+1068], 0
  0bee0	7d 09		 jge	 SHORT $LN47@FixUsersPl
  0bee2	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv277[ebp], 0
  0bee9	eb 15		 jmp	 SHORT $LN48@FixUsersPl
$LN47@FixUsersPl:
  0beeb	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$238278[ebp]
  0beee	33 d2		 xor	 edx, edx
  0bef0	81 b9 2c 04 00
	00 97 3a 00 00	 cmp	 DWORD PTR [ecx+1068], 14999 ; 00003a97H
  0befa	0f 9e c2	 setle	 dl
  0befd	89 55 b0	 mov	 DWORD PTR tv277[ebp], edx
$LN48@FixUsersPl:
  0bf00	83 7d b0 00	 cmp	 DWORD PTR tv277[ebp], 0
  0bf04	0f 84 ca 00 00
	00		 je	 $LN9@FixUsersPl
  0bf0a	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0bf0d	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0bf13	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0bf16	8b 94 01 58 04
	00 00		 mov	 edx, DWORD PTR [ecx+eax+1112]
  0bf1d	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  0bf23	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$238278[ebp]
  0bf26	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0bf2c	8b 80 2c 04 00
	00		 mov	 eax, DWORD PTR [eax+1068]
  0bf32	3b 84 11 2c 04
	00 00		 cmp	 eax, DWORD PTR [ecx+edx+1068]
  0bf39	0f 85 95 00 00
	00		 jne	 $LN9@FixUsersPl

; 4060 : 					{
; 4061 : 						if ( !BC_MAP_RANGE(lpObj->MapNumber) || lpObj->Live == 0 || lpObj->Life <= 0.0 )

  0bf3f	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$238278[ebp]
  0bf42	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  0bf49	83 f9 34	 cmp	 ecx, 52			; 00000034H
  0bf4c	75 09		 jne	 SHORT $LN51@FixUsersPl
  0bf4e	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv299[ebp], 1
  0bf55	eb 33		 jmp	 SHORT $LN52@FixUsersPl
$LN51@FixUsersPl:
  0bf57	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$238278[ebp]
  0bf5a	0f b6 82 49 01
	00 00		 movzx	 eax, BYTE PTR [edx+329]
  0bf61	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  0bf64	7d 09		 jge	 SHORT $LN49@FixUsersPl
  0bf66	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv298[ebp], 0
  0bf6d	eb 15		 jmp	 SHORT $LN50@FixUsersPl
$LN49@FixUsersPl:
  0bf6f	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$238278[ebp]
  0bf72	0f b6 91 49 01
	00 00		 movzx	 edx, BYTE PTR [ecx+329]
  0bf79	33 c0		 xor	 eax, eax
  0bf7b	83 fa 11	 cmp	 edx, 17			; 00000011H
  0bf7e	0f 9e c0	 setle	 al
  0bf81	89 45 ac	 mov	 DWORD PTR tv298[ebp], eax
$LN50@FixUsersPl:
  0bf84	8b 4d ac	 mov	 ecx, DWORD PTR tv298[ebp]
  0bf87	89 4d b0	 mov	 DWORD PTR tv299[ebp], ecx
$LN52@FixUsersPl:
  0bf8a	83 7d b0 00	 cmp	 DWORD PTR tv299[ebp], 0
  0bf8e	74 21		 je	 SHORT $LN7@FixUsersPl
  0bf90	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$238278[ebp]
  0bf93	0f b6 48 6a	 movzx	 ecx, BYTE PTR [eax+106]
  0bf97	85 c9		 test	 ecx, ecx
  0bf99	74 16		 je	 SHORT $LN7@FixUsersPl
  0bf9b	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$238278[ebp]
  0bf9e	d9 80 fc 00 00
	00		 fld	 DWORD PTR [eax+252]
  0bfa4	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@0000000000000000
  0bfaa	df e0		 fnstsw	 ax
  0bfac	f6 c4 41	 test	 ah, 65			; 00000041H
  0bfaf	7a 1e		 jp	 SHORT $LN8@FixUsersPl
$LN7@FixUsersPl:

; 4062 : 						{
; 4063 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 4;

  0bfb1	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0bfb4	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0bfba	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0bfbd	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0bfc1	8b 45 f8	 mov	 eax, DWORD PTR _i$238270[ebp]
  0bfc4	6b c0 14	 imul	 eax, 20			; 00000014H
  0bfc7	c7 44 02 24 04
	00 00 00	 mov	 DWORD PTR [edx+eax+36], 4
$LN8@FixUsersPl:

; 4064 : 						}
; 4065 : 					}
; 4066 : 					else 

  0bfcf	e9 b1 00 00 00	 jmp	 $LN4@FixUsersPl
$LN9@FixUsersPl:

; 4067 : 					{
; 4068 : 						if ( BC_MAP_RANGE(lpObj->MapNumber) && lpObj->Live == TRUE && lpObj->Life > 0.0 )

  0bfd4	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$238278[ebp]
  0bfd7	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  0bfde	83 f9 34	 cmp	 ecx, 52			; 00000034H
  0bfe1	75 09		 jne	 SHORT $LN55@FixUsersPl
  0bfe3	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv325[ebp], 1
  0bfea	eb 33		 jmp	 SHORT $LN56@FixUsersPl
$LN55@FixUsersPl:
  0bfec	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$238278[ebp]
  0bfef	0f b6 82 49 01
	00 00		 movzx	 eax, BYTE PTR [edx+329]
  0bff6	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  0bff9	7d 09		 jge	 SHORT $LN53@FixUsersPl
  0bffb	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv324[ebp], 0
  0c002	eb 15		 jmp	 SHORT $LN54@FixUsersPl
$LN53@FixUsersPl:
  0c004	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$238278[ebp]
  0c007	0f b6 91 49 01
	00 00		 movzx	 edx, BYTE PTR [ecx+329]
  0c00e	33 c0		 xor	 eax, eax
  0c010	83 fa 11	 cmp	 edx, 17			; 00000011H
  0c013	0f 9e c0	 setle	 al
  0c016	89 45 ac	 mov	 DWORD PTR tv324[ebp], eax
$LN54@FixUsersPl:
  0c019	8b 4d ac	 mov	 ecx, DWORD PTR tv324[ebp]
  0c01c	89 4d b0	 mov	 DWORD PTR tv325[ebp], ecx
$LN56@FixUsersPl:
  0c01f	83 7d b0 00	 cmp	 DWORD PTR tv325[ebp], 0
  0c023	74 42		 je	 SHORT $LN5@FixUsersPl
  0c025	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$238278[ebp]
  0c028	0f b6 48 6a	 movzx	 ecx, BYTE PTR [eax+106]
  0c02c	83 f9 01	 cmp	 ecx, 1
  0c02f	75 36		 jne	 SHORT $LN5@FixUsersPl
  0c031	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$238278[ebp]
  0c034	d9 80 fc 00 00
	00		 fld	 DWORD PTR [eax+252]
  0c03a	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@0000000000000000
  0c040	df e0		 fnstsw	 ax
  0c042	f6 c4 41	 test	 ah, 65			; 00000041H
  0c045	75 20		 jne	 SHORT $LN5@FixUsersPl

; 4069 : 						{
; 4070 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 0;

  0c047	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0c04a	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0c050	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0c053	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0c057	8b 45 f8	 mov	 eax, DWORD PTR _i$238270[ebp]
  0c05a	6b c0 14	 imul	 eax, 20			; 00000014H
  0c05d	c7 44 02 24 00
	00 00 00	 mov	 DWORD PTR [edx+eax+36], 0

; 4071 : 						}
; 4072 : 						else

  0c065	eb 1e		 jmp	 SHORT $LN4@FixUsersPl
$LN5@FixUsersPl:

; 4073 : 						{
; 4074 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 1;

  0c067	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0c06a	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0c070	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0c073	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0c077	8b 45 f8	 mov	 eax, DWORD PTR _i$238270[ebp]
  0c07a	6b c0 14	 imul	 eax, 20			; 00000014H
  0c07d	c7 44 02 24 01
	00 00 00	 mov	 DWORD PTR [edx+eax+36], 1
$LN4@FixUsersPl:

; 4075 : 						}
; 4076 : 					}
; 4077 : 					break;

  0c085	eb 7f		 jmp	 SHORT $LN20@FixUsersPl
$LN3@FixUsersPl:

; 4078 : 				case 4:
; 4079 : 					if ( !OBJMAX_RANGE(lpObj->PartyNumber) || lpObj->PartyNumber != gObj[this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].PartyNumber )

  0c087	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$238278[ebp]
  0c08a	83 b8 2c 04 00
	00 00		 cmp	 DWORD PTR [eax+1068], 0
  0c091	7d 09		 jge	 SHORT $LN57@FixUsersPl
  0c093	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv352[ebp], 0
  0c09a	eb 15		 jmp	 SHORT $LN58@FixUsersPl
$LN57@FixUsersPl:
  0c09c	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$238278[ebp]
  0c09f	33 d2		 xor	 edx, edx
  0c0a1	81 b9 2c 04 00
	00 97 3a 00 00	 cmp	 DWORD PTR [ecx+1068], 14999 ; 00003a97H
  0c0ab	0f 9e c2	 setle	 dl
  0c0ae	89 55 b0	 mov	 DWORD PTR tv352[ebp], edx
$LN58@FixUsersPl:
  0c0b1	83 7d b0 00	 cmp	 DWORD PTR tv352[ebp], 0
  0c0b5	74 31		 je	 SHORT $LN1@FixUsersPl
  0c0b7	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0c0ba	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0c0c0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0c0c3	8b 94 01 58 04
	00 00		 mov	 edx, DWORD PTR [ecx+eax+1112]
  0c0ca	69 d2 38 2b 00
	00		 imul	 edx, 11064		; 00002b38H
  0c0d0	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$238278[ebp]
  0c0d3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0c0d9	8b 80 2c 04 00
	00		 mov	 eax, DWORD PTR [eax+1068]
  0c0df	3b 84 11 2c 04
	00 00		 cmp	 eax, DWORD PTR [ecx+edx+1068]
  0c0e6	74 1e		 je	 SHORT $LN2@FixUsersPl
$LN1@FixUsersPl:

; 4080 : 					{
; 4081 : 						this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 1;

  0c0e8	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0c0eb	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0c0f1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0c0f4	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0c0f8	8b 45 f8	 mov	 eax, DWORD PTR _i$238270[ebp]
  0c0fb	6b c0 14	 imul	 eax, 20			; 00000014H
  0c0fe	c7 44 02 24 01
	00 00 00	 mov	 DWORD PTR [edx+eax+36], 1
$LN2@FixUsersPl:
$LN20@FixUsersPl:

; 4082 : 					}
; 4083 : 					break;
; 4084 : 			}
; 4085 : 
; 4086 : 			LogAddTD("[Blood Castle] (%d) [%s][%s] FixUsersPlayStateWin() - State : %d", iBridgeIndex+1, lpObj->AccountID, lpObj->Name, this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState);

  0c106	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0c109	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0c10f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0c112	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0c116	8b 45 f8	 mov	 eax, DWORD PTR _i$238270[ebp]
  0c119	6b c0 14	 imul	 eax, 20			; 00000014H
  0c11c	8b 4c 02 24	 mov	 ecx, DWORD PTR [edx+eax+36]
  0c120	51		 push	 ecx
  0c121	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$238278[ebp]
  0c124	83 c2 77	 add	 edx, 119		; 00000077H
  0c127	52		 push	 edx
  0c128	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$238278[ebp]
  0c12b	83 c0 6c	 add	 eax, 108		; 0000006cH
  0c12e	50		 push	 eax
  0c12f	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  0c132	83 c1 01	 add	 ecx, 1
  0c135	51		 push	 ecx
  0c136	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@FFFJNKMC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fix@
  0c13b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0c141	83 c4 14	 add	 esp, 20			; 00000014H

; 4087 : 		}

  0c144	e9 fc f9 ff ff	 jmp	 $LN27@FixUsersPl
$LN26@FixUsersPl:
$LN31@FixUsersPl:

; 4088 : 	}
; 4089 : }

  0c149	5f		 pop	 edi
  0c14a	5e		 pop	 esi
  0c14b	5b		 pop	 ebx
  0c14c	8b e5		 mov	 esp, ebp
  0c14e	5d		 pop	 ebp
  0c14f	c2 04 00	 ret	 4
  0c152	8b ff		 npad	 2
$LN59@FixUsersPl:
  0c154	00 00 00 00	 DD	 $LN19@FixUsersPl
  0c158	00 00 00 00	 DD	 $LN12@FixUsersPl
  0c15c	00 00 00 00	 DD	 $LN20@FixUsersPl
  0c160	00 00 00 00	 DD	 $LN10@FixUsersPl
  0c164	00 00 00 00	 DD	 $LN3@FixUsersPl
?FixUsersPlayStateWin@CBloodCastle@@QAEXH@Z ENDP	; CBloodCastle::FixUsersPlayStateWin
_TEXT	ENDS
PUBLIC	??_C@_0EC@KMBIFBDF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fix@ ; `string'
;	COMDAT ??_C@_0EC@KMBIFBDF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fix@
CONST	SEGMENT
??_C@_0EC@KMBIFBDF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fix@ DB '['
	DB	'Blood Castle] (%d) [%s][%s] FixUsersPlayStateFail() - State :'
	DB	' %d', 00H					; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
_TEXT	SEGMENT
tv179 = -84						; size = 4
tv180 = -80						; size = 4
tv168 = -80						; size = 4
tv67 = -80						; size = 4
_lpObj$238316 = -12					; size = 4
_i$238308 = -8						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?FixUsersPlayStateFail@CBloodCastle@@QAEXH@Z PROC	; CBloodCastle::FixUsersPlayStateFail
; _this$ = ecx

; 4092 : {

  0c170	55		 push	 ebp
  0c171	8b ec		 mov	 ebp, esp
  0c173	83 ec 54	 sub	 esp, 84			; 00000054H
  0c176	53		 push	 ebx
  0c177	56		 push	 esi
  0c178	57		 push	 edi
  0c179	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4093 : 	if ( !BC_BRIDGE_RANGE(iBridgeIndex) )

  0c17c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  0c180	7d 09		 jge	 SHORT $LN18@FixUsersPl@2
  0c182	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  0c189	eb 0c		 jmp	 SHORT $LN19@FixUsersPl@2
$LN18@FixUsersPl@2:
  0c18b	33 c0		 xor	 eax, eax
  0c18d	83 7d 08 07	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 7
  0c191	0f 9e c0	 setle	 al
  0c194	89 45 b0	 mov	 DWORD PTR tv67[ebp], eax
$LN19@FixUsersPl@2:
  0c197	83 7d b0 00	 cmp	 DWORD PTR tv67[ebp], 0
  0c19b	75 05		 jne	 SHORT $LN15@FixUsersPl@2

; 4094 : 		return;

  0c19d	e9 76 02 00 00	 jmp	 $LN16@FixUsersPl@2
$LN15@FixUsersPl@2:

; 4095 : 
; 4096 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  0c1a2	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$238308[ebp], 0
  0c1a9	eb 09		 jmp	 SHORT $LN14@FixUsersPl@2
$LN13@FixUsersPl@2:
  0c1ab	8b 45 f8	 mov	 eax, DWORD PTR _i$238308[ebp]
  0c1ae	83 c0 01	 add	 eax, 1
  0c1b1	89 45 f8	 mov	 DWORD PTR _i$238308[ebp], eax
$LN14@FixUsersPl@2:
  0c1b4	83 7d f8 28	 cmp	 DWORD PTR _i$238308[ebp], 40 ; 00000028H
  0c1b8	0f 8d 5a 02 00
	00		 jge	 $LN12@FixUsersPl@2

; 4097 : 	{
; 4098 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == -1 )

  0c1be	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0c1c1	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0c1c7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0c1ca	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0c1ce	8b 45 f8	 mov	 eax, DWORD PTR _i$238308[ebp]
  0c1d1	6b c0 14	 imul	 eax, 20			; 00000014H
  0c1d4	83 7c 02 18 ff	 cmp	 DWORD PTR [edx+eax+24], -1
  0c1d9	75 02		 jne	 SHORT $LN11@FixUsersPl@2

; 4099 : 			continue;

  0c1db	eb ce		 jmp	 SHORT $LN13@FixUsersPl@2
$LN11@FixUsersPl@2:

; 4100 : 
; 4101 : 		if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected < PLAYER_PLAYING )

  0c1dd	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0c1e0	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0c1e6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0c1e9	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0c1ed	8b 45 f8	 mov	 eax, DWORD PTR _i$238308[ebp]
  0c1f0	6b c0 14	 imul	 eax, 20			; 00000014H
  0c1f3	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  0c1f7	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0c1fd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0c203	83 7c 0a 04 03	 cmp	 DWORD PTR [edx+ecx+4], 3
  0c208	7d 02		 jge	 SHORT $LN10@FixUsersPl@2

; 4102 : 			continue;

  0c20a	eb 9f		 jmp	 SHORT $LN13@FixUsersPl@2
$LN10@FixUsersPl@2:

; 4103 : 
; 4104 : 		if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex == -1 ||
; 4105 : 			 gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex == -1 ||
; 4106 : 			 gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex != iBridgeIndex )

  0c20c	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0c20f	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0c215	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0c218	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0c21c	8b 45 f8	 mov	 eax, DWORD PTR _i$238308[ebp]
  0c21f	6b c0 14	 imul	 eax, 20			; 00000014H
  0c222	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  0c226	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0c22c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0c232	0f be 84 0a 9e
	0e 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3742]
  0c23a	83 f8 ff	 cmp	 eax, -1
  0c23d	74 66		 je	 SHORT $LN8@FixUsersPl@2
  0c23f	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0c242	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0c248	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0c24b	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0c24f	8b 45 f8	 mov	 eax, DWORD PTR _i$238308[ebp]
  0c252	6b c0 14	 imul	 eax, 20			; 00000014H
  0c255	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  0c259	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0c25f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0c265	0f be 84 0a 9f
	0e 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3743]
  0c26d	83 f8 ff	 cmp	 eax, -1
  0c270	74 33		 je	 SHORT $LN8@FixUsersPl@2
  0c272	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0c275	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0c27b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0c27e	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0c282	8b 45 f8	 mov	 eax, DWORD PTR _i$238308[ebp]
  0c285	6b c0 14	 imul	 eax, 20			; 00000014H
  0c288	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  0c28c	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0c292	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0c298	0f be 84 0a 9e
	0e 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3742]
  0c2a0	3b 45 08	 cmp	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0c2a3	74 05		 je	 SHORT $LN9@FixUsersPl@2
$LN8@FixUsersPl@2:

; 4107 : 			continue;

  0c2a5	e9 01 ff ff ff	 jmp	 $LN13@FixUsersPl@2
$LN9@FixUsersPl@2:

; 4108 : 
; 4109 : 		LPOBJ lpObj = &gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex];

  0c2aa	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0c2ad	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0c2b3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0c2b6	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0c2ba	8b 45 f8	 mov	 eax, DWORD PTR _i$238308[ebp]
  0c2bd	6b c0 14	 imul	 eax, 20			; 00000014H
  0c2c0	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  0c2c4	69 c9 38 2b 00
	00		 imul	 ecx, 11064		; 00002b38H
  0c2ca	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0c2d0	89 4d f4	 mov	 DWORD PTR _lpObj$238316[ebp], ecx

; 4110 : 
; 4111 : 		switch ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState )

  0c2d3	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0c2d6	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0c2dc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0c2df	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0c2e3	8b 45 f8	 mov	 eax, DWORD PTR _i$238308[ebp]
  0c2e6	6b c0 14	 imul	 eax, 20			; 00000014H
  0c2e9	8b 4c 02 24	 mov	 ecx, DWORD PTR [edx+eax+36]
  0c2ed	89 4d b0	 mov	 DWORD PTR tv168[ebp], ecx
  0c2f0	83 7d b0 03	 cmp	 DWORD PTR tv168[ebp], 3
  0c2f4	74 0f		 je	 SHORT $LN5@FixUsersPl@2
  0c2f6	83 7d b0 04	 cmp	 DWORD PTR tv168[ebp], 4
  0c2fa	0f 84 b7 00 00
	00		 je	 $LN1@FixUsersPl@2
  0c300	e9 d0 00 00 00	 jmp	 $LN6@FixUsersPl@2
$LN5@FixUsersPl@2:

; 4112 : 		{
; 4113 : 			case 3:
; 4114 : 				if ( !BC_MAP_RANGE(lpObj->MapNumber) || lpObj->Live == 0 || lpObj->Life <= 0.0 )

  0c305	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$238316[ebp]
  0c308	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  0c30f	83 f9 34	 cmp	 ecx, 52			; 00000034H
  0c312	75 09		 jne	 SHORT $LN22@FixUsersPl@2
  0c314	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv180[ebp], 1
  0c31b	eb 33		 jmp	 SHORT $LN23@FixUsersPl@2
$LN22@FixUsersPl@2:
  0c31d	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$238316[ebp]
  0c320	0f b6 82 49 01
	00 00		 movzx	 eax, BYTE PTR [edx+329]
  0c327	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  0c32a	7d 09		 jge	 SHORT $LN20@FixUsersPl@2
  0c32c	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv179[ebp], 0
  0c333	eb 15		 jmp	 SHORT $LN21@FixUsersPl@2
$LN20@FixUsersPl@2:
  0c335	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$238316[ebp]
  0c338	0f b6 91 49 01
	00 00		 movzx	 edx, BYTE PTR [ecx+329]
  0c33f	33 c0		 xor	 eax, eax
  0c341	83 fa 11	 cmp	 edx, 17			; 00000011H
  0c344	0f 9e c0	 setle	 al
  0c347	89 45 ac	 mov	 DWORD PTR tv179[ebp], eax
$LN21@FixUsersPl@2:
  0c34a	8b 4d ac	 mov	 ecx, DWORD PTR tv179[ebp]
  0c34d	89 4d b0	 mov	 DWORD PTR tv180[ebp], ecx
$LN23@FixUsersPl@2:
  0c350	83 7d b0 00	 cmp	 DWORD PTR tv180[ebp], 0
  0c354	74 21		 je	 SHORT $LN3@FixUsersPl@2
  0c356	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$238316[ebp]
  0c359	0f b6 48 6a	 movzx	 ecx, BYTE PTR [eax+106]
  0c35d	85 c9		 test	 ecx, ecx
  0c35f	74 16		 je	 SHORT $LN3@FixUsersPl@2
  0c361	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$238316[ebp]
  0c364	d9 80 fc 00 00
	00		 fld	 DWORD PTR [eax+252]
  0c36a	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@0000000000000000
  0c370	df e0		 fnstsw	 ax
  0c372	f6 c4 41	 test	 ah, 65			; 00000041H
  0c375	7a 20		 jp	 SHORT $LN4@FixUsersPl@2
$LN3@FixUsersPl@2:

; 4115 : 				{
; 4116 : 					this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 1;

  0c377	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0c37a	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0c380	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0c383	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0c387	8b 45 f8	 mov	 eax, DWORD PTR _i$238308[ebp]
  0c38a	6b c0 14	 imul	 eax, 20			; 00000014H
  0c38d	c7 44 02 24 01
	00 00 00	 mov	 DWORD PTR [edx+eax+36], 1

; 4117 : 				}
; 4118 : 				else

  0c395	eb 1e		 jmp	 SHORT $LN2@FixUsersPl@2
$LN4@FixUsersPl@2:

; 4119 : 				{
; 4120 : 					this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 0;

  0c397	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0c39a	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0c3a0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0c3a3	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0c3a7	8b 45 f8	 mov	 eax, DWORD PTR _i$238308[ebp]
  0c3aa	6b c0 14	 imul	 eax, 20			; 00000014H
  0c3ad	c7 44 02 24 00
	00 00 00	 mov	 DWORD PTR [edx+eax+36], 0
$LN2@FixUsersPl@2:

; 4121 : 				}
; 4122 : 				break;

  0c3b5	eb 1e		 jmp	 SHORT $LN6@FixUsersPl@2
$LN1@FixUsersPl@2:

; 4123 : 			case 4:
; 4124 : 				this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 1;

  0c3b7	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0c3ba	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0c3c0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0c3c3	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0c3c7	8b 45 f8	 mov	 eax, DWORD PTR _i$238308[ebp]
  0c3ca	6b c0 14	 imul	 eax, 20			; 00000014H
  0c3cd	c7 44 02 24 01
	00 00 00	 mov	 DWORD PTR [edx+eax+36], 1
$LN6@FixUsersPl@2:

; 4125 : 				break;
; 4126 : 		}
; 4127 : 
; 4128 : 		LogAddTD("[Blood Castle] (%d) [%s][%s] FixUsersPlayStateFail() - State : %d",	iBridgeIndex+1, lpObj->AccountID, lpObj->Name,	this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState);

  0c3d5	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0c3d8	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0c3de	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0c3e1	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0c3e5	8b 45 f8	 mov	 eax, DWORD PTR _i$238308[ebp]
  0c3e8	6b c0 14	 imul	 eax, 20			; 00000014H
  0c3eb	8b 4c 02 24	 mov	 ecx, DWORD PTR [edx+eax+36]
  0c3ef	51		 push	 ecx
  0c3f0	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$238316[ebp]
  0c3f3	83 c2 77	 add	 edx, 119		; 00000077H
  0c3f6	52		 push	 edx
  0c3f7	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$238316[ebp]
  0c3fa	83 c0 6c	 add	 eax, 108		; 0000006cH
  0c3fd	50		 push	 eax
  0c3fe	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  0c401	83 c1 01	 add	 ecx, 1
  0c404	51		 push	 ecx
  0c405	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@KMBIFBDF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fix@
  0c40a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0c410	83 c4 14	 add	 esp, 20			; 00000014H

; 4129 : 	}

  0c413	e9 93 fd ff ff	 jmp	 $LN13@FixUsersPl@2
$LN12@FixUsersPl@2:
$LN16@FixUsersPl@2:

; 4130 : }

  0c418	5f		 pop	 edi
  0c419	5e		 pop	 esi
  0c41a	5b		 pop	 ebx
  0c41b	8b e5		 mov	 esp, ebp
  0c41d	5d		 pop	 ebp
  0c41e	c2 04 00	 ret	 4
?FixUsersPlayStateFail@CBloodCastle@@QAEXH@Z ENDP	; CBloodCastle::FixUsersPlayStateFail
; Function compile flags: /Odtp /ZI
tv64 = -76						; size = 4
_iMapNumber$ = -8					; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z PROC		; CBloodCastle::GetBridgeMapNumber
; _this$ = ecx

; 4134 : {

  0c430	55		 push	 ebp
  0c431	8b ec		 mov	 ebp, esp
  0c433	83 ec 4c	 sub	 esp, 76			; 0000004cH
  0c436	53		 push	 ebx
  0c437	56		 push	 esi
  0c438	57		 push	 edi
  0c439	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4135 : 	int iMapNumber = 0;

  0c43c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iMapNumber$[ebp], 0

; 4136 : 
; 4137 : 	switch(iBridgeIndex)

  0c443	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0c446	89 45 b4	 mov	 DWORD PTR tv64[ebp], eax
  0c449	83 7d b4 07	 cmp	 DWORD PTR tv64[ebp], 7
  0c44d	77 50		 ja	 SHORT $LN9@GetBridgeM
  0c44f	8b 4d b4	 mov	 ecx, DWORD PTR tv64[ebp]
  0c452	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN13@GetBridgeM[ecx*4]
$LN8@GetBridgeM:

; 4138 : 	{
; 4139 : 	case 0:
; 4140 : 		iMapNumber = MAP_INDEX_BLOODCASTLE1;

  0c459	c7 45 f8 0b 00
	00 00		 mov	 DWORD PTR _iMapNumber$[ebp], 11 ; 0000000bH

; 4141 : 		break;

  0c460	eb 3d		 jmp	 SHORT $LN9@GetBridgeM
$LN7@GetBridgeM:

; 4142 : 	case 1:
; 4143 : 		iMapNumber = MAP_INDEX_BLOODCASTLE2;

  0c462	c7 45 f8 0c 00
	00 00		 mov	 DWORD PTR _iMapNumber$[ebp], 12 ; 0000000cH

; 4144 : 		break;

  0c469	eb 34		 jmp	 SHORT $LN9@GetBridgeM
$LN6@GetBridgeM:

; 4145 : 	case 2:
; 4146 : 		iMapNumber = MAP_INDEX_BLOODCASTLE3;

  0c46b	c7 45 f8 0d 00
	00 00		 mov	 DWORD PTR _iMapNumber$[ebp], 13 ; 0000000dH

; 4147 : 		break;

  0c472	eb 2b		 jmp	 SHORT $LN9@GetBridgeM
$LN5@GetBridgeM:

; 4148 : 	case 3:
; 4149 : 		iMapNumber = MAP_INDEX_BLOODCASTLE4;

  0c474	c7 45 f8 0e 00
	00 00		 mov	 DWORD PTR _iMapNumber$[ebp], 14 ; 0000000eH

; 4150 : 		break;

  0c47b	eb 22		 jmp	 SHORT $LN9@GetBridgeM
$LN4@GetBridgeM:

; 4151 : 	case 4:
; 4152 : 		iMapNumber = MAP_INDEX_BLOODCASTLE5;

  0c47d	c7 45 f8 0f 00
	00 00		 mov	 DWORD PTR _iMapNumber$[ebp], 15 ; 0000000fH

; 4153 : 		break;

  0c484	eb 19		 jmp	 SHORT $LN9@GetBridgeM
$LN3@GetBridgeM:

; 4154 : 	case 5:
; 4155 : 		iMapNumber = MAP_INDEX_BLOODCASTLE6;

  0c486	c7 45 f8 10 00
	00 00		 mov	 DWORD PTR _iMapNumber$[ebp], 16 ; 00000010H

; 4156 : 		break;

  0c48d	eb 10		 jmp	 SHORT $LN9@GetBridgeM
$LN2@GetBridgeM:

; 4157 : 	case 6:
; 4158 : 		iMapNumber = MAP_INDEX_BLOODCASTLE7;

  0c48f	c7 45 f8 11 00
	00 00		 mov	 DWORD PTR _iMapNumber$[ebp], 17 ; 00000011H

; 4159 : 		break;

  0c496	eb 07		 jmp	 SHORT $LN9@GetBridgeM
$LN1@GetBridgeM:

; 4160 : 	case 7:
; 4161 : 		iMapNumber = MAP_INDEX_BLOODCASTLE8;

  0c498	c7 45 f8 34 00
	00 00		 mov	 DWORD PTR _iMapNumber$[ebp], 52 ; 00000034H
$LN9@GetBridgeM:

; 4162 : 		break;
; 4163 : 	}
; 4164 : 
; 4165 : 	return iMapNumber;

  0c49f	8b 45 f8	 mov	 eax, DWORD PTR _iMapNumber$[ebp]

; 4166 : }

  0c4a2	5f		 pop	 edi
  0c4a3	5e		 pop	 esi
  0c4a4	5b		 pop	 ebx
  0c4a5	8b e5		 mov	 esp, ebp
  0c4a7	5d		 pop	 ebp
  0c4a8	c2 04 00	 ret	 4
  0c4ab	90		 npad	 1
$LN13@GetBridgeM:
  0c4ac	00 00 00 00	 DD	 $LN8@GetBridgeM
  0c4b0	00 00 00 00	 DD	 $LN7@GetBridgeM
  0c4b4	00 00 00 00	 DD	 $LN6@GetBridgeM
  0c4b8	00 00 00 00	 DD	 $LN5@GetBridgeM
  0c4bc	00 00 00 00	 DD	 $LN4@GetBridgeM
  0c4c0	00 00 00 00	 DD	 $LN3@GetBridgeM
  0c4c4	00 00 00 00	 DD	 $LN2@GetBridgeM
  0c4c8	00 00 00 00	 DD	 $LN1@GetBridgeM
?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z ENDP		; CBloodCastle::GetBridgeMapNumber
; Function compile flags: /Odtp /ZI
tv64 = -76						; size = 4
_iBridgeIndex$ = -8					; size = 4
_this$ = -4						; size = 4
_iMAP_NUM$ = 8						; size = 4
?GetBridgeIndex@CBloodCastle@@QAEHH@Z PROC		; CBloodCastle::GetBridgeIndex
; _this$ = ecx

; 4170 : {

  0c4d0	55		 push	 ebp
  0c4d1	8b ec		 mov	 ebp, esp
  0c4d3	83 ec 4c	 sub	 esp, 76			; 0000004cH
  0c4d6	53		 push	 ebx
  0c4d7	56		 push	 esi
  0c4d8	57		 push	 edi
  0c4d9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4171 : 	int iBridgeIndex = -1;

  0c4dc	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _iBridgeIndex$[ebp], -1

; 4172 : 
; 4173 : 	switch(iMAP_NUM)

  0c4e3	8b 45 08	 mov	 eax, DWORD PTR _iMAP_NUM$[ebp]
  0c4e6	89 45 b4	 mov	 DWORD PTR tv64[ebp], eax
  0c4e9	8b 4d b4	 mov	 ecx, DWORD PTR tv64[ebp]
  0c4ec	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  0c4ef	89 4d b4	 mov	 DWORD PTR tv64[ebp], ecx
  0c4f2	83 7d b4 29	 cmp	 DWORD PTR tv64[ebp], 41	; 00000029H
  0c4f6	77 57		 ja	 SHORT $LN9@GetBridgeI
  0c4f8	8b 55 b4	 mov	 edx, DWORD PTR tv64[ebp]
  0c4fb	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN13@GetBridgeI[edx]
  0c502	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN14@GetBridgeI[eax*4]
$LN8@GetBridgeI:

; 4174 : 	{
; 4175 : 	case MAP_INDEX_BLOODCASTLE1:
; 4176 : 		iBridgeIndex = 0;

  0c509	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iBridgeIndex$[ebp], 0

; 4177 : 		break;

  0c510	eb 3d		 jmp	 SHORT $LN9@GetBridgeI
$LN7@GetBridgeI:

; 4178 : 	case MAP_INDEX_BLOODCASTLE2:
; 4179 : 		iBridgeIndex = 1;

  0c512	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _iBridgeIndex$[ebp], 1

; 4180 : 		break;

  0c519	eb 34		 jmp	 SHORT $LN9@GetBridgeI
$LN6@GetBridgeI:

; 4181 : 	case MAP_INDEX_BLOODCASTLE3:
; 4182 : 		iBridgeIndex = 2;

  0c51b	c7 45 f8 02 00
	00 00		 mov	 DWORD PTR _iBridgeIndex$[ebp], 2

; 4183 : 		break;

  0c522	eb 2b		 jmp	 SHORT $LN9@GetBridgeI
$LN5@GetBridgeI:

; 4184 : 	case MAP_INDEX_BLOODCASTLE4:
; 4185 : 		iBridgeIndex = 3;

  0c524	c7 45 f8 03 00
	00 00		 mov	 DWORD PTR _iBridgeIndex$[ebp], 3

; 4186 : 		break;

  0c52b	eb 22		 jmp	 SHORT $LN9@GetBridgeI
$LN4@GetBridgeI:

; 4187 : 	case MAP_INDEX_BLOODCASTLE5:
; 4188 : 		iBridgeIndex = 4;

  0c52d	c7 45 f8 04 00
	00 00		 mov	 DWORD PTR _iBridgeIndex$[ebp], 4

; 4189 : 		break;

  0c534	eb 19		 jmp	 SHORT $LN9@GetBridgeI
$LN3@GetBridgeI:

; 4190 : 	case MAP_INDEX_BLOODCASTLE6:
; 4191 : 		iBridgeIndex = 5;

  0c536	c7 45 f8 05 00
	00 00		 mov	 DWORD PTR _iBridgeIndex$[ebp], 5

; 4192 : 		break;

  0c53d	eb 10		 jmp	 SHORT $LN9@GetBridgeI
$LN2@GetBridgeI:

; 4193 : 	case MAP_INDEX_BLOODCASTLE7:
; 4194 : 		iBridgeIndex = 6;

  0c53f	c7 45 f8 06 00
	00 00		 mov	 DWORD PTR _iBridgeIndex$[ebp], 6

; 4195 : 		break;

  0c546	eb 07		 jmp	 SHORT $LN9@GetBridgeI
$LN1@GetBridgeI:

; 4196 : 	case MAP_INDEX_BLOODCASTLE8:
; 4197 : 		iBridgeIndex = 7;

  0c548	c7 45 f8 07 00
	00 00		 mov	 DWORD PTR _iBridgeIndex$[ebp], 7
$LN9@GetBridgeI:

; 4198 : 		break;
; 4199 : 	}
; 4200 : 
; 4201 : 	return iBridgeIndex;

  0c54f	8b 45 f8	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]

; 4202 : }

  0c552	5f		 pop	 edi
  0c553	5e		 pop	 esi
  0c554	5b		 pop	 ebx
  0c555	8b e5		 mov	 esp, ebp
  0c557	5d		 pop	 ebp
  0c558	c2 04 00	 ret	 4
  0c55b	90		 npad	 1
$LN14@GetBridgeI:
  0c55c	00 00 00 00	 DD	 $LN8@GetBridgeI
  0c560	00 00 00 00	 DD	 $LN7@GetBridgeI
  0c564	00 00 00 00	 DD	 $LN6@GetBridgeI
  0c568	00 00 00 00	 DD	 $LN5@GetBridgeI
  0c56c	00 00 00 00	 DD	 $LN4@GetBridgeI
  0c570	00 00 00 00	 DD	 $LN3@GetBridgeI
  0c574	00 00 00 00	 DD	 $LN2@GetBridgeI
  0c578	00 00 00 00	 DD	 $LN1@GetBridgeI
  0c57c	00 00 00 00	 DD	 $LN9@GetBridgeI
$LN13@GetBridgeI:
  0c580	00		 DB	 0
  0c581	01		 DB	 1
  0c582	02		 DB	 2
  0c583	03		 DB	 3
  0c584	04		 DB	 4
  0c585	05		 DB	 5
  0c586	06		 DB	 6
  0c587	08		 DB	 8
  0c588	08		 DB	 8
  0c589	08		 DB	 8
  0c58a	08		 DB	 8
  0c58b	08		 DB	 8
  0c58c	08		 DB	 8
  0c58d	08		 DB	 8
  0c58e	08		 DB	 8
  0c58f	08		 DB	 8
  0c590	08		 DB	 8
  0c591	08		 DB	 8
  0c592	08		 DB	 8
  0c593	08		 DB	 8
  0c594	08		 DB	 8
  0c595	08		 DB	 8
  0c596	08		 DB	 8
  0c597	08		 DB	 8
  0c598	08		 DB	 8
  0c599	08		 DB	 8
  0c59a	08		 DB	 8
  0c59b	08		 DB	 8
  0c59c	08		 DB	 8
  0c59d	08		 DB	 8
  0c59e	08		 DB	 8
  0c59f	08		 DB	 8
  0c5a0	08		 DB	 8
  0c5a1	08		 DB	 8
  0c5a2	08		 DB	 8
  0c5a3	08		 DB	 8
  0c5a4	08		 DB	 8
  0c5a5	08		 DB	 8
  0c5a6	08		 DB	 8
  0c5a7	08		 DB	 8
  0c5a8	08		 DB	 8
  0c5a9	07		 DB	 7
?GetBridgeIndex@CBloodCastle@@QAEHH@Z ENDP		; CBloodCastle::GetBridgeIndex
_TEXT	ENDS
PUBLIC	?GetItemMapNumberFirst@CBloodCastle@@QAEHH@Z	; CBloodCastle::GetItemMapNumberFirst
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv64 = -76						; size = 4
_iMapNumber$ = -8					; size = 4
_this$ = -4						; size = 4
_iMAP_NUM$ = 8						; size = 4
?GetItemMapNumberFirst@CBloodCastle@@QAEHH@Z PROC	; CBloodCastle::GetItemMapNumberFirst
; _this$ = ecx

; 4206 : {

  0c5b0	55		 push	 ebp
  0c5b1	8b ec		 mov	 ebp, esp
  0c5b3	83 ec 4c	 sub	 esp, 76			; 0000004cH
  0c5b6	53		 push	 ebx
  0c5b7	56		 push	 esi
  0c5b8	57		 push	 edi
  0c5b9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4207 : 	int iMapNumber = iMAP_NUM;

  0c5bc	8b 45 08	 mov	 eax, DWORD PTR _iMAP_NUM$[ebp]
  0c5bf	89 45 f8	 mov	 DWORD PTR _iMapNumber$[ebp], eax

; 4208 : 
; 4209 : 	switch(iMAP_NUM)

  0c5c2	8b 45 08	 mov	 eax, DWORD PTR _iMAP_NUM$[ebp]
  0c5c5	89 45 b4	 mov	 DWORD PTR tv64[ebp], eax
  0c5c8	8b 4d b4	 mov	 ecx, DWORD PTR tv64[ebp]
  0c5cb	81 e9 ee 00 00
	00		 sub	 ecx, 238		; 000000eeH
  0c5d1	89 4d b4	 mov	 DWORD PTR tv64[ebp], ecx
  0c5d4	83 7d b4 07	 cmp	 DWORD PTR tv64[ebp], 7
  0c5d8	77 50		 ja	 SHORT $LN9@GetItemMap
  0c5da	8b 55 b4	 mov	 edx, DWORD PTR tv64[ebp]
  0c5dd	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN13@GetItemMap[edx*4]
$LN8@GetItemMap:

; 4210 : 	{
; 4211 : 	case 238:
; 4212 : 		iMapNumber = MAP_INDEX_BLOODCASTLE1;

  0c5e4	c7 45 f8 0b 00
	00 00		 mov	 DWORD PTR _iMapNumber$[ebp], 11 ; 0000000bH

; 4213 : 		break;

  0c5eb	eb 3d		 jmp	 SHORT $LN9@GetItemMap
$LN7@GetItemMap:

; 4214 : 	case 239:
; 4215 : 		iMapNumber = MAP_INDEX_BLOODCASTLE2;

  0c5ed	c7 45 f8 0c 00
	00 00		 mov	 DWORD PTR _iMapNumber$[ebp], 12 ; 0000000cH

; 4216 : 		break;

  0c5f4	eb 34		 jmp	 SHORT $LN9@GetItemMap
$LN6@GetItemMap:

; 4217 : 	case 240:
; 4218 : 		iMapNumber = MAP_INDEX_BLOODCASTLE3;

  0c5f6	c7 45 f8 0d 00
	00 00		 mov	 DWORD PTR _iMapNumber$[ebp], 13 ; 0000000dH

; 4219 : 		break;

  0c5fd	eb 2b		 jmp	 SHORT $LN9@GetItemMap
$LN5@GetItemMap:

; 4220 : 	case 241:
; 4221 : 		iMapNumber = MAP_INDEX_BLOODCASTLE4;

  0c5ff	c7 45 f8 0e 00
	00 00		 mov	 DWORD PTR _iMapNumber$[ebp], 14 ; 0000000eH

; 4222 : 		break;

  0c606	eb 22		 jmp	 SHORT $LN9@GetItemMap
$LN4@GetItemMap:

; 4223 : 	case 242:
; 4224 : 		iMapNumber = MAP_INDEX_BLOODCASTLE5;

  0c608	c7 45 f8 0f 00
	00 00		 mov	 DWORD PTR _iMapNumber$[ebp], 15 ; 0000000fH

; 4225 : 		break;

  0c60f	eb 19		 jmp	 SHORT $LN9@GetItemMap
$LN3@GetItemMap:

; 4226 : 	case 243:
; 4227 : 		iMapNumber = MAP_INDEX_BLOODCASTLE6;

  0c611	c7 45 f8 10 00
	00 00		 mov	 DWORD PTR _iMapNumber$[ebp], 16 ; 00000010H

; 4228 : 		break;

  0c618	eb 10		 jmp	 SHORT $LN9@GetItemMap
$LN2@GetItemMap:

; 4229 : 	case 244:
; 4230 : 		iMapNumber = MAP_INDEX_BLOODCASTLE7;

  0c61a	c7 45 f8 11 00
	00 00		 mov	 DWORD PTR _iMapNumber$[ebp], 17 ; 00000011H

; 4231 : 		break;

  0c621	eb 07		 jmp	 SHORT $LN9@GetItemMap
$LN1@GetItemMap:

; 4232 : 	case 245:
; 4233 : 		iMapNumber = MAP_INDEX_BLOODCASTLE8;

  0c623	c7 45 f8 34 00
	00 00		 mov	 DWORD PTR _iMapNumber$[ebp], 52 ; 00000034H
$LN9@GetItemMap:

; 4234 : 		break;
; 4235 : 	}
; 4236 : 
; 4237 : 	return iMapNumber;

  0c62a	8b 45 f8	 mov	 eax, DWORD PTR _iMapNumber$[ebp]

; 4238 : }

  0c62d	5f		 pop	 edi
  0c62e	5e		 pop	 esi
  0c62f	5b		 pop	 ebx
  0c630	8b e5		 mov	 esp, ebp
  0c632	5d		 pop	 ebp
  0c633	c2 04 00	 ret	 4
  0c636	8b ff		 npad	 2
$LN13@GetItemMap:
  0c638	00 00 00 00	 DD	 $LN8@GetItemMap
  0c63c	00 00 00 00	 DD	 $LN7@GetItemMap
  0c640	00 00 00 00	 DD	 $LN6@GetItemMap
  0c644	00 00 00 00	 DD	 $LN5@GetItemMap
  0c648	00 00 00 00	 DD	 $LN4@GetItemMap
  0c64c	00 00 00 00	 DD	 $LN3@GetItemMap
  0c650	00 00 00 00	 DD	 $LN2@GetItemMap
  0c654	00 00 00 00	 DD	 $LN1@GetItemMap
?GetItemMapNumberFirst@CBloodCastle@@QAEHH@Z ENDP	; CBloodCastle::GetItemMapNumberFirst
_TEXT	ENDS
PUBLIC	?GetItemMapNumberSecond@CBloodCastle@@QAEHH@Z	; CBloodCastle::GetItemMapNumberSecond
; Function compile flags: /Odtp /ZI
_TEXT	SEGMENT
tv64 = -76						; size = 4
_iMapNumber$ = -8					; size = 4
_this$ = -4						; size = 4
_iMAP_NUM$ = 8						; size = 4
?GetItemMapNumberSecond@CBloodCastle@@QAEHH@Z PROC	; CBloodCastle::GetItemMapNumberSecond
; _this$ = ecx

; 4242 : {

  0c660	55		 push	 ebp
  0c661	8b ec		 mov	 ebp, esp
  0c663	83 ec 4c	 sub	 esp, 76			; 0000004cH
  0c666	53		 push	 ebx
  0c667	56		 push	 esi
  0c668	57		 push	 edi
  0c669	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4243 : 	int iMapNumber = iMAP_NUM;

  0c66c	8b 45 08	 mov	 eax, DWORD PTR _iMAP_NUM$[ebp]
  0c66f	89 45 f8	 mov	 DWORD PTR _iMapNumber$[ebp], eax

; 4244 : 
; 4245 : 	switch(iMAP_NUM)

  0c672	8b 45 08	 mov	 eax, DWORD PTR _iMAP_NUM$[ebp]
  0c675	89 45 b4	 mov	 DWORD PTR tv64[ebp], eax
  0c678	8b 4d b4	 mov	 ecx, DWORD PTR tv64[ebp]
  0c67b	81 e9 f6 00 00
	00		 sub	 ecx, 246		; 000000f6H
  0c681	89 4d b4	 mov	 DWORD PTR tv64[ebp], ecx
  0c684	83 7d b4 07	 cmp	 DWORD PTR tv64[ebp], 7
  0c688	77 50		 ja	 SHORT $LN9@GetItemMap@2
  0c68a	8b 55 b4	 mov	 edx, DWORD PTR tv64[ebp]
  0c68d	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN13@GetItemMap@2[edx*4]
$LN8@GetItemMap@2:

; 4246 : 	{
; 4247 : 	case 246:
; 4248 : 		iMapNumber = MAP_INDEX_BLOODCASTLE1;

  0c694	c7 45 f8 0b 00
	00 00		 mov	 DWORD PTR _iMapNumber$[ebp], 11 ; 0000000bH

; 4249 : 		break;

  0c69b	eb 3d		 jmp	 SHORT $LN9@GetItemMap@2
$LN7@GetItemMap@2:

; 4250 : 	case 247:
; 4251 : 		iMapNumber = MAP_INDEX_BLOODCASTLE2;

  0c69d	c7 45 f8 0c 00
	00 00		 mov	 DWORD PTR _iMapNumber$[ebp], 12 ; 0000000cH

; 4252 : 		break;

  0c6a4	eb 34		 jmp	 SHORT $LN9@GetItemMap@2
$LN6@GetItemMap@2:

; 4253 : 	case 248:
; 4254 : 		iMapNumber = MAP_INDEX_BLOODCASTLE3;

  0c6a6	c7 45 f8 0d 00
	00 00		 mov	 DWORD PTR _iMapNumber$[ebp], 13 ; 0000000dH

; 4255 : 		break;

  0c6ad	eb 2b		 jmp	 SHORT $LN9@GetItemMap@2
$LN5@GetItemMap@2:

; 4256 : 	case 249:
; 4257 : 		iMapNumber = MAP_INDEX_BLOODCASTLE4;

  0c6af	c7 45 f8 0e 00
	00 00		 mov	 DWORD PTR _iMapNumber$[ebp], 14 ; 0000000eH

; 4258 : 		break;

  0c6b6	eb 22		 jmp	 SHORT $LN9@GetItemMap@2
$LN4@GetItemMap@2:

; 4259 : 	case 250:
; 4260 : 		iMapNumber = MAP_INDEX_BLOODCASTLE5;

  0c6b8	c7 45 f8 0f 00
	00 00		 mov	 DWORD PTR _iMapNumber$[ebp], 15 ; 0000000fH

; 4261 : 		break;

  0c6bf	eb 19		 jmp	 SHORT $LN9@GetItemMap@2
$LN3@GetItemMap@2:

; 4262 : 	case 251:
; 4263 : 		iMapNumber = MAP_INDEX_BLOODCASTLE6;

  0c6c1	c7 45 f8 10 00
	00 00		 mov	 DWORD PTR _iMapNumber$[ebp], 16 ; 00000010H

; 4264 : 		break;

  0c6c8	eb 10		 jmp	 SHORT $LN9@GetItemMap@2
$LN2@GetItemMap@2:

; 4265 : 	case 252:
; 4266 : 		iMapNumber = MAP_INDEX_BLOODCASTLE7;

  0c6ca	c7 45 f8 11 00
	00 00		 mov	 DWORD PTR _iMapNumber$[ebp], 17 ; 00000011H

; 4267 : 		break;

  0c6d1	eb 07		 jmp	 SHORT $LN9@GetItemMap@2
$LN1@GetItemMap@2:

; 4268 : 	case 253:
; 4269 : 		iMapNumber = MAP_INDEX_BLOODCASTLE8;

  0c6d3	c7 45 f8 34 00
	00 00		 mov	 DWORD PTR _iMapNumber$[ebp], 52 ; 00000034H
$LN9@GetItemMap@2:

; 4270 : 		break;
; 4271 : 	}
; 4272 : 
; 4273 : 	return iMapNumber;

  0c6da	8b 45 f8	 mov	 eax, DWORD PTR _iMapNumber$[ebp]

; 4274 : }

  0c6dd	5f		 pop	 edi
  0c6de	5e		 pop	 esi
  0c6df	5b		 pop	 ebx
  0c6e0	8b e5		 mov	 esp, ebp
  0c6e2	5d		 pop	 ebp
  0c6e3	c2 04 00	 ret	 4
  0c6e6	8b ff		 npad	 2
$LN13@GetItemMap@2:
  0c6e8	00 00 00 00	 DD	 $LN8@GetItemMap@2
  0c6ec	00 00 00 00	 DD	 $LN7@GetItemMap@2
  0c6f0	00 00 00 00	 DD	 $LN6@GetItemMap@2
  0c6f4	00 00 00 00	 DD	 $LN5@GetItemMap@2
  0c6f8	00 00 00 00	 DD	 $LN4@GetItemMap@2
  0c6fc	00 00 00 00	 DD	 $LN3@GetItemMap@2
  0c700	00 00 00 00	 DD	 $LN2@GetItemMap@2
  0c704	00 00 00 00	 DD	 $LN1@GetItemMap@2
?GetItemMapNumberSecond@CBloodCastle@@QAEHH@Z ENDP	; CBloodCastle::GetItemMapNumberSecond
_TEXT	ENDS
PUBLIC	??0?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@V?$allocator@UBLOODCASTLE_START_TIME@@@1@@Z ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >
PUBLIC	??0?$allocator@UBLOODCASTLE_START_TIME@@@std@@QAE@XZ ; std::allocator<BLOODCASTLE_START_TIME>::allocator<BLOODCASTLE_START_TIME>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\list
;	COMDAT ??0?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T239602 = -72						; size = 4
_this$ = -4						; size = 4
??0?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@XZ PROC ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >, COMDAT
; _this$ = ecx

; 607  : 		{	// construct empty list

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	51		 push	 ecx
  0000d	8b cc		 mov	 ecx, esp
  0000f	89 65 b8	 mov	 DWORD PTR $T239602[ebp], esp
  00012	e8 00 00 00 00	 call	 ??0?$allocator@UBLOODCASTLE_START_TIME@@@std@@QAE@XZ ; std::allocator<BLOODCASTLE_START_TIME>::allocator<BLOODCASTLE_START_TIME>
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@V?$allocator@UBLOODCASTLE_START_TIME@@@1@@Z ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >

; 608  : 		}

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@XZ ENDP ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >
_TEXT	ENDS
PUBLIC	??1?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@XZ ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::~_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >
PUBLIC	?_Tidy@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEXXZ ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??1?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@XZ PROC ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::~list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >, COMDAT
; _this$ = ecx

; 769  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 770  : 		_Tidy();

  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?_Tidy@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEXXZ ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Tidy

; 771  : 		}

  0003a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??1?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@XZ ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::~_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >
  00049	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@XZ ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::~_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >
__ehhandler$??1?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@XZ ENDP ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::~list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >
PUBLIC	??0?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE@PAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@PBV?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@@Z ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >
PUBLIC	?_Nextnode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@@Z ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Nextnode
; Function compile flags: /Odtp /ZI
;	COMDAT ?begin@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@2@XZ PROC ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 782  : 		return (iterator(this->_Nextnode(this->_Myhead), this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	52		 push	 edx
  00016	e8 00 00 00 00	 call	 ?_Nextnode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@@Z ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Nextnode
  0001b	83 c4 04	 add	 esp, 4
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	50		 push	 eax
  00021	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00024	e8 00 00 00 00	 call	 ??0?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE@PAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@PBV?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@@Z ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >
  00029	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 783  : 		}

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
?begin@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@2@XZ ENDP ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::begin
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?end@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@2@XZ PROC ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 792  : 		return (iterator(this->_Myhead, this));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	52		 push	 edx
  00016	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00019	e8 00 00 00 00	 call	 ??0?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE@PAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@PBV?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@@Z ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >
  0001e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 793  : 		}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?end@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@2@XZ ENDP ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::end
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?size@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QBEIXZ PROC ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::size, COMDAT
; _this$ = ecx

; 876  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 877  : 		return (this->_Mysize);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 878  : 		}

  00012	5f		 pop	 edi
  00013	5e		 pop	 esi
  00014	5b		 pop	 ebx
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?size@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QBEIXZ ENDP ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::size
_TEXT	ENDS
PUBLIC	?_Insert@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEXV?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@2@ABUBLOODCASTLE_START_TIME@@@Z ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Insert
; Function compile flags: /Odtp /ZI
;	COMDAT ?push_back@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEXABUBLOODCASTLE_START_TIME@@@Z
_TEXT	SEGMENT
$T239621 = -76						; size = 4
$T239622 = -72						; size = 4
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEXABUBLOODCASTLE_START_TIME@@@Z PROC ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::push_back, COMDAT
; _this$ = ecx

; 926  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 927  : 		_Insert(end(), _Val);

  0000c	8d 45 b8	 lea	 eax, DWORD PTR $T239622[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?end@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@2@XZ ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::end
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d b4	 mov	 DWORD PTR $T239621[ebp], ecx
  0001d	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  00020	52		 push	 edx
  00021	8b 45 b4	 mov	 eax, DWORD PTR $T239621[ebp]
  00024	50		 push	 eax
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	e8 00 00 00 00	 call	 ?_Insert@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEXV?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@2@ABUBLOODCASTLE_START_TIME@@@Z ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Insert

; 928  : 		}

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
?push_back@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEXABUBLOODCASTLE_START_TIME@@@Z ENDP ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::push_back
_TEXT	ENDS
PUBLIC	??0?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE@XZ ; std::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE@XZ PROC ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >, COMDAT
; _this$ = ecx

; 336  : 	_List_iterator()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE@XZ ; std::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >

; 337  : 		{	// construct with null node
; 338  : 		}

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >
_TEXT	ENDS
PUBLIC	??D?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBEABUBLOODCASTLE_START_TIME@@XZ ; std::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator*
; Function compile flags: /Odtp /ZI
;	COMDAT ??D?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBEAAUBLOODCASTLE_START_TIME@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBEAAUBLOODCASTLE_START_TIME@@XZ PROC ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator*, COMDAT
; _this$ = ecx

; 359  : 		{	// return designated value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 360  : 		return ((reference)**(_Mybase *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBEABUBLOODCASTLE_START_TIME@@XZ ; std::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator*

; 361  : 		}

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??D?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBEAAUBLOODCASTLE_START_TIME@@XZ ENDP ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator*
_TEXT	ENDS
PUBLIC	??E?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator++
; Function compile flags: /Odtp /ZI
;	COMDAT ??E?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator++, COMDAT
; _this$ = ecx

; 369  : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 370  : 		++(*(_Mybase *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??E?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator++

; 371  : 		return (*this);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 372  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??E?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator++
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??E?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator++, COMDAT
; _this$ = ecx

; 375  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 376  : 		_Myiter _Tmp = *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	89 4d f8	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 377  : 		++*this;

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??E?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator++

; 378  : 		return (_Tmp);

  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Tmp$[ebp]
  00022	89 08		 mov	 DWORD PTR [eax], ecx
  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 379  : 		}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
??E?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator++
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??8?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator==, COMDAT
; _this$ = ecx

; 281  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 282  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 283  : 		if (this->_Getcont() == 0
; 284  : 			|| this->_Getcont() != _Right._Getcont())
; 285  : 			{	// report error
; 286  : 			_DEBUG_ERROR("list iterators incompatible");
; 287  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 288  : 			}
; 289  : 
; 290  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 291  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 292  : 			&& this->_Getcont() == _Right._Getcont());
; 293  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 294  : 
; 295  : 		return (this->_Ptr == _Right._Ptr);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00012	8b 10		 mov	 edx, DWORD PTR [eax]
  00014	33 c0		 xor	 eax, eax
  00016	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00018	0f 94 c0	 sete	 al

; 296  : 		}

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??8?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator==
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??9?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator!=, COMDAT
; _this$ = ecx

; 299  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 300  : 		return (!(*this == _Right));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??8?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator==
  00018	0f b6 c0	 movzx	 eax, al
  0001b	f7 d8		 neg	 eax
  0001d	1b c0		 sbb	 eax, eax
  0001f	83 c0 01	 add	 eax, 1

; 301  : 		}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??9?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator!=
_TEXT	ENDS
PUBLIC	?_Incsize@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEXI@Z ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Incsize
PUBLIC	?_Buynode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@0ABUBLOODCASTLE_START_TIME@@@Z ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Buynode
PUBLIC	?_Prevnode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@@Z ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Prevnode
PUBLIC	?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@XZ ; std::_List_unchecked_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >,std::_Iterator_base0>::_Mynode
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Insert@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEXV?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@2@ABUBLOODCASTLE_START_TIME@@@Z
_TEXT	SEGMENT
__Newnode$ = -12					; size = 4
__Pnode$ = -8						; size = 4
_this$ = -4						; size = 4
__Where$ = 8						; size = 4
__Val$ = 12						; size = 4
?_Insert@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEXV?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@2@ABUBLOODCASTLE_START_TIME@@@Z PROC ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Insert, COMDAT
; _this$ = ecx

; 967  : 		{	// insert _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 968  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 969  : 		if (_Where._Getcont() != this)
; 970  : 			_DEBUG_ERROR("list insert iterator outside range");
; 971  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 972  : 
; 973  : 		_Nodeptr _Pnode = _Where._Mynode();

  0000c	8d 4d 08	 lea	 ecx, DWORD PTR __Where$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@XZ ; std::_List_unchecked_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >,std::_Iterator_base0>::_Mynode
  00014	89 45 f8	 mov	 DWORD PTR __Pnode$[ebp], eax

; 974  : 		_Nodeptr _Newnode =
; 975  : 			this->_Buynode(_Pnode, this->_Prevnode(_Pnode), _Val);

  00017	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ?_Prevnode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@@Z ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Prevnode
  00024	83 c4 04	 add	 esp, 4
  00027	8b 10		 mov	 edx, DWORD PTR [eax]
  00029	52		 push	 edx
  0002a	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0002d	50		 push	 eax
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ?_Buynode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@0ABUBLOODCASTLE_START_TIME@@@Z ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Buynode
  00036	89 45 f4	 mov	 DWORD PTR __Newnode$[ebp], eax

; 976  : 		_Incsize(1);

  00039	6a 01		 push	 1
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ?_Incsize@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEXI@Z ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Incsize

; 977  : 		this->_Prevnode(_Pnode) = _Newnode;

  00043	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ?_Prevnode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@@Z ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Prevnode
  0004c	83 c4 04	 add	 esp, 4
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00052	89 08		 mov	 DWORD PTR [eax], ecx

; 978  : 		this->_Nextnode(this->_Prevnode(_Newnode)) = _Newnode;

  00054	8b 45 f4	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 ?_Prevnode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@@Z ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Prevnode
  0005d	83 c4 04	 add	 esp, 4
  00060	8b 08		 mov	 ecx, DWORD PTR [eax]
  00062	51		 push	 ecx
  00063	e8 00 00 00 00	 call	 ?_Nextnode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@@Z ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Nextnode
  00068	83 c4 04	 add	 esp, 4
  0006b	8b 55 f4	 mov	 edx, DWORD PTR __Newnode$[ebp]
  0006e	89 10		 mov	 DWORD PTR [eax], edx

; 979  : 		}

  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	5b		 pop	 ebx
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c2 08 00	 ret	 8
?_Insert@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEXV?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@2@ABUBLOODCASTLE_START_TIME@@@Z ENDP ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Insert
_TEXT	ENDS
PUBLIC	?clear@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEXXZ ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::clear
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Tidy@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEXXZ PROC ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Tidy, COMDAT
; _this$ = ecx

; 1496 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1497 : 		clear();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?clear@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEXXZ ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::clear

; 1498 : 		}

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?_Tidy@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEXXZ ENDP ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Tidy
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@I@Z ; std::allocator<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>::allocate
PUBLIC	??0?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@V?$allocator@UBLOODCASTLE_START_TIME@@@1@@Z ; std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >
PUBLIC	??0?$allocator@UBLOODCASTLE_START_TIME@@@std@@QAE@ABV01@@Z ; std::allocator<BLOODCASTLE_START_TIME>::allocator<BLOODCASTLE_START_TIME>
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@V?$allocator@UBLOODCASTLE_START_TIME@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@V?$allocator@UBLOODCASTLE_START_TIME@@@1@@Z PROC ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >, COMDAT
; _this$ = ecx

; 493  : 		{	// construct base, and allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	51		 push	 ecx
  0000d	8b cc		 mov	 ecx, esp
  0000f	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??0?$allocator@UBLOODCASTLE_START_TIME@@@std@@QAE@ABV01@@Z ; std::allocator<BLOODCASTLE_START_TIME>::allocator<BLOODCASTLE_START_TIME>
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ??0?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@V?$allocator@UBLOODCASTLE_START_TIME@@@1@@Z ; std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >

; 494  : 		this->_Mysize = 0;

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 495  : 		this->_Myhead = this->_Alnod.allocate(1);

  0002a	6a 01		 push	 1
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	83 c1 08	 add	 ecx, 8
  00032	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@I@Z ; std::allocator<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>::allocate
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	89 01		 mov	 DWORD PTR [ecx], eax

; 496  : 		this->_Nextnode(this->_Myhead) = this->_Myhead;

  0003c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00041	51		 push	 ecx
  00042	e8 00 00 00 00	 call	 ?_Nextnode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@@Z ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Nextnode
  00047	83 c4 04	 add	 esp, 4
  0004a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0004d	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0004f	89 08		 mov	 DWORD PTR [eax], ecx

; 497  : 		this->_Prevnode(this->_Myhead) = this->_Myhead;

  00051	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00054	8b 08		 mov	 ecx, DWORD PTR [eax]
  00056	51		 push	 ecx
  00057	e8 00 00 00 00	 call	 ?_Prevnode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@@Z ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Prevnode
  0005c	83 c4 04	 add	 esp, 4
  0005f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00062	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00064	89 08		 mov	 DWORD PTR [eax], ecx

; 498  : 		}

  00066	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi
  0006b	5b		 pop	 ebx
  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c2 04 00	 ret	 4
??0?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@V?$allocator@UBLOODCASTLE_START_TIME@@@1@@Z ENDP ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@I@Z ; std::allocator<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>::deallocate
; Function compile flags: /Odtp /ZI
;	COMDAT ??1?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@XZ PROC ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::~_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >, COMDAT
; _this$ = ecx

; 501  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 502  : 		this->_Alnod.deallocate(this->_Myhead, 1);

  0000c	6a 01		 push	 1
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	83 c1 08	 add	 ecx, 8
  0001a	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@I@Z ; std::allocator<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>::deallocate

; 503  : 		}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??1?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@XZ ENDP ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::~_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Nextnode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Nextnode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@@Z PROC ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Nextnode, COMDAT

; 560  : 		{	// return reference to successor pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 561  : 		return ((_Nodepref)(*_Pnode)._Next);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 562  : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Nextnode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@@Z ENDP ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Nextnode
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UBLOODCASTLE_START_TIME@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@UBLOODCASTLE_START_TIME@@@std@@QAE@XZ PROC ; std::allocator<BLOODCASTLE_START_TIME>::allocator<BLOODCASTLE_START_TIME>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@UBLOODCASTLE_START_TIME@@@std@@QAE@XZ ENDP ; std::allocator<BLOODCASTLE_START_TIME>::allocator<BLOODCASTLE_START_TIME>
_TEXT	ENDS
PUBLIC	??0?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE@PAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@PBV?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@@Z ; std::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\list
;	COMDAT ??0?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE@PAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@PBV?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE@PAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@PBV?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@@Z PROC ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >, COMDAT
; _this$ = ecx

; 342  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Plist$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE@PAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@PBV?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@@Z ; std::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >

; 343  : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE@PAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@PBV?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@@Z ENDP ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >
_TEXT	ENDS
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ; std::_List_unchecked_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >,std::_Iterator_base0>
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE@XZ PROC ; std::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >, COMDAT
; _this$ = ecx

; 179  : 		{	// construct with null node pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0?$_List_unchecked_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ; std::_List_unchecked_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >,std::_Iterator_base0>

; 180  : 		}

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >
_TEXT	ENDS
PUBLIC	?_Myval@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@SAAAUBLOODCASTLE_START_TIME@@PAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@@Z ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Myval
; Function compile flags: /Odtp /ZI
;	COMDAT ??D?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBEABUBLOODCASTLE_START_TIME@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBEABUBLOODCASTLE_START_TIME@@XZ PROC ; std::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator*, COMDAT
; _this$ = ecx

; 201  : 		{	// return designated value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 202  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 203  : 		if (this->_Getcont() == 0
; 204  : 			|| this->_Ptr == 0
; 205  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 206  : 			{	// report error
; 207  : 			_DEBUG_ERROR("list iterator not dereferencable");
; 208  : 			_SCL_SECURE_OUT_OF_RANGE;
; 209  : 			}
; 210  : 
; 211  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 212  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 213  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 214  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 215  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 216  : 
; 217  : 		return (_Mylist::_Myval(this->_Ptr));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ?_Myval@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@SAAAUBLOODCASTLE_START_TIME@@PAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@@Z ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Myval
  00017	83 c4 04	 add	 esp, 4

; 218  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??D?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBEABUBLOODCASTLE_START_TIME@@XZ ENDP ; std::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator*
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??E?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator++, COMDAT
; _this$ = ecx

; 221  : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 222  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 223  : 		if (this->_Getcont() == 0
; 224  : 			|| this->_Ptr == 0
; 225  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 226  : 			{	// report error
; 227  : 			_DEBUG_ERROR("list iterator not incrementable");
; 228  : 			_SCL_SECURE_OUT_OF_RANGE;
; 229  : 			}
; 230  : 
; 231  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 232  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 233  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 234  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 235  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 236  : 
; 237  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ?_Nextnode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@@Z ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Nextnode
  00017	83 c4 04	 add	 esp, 4
  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	8b 00		 mov	 eax, DWORD PTR [eax]
  0001f	89 02		 mov	 DWORD PTR [edx], eax

; 238  : 		return (*this);

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 239  : 		}

  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??E?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator++
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@@std@@YAXAAV?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@0@PAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@0@@Z ; std::_Dest_val<std::allocator<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>,std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>
; Function compile flags: /Odtp /ZI
;	COMDAT ?clear@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Pnode$ = -12						; size = 4
__Pnext$ = -8						; size = 4
_this$ = -4						; size = 4
?clear@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEXXZ PROC ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::clear, COMDAT
; _this$ = ecx

; 1096 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1097 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1098 : 		this->_Orphan_ptr(*this, 0);
; 1099 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1100 : 
; 1101 : 		_Nodeptr _Pnext;
; 1102 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ?_Nextnode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@@Z ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Nextnode
  00017	83 c4 04	 add	 esp, 4
  0001a	8b 10		 mov	 edx, DWORD PTR [eax]
  0001c	89 55 f4	 mov	 DWORD PTR __Pnode$[ebp], edx

; 1103 : 		this->_Nextnode(this->_Myhead) = this->_Myhead;

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b 08		 mov	 ecx, DWORD PTR [eax]
  00024	51		 push	 ecx
  00025	e8 00 00 00 00	 call	 ?_Nextnode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@@Z ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Nextnode
  0002a	83 c4 04	 add	 esp, 4
  0002d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00030	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00032	89 08		 mov	 DWORD PTR [eax], ecx

; 1104 : 		this->_Prevnode(this->_Myhead) = this->_Myhead;

  00034	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00037	8b 08		 mov	 ecx, DWORD PTR [eax]
  00039	51		 push	 ecx
  0003a	e8 00 00 00 00	 call	 ?_Prevnode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@@Z ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Prevnode
  0003f	83 c4 04	 add	 esp, 4
  00042	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00045	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00047	89 08		 mov	 DWORD PTR [eax], ecx

; 1105 : 		this->_Mysize = 0;

  00049	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00053	eb 06		 jmp	 SHORT $LN3@clear
$LN2@clear:

; 1106 : 
; 1107 : 		for (; _Pnode != this->_Myhead; _Pnode = _Pnext)

  00055	8b 45 f8	 mov	 eax, DWORD PTR __Pnext$[ebp]
  00058	89 45 f4	 mov	 DWORD PTR __Pnode$[ebp], eax
$LN3@clear:
  0005b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8b 4d f4	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00061	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00063	74 37		 je	 SHORT $LN4@clear

; 1108 : 			{	// delete an element
; 1109 : 			_Pnext = this->_Nextnode(_Pnode);

  00065	8b 45 f4	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 ?_Nextnode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@@Z ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Nextnode
  0006e	83 c4 04	 add	 esp, 4
  00071	8b 08		 mov	 ecx, DWORD PTR [eax]
  00073	89 4d f8	 mov	 DWORD PTR __Pnext$[ebp], ecx

; 1110 : 
; 1111 : 			_Dest_val(this->_Alnod, _Pnode);

  00076	8b 45 f4	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00079	50		 push	 eax
  0007a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	83 c1 08	 add	 ecx, 8
  00080	51		 push	 ecx
  00081	e8 00 00 00 00	 call	 ??$_Dest_val@V?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@@std@@YAXAAV?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@0@PAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@0@@Z ; std::_Dest_val<std::allocator<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>,std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>
  00086	83 c4 08	 add	 esp, 8

; 1112 : 			this->_Alnod.deallocate(_Pnode, 1);

  00089	6a 01		 push	 1
  0008b	8b 45 f4	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0008e	50		 push	 eax
  0008f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00092	83 c1 08	 add	 ecx, 8
  00095	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@I@Z ; std::allocator<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>::deallocate

; 1113 : 			}

  0009a	eb b9		 jmp	 SHORT $LN2@clear
$LN4@clear:

; 1114 : 		}

  0009c	5f		 pop	 edi
  0009d	5e		 pop	 esi
  0009e	5b		 pop	 ebx
  0009f	8b e5		 mov	 esp, ebp
  000a1	5d		 pop	 ebp
  000a2	c3		 ret	 0
?clear@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEXXZ ENDP ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::clear
_TEXT	ENDS
PUBLIC	??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?max_size@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QBEIXZ ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::max_size
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
;	COMDAT ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@ DB 'list<T> too long', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ?_Incsize@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Incsize@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEXI@Z PROC ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Incsize, COMDAT
; _this$ = ecx

; 1519 : 		{	// alter element count, with checking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1520 : 		if (max_size() - this->_Mysize - 1 < _Count)

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?max_size@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QBEIXZ ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::max_size
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  0001a	83 e8 01	 sub	 eax, 1
  0001d	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  00020	73 0a		 jae	 SHORT $LN1@Incsize

; 1521 : 			_Xlength_error("list<T> too long");

  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  00027	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN1@Incsize:

; 1522 : 		this->_Mysize += _Count;

  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00032	03 4d 08	 add	 ecx, DWORD PTR __Count$[ebp]
  00035	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00038	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN3@Incsize:

; 1523 : 		}

  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
?_Incsize@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEXI@Z ENDP ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Incsize
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@UBLOODCASTLE_START_TIME@@ABU3@@std@@YAXAAV?$allocator@UBLOODCASTLE_START_TIME@@@0@PAUBLOODCASTLE_START_TIME@@ABU2@@Z ; std::_Cons_val<std::allocator<BLOODCASTLE_START_TIME>,BLOODCASTLE_START_TIME,BLOODCASTLE_START_TIME const &>
PUBLIC	??$addressof@UBLOODCASTLE_START_TIME@@@std@@YAPAUBLOODCASTLE_START_TIME@@AAU1@@Z ; std::addressof<BLOODCASTLE_START_TIME>
EXTRN	__CxxThrowException@8:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@0ABUBLOODCASTLE_START_TIME@@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@0ABUBLOODCASTLE_START_TIME@@@Z$0
__unwindtable$?_Buynode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@0ABUBLOODCASTLE_START_TIME@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Buynode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@0ABUBLOODCASTLE_START_TIME@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@0ABUBLOODCASTLE_START_TIME@@@Z$2
__ehfuncinfo$?_Buynode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@0ABUBLOODCASTLE_START_TIME@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Buynode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@0ABUBLOODCASTLE_START_TIME@@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@0ABUBLOODCASTLE_START_TIME@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@0ABUBLOODCASTLE_START_TIME@@@Z
_TEXT	SEGMENT
tv134 = -96						; size = 4
tv133 = -92						; size = 4
tv132 = -92						; size = 4
tv131 = -92						; size = 4
__Pnode$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Next$ = 8						; size = 4
__Prev$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Buynode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@0ABUBLOODCASTLE_START_TIME@@@Z PROC ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Buynode, COMDAT
; _this$ = ecx

; 507  : 		{	// allocate a node and set links and value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Buynode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@0ABUBLOODCASTLE_START_TIME@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 50	 sub	 esp, 80			; 00000050H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 508  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

  0002f	6a 01		 push	 1
  00031	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	83 c1 08	 add	 ecx, 8
  00037	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@I@Z ; std::allocator<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>::allocate
  0003c	89 45 e8	 mov	 DWORD PTR __Pnode$[ebp], eax

; 509  : 
; 510  : 		_TRY_BEGIN

  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 511  : 		this->_Nextnode(_Pnode) = _Next;

  00046	8b 45 e8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 ?_Nextnode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@@Z ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Nextnode
  0004f	83 c4 04	 add	 esp, 4
  00052	89 45 a4	 mov	 DWORD PTR tv131[ebp], eax
  00055	8b 4d a4	 mov	 ecx, DWORD PTR tv131[ebp]
  00058	8b 55 08	 mov	 edx, DWORD PTR __Next$[ebp]
  0005b	89 11		 mov	 DWORD PTR [ecx], edx

; 512  : 		this->_Prevnode(_Pnode) = _Prev;

  0005d	8b 45 e8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00060	50		 push	 eax
  00061	e8 00 00 00 00	 call	 ?_Prevnode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@@Z ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Prevnode
  00066	83 c4 04	 add	 esp, 4
  00069	89 45 a4	 mov	 DWORD PTR tv132[ebp], eax
  0006c	8b 4d a4	 mov	 ecx, DWORD PTR tv132[ebp]
  0006f	8b 55 0c	 mov	 edx, DWORD PTR __Prev$[ebp]
  00072	89 11		 mov	 DWORD PTR [ecx], edx

; 513  : 		_Cons_val(this->_Alval, _STD addressof(this->_Myval(_Pnode)), _Val);

  00074	8b 45 e8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 ?_Myval@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@SAAAUBLOODCASTLE_START_TIME@@PAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@@Z ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Myval
  0007d	83 c4 04	 add	 esp, 4
  00080	89 45 a4	 mov	 DWORD PTR tv133[ebp], eax
  00083	8b 4d a4	 mov	 ecx, DWORD PTR tv133[ebp]
  00086	51		 push	 ecx
  00087	e8 00 00 00 00	 call	 ??$addressof@UBLOODCASTLE_START_TIME@@@std@@YAPAUBLOODCASTLE_START_TIME@@AAU1@@Z ; std::addressof<BLOODCASTLE_START_TIME>
  0008c	83 c4 04	 add	 esp, 4
  0008f	89 45 a0	 mov	 DWORD PTR tv134[ebp], eax
  00092	8b 55 10	 mov	 edx, DWORD PTR __Val$[ebp]
  00095	52		 push	 edx
  00096	8b 45 a0	 mov	 eax, DWORD PTR tv134[ebp]
  00099	50		 push	 eax
  0009a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0009d	83 c1 09	 add	 ecx, 9
  000a0	51		 push	 ecx
  000a1	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@UBLOODCASTLE_START_TIME@@ABU3@@std@@YAXAAV?$allocator@UBLOODCASTLE_START_TIME@@@0@PAUBLOODCASTLE_START_TIME@@ABU2@@Z ; std::_Cons_val<std::allocator<BLOODCASTLE_START_TIME>,BLOODCASTLE_START_TIME,BLOODCASTLE_START_TIME const &>
  000a6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a9	eb 27		 jmp	 SHORT $LN4@Buynode
__catch$?_Buynode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@0ABUBLOODCASTLE_START_TIME@@@Z$0:

; 514  : 		_CATCH_ALL
; 515  : 		this->_Alnod.deallocate(_Pnode, 1);

  000ab	6a 01		 push	 1
  000ad	8b 45 e8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  000b0	50		 push	 eax
  000b1	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000b4	83 c1 08	 add	 ecx, 8
  000b7	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@I@Z ; std::allocator<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>::deallocate

; 516  : 		_RERAISE;

  000bc	6a 00		 push	 0
  000be	6a 00		 push	 0
  000c0	e8 00 00 00 00	 call	 __CxxThrowException@8

; 517  : 		_CATCH_END

  000c5	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000cc	b8 00 00 00 00	 mov	 eax, __tryend$?_Buynode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@0ABUBLOODCASTLE_START_TIME@@@Z$1
  000d1	c3		 ret	 0
$LN4@Buynode:
  000d2	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Buynode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@0ABUBLOODCASTLE_START_TIME@@@Z$1:

; 518  : 
; 519  : 		return (_Pnode);

  000d9	8b 45 e8	 mov	 eax, DWORD PTR __Pnode$[ebp]
$LN3@Buynode:

; 520  : 		}

  000dc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000df	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e6	59		 pop	 ecx
  000e7	5f		 pop	 edi
  000e8	5e		 pop	 esi
  000e9	5b		 pop	 ebx
  000ea	8b e5		 mov	 esp, ebp
  000ec	5d		 pop	 ebp
  000ed	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buynode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@0ABUBLOODCASTLE_START_TIME@@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a 9c	 mov	 ecx, DWORD PTR [edx-100]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Buynode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@0ABUBLOODCASTLE_START_TIME@@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@0ABUBLOODCASTLE_START_TIME@@@Z ENDP ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Buynode
; Function compile flags: /Odtp /ZI
;	COMDAT ?_Prevnode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Prevnode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@@Z PROC ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Prevnode, COMDAT

; 565  : 		{	// return reference to predecessor pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 566  : 		return ((_Nodepref)(*_Pnode)._Prev);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	83 c0 04	 add	 eax, 4

; 567  : 		}

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Prevnode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@@Z ENDP ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Prevnode
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Myval@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@SAAAUBLOODCASTLE_START_TIME@@PAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@SAAAUBLOODCASTLE_START_TIME@@PAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@@Z PROC ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Myval, COMDAT

; 570  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 571  : 		return ((reference)(*_Pnode)._Myval);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	83 c0 08	 add	 eax, 8

; 572  : 		}

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Myval@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@SAAAUBLOODCASTLE_START_TIME@@PAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@@Z ENDP ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Myval
_TEXT	ENDS
PUBLIC	??$?0UBLOODCASTLE_START_TIME@@@?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE@ABV?$allocator@UBLOODCASTLE_START_TIME@@@1@@Z ; std::allocator<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>::allocator<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node><BLOODCASTLE_START_TIME>
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@V?$allocator@UBLOODCASTLE_START_TIME@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@V?$allocator@UBLOODCASTLE_START_TIME@@@1@@Z PROC ; std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >, COMDAT
; _this$ = ecx

; 438  : 		{	// construct allocators from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 08	 add	 ecx, 8
  00016	e8 00 00 00 00	 call	 ??$?0UBLOODCASTLE_START_TIME@@@?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE@ABV?$allocator@UBLOODCASTLE_START_TIME@@@1@@Z ; std::allocator<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>::allocator<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node><BLOODCASTLE_START_TIME>
  0001b	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	83 c1 09	 add	 ecx, 9
  00025	e8 00 00 00 00	 call	 ??0?$allocator@UBLOODCASTLE_START_TIME@@@std@@QAE@ABV01@@Z ; std::allocator<BLOODCASTLE_START_TIME>::allocator<BLOODCASTLE_START_TIME>

; 439  : 		}

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??0?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@V?$allocator@UBLOODCASTLE_START_TIME@@@1@@Z ENDP ; std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UBLOODCASTLE_START_TIME@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@UBLOODCASTLE_START_TIME@@@std@@QAE@ABV01@@Z PROC ; std::allocator<BLOODCASTLE_START_TIME>::allocator<BLOODCASTLE_START_TIME>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$allocator@UBLOODCASTLE_START_TIME@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<BLOODCASTLE_START_TIME>::allocator<BLOODCASTLE_START_TIME>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@I@Z PROC ; std::allocator<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 182  : 		::operator delete(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4

; 183  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@I@Z ENDP ; std::allocator<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>
; Function compile flags: /Odtp /ZI
;	COMDAT ?allocate@?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@I@Z PROC ; std::allocator<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 187  : 		return (_Allocate(_Count, (pointer)0));

  0000c	6a 00		 push	 0
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Allocate@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>
  00017	83 c4 08	 add	 esp, 8

; 188  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?allocate@?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@I@Z ENDP ; std::allocator<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@PBV?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >,std::_Iterator_base0>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\list
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE@PAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@PBV?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE@PAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@PBV?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@@Z PROC ; std::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >, COMDAT
; _this$ = ecx

; 184  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Plist$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_List_unchecked_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@PBV?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >,std::_Iterator_base0>

; 185  : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE@PAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@PBV?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@@Z ENDP ; std::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_List_unchecked_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 36   : 		{	// construct with null node pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 37   : 		}

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0?$_List_unchecked_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >,std::_Iterator_base0>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 92   : 		{	// return node pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 93   : 		return (_Ptr);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]

; 94   : 		}

  00011	5f		 pop	 edi
  00012	5e		 pop	 esi
  00013	5b		 pop	 ebx
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UBLOODCASTLE_START_TIME@@@std@@QBEIXZ ; std::allocator<BLOODCASTLE_START_TIME>::max_size
; Function compile flags: /Odtp /ZI
;	COMDAT ?max_size@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QBEIXZ PROC ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::max_size, COMDAT
; _this$ = ecx

; 881  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 882  : 		return (this->_Alval.max_size());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 09	 add	 ecx, 9
  00012	e8 00 00 00 00	 call	 ?max_size@?$allocator@UBLOODCASTLE_START_TIME@@@std@@QBEIXZ ; std::allocator<BLOODCASTLE_START_TIME>::max_size

; 883  : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?max_size@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QBEIXZ ENDP ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::max_size
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@PBV?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_unchecked_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@PBV?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 41   : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 42   : 		this->_Adopt(_Plist);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Plist$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 43   : 		}

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_List_unchecked_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@PBV?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >,std::_Iterator_base0>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UBLOODCASTLE_START_TIME@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -76						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@UBLOODCASTLE_START_TIME@@@std@@QBEIXZ PROC ; std::allocator<BLOODCASTLE_START_TIME>::max_size, COMDAT
; _this$ = ecx

; 217  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  0000c	c7 45 f8 ff ff
	ff 1f		 mov	 DWORD PTR __Count$[ebp], 536870911 ; 1fffffffH

; 219  : 		return (0 < _Count ? _Count : 1);

  00013	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00017	76 08		 jbe	 SHORT $LN3@max_size
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0001c	89 45 b4	 mov	 DWORD PTR tv65[ebp], eax
  0001f	eb 07		 jmp	 SHORT $LN4@max_size
$LN3@max_size:
  00021	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$LN4@max_size:
  00028	8b 45 b4	 mov	 eax, DWORD PTR tv65[ebp]

; 220  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?max_size@?$allocator@UBLOODCASTLE_START_TIME@@@std@@QBEIXZ ENDP ; std::allocator<BLOODCASTLE_START_TIME>::max_size
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@@Z ; std::allocator<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>::destroy
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Dest_val@V?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@@std@@YAXAAV?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@0@PAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@0@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@@std@@YAXAAV?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@0@PAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@0@@Z PROC ; std::_Dest_val<std::allocator<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>,std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>, COMDAT

; 286  : 	{	// destroy using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 287  : 	_Alval.destroy(_Pdest);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  00010	e8 00 00 00 00	 call	 ?destroy@?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@@Z ; std::allocator<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>::destroy

; 288  : 	}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Dest_val@V?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@@std@@YAXAAV?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@0@PAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@0@@Z ENDP ; std::_Dest_val<std::allocator<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>,std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$addressof@UBLOODCASTLE_START_TIME@@@std@@YAPAUBLOODCASTLE_START_TIME@@AAU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@UBLOODCASTLE_START_TIME@@@std@@YAPAUBLOODCASTLE_START_TIME@@AAU1@@Z PROC ; std::addressof<BLOODCASTLE_START_TIME>, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 111  : 	return ((_Ty *) &(char&)_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@UBLOODCASTLE_START_TIME@@@std@@YAPAUBLOODCASTLE_START_TIME@@AAU1@@Z ENDP ; std::addressof<BLOODCASTLE_START_TIME>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UBLOODCASTLE_START_TIME@@@std@@QAEXPAUBLOODCASTLE_START_TIME@@ABU3@@Z ; std::allocator<BLOODCASTLE_START_TIME>::construct
PUBLIC	??$forward@ABUBLOODCASTLE_START_TIME@@@std@@YAABUBLOODCASTLE_START_TIME@@ABU1@@Z ; std::forward<BLOODCASTLE_START_TIME const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ??$_Cons_val@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@UBLOODCASTLE_START_TIME@@ABU3@@std@@YAXAAV?$allocator@UBLOODCASTLE_START_TIME@@@0@PAUBLOODCASTLE_START_TIME@@ABU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@UBLOODCASTLE_START_TIME@@ABU3@@std@@YAXAAV?$allocator@UBLOODCASTLE_START_TIME@@@0@PAUBLOODCASTLE_START_TIME@@ABU2@@Z PROC ; std::_Cons_val<std::allocator<BLOODCASTLE_START_TIME>,BLOODCASTLE_START_TIME,BLOODCASTLE_START_TIME const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@ABUBLOODCASTLE_START_TIME@@@std@@YAABUBLOODCASTLE_START_TIME@@ABU1@@Z ; std::forward<BLOODCASTLE_START_TIME const &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00019	51		 push	 ecx
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Alval$[ebp]
  0001d	e8 00 00 00 00	 call	 ?construct@?$allocator@UBLOODCASTLE_START_TIME@@@std@@QAEXPAUBLOODCASTLE_START_TIME@@ABU3@@Z ; std::allocator<BLOODCASTLE_START_TIME>::construct

; 281  : 	}

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Cons_val@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@UBLOODCASTLE_START_TIME@@ABU3@@std@@YAXAAV?$allocator@UBLOODCASTLE_START_TIME@@@0@PAUBLOODCASTLE_START_TIME@@ABU2@@Z ENDP ; std::_Cons_val<std::allocator<BLOODCASTLE_START_TIME>,BLOODCASTLE_START_TIME,BLOODCASTLE_START_TIME const &>
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??$?0UBLOODCASTLE_START_TIME@@@?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE@ABV?$allocator@UBLOODCASTLE_START_TIME@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0UBLOODCASTLE_START_TIME@@@?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE@ABV?$allocator@UBLOODCASTLE_START_TIME@@@1@@Z PROC ; std::allocator<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>::allocator<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node><BLOODCASTLE_START_TIME>, COMDAT
; _this$ = ecx

; 170  : 		_ALLOCATOR(const _ALLOCATOR<_Other>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 171  : 		{	// construct from a related allocator (do nothing)
; 172  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??$?0UBLOODCASTLE_START_TIME@@@?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE@ABV?$allocator@UBLOODCASTLE_START_TIME@@@1@@Z ENDP ; std::allocator<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>::allocator<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node><BLOODCASTLE_START_TIME>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T239712 = -80						; size = 12
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 31   : 	void *_Ptr = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 32   : 
; 33   : 	if (_Count <= 0)

  00010	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00014	77 09		 ja	 SHORT $LN4@Allocate

; 34   : 		_Count = 0;

  00016	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __Count$[ebp], 0

; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0001d	eb 39		 jmp	 SHORT $LN3@Allocate
$LN4@Allocate:

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0001f	81 7d 08 ff ff
	ff 0f		 cmp	 DWORD PTR __Count$[ebp], 268435455 ; 0fffffffH
  00026	77 18		 ja	 SHORT $LN1@Allocate
  00028	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002b	c1 e0 04	 shl	 eax, 4
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 fc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0003a	83 7d fc 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  0003e	75 18		 jne	 SHORT $LN3@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00040	6a 00		 push	 0
  00042	8d 4d b0	 lea	 ecx, DWORD PTR $T239712[ebp]
  00045	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0004a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0004f	8d 45 b0	 lea	 eax, DWORD PTR $T239712[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Allocate:

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00058	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 40   : 	}

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
??$_Allocate@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>
_TEXT	ENDS
PUBLIC	??$_Construct@UBLOODCASTLE_START_TIME@@ABU1@@std@@YAXPAUBLOODCASTLE_START_TIME@@ABU1@@Z ; std::_Construct<BLOODCASTLE_START_TIME,BLOODCASTLE_START_TIME const &>
; Function compile flags: /Odtp /ZI
;	COMDAT ?construct@?$allocator@UBLOODCASTLE_START_TIME@@@std@@QAEXPAUBLOODCASTLE_START_TIME@@ABU3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UBLOODCASTLE_START_TIME@@@std@@QAEXPAUBLOODCASTLE_START_TIME@@ABU3@@Z PROC ; std::allocator<BLOODCASTLE_START_TIME>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 197  : 		_Construct(_Ptr, _Val);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ??$_Construct@UBLOODCASTLE_START_TIME@@ABU1@@std@@YAXPAUBLOODCASTLE_START_TIME@@ABU1@@Z ; std::_Construct<BLOODCASTLE_START_TIME,BLOODCASTLE_START_TIME const &>
  00019	83 c4 08	 add	 esp, 8

; 198  : 		}

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
?construct@?$allocator@UBLOODCASTLE_START_TIME@@@std@@QAEXPAUBLOODCASTLE_START_TIME@@ABU3@@Z ENDP ; std::allocator<BLOODCASTLE_START_TIME>::construct
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@0@@Z ; std::_Destroy<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>
; Function compile flags: /Odtp /ZI
;	COMDAT ?destroy@?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@@Z PROC ; std::allocator<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 213  : 		_Destroy(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Destroy@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@0@@Z ; std::_Destroy<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>
  00015	83 c4 04	 add	 esp, 4

; 214  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?destroy@?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@@Z ENDP ; std::allocator<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>::destroy
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@ABUBLOODCASTLE_START_TIME@@@std@@YAABUBLOODCASTLE_START_TIME@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUBLOODCASTLE_START_TIME@@@std@@YAABUBLOODCASTLE_START_TIME@@ABU1@@Z PROC ; std::forward<BLOODCASTLE_START_TIME const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	return ((_Ty&&)_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@ABUBLOODCASTLE_START_TIME@@@std@@YAABUBLOODCASTLE_START_TIME@@ABU1@@Z ENDP ; std::forward<BLOODCASTLE_START_TIME const &>
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??2@YAPAXIPAX@Z					; operator new
;	COMDAT xdata$x
; File d:\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$_Construct@UBLOODCASTLE_START_TIME@@ABU1@@std@@YAXPAUBLOODCASTLE_START_TIME@@ABU1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@UBLOODCASTLE_START_TIME@@ABU1@@std@@YAXPAUBLOODCASTLE_START_TIME@@ABU1@@Z$0
__ehfuncinfo$??$_Construct@UBLOODCASTLE_START_TIME@@ABU1@@std@@YAXPAUBLOODCASTLE_START_TIME@@ABU1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@UBLOODCASTLE_START_TIME@@ABU1@@std@@YAXPAUBLOODCASTLE_START_TIME@@ABU1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /ZI
xdata$x	ENDS
;	COMDAT ??$_Construct@UBLOODCASTLE_START_TIME@@ABU1@@std@@YAXPAUBLOODCASTLE_START_TIME@@ABU1@@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
$T239721 = -88						; size = 4
$T239722 = -84						; size = 4
__Vptr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UBLOODCASTLE_START_TIME@@ABU1@@std@@YAXPAUBLOODCASTLE_START_TIME@@ABU1@@Z PROC ; std::_Construct<BLOODCASTLE_START_TIME,BLOODCASTLE_START_TIME const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Construct@UBLOODCASTLE_START_TIME@@ABU1@@std@@YAXPAUBLOODCASTLE_START_TIME@@ABU1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 47   : 	void _FARQ *_Vptr = _Ptr;

  00028	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002b	89 45 f0	 mov	 DWORD PTR __Vptr$[ebp], eax

; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  0002e	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00031	50		 push	 eax
  00032	6a 08		 push	 8
  00034	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00039	83 c4 08	 add	 esp, 8
  0003c	89 45 ac	 mov	 DWORD PTR $T239722[ebp], eax
  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00046	83 7d ac 00	 cmp	 DWORD PTR $T239722[ebp], 0
  0004a	74 21		 je	 SHORT $LN3@Construct
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ??$forward@ABUBLOODCASTLE_START_TIME@@@std@@YAABUBLOODCASTLE_START_TIME@@ABU1@@Z ; std::forward<BLOODCASTLE_START_TIME const &>
  00055	83 c4 04	 add	 esp, 4
  00058	8b 10		 mov	 edx, DWORD PTR [eax]
  0005a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005d	8b 4d ac	 mov	 ecx, DWORD PTR $T239722[ebp]
  00060	89 11		 mov	 DWORD PTR [ecx], edx
  00062	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00065	8b 55 ac	 mov	 edx, DWORD PTR $T239722[ebp]
  00068	89 55 a4	 mov	 DWORD PTR tv74[ebp], edx
  0006b	eb 07		 jmp	 SHORT $LN4@Construct
$LN3@Construct:
  0006d	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@Construct:
  00074	8b 45 a4	 mov	 eax, DWORD PTR tv74[ebp]
  00077	89 45 a8	 mov	 DWORD PTR $T239721[ebp], eax
  0007a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 49   : 	}

  00081	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00084	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008b	59		 pop	 ecx
  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi
  0008e	5b		 pop	 ebx
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@UBLOODCASTLE_START_TIME@@ABU1@@std@@YAXPAUBLOODCASTLE_START_TIME@@ABU1@@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR __Vptr$[ebp]
  00003	50		 push	 eax
  00004	8b 4d ac	 mov	 ecx, DWORD PTR $T239722[ebp]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Construct@UBLOODCASTLE_START_TIME@@ABU1@@std@@YAXPAUBLOODCASTLE_START_TIME@@ABU1@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Construct@UBLOODCASTLE_START_TIME@@ABU1@@std@@YAXPAUBLOODCASTLE_START_TIME@@ABU1@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Construct@UBLOODCASTLE_START_TIME@@ABU1@@std@@YAXPAUBLOODCASTLE_START_TIME@@ABU1@@Z ENDP ; std::_Construct<BLOODCASTLE_START_TIME,BLOODCASTLE_START_TIME const &>
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 81   :         {return (_Where); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 83   :         {return; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@0@@Z PROC ; std::_Destroy<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>, COMDAT

; 62   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Destroy@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@0@@Z ENDP ; std::_Destroy<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File d:\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
; Function compile flags: /Odtp /ZI
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ ; std::bad_alloc::~bad_alloc
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN1@scalar@2
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$LN1@scalar@2:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Odtp /ZI
; File d:\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 48   : 		{	// adopt this iterator by parent

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 49   : 		}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Odtp /ZI
; File d:\projects\exteam6.3\source\gameserver\gameserver\bloodcastle.cpp
;	COMDAT ??__Eg_BloodCastle@@YAXXZ
text$yc	SEGMENT
??__Eg_BloodCastle@@YAXXZ PROC				; `dynamic initializer for 'g_BloodCastle'', COMDAT

; 29   : CBloodCastle g_BloodCastle;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  0000e	e8 00 00 00 00	 call	 ??0CBloodCastle@@QAE@XZ	; CBloodCastle::CBloodCastle
  00013	68 00 00 00 00	 push	 OFFSET ??__Fg_BloodCastle@@YAXXZ ; `dynamic atexit destructor for 'g_BloodCastle''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??__Eg_BloodCastle@@YAXXZ ENDP				; `dynamic initializer for 'g_BloodCastle''
; Function compile flags: /Odtp /ZI
text$yc	ENDS
;	COMDAT ??__Fg_BloodCastle@@YAXXZ
text$yd	SEGMENT
??__Fg_BloodCastle@@YAXXZ PROC				; `dynamic atexit destructor for 'g_BloodCastle'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  0000e	e8 00 00 00 00	 call	 ??1CBloodCastle@@UAE@XZ	; CBloodCastle::~CBloodCastle
  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__Fg_BloodCastle@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_BloodCastle''
text$yd	ENDS
PUBLIC	?g_BloodCastle@@3VCBloodCastle@@A		; g_BloodCastle
_BSS	SEGMENT
?g_BloodCastle@@3VCBloodCastle@@A DB 0232cH DUP (?)	; g_BloodCastle
_BSS	ENDS
CRT$XCU	SEGMENT
_g_BloodCastle$initializer$ DD FLAT:??__Eg_BloodCastle@@YAXXZ
CRT$XCU	ENDS
END
